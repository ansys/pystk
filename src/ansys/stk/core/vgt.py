################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################ 

"""
The Vector Geometry (VGT) API enables users define new or utilize existing geometric constructs such as coordinate systems, vectors, points, angles, axes and planes.

The geometric elements can be used to transform between coordinate
systems, compute first and second derivatives, or perform other types of
analysis.
"""

__all__ = ["AnalysisWorkbenchCentralBody", "AnalysisWorkbenchCentralBodyCollection", "AnalysisWorkbenchCentralBodyRefTo", 
"AnalysisWorkbenchCollection", "AnalysisWorkbenchConverge", "AnalysisWorkbenchDerivative", "AnalysisWorkbenchGeneric", "AnalysisWorkbenchInstance", 
"AnalysisWorkbenchIntegral", "AnalysisWorkbenchInterp", "AnalysisWorkbenchLLAPosition", "AnalysisWorkbenchMethodCallAngleFindAngleResult", 
"AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult", "AnalysisWorkbenchMethodCallAngleFindResult", "AnalysisWorkbenchMethodCallAngleFindWithRateResult", 
"AnalysisWorkbenchMethodCallAxesFindInAxesResult", "AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult", "AnalysisWorkbenchMethodCallAxesTransformResult", 
"AnalysisWorkbenchMethodCallAxesTransformWithRateResult", "AnalysisWorkbenchMethodCallPlaneFindInAxesResult", "AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult", 
"AnalysisWorkbenchMethodCallPlaneFindInSystemResult", "AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult", "AnalysisWorkbenchMethodCallPointLocateInSystemResult", 
"AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult", "AnalysisWorkbenchMethodCallSystemFindInSystemResult", "AnalysisWorkbenchMethodCallSystemTransformResult", 
"AnalysisWorkbenchMethodCallSystemTransformWithRateResult", "AnalysisWorkbenchMethodCallVectorFindInAxesResult", "AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult", 
"AnalysisWorkbenchProvider", "AnalysisWorkbenchRoot", "AnalysisWorkbenchSampling", "AnalysisWorkbenchSignalDelay", "AnalysisWorkbenchTemplate", 
"AnalysisWorkbenchTypeInfo", "CRDN_CALC_SCALAR_TYPE", "CRDN_CONDITION_COMBINED_OPERATION_TYPE", "CRDN_CONDITION_SET_TYPE", 
"CRDN_CONDITION_THRESHOLD_OPTION", "CRDN_CONDITION_TYPE", "CRDN_DIMENSION_INHERITANCE", "CRDN_DIRECTION_TYPE", "CRDN_DISPLAY_AXIS_SELECTOR", 
"CRDN_EVENT_ARRAY_FILTER_TYPE", "CRDN_EVENT_ARRAY_TYPE", "CRDN_EVENT_INTERVAL_COLLECTION_TYPE", "CRDN_EVENT_INTERVAL_LIST_TYPE", 
"CRDN_EVENT_INTERVAL_TYPE", "CRDN_EVENT_LIST_MERGE_OPERATION", "CRDN_EVENT_TYPE", "CRDN_EXTREMUM_CONSTANTS", "CRDN_FILE_INTERPOLATOR_TYPE", 
"CRDN_INTEGRAL_TYPE", "CRDN_INTEGRATION_WINDOW_TYPE", "CRDN_INTERPOLATOR_TYPE", "CRDN_INTERSECTION_SURFACE", "CRDN_INTERVAL_DURATION_KIND", 
"CRDN_INTERVAL_SELECTION", "CRDN_KIND", "CRDN_LAGRANGE_LIBRATION_POINT_TYPE", "CRDN_MEAN_ELEMENT_THEORY", "CRDN_PARAMETER_SET_TYPE", 
"CRDN_PRUNE_FILTER", "CRDN_QUADRANT_TYPE", "CRDN_REFERENCE_SHAPE_TYPE", "CRDN_SAMPLED_REFERENCE_TIME", "CRDN_SAMPLING_METHOD", 
"CRDN_SATISFACTION_CROSSING", "CRDN_SAVE_DATA_OPTION", "CRDN_SIGNAL_PATH_REFERENCE_SYSTEM", "CRDN_SIGNAL_SENSE", "CRDN_SIGNED_ANGLE_TYPE", 
"CRDN_SMART_EPOCH_STATE", "CRDN_SMART_INTERVAL_STATE", "CRDN_SPEED_OPTIONS", "CRDN_START_STOP_OPTION", "CRDN_SURFACE_TYPE", 
"CRDN_SWEEP_MODE", "CRDN_SYSTEM_TYPE", "CRDN_THRESH_CONVERGE_SENSE", "CRDN_TRAJECTORY_AXES_TYPE", "CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE", 
"CRDN_VOLUME_ABERRATION_TYPE", "CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE", "CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE", "CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE", 
"CRDN_VOLUME_CALC_RANGE_SPEED_TYPE", "CRDN_VOLUME_CALC_TYPE", "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE", 
"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE", "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE", "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE", 
"CRDN_VOLUME_CLOCK_HOST_TYPE", "CRDN_VOLUME_COMBINED_OPERATION_TYPE", "CRDN_VOLUME_FROM_GRID_EDGE_TYPE", "CRDN_VOLUME_GRID_TYPE", 
"CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE", "CRDN_VOLUME_OVER_TIME_DURATION_TYPE", "CRDN_VOLUME_RESULT_VECTOR_REQUEST", "CRDN_VOLUME_TIME_SENSE_TYPE", 
"CRDN_VOLUME_TYPE", "CalculationToolCondition", "CalculationToolConditionCombined", "CalculationToolConditionFactory", "CalculationToolConditionGroup", 
"CalculationToolConditionPointInVolume", "CalculationToolConditionScalarBounds", "CalculationToolConditionSet", "CalculationToolConditionSetEvaluateResult", 
"CalculationToolConditionSetEvaluateWithRateResult", "CalculationToolConditionSetFactory", "CalculationToolConditionSetGroup", 
"CalculationToolConditionSetScalarThresholds", "CalculationToolConvergeBasic", "CalculationToolDerivativeBasic", "CalculationToolEvaluateResult", 
"CalculationToolEvaluateWithRateResult", "CalculationToolIntegralBasic", "CalculationToolInterpBasic", "CalculationToolParameterSet", 
"CalculationToolParameterSetAttitude", "CalculationToolParameterSetFactory", "CalculationToolParameterSetGroundTrajectory", 
"CalculationToolParameterSetGroup", "CalculationToolParameterSetOrbit", "CalculationToolParameterSetTrajectory", "CalculationToolParameterSetVector", 
"CalculationToolSamplingBasic", "CalculationToolSamplingCurvatureTolerance", "CalculationToolSamplingFixedStep", "CalculationToolSamplingMethod", 
"CalculationToolSamplingMethodFactory", "CalculationToolSamplingRelativeTolerance", "CalculationToolScalar", "CalculationToolScalarAngle", 
"CalculationToolScalarAverage", "CalculationToolScalarConstant", "CalculationToolScalarCustom", "CalculationToolScalarCustomInline", 
"CalculationToolScalarDataElement", "CalculationToolScalarDerivative", "CalculationToolScalarDotProduct", "CalculationToolScalarElapsedTime", 
"CalculationToolScalarFactory", "CalculationToolScalarFile", "CalculationToolScalarFixedAtTimeInstant", "CalculationToolScalarFunction", 
"CalculationToolScalarFunction2Var", "CalculationToolScalarGroup", "CalculationToolScalarIntegral", "CalculationToolScalarPlugin", 
"CalculationToolScalarPointInVolumeCalc", "CalculationToolScalarStandardDeviation", "CalculationToolScalarSurfaceDistanceBetweenPoints", 
"CalculationToolScalarVectorComponent", "CalculationToolScalarVectorMagnitude", "IAnalysisWorkbenchComponent", "IAnalysisWorkbenchContext", 
"IAnalysisWorkbenchConverge", "IAnalysisWorkbenchDerivative", "IAnalysisWorkbenchIntegral", "IAnalysisWorkbenchInterp", 
"IAnalysisWorkbenchMethodCallResult", "IAnalysisWorkbenchRefTo", "IAnalysisWorkbenchSampling", "IAnalysisWorkbenchSignalDelay", 
"ICalculationToolCondition", "ICalculationToolConditionSet", "ICalculationToolParameterSet", "ICalculationToolSamplingMethod", 
"ICalculationToolScalar", "ISpatialAnalysisToolGridValuesMethod", "ISpatialAnalysisToolVolume", "ISpatialAnalysisToolVolumeCalc", 
"ISpatialAnalysisToolVolumeGrid", "ITimeToolEvent", "ITimeToolEventArray", "ITimeToolEventInterval", "ITimeToolEventIntervalCollection", 
"ITimeToolEventIntervalList", "ITimeToolPruneFilter", "ITimeToolTimeProperties", "IVectorGeometryToolAngle", "IVectorGeometryToolAngleFindAngleResult", 
"IVectorGeometryToolAngleFindAngleWithRateResult", "IVectorGeometryToolAngleFindResult", "IVectorGeometryToolAngleFindWithRateResult", 
"IVectorGeometryToolAxes", "IVectorGeometryToolAxesFindInAxesResult", "IVectorGeometryToolAxesFindInAxesWithRateResult", 
"IVectorGeometryToolAxesTransformResult", "IVectorGeometryToolAxesTransformWithRateResult", "IVectorGeometryToolPlane", 
"IVectorGeometryToolPlaneFindInAxesResult", "IVectorGeometryToolPlaneFindInAxesWithRateResult", "IVectorGeometryToolPlaneFindInSystemResult", 
"IVectorGeometryToolPlaneFindInSystemWithRateResult", "IVectorGeometryToolPoint", "IVectorGeometryToolPointLocateInSystemResult", 
"IVectorGeometryToolPointLocateInSystemWithRateResult", "IVectorGeometryToolSystem", "IVectorGeometryToolSystemFindInSystemResult", 
"IVectorGeometryToolSystemTransformResult", "IVectorGeometryToolSystemTransformWithRateResult", "IVectorGeometryToolVector", 
"IVectorGeometryToolVectorFindInAxesResult", "IVectorGeometryToolVectorFindInAxesWithRateResult", "SpatialAnalysisToolGridCoordinateDefinition", 
"SpatialAnalysisToolGridValuesCustom", "SpatialAnalysisToolGridValuesFixedNumberOfSteps", "SpatialAnalysisToolGridValuesFixedStep", 
"SpatialAnalysisToolGridValuesMethod", "SpatialAnalysisToolVolume", "SpatialAnalysisToolVolumeCalc", "SpatialAnalysisToolVolumeCalcAltitude", 
"SpatialAnalysisToolVolumeCalcAngleOffVector", "SpatialAnalysisToolVolumeCalcConditionSatMetric", "SpatialAnalysisToolVolumeCalcDelayRange", 
"SpatialAnalysisToolVolumeCalcFactory", "SpatialAnalysisToolVolumeCalcFile", "SpatialAnalysisToolVolumeCalcFromScalar", 
"SpatialAnalysisToolVolumeCalcGroup", "SpatialAnalysisToolVolumeCalcRange", "SpatialAnalysisToolVolumeCalcSolarIntensity", 
"SpatialAnalysisToolVolumeCombined", "SpatialAnalysisToolVolumeFactory", "SpatialAnalysisToolVolumeFromCalc", "SpatialAnalysisToolVolumeFromCondition", 
"SpatialAnalysisToolVolumeFromGrid", "SpatialAnalysisToolVolumeFromTimeSatisfaction", "SpatialAnalysisToolVolumeGrid", "SpatialAnalysisToolVolumeGridBearingAlt", 
"SpatialAnalysisToolVolumeGridCartesian", "SpatialAnalysisToolVolumeGridConstrained", "SpatialAnalysisToolVolumeGridCylindrical", 
"SpatialAnalysisToolVolumeGridFactory", "SpatialAnalysisToolVolumeGridGroup", "SpatialAnalysisToolVolumeGridLatLonAlt", 
"SpatialAnalysisToolVolumeGridResult", "SpatialAnalysisToolVolumeGridSpherical", "SpatialAnalysisToolVolumeGroup", "SpatialAnalysisToolVolumeInview", 
"SpatialAnalysisToolVolumeLighting", "SpatialAnalysisToolVolumeOverTime", "TimeToolAxesSamplingInterval", "TimeToolAxesSamplingIntervalCollection", 
"TimeToolAxesSamplingResult", "TimeToolEvent", "TimeToolEventArray", "TimeToolEventArrayConditionCrossings", "TimeToolEventArrayExtrema", 
"TimeToolEventArrayFactory", "TimeToolEventArrayFiltered", "TimeToolEventArrayFixedStep", "TimeToolEventArrayFixedTimes", 
"TimeToolEventArrayGroup", "TimeToolEventArrayMerged", "TimeToolEventArraySignaled", "TimeToolEventArrayStartStopTimes", 
"TimeToolEventEpoch", "TimeToolEventExtremum", "TimeToolEventFactory", "TimeToolEventFindOccurrenceResult", "TimeToolEventGroup", 
"TimeToolEventInterval", "TimeToolEventIntervalBetweenTimeInstants", "TimeToolEventIntervalCollection", "TimeToolEventIntervalCollectionCondition", 
"TimeToolEventIntervalCollectionFactory", "TimeToolEventIntervalCollectionGroup", "TimeToolEventIntervalCollectionLighting", 
"TimeToolEventIntervalCollectionOccurredResult", "TimeToolEventIntervalCollectionSignaled", "TimeToolEventIntervalFactory", 
"TimeToolEventIntervalFixed", "TimeToolEventIntervalFixedDuration", "TimeToolEventIntervalFromIntervalList", "TimeToolEventIntervalGroup", 
"TimeToolEventIntervalList", "TimeToolEventIntervalListCondition", "TimeToolEventIntervalListFactory", "TimeToolEventIntervalListFile", 
"TimeToolEventIntervalListFiltered", "TimeToolEventIntervalListFixed", "TimeToolEventIntervalListGroup", "TimeToolEventIntervalListMerged", 
"TimeToolEventIntervalListScaled", "TimeToolEventIntervalListSignaled", "TimeToolEventIntervalListTimeOffset", "TimeToolEventIntervalResult", 
"TimeToolEventIntervalScaled", "TimeToolEventIntervalSignaled", "TimeToolEventIntervalSmartInterval", "TimeToolEventIntervalTimeOffset", 
"TimeToolEventSignaled", "TimeToolEventSmartEpoch", "TimeToolEventStartStopTime", "TimeToolEventTimeOffset", "TimeToolFindTimesResult", 
"TimeToolFirstIntervalsFilter", "TimeToolGapsFilter", "TimeToolInterval", "TimeToolIntervalCollection", "TimeToolIntervalListResult", 
"TimeToolIntervalVectorCollection", "TimeToolIntervalsFilter", "TimeToolIntervalsVectorResult", "TimeToolLastIntervalsFilter", 
"TimeToolLightTimeDelay", "TimeToolPointSamplingInterval", "TimeToolPointSamplingIntervalCollection", "TimeToolPointSamplingResult", 
"TimeToolPruneFilter", "TimeToolPruneFilterFactory", "TimeToolRelativeSatisfactionConditionFilter", "TimeToolSatisfactionConditionFilter", 
"TimeToolSignalDelayBasic", "VECTOR_GEOMETRY_TOOL_ANGLE_TYPE", "VECTOR_GEOMETRY_TOOL_AXES_TYPE", "VECTOR_GEOMETRY_TOOL_PLANE_TYPE", 
"VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE", "VECTOR_GEOMETRY_TOOL_POINT_TYPE", "VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE", 
"VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE", "VECTOR_GEOMETRY_TOOL_VECTOR_TYPE", "VectorGeometryToolAngle", 
"VectorGeometryToolAngleBetweenPlanes", "VectorGeometryToolAngleBetweenVectors", "VectorGeometryToolAngleDihedral", "VectorGeometryToolAngleFactory", 
"VectorGeometryToolAngleGroup", "VectorGeometryToolAngleRefTo", "VectorGeometryToolAngleRotation", "VectorGeometryToolAngleToPlane", 
"VectorGeometryToolAxes", "VectorGeometryToolAxesAlignedAndConstrained", "VectorGeometryToolAxesAngularOffset", "VectorGeometryToolAxesAtTimeInstant", 
"VectorGeometryToolAxesAttitudeFile", "VectorGeometryToolAxesBPlane", "VectorGeometryToolAxesCommonTasks", "VectorGeometryToolAxesCustomScript", 
"VectorGeometryToolAxesFactory", "VectorGeometryToolAxesFixed", "VectorGeometryToolAxesFixedAtEpoch", "VectorGeometryToolAxesGroup", 
"VectorGeometryToolAxesLabels", "VectorGeometryToolAxesLagrangeLibration", "VectorGeometryToolAxesModelAttach", "VectorGeometryToolAxesOnSurface", 
"VectorGeometryToolAxesPlugin", "VectorGeometryToolAxesRefTo", "VectorGeometryToolAxesSpinning", "VectorGeometryToolAxesTrajectory", 
"VectorGeometryToolPlane", "VectorGeometryToolPlaneFactory", "VectorGeometryToolPlaneGroup", "VectorGeometryToolPlaneLabels", 
"VectorGeometryToolPlaneNormal", "VectorGeometryToolPlaneQuadrant", "VectorGeometryToolPlaneRefTo", "VectorGeometryToolPlaneTrajectory", 
"VectorGeometryToolPlaneTriad", "VectorGeometryToolPlaneTwoVector", "VectorGeometryToolPoint", "VectorGeometryToolPointAtTimeInstant", 
"VectorGeometryToolPointBPlane", "VectorGeometryToolPointCBFixedOffset", "VectorGeometryToolPointCentBodyIntersect", "VectorGeometryToolPointCommonTasks", 
"VectorGeometryToolPointCovarianceGrazing", "VectorGeometryToolPointFactory", "VectorGeometryToolPointFile", "VectorGeometryToolPointFixedInSystem", 
"VectorGeometryToolPointGlint", "VectorGeometryToolPointGrazing", "VectorGeometryToolPointGroup", "VectorGeometryToolPointLagrangeLibration", 
"VectorGeometryToolPointModelAttach", "VectorGeometryToolPointOnSurface", "VectorGeometryToolPointPlaneIntersection", "VectorGeometryToolPointPlaneProjection", 
"VectorGeometryToolPointPlugin", "VectorGeometryToolPointRefTo", "VectorGeometryToolPointSatelliteCollectionEntry", "VectorGeometryToolSystem", 
"VectorGeometryToolSystemAssembled", "VectorGeometryToolSystemCommonTasks", "VectorGeometryToolSystemFactory", "VectorGeometryToolSystemGroup", 
"VectorGeometryToolSystemOnSurface", "VectorGeometryToolSystemRefTo", "VectorGeometryToolVector", "VectorGeometryToolVectorAngleRate", 
"VectorGeometryToolVectorAngularVelocity", "VectorGeometryToolVectorApoapsis", "VectorGeometryToolVectorConing", "VectorGeometryToolVectorCross", 
"VectorGeometryToolVectorCustomScript", "VectorGeometryToolVectorDerivative", "VectorGeometryToolVectorDirectionToStar", 
"VectorGeometryToolVectorDispSurface", "VectorGeometryToolVectorDisplacement", "VectorGeometryToolVectorEccentricity", "VectorGeometryToolVectorFactory", 
"VectorGeometryToolVectorFixedAtEpoch", "VectorGeometryToolVectorFixedAtTimeInstant", "VectorGeometryToolVectorFixedInAxes", 
"VectorGeometryToolVectorGroup", "VectorGeometryToolVectorLineOfNodes", "VectorGeometryToolVectorLinearCombination", "VectorGeometryToolVectorModelAttach", 
"VectorGeometryToolVectorOrbitAngularMomentum", "VectorGeometryToolVectorOrbitNormal", "VectorGeometryToolVectorPeriapsis", 
"VectorGeometryToolVectorPlugin", "VectorGeometryToolVectorProjectAlongVector", "VectorGeometryToolVectorProjection", "VectorGeometryToolVectorRefTo", 
"VectorGeometryToolVectorReflection", "VectorGeometryToolVectorRotationVector", "VectorGeometryToolVectorScalarLinearCombination", 
"VectorGeometryToolVectorScalarScaled", "VectorGeometryToolVectorScaled", "VectorGeometryToolVectorTwoPlanesIntersection", 
"VectorGeometryToolVectorVelocityAcceleration", "VectorGeometryToolWellKnownAxes", "VectorGeometryToolWellKnownEarthAxes", 
"VectorGeometryToolWellKnownEarthSystems", "VectorGeometryToolWellKnownSunAxes", "VectorGeometryToolWellKnownSunSystems", 
"VectorGeometryToolWellKnownSystems"]

import typing

from ctypes   import POINTER
from enum     import IntEnum, IntFlag

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .internal.comutil     import IUnknown, IDispatch
from .internal.apiutil     import (InterfaceProxy, EnumeratorProxy, OutArg, 
    initialize_from_source_object, get_interface_property, set_interface_attribute, 
    set_class_attribute, SupportsDeleteCallback)
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class CRDN_CALC_SCALAR_TYPE(IntEnum):
    """Define available calculation scalar types."""
   
    UNKNOWN = -1
    """Unknown or unsupported calculation scalar types."""
    ANGLE = 0
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    FIXED_AT_TIME_INSTANT = 1
    """Constant scalar created by evaluating input scalar calculation at specified reference time instant."""
    CONSTANT = 2
    """Constant scalar value of specified dimension."""
    DATA_ELEMENT = 3
    """Any time-dependent data element from STK data providers available for parent STK object."""
    DERIVATIVE = 4
    """Derivative of input scalar calculation."""
    ELAPSED_TIME = 5
    """Time elapsed since reference time instant."""
    FILE = 6
    """Tabulated scalar calculation data loaded from specified file."""
    FUNCTION = 7
    """Defined by performing one of specified functions on input scalar."""
    INTEGRAL = 8
    """Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."""
    FUNCTION2_VAR = 9
    """Defined by performing one of specified binary operations on two scalar arguments."""
    VECTOR_MAGNITUDE = 10
    """Scalar equal to magnitude of specified vector."""
    PLUGIN = 11
    """A calc scalar plugin based on a COM object."""
    CUSTOM_SCRIPT = 12
    """A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    SURFACE_DISTANCE_BETWEEN_POINTS = 13
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    DOT_PRODUCT = 14
    """Scalar equal to the dot product between two vectors."""
    VECTOR_COMPONENT = 15
    """Scalar equal to the specified component of a vector when resolved in the specified axes."""
    AVERAGE = 16
    """Average of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."""
    STANDARD_DEVIATION = 17
    """Standard deviation of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."""
    POINT_IN_VOLUME_CALC = 18
    """Calculations Along Trajectory. Use CalculationToolScalarPointInVolumeCalc to access it."""
    CUSTOM_INLINE_SCRIPT = 19
    """Custom inline script scalar."""

CRDN_CALC_SCALAR_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported calculation scalar types."
CRDN_CALC_SCALAR_TYPE.ANGLE.__doc__ = "Scalar equal to angular displacement obtained from any angle in VGT."
CRDN_CALC_SCALAR_TYPE.FIXED_AT_TIME_INSTANT.__doc__ = "Constant scalar created by evaluating input scalar calculation at specified reference time instant."
CRDN_CALC_SCALAR_TYPE.CONSTANT.__doc__ = "Constant scalar value of specified dimension."
CRDN_CALC_SCALAR_TYPE.DATA_ELEMENT.__doc__ = "Any time-dependent data element from STK data providers available for parent STK object."
CRDN_CALC_SCALAR_TYPE.DERIVATIVE.__doc__ = "Derivative of input scalar calculation."
CRDN_CALC_SCALAR_TYPE.ELAPSED_TIME.__doc__ = "Time elapsed since reference time instant."
CRDN_CALC_SCALAR_TYPE.FILE.__doc__ = "Tabulated scalar calculation data loaded from specified file."
CRDN_CALC_SCALAR_TYPE.FUNCTION.__doc__ = "Defined by performing one of specified functions on input scalar."
CRDN_CALC_SCALAR_TYPE.INTEGRAL.__doc__ = "Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
CRDN_CALC_SCALAR_TYPE.FUNCTION2_VAR.__doc__ = "Defined by performing one of specified binary operations on two scalar arguments."
CRDN_CALC_SCALAR_TYPE.VECTOR_MAGNITUDE.__doc__ = "Scalar equal to magnitude of specified vector."
CRDN_CALC_SCALAR_TYPE.PLUGIN.__doc__ = "A calc scalar plugin based on a COM object."
CRDN_CALC_SCALAR_TYPE.CUSTOM_SCRIPT.__doc__ = "A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."
CRDN_CALC_SCALAR_TYPE.SURFACE_DISTANCE_BETWEEN_POINTS.__doc__ = "Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."
CRDN_CALC_SCALAR_TYPE.DOT_PRODUCT.__doc__ = "Scalar equal to the dot product between two vectors."
CRDN_CALC_SCALAR_TYPE.VECTOR_COMPONENT.__doc__ = "Scalar equal to the specified component of a vector when resolved in the specified axes."
CRDN_CALC_SCALAR_TYPE.AVERAGE.__doc__ = "Average of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
CRDN_CALC_SCALAR_TYPE.STANDARD_DEVIATION.__doc__ = "Standard deviation of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
CRDN_CALC_SCALAR_TYPE.POINT_IN_VOLUME_CALC.__doc__ = "Calculations Along Trajectory. Use CalculationToolScalarPointInVolumeCalc to access it."
CRDN_CALC_SCALAR_TYPE.CUSTOM_INLINE_SCRIPT.__doc__ = "Custom inline script scalar."

agcls.AgTypeNameMap["CRDN_CALC_SCALAR_TYPE"] = CRDN_CALC_SCALAR_TYPE

class CRDN_CONDITION_COMBINED_OPERATION_TYPE(IntEnum):
    """Define scalar condition combined operation types."""
   
    AND = 1
    """Scalar condition combined AND operation."""
    OR = 2
    """Scalar condition combined OR operation."""
    XOR = 3
    """Scalar condition combined XOR operation."""
    MINUS = 4
    """Scalar condition combined MINUS operation."""

CRDN_CONDITION_COMBINED_OPERATION_TYPE.AND.__doc__ = "Scalar condition combined AND operation."
CRDN_CONDITION_COMBINED_OPERATION_TYPE.OR.__doc__ = "Scalar condition combined OR operation."
CRDN_CONDITION_COMBINED_OPERATION_TYPE.XOR.__doc__ = "Scalar condition combined XOR operation."
CRDN_CONDITION_COMBINED_OPERATION_TYPE.MINUS.__doc__ = "Scalar condition combined MINUS operation."

agcls.AgTypeNameMap["CRDN_CONDITION_COMBINED_OPERATION_TYPE"] = CRDN_CONDITION_COMBINED_OPERATION_TYPE

class CRDN_CONDITION_SET_TYPE(IntEnum):
    """Define available condition set types."""
   
    UNKNOWN = -1
    """Unknown or unsupported condition set types."""
    SCALAR_THRESHOLDS = 0
    """Condition set placing multiple thresholds on specified scalar."""

CRDN_CONDITION_SET_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported condition set types."
CRDN_CONDITION_SET_TYPE.SCALAR_THRESHOLDS.__doc__ = "Condition set placing multiple thresholds on specified scalar."

agcls.AgTypeNameMap["CRDN_CONDITION_SET_TYPE"] = CRDN_CONDITION_SET_TYPE

class CRDN_CONDITION_THRESHOLD_OPTION(IntEnum):
    """Operations for Scalar Bounds Condition."""
   
    ABOVE_MIN = 1
    """Bound is above a minimum value."""
    BELOW_MAX = 2
    """Bound is below a maximum value."""
    INSIDE_MIN_MAX = 3
    """Bound is between a minimum and maximum value."""
    OUTSIDE_MIN_MAX = 4
    """Bound is outside a minimum and maximum value."""

CRDN_CONDITION_THRESHOLD_OPTION.ABOVE_MIN.__doc__ = "Bound is above a minimum value."
CRDN_CONDITION_THRESHOLD_OPTION.BELOW_MAX.__doc__ = "Bound is below a maximum value."
CRDN_CONDITION_THRESHOLD_OPTION.INSIDE_MIN_MAX.__doc__ = "Bound is between a minimum and maximum value."
CRDN_CONDITION_THRESHOLD_OPTION.OUTSIDE_MIN_MAX.__doc__ = "Bound is outside a minimum and maximum value."

agcls.AgTypeNameMap["CRDN_CONDITION_THRESHOLD_OPTION"] = CRDN_CONDITION_THRESHOLD_OPTION

class CRDN_CONDITION_TYPE(IntEnum):
    """Define available condition types."""
   
    UNKNOWN = -1
    """Unknown or unsupported condition type."""
    SCALAR_BOUNDS = 0
    """Condition placing bounds on specified scalar."""
    COMBINED = 1
    """Multiple conditiones on specified scalar."""
    POINT_IN_VOLUME = 2
    """Condition placing point in volume."""

CRDN_CONDITION_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported condition type."
CRDN_CONDITION_TYPE.SCALAR_BOUNDS.__doc__ = "Condition placing bounds on specified scalar."
CRDN_CONDITION_TYPE.COMBINED.__doc__ = "Multiple conditiones on specified scalar."
CRDN_CONDITION_TYPE.POINT_IN_VOLUME.__doc__ = "Condition placing point in volume."

agcls.AgTypeNameMap["CRDN_CONDITION_TYPE"] = CRDN_CONDITION_TYPE

class CRDN_DIMENSION_INHERITANCE(IntEnum):
    """Define how dimension is inherited."""
   
    NONE = 0
    """Do not inherit dimension."""
    FROM_X = 1
    """Inherit dimension from X scalar."""
    FROM_Y = 2
    """Inherit dimension from Y scalar."""

CRDN_DIMENSION_INHERITANCE.NONE.__doc__ = "Do not inherit dimension."
CRDN_DIMENSION_INHERITANCE.FROM_X.__doc__ = "Inherit dimension from X scalar."
CRDN_DIMENSION_INHERITANCE.FROM_Y.__doc__ = "Inherit dimension from Y scalar."

agcls.AgTypeNameMap["CRDN_DIMENSION_INHERITANCE"] = CRDN_DIMENSION_INHERITANCE

class CRDN_EVENT_ARRAY_FILTER_TYPE(IntEnum):
    """Event array filter types."""
   
    SKIP_TIME_STEP = 0
    """Skip time step."""
    SKIP_COUNT = 1
    """Skip count."""
    INTERVALS = 2
    """Intervals."""

CRDN_EVENT_ARRAY_FILTER_TYPE.SKIP_TIME_STEP.__doc__ = "Skip time step."
CRDN_EVENT_ARRAY_FILTER_TYPE.SKIP_COUNT.__doc__ = "Skip count."
CRDN_EVENT_ARRAY_FILTER_TYPE.INTERVALS.__doc__ = "Intervals."

agcls.AgTypeNameMap["CRDN_EVENT_ARRAY_FILTER_TYPE"] = CRDN_EVENT_ARRAY_FILTER_TYPE

class CRDN_EVENT_ARRAY_TYPE(IntEnum):
    """Define available time array types."""
   
    UNKNOWN = -1
    """Unknown or unsupported time array types."""
    EXTREMA = 0
    """Determine time of local minimum and/or maximum of specified scalar calculation."""
    START_STOP_TIMES = 1
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."""
    MERGED = 2
    """Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."""
    FILTERED = 3
    """Defined by filtering times from original time array according to specified filtering method."""
    FIXED_STEP = 4
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    CONDITION_CROSSINGS = 5
    """Time array containing times at which specified condition changes its satisfaction status."""
    SIGNALED = 6
    """Determine what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
    FIXED_TIMES = 7
    """Time array containing specific times."""

CRDN_EVENT_ARRAY_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported time array types."
CRDN_EVENT_ARRAY_TYPE.EXTREMA.__doc__ = "Determine time of local minimum and/or maximum of specified scalar calculation."
CRDN_EVENT_ARRAY_TYPE.START_STOP_TIMES.__doc__ = "Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."
CRDN_EVENT_ARRAY_TYPE.MERGED.__doc__ = "Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."
CRDN_EVENT_ARRAY_TYPE.FILTERED.__doc__ = "Defined by filtering times from original time array according to specified filtering method."
CRDN_EVENT_ARRAY_TYPE.FIXED_STEP.__doc__ = "Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."
CRDN_EVENT_ARRAY_TYPE.CONDITION_CROSSINGS.__doc__ = "Time array containing times at which specified condition changes its satisfaction status."
CRDN_EVENT_ARRAY_TYPE.SIGNALED.__doc__ = "Determine what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."
CRDN_EVENT_ARRAY_TYPE.FIXED_TIMES.__doc__ = "Time array containing specific times."

agcls.AgTypeNameMap["CRDN_EVENT_ARRAY_TYPE"] = CRDN_EVENT_ARRAY_TYPE

class CRDN_EVENT_INTERVAL_COLLECTION_TYPE(IntEnum):
    """Define available interval collection types."""
   
    UNKNOWN = -1
    """Unknown or unsupported interval collection types."""
    LIGHTING = 0
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    SIGNALED = 1
    """Determine what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
    CONDITION = 2
    """Interval collection containing intervals during which condition set is satisfied."""

CRDN_EVENT_INTERVAL_COLLECTION_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported interval collection types."
CRDN_EVENT_INTERVAL_COLLECTION_TYPE.LIGHTING.__doc__ = "Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."
CRDN_EVENT_INTERVAL_COLLECTION_TYPE.SIGNALED.__doc__ = "Determine what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."
CRDN_EVENT_INTERVAL_COLLECTION_TYPE.CONDITION.__doc__ = "Interval collection containing intervals during which condition set is satisfied."

agcls.AgTypeNameMap["CRDN_EVENT_INTERVAL_COLLECTION_TYPE"] = CRDN_EVENT_INTERVAL_COLLECTION_TYPE

class CRDN_EVENT_INTERVAL_LIST_TYPE(IntEnum):
    """Define available interval list types."""
   
    UNKNOWN = -1
    """Unknown or unsupported interval list types."""
    MERGED = 1
    """Interval list created by merging two constituent interval lists using specified logical operation."""
    FILTERED = 2
    """Defined by filtering intervals from original interval list using specified filtering method."""
    CONDITION = 3
    """Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."""
    SCALED = 4
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale."""
    SIGNALED = 5
    """Determine what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."""
    TIME_OFFSET = 6
    """Interval List defined by shifting specified reference interval list by fixed time offset."""
    FILE = 0
    """Interval list loaded from specified interval file."""
    FIXED = 7
    """Interval list with individual intervals defined between explicitly specified start and stop times."""

CRDN_EVENT_INTERVAL_LIST_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported interval list types."
CRDN_EVENT_INTERVAL_LIST_TYPE.MERGED.__doc__ = "Interval list created by merging two constituent interval lists using specified logical operation."
CRDN_EVENT_INTERVAL_LIST_TYPE.FILTERED.__doc__ = "Defined by filtering intervals from original interval list using specified filtering method."
CRDN_EVENT_INTERVAL_LIST_TYPE.CONDITION.__doc__ = "Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."
CRDN_EVENT_INTERVAL_LIST_TYPE.SCALED.__doc__ = "Interval List defined by scaling every interval in original interval list using either absolute or relative scale."
CRDN_EVENT_INTERVAL_LIST_TYPE.SIGNALED.__doc__ = "Determine what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."
CRDN_EVENT_INTERVAL_LIST_TYPE.TIME_OFFSET.__doc__ = "Interval List defined by shifting specified reference interval list by fixed time offset."
CRDN_EVENT_INTERVAL_LIST_TYPE.FILE.__doc__ = "Interval list loaded from specified interval file."
CRDN_EVENT_INTERVAL_LIST_TYPE.FIXED.__doc__ = "Interval list with individual intervals defined between explicitly specified start and stop times."

agcls.AgTypeNameMap["CRDN_EVENT_INTERVAL_LIST_TYPE"] = CRDN_EVENT_INTERVAL_LIST_TYPE

class CRDN_EVENT_INTERVAL_TYPE(IntEnum):
    """Define available interval types."""
   
    UNKNOWN = -1
    """Unknown or unsupported interval types."""
    FIXED = 0
    """Interval defined between two explicitly specified start and stop times."""
    FIXED_DURATION = 1
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    BETWEEN_TIME_INSTANTS = 2
    """Interval between specified start and stop time instants."""
    FROM_INTERVAL_LIST = 3
    """Interval created from specified interval list by using one of several selection methods."""
    SCALED = 4
    """Interval defined by scaling original interval using either absolute or relative scale."""
    SIGNALED = 5
    """Determine an interval recorded at a target clock location by performing signal transmission."""
    TIME_OFFSET = 6
    """Interval defined by shifting specified reference interval by fixed time offset."""
    SMART_INTERVAL = 7
    """A smart interval."""

CRDN_EVENT_INTERVAL_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported interval types."
CRDN_EVENT_INTERVAL_TYPE.FIXED.__doc__ = "Interval defined between two explicitly specified start and stop times."
CRDN_EVENT_INTERVAL_TYPE.FIXED_DURATION.__doc__ = "Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."
CRDN_EVENT_INTERVAL_TYPE.BETWEEN_TIME_INSTANTS.__doc__ = "Interval between specified start and stop time instants."
CRDN_EVENT_INTERVAL_TYPE.FROM_INTERVAL_LIST.__doc__ = "Interval created from specified interval list by using one of several selection methods."
CRDN_EVENT_INTERVAL_TYPE.SCALED.__doc__ = "Interval defined by scaling original interval using either absolute or relative scale."
CRDN_EVENT_INTERVAL_TYPE.SIGNALED.__doc__ = "Determine an interval recorded at a target clock location by performing signal transmission."
CRDN_EVENT_INTERVAL_TYPE.TIME_OFFSET.__doc__ = "Interval defined by shifting specified reference interval by fixed time offset."
CRDN_EVENT_INTERVAL_TYPE.SMART_INTERVAL.__doc__ = "A smart interval."

agcls.AgTypeNameMap["CRDN_EVENT_INTERVAL_TYPE"] = CRDN_EVENT_INTERVAL_TYPE

class CRDN_EVENT_LIST_MERGE_OPERATION(IntEnum):
    """Define merge operations for interval lists."""
   
    AND = 0
    """Intervals both in A and B."""
    OR = 1
    """Intervals in A or B."""
    XOR = 2
    """Intervals in A or B but not in both."""
    MINUS = 3
    """Intervals in A and not in B."""

CRDN_EVENT_LIST_MERGE_OPERATION.AND.__doc__ = "Intervals both in A and B."
CRDN_EVENT_LIST_MERGE_OPERATION.OR.__doc__ = "Intervals in A or B."
CRDN_EVENT_LIST_MERGE_OPERATION.XOR.__doc__ = "Intervals in A or B but not in both."
CRDN_EVENT_LIST_MERGE_OPERATION.MINUS.__doc__ = "Intervals in A and not in B."

agcls.AgTypeNameMap["CRDN_EVENT_LIST_MERGE_OPERATION"] = CRDN_EVENT_LIST_MERGE_OPERATION

class CRDN_EVENT_TYPE(IntEnum):
    """Define available time instant types."""
   
    UNKNOWN = -1
    """Unknown or unsupported time instant types."""
    EPOCH = 0
    """Time instant set at specified date/time."""
    EXTREMUM = 1
    """Determine time of global minimum or maximum of specified scalar calculation."""
    FROM_INTERVAL = 2
    """Start or stop time of selected reference interval."""
    SIGNALED = 3
    """Determine what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."""
    TIME_OFFSET = 4
    """Time instant at fixed offset from specified reference time instant."""
    SMART_EPOCH = 5
    """A smart epoch."""

CRDN_EVENT_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported time instant types."
CRDN_EVENT_TYPE.EPOCH.__doc__ = "Time instant set at specified date/time."
CRDN_EVENT_TYPE.EXTREMUM.__doc__ = "Determine time of global minimum or maximum of specified scalar calculation."
CRDN_EVENT_TYPE.FROM_INTERVAL.__doc__ = "Start or stop time of selected reference interval."
CRDN_EVENT_TYPE.SIGNALED.__doc__ = "Determine what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."
CRDN_EVENT_TYPE.TIME_OFFSET.__doc__ = "Time instant at fixed offset from specified reference time instant."
CRDN_EVENT_TYPE.SMART_EPOCH.__doc__ = "A smart epoch."

agcls.AgTypeNameMap["CRDN_EVENT_TYPE"] = CRDN_EVENT_TYPE

class CRDN_EXTREMUM_CONSTANTS(IntFlag):
    """These constants are utilized when finding a local or global minimum or maximum, or the threshold crossing."""
   
    MINIMUM = 1
    """Find the minimum value."""
    MAXIMUM = 2
    """Find the maximum value."""

CRDN_EXTREMUM_CONSTANTS.MINIMUM.__doc__ = "Find the minimum value."
CRDN_EXTREMUM_CONSTANTS.MAXIMUM.__doc__ = "Find the maximum value."

agcls.AgTypeNameMap["CRDN_EXTREMUM_CONSTANTS"] = CRDN_EXTREMUM_CONSTANTS

class CRDN_FILE_INTERPOLATOR_TYPE(IntEnum):
    """Interpolator types."""
   
    INVALID = -1
    """Unknown or invalid interpolator."""
    LAGRANGE = 1
    """Lagrange interpolation."""
    HERMITE = 2
    """Hermite interpolation."""
    HOLD_PREVIOUS = 3
    """Holds the value at the closest previous sample time to any requested time."""
    HOLD_NEXT = 4
    """Holds the value at the closest next sample time to any requested time."""
    HOLD_NEAREST = 5
    """Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."""

CRDN_FILE_INTERPOLATOR_TYPE.INVALID.__doc__ = "Unknown or invalid interpolator."
CRDN_FILE_INTERPOLATOR_TYPE.LAGRANGE.__doc__ = "Lagrange interpolation."
CRDN_FILE_INTERPOLATOR_TYPE.HERMITE.__doc__ = "Hermite interpolation."
CRDN_FILE_INTERPOLATOR_TYPE.HOLD_PREVIOUS.__doc__ = "Holds the value at the closest previous sample time to any requested time."
CRDN_FILE_INTERPOLATOR_TYPE.HOLD_NEXT.__doc__ = "Holds the value at the closest next sample time to any requested time."
CRDN_FILE_INTERPOLATOR_TYPE.HOLD_NEAREST.__doc__ = "Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."

agcls.AgTypeNameMap["CRDN_FILE_INTERPOLATOR_TYPE"] = CRDN_FILE_INTERPOLATOR_TYPE

class CRDN_INTEGRAL_TYPE(IntEnum):
    """Integral types."""
   
    FIXED_STEP_SIMPSON = 2
    """Simpson integral method."""
    FIXED_STEP_TRAPZ = 1
    """Trapezoidal integral method."""
    ADAPTIVE_STEP = 3
    """Adaptive Lobatto integral method."""

CRDN_INTEGRAL_TYPE.FIXED_STEP_SIMPSON.__doc__ = "Simpson integral method."
CRDN_INTEGRAL_TYPE.FIXED_STEP_TRAPZ.__doc__ = "Trapezoidal integral method."
CRDN_INTEGRAL_TYPE.ADAPTIVE_STEP.__doc__ = "Adaptive Lobatto integral method."

agcls.AgTypeNameMap["CRDN_INTEGRAL_TYPE"] = CRDN_INTEGRAL_TYPE

class CRDN_INTEGRATION_WINDOW_TYPE(IntEnum):
    """Define the interval of times during which an integral is evaluated."""
   
    TOTAL = 0
    """Define the integral's window as the entire available interval list which effectively makes the value of the integral constant."""
    CUMULATIVE_TO_CURRENT = 1
    """Define the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."""
    CUMULATIVE_FROM_CURRENT = 2
    """Define the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."""
    SLIDING_WINDOW = 3
    """Define the integral's window as the interval of times centered around the current time with the specified front and back durations."""

CRDN_INTEGRATION_WINDOW_TYPE.TOTAL.__doc__ = "Define the integral's window as the entire available interval list which effectively makes the value of the integral constant."
CRDN_INTEGRATION_WINDOW_TYPE.CUMULATIVE_TO_CURRENT.__doc__ = "Define the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."
CRDN_INTEGRATION_WINDOW_TYPE.CUMULATIVE_FROM_CURRENT.__doc__ = "Define the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."
CRDN_INTEGRATION_WINDOW_TYPE.SLIDING_WINDOW.__doc__ = "Define the integral's window as the interval of times centered around the current time with the specified front and back durations."

agcls.AgTypeNameMap["CRDN_INTEGRATION_WINDOW_TYPE"] = CRDN_INTEGRATION_WINDOW_TYPE

class CRDN_INTERPOLATOR_TYPE(IntEnum):
    """Interpolator types."""
   
    INVALID = -1
    """Unknown or invalid interpolator."""
    LAGRANGE = 1
    """Lagrange interpolation."""
    HERMITE = 2
    """Hermite interpolation."""

CRDN_INTERPOLATOR_TYPE.INVALID.__doc__ = "Unknown or invalid interpolator."
CRDN_INTERPOLATOR_TYPE.LAGRANGE.__doc__ = "Lagrange interpolation."
CRDN_INTERPOLATOR_TYPE.HERMITE.__doc__ = "Hermite interpolation."

agcls.AgTypeNameMap["CRDN_INTERPOLATOR_TYPE"] = CRDN_INTERPOLATOR_TYPE

class CRDN_INTERVAL_DURATION_KIND(IntEnum):
    """Duration for filtering intervals or gaps from interval lists or time arrays."""
   
    AT_LEAST = 0
    """Filter by at least a specified number of seconds."""
    AT_MOST = 1
    """Filter by at most a specified number of seconds."""

CRDN_INTERVAL_DURATION_KIND.AT_LEAST.__doc__ = "Filter by at least a specified number of seconds."
CRDN_INTERVAL_DURATION_KIND.AT_MOST.__doc__ = "Filter by at most a specified number of seconds."

agcls.AgTypeNameMap["CRDN_INTERVAL_DURATION_KIND"] = CRDN_INTERVAL_DURATION_KIND

class CRDN_INTERVAL_SELECTION(IntEnum):
    """Select the method to choose an interval from an interval list."""
   
    FROM_START = 1
    """Select an interval by counting a specified number from the first interval."""
    FROM_END = 2
    """Select an interval by counting a specified number back from the last interval."""
    MAX_DURATION = 4
    """Select the interval with the largest duration."""
    MIN_DURATION = 5
    """Select the interval with the smallest duration."""
    MAX_GAP = 9
    """Select the largest gap between intervals."""
    MIN_GAP = 10
    """Select the largest gap between intervals."""
    SPAN = 100
    """Select the interval that is the span of the interval list."""

CRDN_INTERVAL_SELECTION.FROM_START.__doc__ = "Select an interval by counting a specified number from the first interval."
CRDN_INTERVAL_SELECTION.FROM_END.__doc__ = "Select an interval by counting a specified number back from the last interval."
CRDN_INTERVAL_SELECTION.MAX_DURATION.__doc__ = "Select the interval with the largest duration."
CRDN_INTERVAL_SELECTION.MIN_DURATION.__doc__ = "Select the interval with the smallest duration."
CRDN_INTERVAL_SELECTION.MAX_GAP.__doc__ = "Select the largest gap between intervals."
CRDN_INTERVAL_SELECTION.MIN_GAP.__doc__ = "Select the largest gap between intervals."
CRDN_INTERVAL_SELECTION.SPAN.__doc__ = "Select the interval that is the span of the interval list."

agcls.AgTypeNameMap["CRDN_INTERVAL_SELECTION"] = CRDN_INTERVAL_SELECTION

class CRDN_PARAMETER_SET_TYPE(IntEnum):
    """Define parameter set types."""
   
    UNKNOWN = -1
    """Unknown or unsupported parameter set."""
    ATTITUDE = 0
    """A parameter set type is defined by identifying one set of axes in reference to another."""
    GROUND_TRAJECTORY = 1
    """A parameter set type is defined by identifying location in reference central body."""
    TRAJECTORY = 2
    """A parameter set type is defined by identifying location in reference coordinate system."""
    ORBIT = 3
    """A parameter set type is defined by identifying orbiting point and its central body."""
    VECTOR = 4
    """A parameter set type is defined by identifying vector in reference axes."""

CRDN_PARAMETER_SET_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported parameter set."
CRDN_PARAMETER_SET_TYPE.ATTITUDE.__doc__ = "A parameter set type is defined by identifying one set of axes in reference to another."
CRDN_PARAMETER_SET_TYPE.GROUND_TRAJECTORY.__doc__ = "A parameter set type is defined by identifying location in reference central body."
CRDN_PARAMETER_SET_TYPE.TRAJECTORY.__doc__ = "A parameter set type is defined by identifying location in reference coordinate system."
CRDN_PARAMETER_SET_TYPE.ORBIT.__doc__ = "A parameter set type is defined by identifying orbiting point and its central body."
CRDN_PARAMETER_SET_TYPE.VECTOR.__doc__ = "A parameter set type is defined by identifying vector in reference axes."

agcls.AgTypeNameMap["CRDN_PARAMETER_SET_TYPE"] = CRDN_PARAMETER_SET_TYPE

class CRDN_PRUNE_FILTER(IntEnum):
    """Specify the filter for filtering interval lists or time arrays."""
   
    UNKNOWN = 0
    """Unknown or unsupported prune filter."""
    FIRST_INTERVALS = 1
    """Select specified number of first intervals from original list."""
    LAST_INTERVALS = 2
    """Select specified number of last intervals from original list."""
    INTERVALS = 3
    """Select intervals which satisfy additional duration condition."""
    GAPS = 4
    """Select gaps between intervals which satisfy additional duration condition."""
    SATISFACTION_INTERVALS = 5
    """Satisfaction Intervals selects intervals which satisfy additional condition and duration."""
    RELATIVE_SATISFACTION_INTERVALS = 6
    """Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."""

CRDN_PRUNE_FILTER.UNKNOWN.__doc__ = "Unknown or unsupported prune filter."
CRDN_PRUNE_FILTER.FIRST_INTERVALS.__doc__ = "Select specified number of first intervals from original list."
CRDN_PRUNE_FILTER.LAST_INTERVALS.__doc__ = "Select specified number of last intervals from original list."
CRDN_PRUNE_FILTER.INTERVALS.__doc__ = "Select intervals which satisfy additional duration condition."
CRDN_PRUNE_FILTER.GAPS.__doc__ = "Select gaps between intervals which satisfy additional duration condition."
CRDN_PRUNE_FILTER.SATISFACTION_INTERVALS.__doc__ = "Satisfaction Intervals selects intervals which satisfy additional condition and duration."
CRDN_PRUNE_FILTER.RELATIVE_SATISFACTION_INTERVALS.__doc__ = "Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."

agcls.AgTypeNameMap["CRDN_PRUNE_FILTER"] = CRDN_PRUNE_FILTER

class CRDN_SAMPLED_REFERENCE_TIME(IntEnum):
    """Event array reference type."""
   
    REFERENCE_EVENT = 0
    """Use a Time Instant as the reference time."""
    START_OF_EACH_INTERVAL = 1
    """Use the start of each interval as the reference time."""
    STOP_OF_EACH_INTERVAL = 2
    """Use the stop of each interval as the reference time."""
    START_OF_INTERVAL_LIST = 3
    """Use the start of each interval list as the reference time."""
    STOP_OF_INTERVAL_LIST = 4
    """Use the stop of each interval list as the reference time."""

CRDN_SAMPLED_REFERENCE_TIME.REFERENCE_EVENT.__doc__ = "Use a Time Instant as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.START_OF_EACH_INTERVAL.__doc__ = "Use the start of each interval as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.STOP_OF_EACH_INTERVAL.__doc__ = "Use the stop of each interval as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.START_OF_INTERVAL_LIST.__doc__ = "Use the start of each interval list as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.STOP_OF_INTERVAL_LIST.__doc__ = "Use the stop of each interval list as the reference time."

agcls.AgTypeNameMap["CRDN_SAMPLED_REFERENCE_TIME"] = CRDN_SAMPLED_REFERENCE_TIME

class CRDN_SAMPLING_METHOD(IntEnum):
    """Define the Sampling Method."""
   
    UNKNOWN = 0
    """Unknown or unsupported sampling method."""
    FIXED_STEP = 1
    """Fixed step sampling method."""
    RELATIVE_TOLERANCE = 2
    """Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."""
    CURVATURE_TOLERANCE = 3
    """Curvature tolerance also uses changes in slope between samples."""

CRDN_SAMPLING_METHOD.UNKNOWN.__doc__ = "Unknown or unsupported sampling method."
CRDN_SAMPLING_METHOD.FIXED_STEP.__doc__ = "Fixed step sampling method."
CRDN_SAMPLING_METHOD.RELATIVE_TOLERANCE.__doc__ = "Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."
CRDN_SAMPLING_METHOD.CURVATURE_TOLERANCE.__doc__ = "Curvature tolerance also uses changes in slope between samples."

agcls.AgTypeNameMap["CRDN_SAMPLING_METHOD"] = CRDN_SAMPLING_METHOD

class CRDN_SATISFACTION_CROSSING(IntEnum):
    """Direction crossing flags."""
   
    NONE = 0
    """Use either off-to-on or on-to-off condition to determine satisfaction."""
    IN = 1
    """Satisfaction occurs when crossing from off to on condition."""
    OUT = 2
    """Satisfaction occurs when crossing from on to off condition."""

CRDN_SATISFACTION_CROSSING.NONE.__doc__ = "Use either off-to-on or on-to-off condition to determine satisfaction."
CRDN_SATISFACTION_CROSSING.IN.__doc__ = "Satisfaction occurs when crossing from off to on condition."
CRDN_SATISFACTION_CROSSING.OUT.__doc__ = "Satisfaction occurs when crossing from on to off condition."

agcls.AgTypeNameMap["CRDN_SATISFACTION_CROSSING"] = CRDN_SATISFACTION_CROSSING

class CRDN_SAVE_DATA_OPTION(IntEnum):
    """Method for saving computed data."""
   
    APPLICATION_SETTINGS = -1
    """Use the application setting to determine whether computed data should be saved/loaded."""
    YES = 100
    """Save/load computed data."""
    NO = 10
    """Don't save computed data, recompute data on load."""

CRDN_SAVE_DATA_OPTION.APPLICATION_SETTINGS.__doc__ = "Use the application setting to determine whether computed data should be saved/loaded."
CRDN_SAVE_DATA_OPTION.YES.__doc__ = "Save/load computed data."
CRDN_SAVE_DATA_OPTION.NO.__doc__ = "Don't save computed data, recompute data on load."

agcls.AgTypeNameMap["CRDN_SAVE_DATA_OPTION"] = CRDN_SAVE_DATA_OPTION

class CRDN_SIGNAL_PATH_REFERENCE_SYSTEM(IntEnum):
    """Signal path reference system types."""
   
    USE_ACCESS_DEFAULT = -1
    """Use Access default system."""
    CENTRAL_BODY_INERTIAL = 0
    """Use central body inertial system."""
    SOLAR_SYSTEM_BARYCENTER = 1
    """Use solar system barycenter system."""
    CUSTOM = 2
    """User will specify a system."""

CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.USE_ACCESS_DEFAULT.__doc__ = "Use Access default system."
CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.CENTRAL_BODY_INERTIAL.__doc__ = "Use central body inertial system."
CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.SOLAR_SYSTEM_BARYCENTER.__doc__ = "Use solar system barycenter system."
CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.CUSTOM.__doc__ = "User will specify a system."

agcls.AgTypeNameMap["CRDN_SIGNAL_PATH_REFERENCE_SYSTEM"] = CRDN_SIGNAL_PATH_REFERENCE_SYSTEM

class CRDN_SMART_EPOCH_STATE(IntEnum):
    """Smart epoch states."""
   
    EXPLICIT = 0
    """Smart epoch is specified explicitly using a time."""
    IMPLICIT = 3
    """Smart epoch is specified implicitly."""

CRDN_SMART_EPOCH_STATE.EXPLICIT.__doc__ = "Smart epoch is specified explicitly using a time."
CRDN_SMART_EPOCH_STATE.IMPLICIT.__doc__ = "Smart epoch is specified implicitly."

agcls.AgTypeNameMap["CRDN_SMART_EPOCH_STATE"] = CRDN_SMART_EPOCH_STATE

class CRDN_SMART_INTERVAL_STATE(IntEnum):
    """Smart interval states."""
   
    EXPLICIT = 0
    """Smart interval is specified explicitly using start/stop times."""
    IMPLICIT = 1
    """Smart interval is specified implicitly using start/stop times."""
    START_STOP = 2
    """Smart interval is specified using smart epochs."""
    START_DURATION = 4
    """Smart interval is specified using a start epoch and duration."""
    EXPLICIT_DURATION = 3
    """Smart interval is specified using a start time and explicit duration."""

CRDN_SMART_INTERVAL_STATE.EXPLICIT.__doc__ = "Smart interval is specified explicitly using start/stop times."
CRDN_SMART_INTERVAL_STATE.IMPLICIT.__doc__ = "Smart interval is specified implicitly using start/stop times."
CRDN_SMART_INTERVAL_STATE.START_STOP.__doc__ = "Smart interval is specified using smart epochs."
CRDN_SMART_INTERVAL_STATE.START_DURATION.__doc__ = "Smart interval is specified using a start epoch and duration."
CRDN_SMART_INTERVAL_STATE.EXPLICIT_DURATION.__doc__ = "Smart interval is specified using a start time and explicit duration."

agcls.AgTypeNameMap["CRDN_SMART_INTERVAL_STATE"] = CRDN_SMART_INTERVAL_STATE

class CRDN_SPEED_OPTIONS(IntEnum):
    """Define various speed options."""
   
    LIGHT_TRANSMISSION_SPEED = 1
    """Light transmission speed."""
    CUSTOM_TRANSMISSION_SPEED = 2
    """Custom transmission speed."""

CRDN_SPEED_OPTIONS.LIGHT_TRANSMISSION_SPEED.__doc__ = "Light transmission speed."
CRDN_SPEED_OPTIONS.CUSTOM_TRANSMISSION_SPEED.__doc__ = "Custom transmission speed."

agcls.AgTypeNameMap["CRDN_SPEED_OPTIONS"] = CRDN_SPEED_OPTIONS

class CRDN_START_STOP_OPTION(IntEnum):
    """Start/stop options."""
   
    COUNT_START_ONLY = 1
    """Use the start time of the interval."""
    COUNT_STOP_ONLY = 2
    """Use the stop time of the interval."""
    COUNT_START_STOP = 3
    """Use the start time and stop time of the interval."""

CRDN_START_STOP_OPTION.COUNT_START_ONLY.__doc__ = "Use the start time of the interval."
CRDN_START_STOP_OPTION.COUNT_STOP_ONLY.__doc__ = "Use the stop time of the interval."
CRDN_START_STOP_OPTION.COUNT_START_STOP.__doc__ = "Use the start time and stop time of the interval."

agcls.AgTypeNameMap["CRDN_START_STOP_OPTION"] = CRDN_START_STOP_OPTION

class CRDN_THRESH_CONVERGE_SENSE(IntEnum):
    """Specify the desired sense of the results from threshold crossing computations."""
   
    SIMPLE = 0
    """Just converge within tolerance."""
    ABOVE = 1
    """Result above or at threshold."""
    BELOW = 2
    """Result below or at threshold."""

CRDN_THRESH_CONVERGE_SENSE.SIMPLE.__doc__ = "Just converge within tolerance."
CRDN_THRESH_CONVERGE_SENSE.ABOVE.__doc__ = "Result above or at threshold."
CRDN_THRESH_CONVERGE_SENSE.BELOW.__doc__ = "Result below or at threshold."

agcls.AgTypeNameMap["CRDN_THRESH_CONVERGE_SENSE"] = CRDN_THRESH_CONVERGE_SENSE

class VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE(IntEnum):
    """Define component directions for a vector."""
   
    X = 0
    """X component."""
    Y = 1
    """Y component."""
    Z = 2
    """Z component."""
    MINUS_X = 3
    """-X component."""
    MINUS_Y = 4
    """-Y component."""
    MINUS_Z = 5
    """-Z component."""

VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.X.__doc__ = "X component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.Y.__doc__ = "Y component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.Z.__doc__ = "Z component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.MINUS_X.__doc__ = "-X component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.MINUS_Y.__doc__ = "-Y component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.MINUS_Z.__doc__ = "-Z component."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE"] = VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE

class CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE(IntEnum):
    """Define volume calc altitude reference types."""
   
    ELLIPSOID = 0
    """Volume calc altitude above reference ellipsoid."""
    TERRAIN = 1
    """Volume calc altitude reference above terrain."""
    MSL = 2
    """Volume calc altitude reference above mean sea level."""

CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE.ELLIPSOID.__doc__ = "Volume calc altitude above reference ellipsoid."
CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE.TERRAIN.__doc__ = "Volume calc altitude reference above terrain."
CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE.MSL.__doc__ = "Volume calc altitude reference above mean sea level."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE"] = CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE

class CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE(IntEnum):
    """Define volume calc angle off vector reference types."""
   
    PLANE_SIGNED = 1
    """Volume calc angle off plane signed."""
    PLANE_UNSIGNED = 2
    """Volume calc angle off plane unsigned."""
    ABOUT_VECTOR_SIGNED = 4
    """Volume calc angle about vector signed."""
    ABOUT_VECTOR_UNSIGNED = 8
    """Volume calc angle about vector unsigned."""
    VECTOR = 16
    """Volume calc angle off vector."""

CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.PLANE_SIGNED.__doc__ = "Volume calc angle off plane signed."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.PLANE_UNSIGNED.__doc__ = "Volume calc angle off plane unsigned."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.ABOUT_VECTOR_SIGNED.__doc__ = "Volume calc angle about vector signed."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.ABOUT_VECTOR_UNSIGNED.__doc__ = "Volume calc angle about vector unsigned."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.VECTOR.__doc__ = "Volume calc angle off vector."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE"] = CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE

class CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE(IntEnum):
    """Define volume calc range distance types."""
   
    FROM_POINT = 0
    """Volume calc range distance type from point."""
    ALONG_VECTOR_SIGNED = 1
    """Volume calc range distance type from point."""
    ALONG_VECTOR_UNSIGNED = 2
    """Volume calc range distance type along vector unsigned."""
    PLANE_SIGNED = 4
    """Volume calc range distance type plane signed."""
    PLANE_UNSIGNED = 8
    """Volume calc range distance type plane signed."""

CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.FROM_POINT.__doc__ = "Volume calc range distance type from point."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.ALONG_VECTOR_SIGNED.__doc__ = "Volume calc range distance type from point."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.ALONG_VECTOR_UNSIGNED.__doc__ = "Volume calc range distance type along vector unsigned."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.PLANE_SIGNED.__doc__ = "Volume calc range distance type plane signed."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.PLANE_UNSIGNED.__doc__ = "Volume calc range distance type plane signed."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE"] = CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE

class CRDN_VOLUME_CALC_RANGE_SPEED_TYPE(IntEnum):
    """Define volume calc range distance types."""
   
    LIGHT = 1
    """Volume calc range distance type from point."""
    CUSTOM = 2
    """Volume calc range distance type from point."""

CRDN_VOLUME_CALC_RANGE_SPEED_TYPE.LIGHT.__doc__ = "Volume calc range distance type from point."
CRDN_VOLUME_CALC_RANGE_SPEED_TYPE.CUSTOM.__doc__ = "Volume calc range distance type from point."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_RANGE_SPEED_TYPE"] = CRDN_VOLUME_CALC_RANGE_SPEED_TYPE

class CRDN_VOLUME_CALC_TYPE(IntEnum):
    """Define volume calc types."""
   
    UNKNOWN = -1
    """Unknown or unsupported volume calc."""
    ALTITUDE = 0
    """volume calc type altitude to location."""
    ANGLE_OFF_VECTOR = 1
    """volume calc type angle to location."""
    FILE = 2
    """volume calc type File."""
    FROM_SCALAR = 3
    """volume calc type scalar at location."""
    SOLAR_INTENSITY = 4
    """volume calc type Solar Intensity."""
    VOLUME_SATISFACTION_METRIC = 5
    """volume calc type Spatial Condition Satisfaction Metric."""
    RANGE = 6
    """volume calc type Distance to Location."""
    DELAY_RANGE = 7
    """volume calc type Propagation Delay to Location."""

CRDN_VOLUME_CALC_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported volume calc."
CRDN_VOLUME_CALC_TYPE.ALTITUDE.__doc__ = "volume calc type altitude to location."
CRDN_VOLUME_CALC_TYPE.ANGLE_OFF_VECTOR.__doc__ = "volume calc type angle to location."
CRDN_VOLUME_CALC_TYPE.FILE.__doc__ = "volume calc type File."
CRDN_VOLUME_CALC_TYPE.FROM_SCALAR.__doc__ = "volume calc type scalar at location."
CRDN_VOLUME_CALC_TYPE.SOLAR_INTENSITY.__doc__ = "volume calc type Solar Intensity."
CRDN_VOLUME_CALC_TYPE.VOLUME_SATISFACTION_METRIC.__doc__ = "volume calc type Spatial Condition Satisfaction Metric."
CRDN_VOLUME_CALC_TYPE.RANGE.__doc__ = "volume calc type Distance to Location."
CRDN_VOLUME_CALC_TYPE.DELAY_RANGE.__doc__ = "volume calc type Propagation Delay to Location."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_TYPE"] = CRDN_VOLUME_CALC_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE(IntEnum):
    """Define volume calc spatial condition accumulation types."""
   
    UP_TO_CURRENT_TIME = -1
    """Volume calc spatial condition satisfaction accumulation type up to current time."""
    CURRENT_TIME = 0
    """Volume calc spatial condition satisfaction accumulation type current time."""
    FROM_CURRENT_TIME = 1
    """Volume calc spatial condition satisfaction accumulation type from current time."""
    TOTAL = 10
    """Volume calc spatial condition satisfaction accumulation type total."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.UP_TO_CURRENT_TIME.__doc__ = "Volume calc spatial condition satisfaction accumulation type up to current time."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.CURRENT_TIME.__doc__ = "Volume calc spatial condition satisfaction accumulation type current time."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.FROM_CURRENT_TIME.__doc__ = "Volume calc spatial condition satisfaction accumulation type from current time."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.TOTAL.__doc__ = "Volume calc spatial condition satisfaction accumulation type total."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE(IntEnum):
    """Define volume calc spatial condition duration types."""
   
    MIN = -1
    """Volume calc spatial condition satisfaction duration type minimum."""
    SUM = 0
    """Volume calc spatial condition satisfaction duration type sum."""
    MAX = 1
    """Volume calc spatial condition satisfaction duration type maximum."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE.MIN.__doc__ = "Volume calc spatial condition satisfaction duration type minimum."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE.SUM.__doc__ = "Volume calc spatial condition satisfaction duration type sum."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE.MAX.__doc__ = "Volume calc spatial condition satisfaction duration type maximum."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE(IntEnum):
    """Define volume calc spatial condition filter types."""
   
    FIRST_INTERVALS = -10
    """Volume calc spatial condition satisfaction filter type first intervals."""
    LAST_INTERVALS = -20
    """Volume calc spatial condition satisfaction filter type last intervals."""
    NONE = 0
    """Volume calc spatial condition satisfaction filter type none."""
    GAP_DURATION = 1
    """Volume calc spatial condition satisfaction filter type gap duration."""
    INTERVAL_DURATION = 2
    """Volume calc spatial condition satisfaction filter type interval duration."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.FIRST_INTERVALS.__doc__ = "Volume calc spatial condition satisfaction filter type first intervals."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.LAST_INTERVALS.__doc__ = "Volume calc spatial condition satisfaction filter type last intervals."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.NONE.__doc__ = "Volume calc spatial condition satisfaction filter type none."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.GAP_DURATION.__doc__ = "Volume calc spatial condition satisfaction filter type gap duration."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.INTERVAL_DURATION.__doc__ = "Volume calc spatial condition satisfaction filter type interval duration."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE(IntEnum):
    """Define volume calc spatial condition satisfaction metric types."""
   
    NUMBER_OF_GAPS = -2
    """Volume calc spatial condition satisfaction metric type number of gaps."""
    NUMBER_OF_INTERVALS = -1
    """Volume calc spatial condition satisfaction metric type number of intervals."""
    TIME_SINCE_LAST_SATISFACTION = 1
    """Volume calc spatial condition satisfaction metric type time since last satisfaction."""
    TIME_UNTIL_NEXT_SATISFACTION = 2
    """Volume calc spatial condition satisfaction metric type time until next satisfaction."""
    INTERVAL_DURATION = 10
    """Volume calc spatial condition satisfaction metric type interbnal duration."""
    GAP_DURATION = 20
    """Volume calc spatial condition satisfaction metric type gap duration."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.NUMBER_OF_GAPS.__doc__ = "Volume calc spatial condition satisfaction metric type number of gaps."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.NUMBER_OF_INTERVALS.__doc__ = "Volume calc spatial condition satisfaction metric type number of intervals."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.TIME_SINCE_LAST_SATISFACTION.__doc__ = "Volume calc spatial condition satisfaction metric type time since last satisfaction."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.TIME_UNTIL_NEXT_SATISFACTION.__doc__ = "Volume calc spatial condition satisfaction metric type time until next satisfaction."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.INTERVAL_DURATION.__doc__ = "Volume calc spatial condition satisfaction metric type interbnal duration."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.GAP_DURATION.__doc__ = "Volume calc spatial condition satisfaction metric type gap duration."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE

class CRDN_VOLUME_GRID_TYPE(IntEnum):
    """Define volume grid types."""
   
    UNKNOWN = -1
    """Unknown or unsupported volume grid."""
    CARTESIAN = 0
    """volume grid type cartesian."""
    CYLINDRICAL = 1
    """volume grid type Cylindrical."""
    SPHERICAL = 2
    """volume grid type Spherical."""
    CONSTRAINED = 3
    """volume grid type Constrained."""
    LAT_LON_ALTITUDE = 4
    """volume grid type LatLonAlt (Cartographic)."""
    BEARING_ALTITUDE = 5
    """volume grid type BearingAlt (Surface Bearing)."""

CRDN_VOLUME_GRID_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported volume grid."
CRDN_VOLUME_GRID_TYPE.CARTESIAN.__doc__ = "volume grid type cartesian."
CRDN_VOLUME_GRID_TYPE.CYLINDRICAL.__doc__ = "volume grid type Cylindrical."
CRDN_VOLUME_GRID_TYPE.SPHERICAL.__doc__ = "volume grid type Spherical."
CRDN_VOLUME_GRID_TYPE.CONSTRAINED.__doc__ = "volume grid type Constrained."
CRDN_VOLUME_GRID_TYPE.LAT_LON_ALTITUDE.__doc__ = "volume grid type LatLonAlt (Cartographic)."
CRDN_VOLUME_GRID_TYPE.BEARING_ALTITUDE.__doc__ = "volume grid type BearingAlt (Surface Bearing)."

agcls.AgTypeNameMap["CRDN_VOLUME_GRID_TYPE"] = CRDN_VOLUME_GRID_TYPE

class CRDN_VOLUME_RESULT_VECTOR_REQUEST(IntEnum):
    """Define volume result vector request types."""
   
    POSITION = 1
    """volume result vector request pos type."""
    NATIVE_POSITION = 2
    """volume result vector request native pos type."""
    METRIC = 16
    """volume result vector request metric type."""
    SATISFACTION = 32
    """volume result vector request satisfaction type."""
    GRADIENT = 256
    """volume result vector request gradient type."""

CRDN_VOLUME_RESULT_VECTOR_REQUEST.POSITION.__doc__ = "volume result vector request pos type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.NATIVE_POSITION.__doc__ = "volume result vector request native pos type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.METRIC.__doc__ = "volume result vector request metric type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.SATISFACTION.__doc__ = "volume result vector request satisfaction type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.GRADIENT.__doc__ = "volume result vector request gradient type."

agcls.AgTypeNameMap["CRDN_VOLUME_RESULT_VECTOR_REQUEST"] = CRDN_VOLUME_RESULT_VECTOR_REQUEST

class CRDN_VOLUME_TYPE(IntEnum):
    """Define volume grid types."""
   
    UNKNOWN = -1
    """Unknown or unsupported volume."""
    COMBINED = 0
    """volume type combined."""
    LIGHTING = 1
    """volume type lighting."""
    OVER_TIME = 2
    """volume type over time."""
    FROM_GRID = 3
    """volume type from grid (Grid Bounding Volume)."""
    FROM_CALC = 4
    """volume type from calc (Spatial Calculation Bounds)."""
    FROM_TIME_SATISFACTION = 5
    """volume type from time satisfaction (Valid Time At Location)."""
    FROM_CONDITION = 6
    """volume type from condition (Condition At Location)."""
    INVIEW = 7
    """volume type Inview (Access To Location)."""

CRDN_VOLUME_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported volume."
CRDN_VOLUME_TYPE.COMBINED.__doc__ = "volume type combined."
CRDN_VOLUME_TYPE.LIGHTING.__doc__ = "volume type lighting."
CRDN_VOLUME_TYPE.OVER_TIME.__doc__ = "volume type over time."
CRDN_VOLUME_TYPE.FROM_GRID.__doc__ = "volume type from grid (Grid Bounding Volume)."
CRDN_VOLUME_TYPE.FROM_CALC.__doc__ = "volume type from calc (Spatial Calculation Bounds)."
CRDN_VOLUME_TYPE.FROM_TIME_SATISFACTION.__doc__ = "volume type from time satisfaction (Valid Time At Location)."
CRDN_VOLUME_TYPE.FROM_CONDITION.__doc__ = "volume type from condition (Condition At Location)."
CRDN_VOLUME_TYPE.INVIEW.__doc__ = "volume type Inview (Access To Location)."

agcls.AgTypeNameMap["CRDN_VOLUME_TYPE"] = CRDN_VOLUME_TYPE

class CRDN_VOLUME_ABERRATION_TYPE(IntEnum):
    """Define the model of aberration to use."""
   
    UNKNOWN = -1
    """Aberration type unknown."""
    TOTAL = 0
    """Aberration type total."""
    ANNUAL = 1
    """SAberration type annual."""
    NONE = 2
    """Aberration type none."""

CRDN_VOLUME_ABERRATION_TYPE.UNKNOWN.__doc__ = "Aberration type unknown."
CRDN_VOLUME_ABERRATION_TYPE.TOTAL.__doc__ = "Aberration type total."
CRDN_VOLUME_ABERRATION_TYPE.ANNUAL.__doc__ = "SAberration type annual."
CRDN_VOLUME_ABERRATION_TYPE.NONE.__doc__ = "Aberration type none."

agcls.AgTypeNameMap["CRDN_VOLUME_ABERRATION_TYPE"] = CRDN_VOLUME_ABERRATION_TYPE

class CRDN_VOLUME_CLOCK_HOST_TYPE(IntEnum):
    """Define whether base or target of an Access instance holds the clock for Access times."""
   
    UNKNOWN = -1
    """Unknown."""
    BASE = 0
    """Base object holds time instance."""
    TARGET = 1
    """Target object holds time instance."""

CRDN_VOLUME_CLOCK_HOST_TYPE.UNKNOWN.__doc__ = "Unknown."
CRDN_VOLUME_CLOCK_HOST_TYPE.BASE.__doc__ = "Base object holds time instance."
CRDN_VOLUME_CLOCK_HOST_TYPE.TARGET.__doc__ = "Target object holds time instance."

agcls.AgTypeNameMap["CRDN_VOLUME_CLOCK_HOST_TYPE"] = CRDN_VOLUME_CLOCK_HOST_TYPE

class CRDN_VOLUME_COMBINED_OPERATION_TYPE(IntEnum):
    """Define spatial condition combined operation types."""
   
    AND = 1
    """Spatial condition combined AND operation."""
    OR = 2
    """Spatial condition combined OR operation."""
    XOR = 3
    """Spatial condition combined XOR operation."""
    MINUS = 4
    """Spatial condition combined MINUS operation."""

CRDN_VOLUME_COMBINED_OPERATION_TYPE.AND.__doc__ = "Spatial condition combined AND operation."
CRDN_VOLUME_COMBINED_OPERATION_TYPE.OR.__doc__ = "Spatial condition combined OR operation."
CRDN_VOLUME_COMBINED_OPERATION_TYPE.XOR.__doc__ = "Spatial condition combined XOR operation."
CRDN_VOLUME_COMBINED_OPERATION_TYPE.MINUS.__doc__ = "Spatial condition combined MINUS operation."

agcls.AgTypeNameMap["CRDN_VOLUME_COMBINED_OPERATION_TYPE"] = CRDN_VOLUME_COMBINED_OPERATION_TYPE

class CRDN_VOLUME_FROM_GRID_EDGE_TYPE(IntEnum):
    """Define spatial condition from grid edge type."""
   
    MASK_POINTS = 16
    """Spatial condition over time from grid edge type mask points."""
    MASK_VOXELS = 32
    """Spatial condition over time from grid edge type mask voxels."""

CRDN_VOLUME_FROM_GRID_EDGE_TYPE.MASK_POINTS.__doc__ = "Spatial condition over time from grid edge type mask points."
CRDN_VOLUME_FROM_GRID_EDGE_TYPE.MASK_VOXELS.__doc__ = "Spatial condition over time from grid edge type mask voxels."

agcls.AgTypeNameMap["CRDN_VOLUME_FROM_GRID_EDGE_TYPE"] = CRDN_VOLUME_FROM_GRID_EDGE_TYPE

class CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE(IntFlag):
    """Define spatial condition lighting conditions types."""
   
    TYPE_UNDEFINED = 0
    """Spatial condition lighting undefined."""
    TYPE_SUNLIGHT = 1
    """Spatial condition lighting sun light."""
    TYPE_PENUMBRA = 2
    """Spatial condition lighting penumbra."""
    TYPE_UMBRA = 4
    """Spatial condition lighting umbra."""

CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_UNDEFINED.__doc__ = "Spatial condition lighting undefined."
CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_SUNLIGHT.__doc__ = "Spatial condition lighting sun light."
CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_PENUMBRA.__doc__ = "Spatial condition lighting penumbra."
CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_UMBRA.__doc__ = "Spatial condition lighting umbra."

agcls.AgTypeNameMap["CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE"] = CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE

class CRDN_VOLUME_OVER_TIME_DURATION_TYPE(IntEnum):
    """Define spatial condition over time duration type."""
   
    STATIC = 0
    """Spatial condition over time duration type Static."""
    CUMULATIVE_TO_CURRENT = 1
    """Spatial condition over time duration type CumulativeToCurrent."""
    CUMULATIVE_FROM_CURRENT = 2
    """Spatial condition over time duration type CumulativeFromCurrent."""
    SLIDING_WINDOW = 3
    """Spatial condition over time duration type SlidingWindow."""

CRDN_VOLUME_OVER_TIME_DURATION_TYPE.STATIC.__doc__ = "Spatial condition over time duration type Static."
CRDN_VOLUME_OVER_TIME_DURATION_TYPE.CUMULATIVE_TO_CURRENT.__doc__ = "Spatial condition over time duration type CumulativeToCurrent."
CRDN_VOLUME_OVER_TIME_DURATION_TYPE.CUMULATIVE_FROM_CURRENT.__doc__ = "Spatial condition over time duration type CumulativeFromCurrent."
CRDN_VOLUME_OVER_TIME_DURATION_TYPE.SLIDING_WINDOW.__doc__ = "Spatial condition over time duration type SlidingWindow."

agcls.AgTypeNameMap["CRDN_VOLUME_OVER_TIME_DURATION_TYPE"] = CRDN_VOLUME_OVER_TIME_DURATION_TYPE

class CRDN_VOLUME_TIME_SENSE_TYPE(IntEnum):
    """Define whether object1 or object2 of an Access instance holds the clock for Access times."""
   
    UNKNOWN = -1
    """Unklnown."""
    TRANSMIT = 0
    """Position is computed in Time Sense."""
    RECEIVE = 1
    """Position is computed in Receive Sense."""

CRDN_VOLUME_TIME_SENSE_TYPE.UNKNOWN.__doc__ = "Unklnown."
CRDN_VOLUME_TIME_SENSE_TYPE.TRANSMIT.__doc__ = "Position is computed in Time Sense."
CRDN_VOLUME_TIME_SENSE_TYPE.RECEIVE.__doc__ = "Position is computed in Receive Sense."

agcls.AgTypeNameMap["CRDN_VOLUME_TIME_SENSE_TYPE"] = CRDN_VOLUME_TIME_SENSE_TYPE

class CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE(IntEnum):
    """Define volumetric grid values method types."""
   
    METHOD_UNKNOWN = -1
    """Unknown or unsupportedgrid values method."""
    METHOD_FIXED_NUM_STEPS = 0
    """Fixed number steps grid values method for volumetric grid."""
    METHOD_FIXED_STEP_SIZE = 1
    """Fixed step size grid values method for volumetric grid."""
    METHOD_CUSTOM_VALUES = 2
    """Custom grid values method for volumetric grid."""

CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_UNKNOWN.__doc__ = "Unknown or unsupportedgrid values method."
CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_FIXED_NUM_STEPS.__doc__ = "Fixed number steps grid values method for volumetric grid."
CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_FIXED_STEP_SIZE.__doc__ = "Fixed step size grid values method for volumetric grid."
CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_CUSTOM_VALUES.__doc__ = "Custom grid values method for volumetric grid."

agcls.AgTypeNameMap["CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE"] = CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE

class CRDN_KIND(IntEnum):
    """Represents kinds of vectory geometry components."""
   
    UNKNOWN = -1
    """Unsupported component kind."""
    INVALID = 0
    """Invalid component."""
    AXES = 1
    """Axes component."""
    ANGLE = 2
    """Angle component."""
    VECTOR = 3
    """Vector component."""
    POINT = 4
    """Point component."""
    PLANE = 5
    """Plane component."""
    SYSTEM = 6
    """System component."""
    EVENT = 7
    """An event."""
    EVENT_ARRAY = 8
    """An event array."""
    EVENT_INTERVAL = 9
    """An event interval."""
    EVENT_INTERVAL_COLLECTION = 10
    """An event interval collection."""
    EVENT_INTERVAL_LIST = 11
    """A list of event intervals."""
    PARAMETER_SET = 12
    """A parameter set."""
    CALC_SCALAR = 13
    """A scalar."""
    CONDITION = 14
    """A condition."""
    CONDITION_SET = 15
    """A condition set."""
    VOLUME_GRID = 16
    """A volume grid."""
    VOLUME = 17
    """A volume."""
    VOLUME_CALC = 18
    """A volume calc."""

CRDN_KIND.UNKNOWN.__doc__ = "Unsupported component kind."
CRDN_KIND.INVALID.__doc__ = "Invalid component."
CRDN_KIND.AXES.__doc__ = "Axes component."
CRDN_KIND.ANGLE.__doc__ = "Angle component."
CRDN_KIND.VECTOR.__doc__ = "Vector component."
CRDN_KIND.POINT.__doc__ = "Point component."
CRDN_KIND.PLANE.__doc__ = "Plane component."
CRDN_KIND.SYSTEM.__doc__ = "System component."
CRDN_KIND.EVENT.__doc__ = "An event."
CRDN_KIND.EVENT_ARRAY.__doc__ = "An event array."
CRDN_KIND.EVENT_INTERVAL.__doc__ = "An event interval."
CRDN_KIND.EVENT_INTERVAL_COLLECTION.__doc__ = "An event interval collection."
CRDN_KIND.EVENT_INTERVAL_LIST.__doc__ = "A list of event intervals."
CRDN_KIND.PARAMETER_SET.__doc__ = "A parameter set."
CRDN_KIND.CALC_SCALAR.__doc__ = "A scalar."
CRDN_KIND.CONDITION.__doc__ = "A condition."
CRDN_KIND.CONDITION_SET.__doc__ = "A condition set."
CRDN_KIND.VOLUME_GRID.__doc__ = "A volume grid."
CRDN_KIND.VOLUME.__doc__ = "A volume."
CRDN_KIND.VOLUME_CALC.__doc__ = "A volume calc."

agcls.AgTypeNameMap["CRDN_KIND"] = CRDN_KIND

class VECTOR_GEOMETRY_TOOL_ANGLE_TYPE(IntEnum):
    """Represents angle types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    BETWEEN_VECTORS = 0
    """An angle between two vectors."""
    BETWEEN_PLANES = 1
    """An angle between two planes."""
    DIHEDRAL_ANGLE = 2
    """An angle between two vectors about an axis."""
    ROTATION = 3
    """Angle of the shortest rotation between the two specified axes."""
    TO_PLANE = 4
    """An angle between a vector and a plane."""
    TEMPLATE = 5
    """Represents a VGT angle created from a template. This type of angle is not creatable."""

VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.BETWEEN_VECTORS.__doc__ = "An angle between two vectors."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.BETWEEN_PLANES.__doc__ = "An angle between two planes."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.DIHEDRAL_ANGLE.__doc__ = "An angle between two vectors about an axis."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.ROTATION.__doc__ = "Angle of the shortest rotation between the two specified axes."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.TO_PLANE.__doc__ = "An angle between a vector and a plane."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.TEMPLATE.__doc__ = "Represents a VGT angle created from a template. This type of angle is not creatable."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_ANGLE_TYPE"] = VECTOR_GEOMETRY_TOOL_ANGLE_TYPE

class VECTOR_GEOMETRY_TOOL_AXES_TYPE(IntEnum):
    """Represents vector types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    LAGRANGE_LIBRATION = 0
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    ANGULAR_OFFSET = 1
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    FIXED_AT_EPOCH = 2
    """Axes based on another set fixed at a specified epoch."""
    B_PLANE = 3
    """B-Plane axes using the selected target body and reference vector."""
    CUSTOM_SCRIPT = 4
    """Customized axes offset with respect to a set of reference Axes."""
    FIXED = 6
    """Axes fixed in reference axes."""
    ALIGNED_AND_CONSTRAINED = 7
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    MODEL_ATTACHMENT = 8
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    SPINNING = 9
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    ON_SURFACE = 10
    """Projection of the reference point onto the central body."""
    TRAJECTORY = 11
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    TEMPLATE = 12
    """Represents a VGT axes created from a template. This type of axes is not creatable."""
    AT_TIME_INSTANT = 13
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    PLUGIN = 14
    """An axes plugin point."""
    FILE = 5
    """Axes specified by data from a file."""

VECTOR_GEOMETRY_TOOL_AXES_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.LAGRANGE_LIBRATION.__doc__ = "Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.ANGULAR_OFFSET.__doc__ = "Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.FIXED_AT_EPOCH.__doc__ = "Axes based on another set fixed at a specified epoch."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.B_PLANE.__doc__ = "B-Plane axes using the selected target body and reference vector."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.CUSTOM_SCRIPT.__doc__ = "Customized axes offset with respect to a set of reference Axes."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.FIXED.__doc__ = "Axes fixed in reference axes."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.ALIGNED_AND_CONSTRAINED.__doc__ = "Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.MODEL_ATTACHMENT.__doc__ = "Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.SPINNING.__doc__ = "Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.ON_SURFACE.__doc__ = "Projection of the reference point onto the central body."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.TRAJECTORY.__doc__ = "Axes based on trajectory of the point relative to the reference coordinate system."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.TEMPLATE.__doc__ = "Represents a VGT axes created from a template. This type of axes is not creatable."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.AT_TIME_INSTANT.__doc__ = "Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.PLUGIN.__doc__ = "An axes plugin point."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.FILE.__doc__ = "Axes specified by data from a file."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_AXES_TYPE"] = VECTOR_GEOMETRY_TOOL_AXES_TYPE

class VECTOR_GEOMETRY_TOOL_PLANE_TYPE(IntEnum):
    """Represents plane types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    NORMAL = 0
    """A plane normal to a vector at a given point."""
    QUADRANT = 1
    """A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."""
    TRAJECTORY = 2
    """A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."""
    TRIAD = 3
    """A plane is defined by the three points."""
    TEMPLATE = 4
    """Represents a VGT plane created from a template. This type of plane is not creatable."""
    TWO_VECTOR = 5
    """A plane passing through point and containing two given vectors."""

VECTOR_GEOMETRY_TOOL_PLANE_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.NORMAL.__doc__ = "A plane normal to a vector at a given point."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.QUADRANT.__doc__ = "A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TRAJECTORY.__doc__ = "A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TRIAD.__doc__ = "A plane is defined by the three points."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TEMPLATE.__doc__ = "Represents a VGT plane created from a template. This type of plane is not creatable."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TWO_VECTOR.__doc__ = "A plane passing through point and containing two given vectors."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_PLANE_TYPE"] = VECTOR_GEOMETRY_TOOL_PLANE_TYPE

class VECTOR_GEOMETRY_TOOL_POINT_TYPE(IntEnum):
    """Represents point types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    B_PLANE = 0
    """B-Plane point using the selected target body."""
    GRAZING = 1
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    COVARIANCE_GRAZING = 2
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    FIXED_IN_SYSTEM = 4
    """Point fixed in a reference coordinate system."""
    GLINT = 5
    """Point on central body surface that reflects from source to observer."""
    PLANE_INTERSECTION = 6
    """Point on a plane located along a given direction looking from a given origin."""
    MODEL_ATTACHMENT = 7
    """Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    PLANE_PROJECTION = 8
    """The projection of a point onto a reference plane."""
    ON_SURFACE = 9
    """The detic subpoint of the reference point as projected onto the central body."""
    LAGRANGE_LIBRATION = 10
    """Libration point using one primary and multiple secondary central bodies."""
    TEMPLATE = 11
    """Represents a VGT point created from a template. This type of point is not creatable."""
    CENTRAL_BODY_INTERSECT = 12
    """Point on central body surface along direction vector originating at source point."""
    AT_TIME_INSTANT = 13
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    PLUGIN = 14
    """A point plugin point."""
    FILE = 3
    """Point specified by data from a file."""
    FIXED_ON_CENTRAL_BODY = 15
    """Point fixed on a central body."""
    SATELLITE_COLLECTION_ENTRY = 16
    """A point placed at the center of mass of a specified satellite of the satellite collection."""

VECTOR_GEOMETRY_TOOL_POINT_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.B_PLANE.__doc__ = "B-Plane point using the selected target body."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.GRAZING.__doc__ = "The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.COVARIANCE_GRAZING.__doc__ = "The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.FIXED_IN_SYSTEM.__doc__ = "Point fixed in a reference coordinate system."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.GLINT.__doc__ = "Point on central body surface that reflects from source to observer."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.PLANE_INTERSECTION.__doc__ = "Point on a plane located along a given direction looking from a given origin."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.MODEL_ATTACHMENT.__doc__ = "Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.PLANE_PROJECTION.__doc__ = "The projection of a point onto a reference plane."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.ON_SURFACE.__doc__ = "The detic subpoint of the reference point as projected onto the central body."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.LAGRANGE_LIBRATION.__doc__ = "Libration point using one primary and multiple secondary central bodies."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.TEMPLATE.__doc__ = "Represents a VGT point created from a template. This type of point is not creatable."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.CENTRAL_BODY_INTERSECT.__doc__ = "Point on central body surface along direction vector originating at source point."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.AT_TIME_INSTANT.__doc__ = "Point fixed relative to reference system based on another point evaluated at specified time instant."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.PLUGIN.__doc__ = "A point plugin point."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.FILE.__doc__ = "Point specified by data from a file."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.FIXED_ON_CENTRAL_BODY.__doc__ = "Point fixed on a central body."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.SATELLITE_COLLECTION_ENTRY.__doc__ = "A point placed at the center of mass of a specified satellite of the satellite collection."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_POINT_TYPE"] = VECTOR_GEOMETRY_TOOL_POINT_TYPE

class CRDN_SYSTEM_TYPE(IntEnum):
    """Represents system types."""
   
    UNKNOWN = -1
    """Unknown or unsupported system type."""
    ASSEMBLED = 0
    """A system assembled from an origin point and a set of reference axes."""
    ON_SURFACE = 1
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."""
    TEMPLATE = 2
    """Represents a VGT system created from a template. This type of system is not creatable."""

CRDN_SYSTEM_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported system type."
CRDN_SYSTEM_TYPE.ASSEMBLED.__doc__ = "A system assembled from an origin point and a set of reference axes."
CRDN_SYSTEM_TYPE.ON_SURFACE.__doc__ = "A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."
CRDN_SYSTEM_TYPE.TEMPLATE.__doc__ = "Represents a VGT system created from a template. This type of system is not creatable."

agcls.AgTypeNameMap["CRDN_SYSTEM_TYPE"] = CRDN_SYSTEM_TYPE

class VECTOR_GEOMETRY_TOOL_VECTOR_TYPE(IntEnum):
    """Represents vector types."""
   
    UNKNOWN = -1
    """Unknown or unsupported vector type."""
    DISPLACEMENT = 0
    """Vector defined by its start and end points."""
    APOAPSIS = 1
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    FIXED_AT_EPOCH = 2
    """Based on another vector fixed at a specified epoch."""
    ANGULAR_VELOCITY = 3
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    CONING = 4
    """Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."""
    CROSS_PRODUCT = 5
    """The vector cross product of two vectors."""
    CUSTOM_SCRIPT = 6
    """Customized vector components defined with respect to reference axes."""
    DERIVATIVE = 7
    """Derivative of a vector computed with respect to specified axes."""
    ANGLE_RATE = 8
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    ECCENTRICITY = 9
    """Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    FIXED_IN_AXES = 10
    """Vector fixed in reference axes."""
    TWO_PLANES_INTERSECTION = 12
    """Defined along the intersection of two planes."""
    LINE_OF_NODES = 13
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    MODEL_ATTACHMENT = 14
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    ORBIT_ANGULAR_MOMENTUM = 15
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    ORBIT_NORMAL = 16
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    PERIAPSIS = 17
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    PROJECTION = 18
    """A projection of a vector computed with respect to a reference plane."""
    REFLECTION = 19
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    SCALED = 20
    """Scaled version of the input vector."""
    DIRECTION_TO_STAR = 21
    """Defined with respect to a star object."""
    TEMPLATE = 22
    """Represents a VGT vector created from a template. This type of vector is not creatable."""
    AT_TIME_INSTANT = 23
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    LINEAR_COMBINATION = 24
    """Linear combination of two input vectors."""
    PROJECT_ALONG = 25
    """A projection of a source vector in the direction of another vector."""
    SCALAR_LINEAR_COMBINATION = 26
    """Linear combination of two input vectors using scalars."""
    SCALAR_SCALED = 27
    """Scaled version of the input vector using scalar."""
    VELOCITY = 28
    """Velocity vector of a point in a coordinate system."""
    PLUGIN = 29
    """A vector plugin point."""
    ROTATION_VECTOR = 30
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    DISPLACEMENT_ON_SURFACE = 31
    """Displacement between origin and destination points using surface distance and altitude difference."""

VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported vector type."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DISPLACEMENT.__doc__ = "Vector defined by its start and end points."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.APOAPSIS.__doc__ = "Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.FIXED_AT_EPOCH.__doc__ = "Based on another vector fixed at a specified epoch."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ANGULAR_VELOCITY.__doc__ = "Angular velocity vector of one set of axes computed with respect to the reference set."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.CONING.__doc__ = "Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.CROSS_PRODUCT.__doc__ = "The vector cross product of two vectors."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.CUSTOM_SCRIPT.__doc__ = "Customized vector components defined with respect to reference axes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DERIVATIVE.__doc__ = "Derivative of a vector computed with respect to specified axes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ANGLE_RATE.__doc__ = "Angle rate vector perpendicular to the plane in which the angle is defined."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ECCENTRICITY.__doc__ = "Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.FIXED_IN_AXES.__doc__ = "Vector fixed in reference axes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.TWO_PLANES_INTERSECTION.__doc__ = "Defined along the intersection of two planes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.LINE_OF_NODES.__doc__ = "Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.MODEL_ATTACHMENT.__doc__ = "Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ORBIT_ANGULAR_MOMENTUM.__doc__ = "Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ORBIT_NORMAL.__doc__ = "Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PERIAPSIS.__doc__ = "Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PROJECTION.__doc__ = "A projection of a vector computed with respect to a reference plane."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.REFLECTION.__doc__ = "Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.SCALED.__doc__ = "Scaled version of the input vector."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DIRECTION_TO_STAR.__doc__ = "Defined with respect to a star object."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.TEMPLATE.__doc__ = "Represents a VGT vector created from a template. This type of vector is not creatable."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.AT_TIME_INSTANT.__doc__ = "Vector fixed relative to reference axes based on another vector evaluated at specified time instant."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.LINEAR_COMBINATION.__doc__ = "Linear combination of two input vectors."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PROJECT_ALONG.__doc__ = "A projection of a source vector in the direction of another vector."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.SCALAR_LINEAR_COMBINATION.__doc__ = "Linear combination of two input vectors using scalars."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.SCALAR_SCALED.__doc__ = "Scaled version of the input vector using scalar."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.VELOCITY.__doc__ = "Velocity vector of a point in a coordinate system."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PLUGIN.__doc__ = "A vector plugin point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ROTATION_VECTOR.__doc__ = "Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DISPLACEMENT_ON_SURFACE.__doc__ = "Displacement between origin and destination points using surface distance and altitude difference."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_VECTOR_TYPE"] = VECTOR_GEOMETRY_TOOL_VECTOR_TYPE

class CRDN_MEAN_ELEMENT_THEORY(IntEnum):
    """Mean element theory types for approximating motion."""
   
    OSCULATING = 1
    """Osculating elements (six standard Keplerian orbital elements)."""
    KOZAI = 2
    """The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."""
    BROUWER_LYDDANE_LONG = 3
    """Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."""
    BROUWER_LYDDANE_SHORT = 4
    """Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."""

CRDN_MEAN_ELEMENT_THEORY.OSCULATING.__doc__ = "Osculating elements (six standard Keplerian orbital elements)."
CRDN_MEAN_ELEMENT_THEORY.KOZAI.__doc__ = "The Kozai-Iszak (KI) mean elements are based upon the paper ``The Motion of a Close earth satellite,`` Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."
CRDN_MEAN_ELEMENT_THEORY.BROUWER_LYDDANE_LONG.__doc__ = "Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
CRDN_MEAN_ELEMENT_THEORY.BROUWER_LYDDANE_SHORT.__doc__ = "Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."

agcls.AgTypeNameMap["CRDN_MEAN_ELEMENT_THEORY"] = CRDN_MEAN_ELEMENT_THEORY

class CRDN_DIRECTION_TYPE(IntEnum):
    """Direction options."""
   
    INCOMING_ASYMPTOTE = 1
    """Incoming direction."""
    OUTGOING_ASYMPTOTE = 2
    """Outgoing direction."""

CRDN_DIRECTION_TYPE.INCOMING_ASYMPTOTE.__doc__ = "Incoming direction."
CRDN_DIRECTION_TYPE.OUTGOING_ASYMPTOTE.__doc__ = "Outgoing direction."

agcls.AgTypeNameMap["CRDN_DIRECTION_TYPE"] = CRDN_DIRECTION_TYPE

class CRDN_LAGRANGE_LIBRATION_POINT_TYPE(IntEnum):
    """Types of the Lagrange points, also known as libration points. Lagrange points are points in space where gravitational forces and the orbital motion of a body balance each other."""
   
    L1 = 1
    """A point between the Sun and Earth."""
    L2 = 2
    """Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."""
    L3 = 3
    """L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."""
    L4 = 4
    """The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."""
    L5 = 5
    """The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."""

CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L1.__doc__ = "A point between the Sun and Earth."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L2.__doc__ = "Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L3.__doc__ = "L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L4.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L5.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."

agcls.AgTypeNameMap["CRDN_LAGRANGE_LIBRATION_POINT_TYPE"] = CRDN_LAGRANGE_LIBRATION_POINT_TYPE

class CRDN_QUADRANT_TYPE(IntEnum):
    """Quadrants from a reference system (e.g., XY, XZ, YZ, YX, ZX, ZY)."""
   
    XY = 1
    """XY quadrant."""
    YX = 2
    """YX quadrant."""
    XZ = 3
    """XZ quadrant."""
    ZX = 4
    """ZX quadrant."""
    YZ = 5
    """YZ quadrant."""
    ZY = 6
    """ZY quadrant."""

CRDN_QUADRANT_TYPE.XY.__doc__ = "XY quadrant."
CRDN_QUADRANT_TYPE.YX.__doc__ = "YX quadrant."
CRDN_QUADRANT_TYPE.XZ.__doc__ = "XZ quadrant."
CRDN_QUADRANT_TYPE.ZX.__doc__ = "ZX quadrant."
CRDN_QUADRANT_TYPE.YZ.__doc__ = "YZ quadrant."
CRDN_QUADRANT_TYPE.ZY.__doc__ = "ZY quadrant."

agcls.AgTypeNameMap["CRDN_QUADRANT_TYPE"] = CRDN_QUADRANT_TYPE

class CRDN_TRAJECTORY_AXES_TYPE(IntEnum):
    """Trajectory axes coordinate types."""
   
    ICR = 0
    """Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."""
    VNC = 1
    """Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."""
    RIC = 2
    """Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."""
    LVLH = 3
    """Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."""
    VVLH = 4
    """Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."""
    BBR = 5
    """Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."""
    EQUINOCTIAL = 6
    """Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."""
    NTC = 7
    """Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."""

CRDN_TRAJECTORY_AXES_TYPE.ICR.__doc__ = "Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."
CRDN_TRAJECTORY_AXES_TYPE.VNC.__doc__ = "Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."
CRDN_TRAJECTORY_AXES_TYPE.RIC.__doc__ = "Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."
CRDN_TRAJECTORY_AXES_TYPE.LVLH.__doc__ = "Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."
CRDN_TRAJECTORY_AXES_TYPE.VVLH.__doc__ = "Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."
CRDN_TRAJECTORY_AXES_TYPE.BBR.__doc__ = "Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."
CRDN_TRAJECTORY_AXES_TYPE.EQUINOCTIAL.__doc__ = "Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."
CRDN_TRAJECTORY_AXES_TYPE.NTC.__doc__ = "Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."

agcls.AgTypeNameMap["CRDN_TRAJECTORY_AXES_TYPE"] = CRDN_TRAJECTORY_AXES_TYPE

class CRDN_DISPLAY_AXIS_SELECTOR(IntEnum):
    """Rotation directions."""
   
    X = 0
    """Rotate about Axis X."""
    Y = 1
    """Rotate about Axis Y."""
    Z = 2
    """Rotate about Axis Z."""

CRDN_DISPLAY_AXIS_SELECTOR.X.__doc__ = "Rotate about Axis X."
CRDN_DISPLAY_AXIS_SELECTOR.Y.__doc__ = "Rotate about Axis Y."
CRDN_DISPLAY_AXIS_SELECTOR.Z.__doc__ = "Rotate about Axis Z."

agcls.AgTypeNameMap["CRDN_DISPLAY_AXIS_SELECTOR"] = CRDN_DISPLAY_AXIS_SELECTOR

class CRDN_SIGNED_ANGLE_TYPE(IntEnum):
    """Define options for computing an angle."""
   
    NONE = 0
    """Choose the option to use unsigned angle."""
    POSITIVE = 1
    """Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."""
    NEGATIVE = 2
    """Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."""

CRDN_SIGNED_ANGLE_TYPE.NONE.__doc__ = "Choose the option to use unsigned angle."
CRDN_SIGNED_ANGLE_TYPE.POSITIVE.__doc__ = "Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."
CRDN_SIGNED_ANGLE_TYPE.NEGATIVE.__doc__ = "Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."

agcls.AgTypeNameMap["CRDN_SIGNED_ANGLE_TYPE"] = CRDN_SIGNED_ANGLE_TYPE

class VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE(IntEnum):
    """B-Plane point types."""
   
    ASYMPTOTE = 1
    """Asymptote."""
    A_TWO_BODY = 2
    """Two body."""

VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE.ASYMPTOTE.__doc__ = "Asymptote."
VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE.A_TWO_BODY.__doc__ = "Two body."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE"] = VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE

class CRDN_REFERENCE_SHAPE_TYPE(IntEnum):
    """Surface shape types."""
   
    ELLIPSOID = 1
    """An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."""
    TERRAIN = 2
    """Terrain as the terrain reference."""
    MSL = 3
    """Mean Sea Level as the terrain reference."""

CRDN_REFERENCE_SHAPE_TYPE.ELLIPSOID.__doc__ = "An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."
CRDN_REFERENCE_SHAPE_TYPE.TERRAIN.__doc__ = "Terrain as the terrain reference."
CRDN_REFERENCE_SHAPE_TYPE.MSL.__doc__ = "Mean Sea Level as the terrain reference."

agcls.AgTypeNameMap["CRDN_REFERENCE_SHAPE_TYPE"] = CRDN_REFERENCE_SHAPE_TYPE

class CRDN_SURFACE_TYPE(IntEnum):
    """Surface types."""
   
    DETIC = 1
    """Detic surface model."""
    CENTRIC = 2
    """Centric surface model."""

CRDN_SURFACE_TYPE.DETIC.__doc__ = "Detic surface model."
CRDN_SURFACE_TYPE.CENTRIC.__doc__ = "Centric surface model."

agcls.AgTypeNameMap["CRDN_SURFACE_TYPE"] = CRDN_SURFACE_TYPE

class CRDN_SWEEP_MODE(IntEnum):
    """The rotation sweeping modes."""
   
    BIDIRECTIONAL = 1
    """Bidirectional sweeping mode."""
    UNIDIRECTIONAL = 2
    """Unidirectional sweeping mode."""

CRDN_SWEEP_MODE.BIDIRECTIONAL.__doc__ = "Bidirectional sweeping mode."
CRDN_SWEEP_MODE.UNIDIRECTIONAL.__doc__ = "Unidirectional sweeping mode."

agcls.AgTypeNameMap["CRDN_SWEEP_MODE"] = CRDN_SWEEP_MODE

class CRDN_SIGNAL_SENSE(IntEnum):
    """Signal sense transmission options."""
   
    RECEIVE = 1
    """Signal receive."""
    TRANSMIT = 2
    """Signal transmit."""

CRDN_SIGNAL_SENSE.RECEIVE.__doc__ = "Signal receive."
CRDN_SIGNAL_SENSE.TRANSMIT.__doc__ = "Signal transmit."

agcls.AgTypeNameMap["CRDN_SIGNAL_SENSE"] = CRDN_SIGNAL_SENSE

class CRDN_INTERSECTION_SURFACE(IntEnum):
    """Intersection surface flags."""
   
    AT_CENTRAL_BODY_ELLIPSOID = 0
    """Intersection with central body ellipsoid."""
    AT_ALTITUDE_ABOVE_ELLIPSOID = 1
    """Intersection at altitude."""
    AT_TERRAIN = 2
    """Use terrain as intersection surface."""

CRDN_INTERSECTION_SURFACE.AT_CENTRAL_BODY_ELLIPSOID.__doc__ = "Intersection with central body ellipsoid."
CRDN_INTERSECTION_SURFACE.AT_ALTITUDE_ABOVE_ELLIPSOID.__doc__ = "Intersection at altitude."
CRDN_INTERSECTION_SURFACE.AT_TERRAIN.__doc__ = "Use terrain as intersection surface."

agcls.AgTypeNameMap["CRDN_INTERSECTION_SURFACE"] = CRDN_INTERSECTION_SURFACE

class VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE(IntEnum):
    """Dimension inheritance constants used to configure the dimension inheritance of a vector scaled by a scalar."""
   
    NONE = 0
    """Do not inherit dimension."""
    FROM_SCALAR = 1
    """Inherit dimension from scalar."""
    FROM_VECTOR = 2
    """Inherit dimension from vector."""

VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE.NONE.__doc__ = "Do not inherit dimension."
VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE.FROM_SCALAR.__doc__ = "Inherit dimension from scalar."
VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE.FROM_VECTOR.__doc__ = "Inherit dimension from vector."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE"] = VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE


class IVectorGeometryToolPoint(object):
    """The interface defines methods and properties common to all points."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _locate_in_system_with_rate_method_offset = 2
    _locate_in_system_method_offset = 3
    _metadata = {
        "iid_data" : (4624590286464293543, 3973676715389699987),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPoint."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPoint)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPoint)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPoint, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_POINT_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_POINT_TYPE":
        """Return a type of the point object."""
        return self._intf.get_property(IVectorGeometryToolPoint._metadata, IVectorGeometryToolPoint._get_type_metadata)

    _locate_in_system_with_rate_metadata = { "offset" : _locate_in_system_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceOutArg,) }
    def locate_in_system_with_rate(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPointLocateInSystemWithRateResult":
        """Locates the point's position and velocity in a specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPoint._metadata, IVectorGeometryToolPoint._locate_in_system_with_rate_metadata, epoch, system, OutArg())

    _locate_in_system_metadata = { "offset" : _locate_in_system_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceOutArg,) }
    def locate_in_system(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPointLocateInSystemResult":
        """Locates the point's position in a specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPoint._metadata, IVectorGeometryToolPoint._locate_in_system_metadata, epoch, system, OutArg())

    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((4624590286464293543, 3973676715389699987), IVectorGeometryToolPoint)
agcls.AgTypeNameMap["IVectorGeometryToolPoint"] = IVectorGeometryToolPoint

class IVectorGeometryToolVector(object):
    """The interface defines methods and properties common to all vectors."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _find_in_axes_method_offset = 2
    _find_in_axes_with_rate_method_offset = 3
    _metadata = {
        "iid_data" : (4994471793862230398, 8121306839707329686),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolVector."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVector)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVector)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVector, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_VECTOR_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_VECTOR_TYPE":
        """Return a type of the vector object."""
        return self._intf.get_property(IVectorGeometryToolVector._metadata, IVectorGeometryToolVector._get_type_metadata)

    _find_in_axes_metadata = { "offset" : _find_in_axes_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_in_axes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolVectorFindInAxesResult":
        """Compute the vector in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolVector._metadata, IVectorGeometryToolVector._find_in_axes_metadata, epoch, axes, OutArg())

    _find_in_axes_with_rate_metadata = { "offset" : _find_in_axes_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_in_axes_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolVectorFindInAxesWithRateResult":
        """Compute the vector and its rate in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolVector._metadata, IVectorGeometryToolVector._find_in_axes_with_rate_metadata, epoch, axes, OutArg())

    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((4994471793862230398, 8121306839707329686), IVectorGeometryToolVector)
agcls.AgTypeNameMap["IVectorGeometryToolVector"] = IVectorGeometryToolVector

class IVectorGeometryToolSystem(object):
    """The interface contains methods and properties shared by all VGT systems."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _find_in_system_method_offset = 2
    _transform_method_offset = 3
    _transform_with_rate_method_offset = 4
    _metadata = {
        "iid_data" : (4788837751689081889, 7300266131152037277),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolSystem."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystem)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystem)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystem, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SYSTEM_TYPE),) }
    @property
    def type(self) -> "CRDN_SYSTEM_TYPE":
        """Return a type of the system object."""
        return self._intf.get_property(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._get_type_metadata)

    _find_in_system_metadata = { "offset" : _find_in_system_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceOutArg,) }
    def find_in_system(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolSystemFindInSystemResult":
        """Find position, velocity, rate and orientation using the specified system."""
        return self._intf.invoke(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._find_in_system_metadata, epoch, system, OutArg())

    _transform_metadata = { "offset" : _transform_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceInArg("ICartesian3Vector"), agmarshall.InterfaceOutArg,) }
    def transform(self, epoch:typing.Any, outputSystem:"IVectorGeometryToolSystem", positionInMySystem:"ICartesian3Vector") -> "IVectorGeometryToolSystemTransformResult":
        """Translate the position vector from this system into the output system."""
        return self._intf.invoke(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._transform_metadata, epoch, outputSystem, positionInMySystem, OutArg())

    _transform_with_rate_metadata = { "offset" : _transform_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceInArg("ICartesian3Vector"), agmarshall.InterfaceInArg("ICartesian3Vector"), agmarshall.InterfaceOutArg,) }
    def transform_with_rate(self, epoch:typing.Any, outputSystem:"IVectorGeometryToolSystem", positionInMySystem:"ICartesian3Vector", velocityInMySystem:"ICartesian3Vector") -> "IVectorGeometryToolSystemTransformWithRateResult":
        """Translate the position and rate vectors from this system into the output system."""
        return self._intf.invoke(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._transform_with_rate_metadata, epoch, outputSystem, positionInMySystem, velocityInMySystem, OutArg())

    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((4788837751689081889, 7300266131152037277), IVectorGeometryToolSystem)
agcls.AgTypeNameMap["IVectorGeometryToolSystem"] = IVectorGeometryToolSystem

class IVectorGeometryToolAxes(object):
    """The interface defines methods and properties common to all axes."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _find_in_axes_with_rate_method_offset = 2
    _find_in_axes_method_offset = 3
    _get_labels_method_offset = 4
    _get_x_method_offset = 5
    _get_y_method_offset = 6
    _get_z_method_offset = 7
    _transform_method_offset = 8
    _transform_with_rate_method_offset = 9
    _metadata = {
        "iid_data" : (4641684088358424472, 9856172197771500675),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAxes."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxes)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxes)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxes, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_AXES_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_AXES_TYPE":
        """Return a type of the axes object."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_type_metadata)

    _find_in_axes_with_rate_metadata = { "offset" : _find_in_axes_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_in_axes_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAxesFindInAxesWithRateResult":
        """Find an angular velocity and orientation in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._find_in_axes_with_rate_metadata, epoch, axes, OutArg())

    _find_in_axes_metadata = { "offset" : _find_in_axes_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_in_axes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAxesFindInAxesResult":
        """Find an orientation in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._find_in_axes_metadata, epoch, axes, OutArg())

    _get_labels_metadata = { "offset" : _get_labels_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def labels(self) -> "VectorGeometryToolAxesLabels":
        """Return an object that allows modifying the axes labels."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_labels_metadata)

    _get_x_metadata = { "offset" : _get_x_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x(self) -> "IVectorGeometryToolVector":
        """Return the X axis of the component."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_x_metadata)

    _get_y_metadata = { "offset" : _get_y_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y(self) -> "IVectorGeometryToolVector":
        """Return the Y axis of the component."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_y_metadata)

    _get_z_metadata = { "offset" : _get_z_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def z(self) -> "IVectorGeometryToolVector":
        """Return the Z axis of the component."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_z_metadata)

    _transform_metadata = { "offset" : _transform_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("ICartesian3Vector"), agmarshall.InterfaceOutArg,) }
    def transform(self, epoch:typing.Any, outputAxes:"IVectorGeometryToolAxes", vectorInMyAxes:"ICartesian3Vector") -> "IVectorGeometryToolAxesTransformResult":
        """Transform the input vector from this axes into the output axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._transform_metadata, epoch, outputAxes, vectorInMyAxes, OutArg())

    _transform_with_rate_metadata = { "offset" : _transform_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("ICartesian3Vector"), agmarshall.InterfaceInArg("ICartesian3Vector"), agmarshall.InterfaceOutArg,) }
    def transform_with_rate(self, epoch:typing.Any, outputAxes:"IVectorGeometryToolAxes", vectorInMyAxes:"ICartesian3Vector", rateInMyAxes:"ICartesian3Vector") -> "IVectorGeometryToolAxesTransformWithRateResult":
        """Transform the input vector and vector's rate from this axes into the output axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._transform_with_rate_metadata, epoch, outputAxes, vectorInMyAxes, rateInMyAxes, OutArg())

    _property_names[type] = "type"
    _property_names[labels] = "labels"
    _property_names[x] = "x"
    _property_names[y] = "y"
    _property_names[z] = "z"


agcls.AgClassCatalog.add_catalog_entry((4641684088358424472, 9856172197771500675), IVectorGeometryToolAxes)
agcls.AgTypeNameMap["IVectorGeometryToolAxes"] = IVectorGeometryToolAxes

class IVectorGeometryToolAngle(object):
    """The interface defines methods and properties common to all angles."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _find_angle_method_offset = 2
    _find_angle_with_rate_method_offset = 3
    _find_coordinates_method_offset = 4
    _find_coordinates_with_rate_method_offset = 5
    _metadata = {
        "iid_data" : (5576499434980039356, 3250766286789469325),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAngle."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngle)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngle)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngle, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_ANGLE_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_ANGLE_TYPE":
        """Return a type of the angle object."""
        return self._intf.get_property(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._get_type_metadata)

    _find_angle_metadata = { "offset" : _find_angle_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def find_angle(self, epoch:typing.Any) -> "IVectorGeometryToolAngleFindAngleResult":
        """Find an angle at the specified epoch."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_angle_metadata, epoch, OutArg())

    _find_angle_with_rate_metadata = { "offset" : _find_angle_with_rate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def find_angle_with_rate(self, epoch:typing.Any) -> "IVectorGeometryToolAngleFindAngleWithRateResult":
        """Find an angle and angle rate."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_angle_with_rate_metadata, epoch, OutArg())

    _find_coordinates_metadata = { "offset" : _find_coordinates_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_coordinates(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAngleFindResult":
        """Find the angle value and three vectors that define the angle in a specified input axes."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_coordinates_metadata, epoch, axes, OutArg())

    _find_coordinates_with_rate_metadata = { "offset" : _find_coordinates_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_coordinates_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAngleFindWithRateResult":
        """Find the angle value, the angle rate and three vectors that define the angle in a specified input axes."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_coordinates_with_rate_metadata, epoch, axes, OutArg())

    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((5576499434980039356, 3250766286789469325), IVectorGeometryToolAngle)
agcls.AgTypeNameMap["IVectorGeometryToolAngle"] = IVectorGeometryToolAngle

class IVectorGeometryToolPlane(object):
    """The interface defines methods and properties common to all VGT planes."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _find_in_axes_method_offset = 2
    _find_in_axes_with_rate_method_offset = 3
    _find_in_system_method_offset = 4
    _find_in_system_with_rate_method_offset = 5
    _get_labels_method_offset = 6
    _metadata = {
        "iid_data" : (4649944266039171678, 14893747184173212307),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPlane."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlane)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlane)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlane, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_PLANE_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_PLANE_TYPE":
        """Return a type of the plane object."""
        return self._intf.get_property(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._get_type_metadata)

    _find_in_axes_metadata = { "offset" : _find_in_axes_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_in_axes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolPlaneFindInAxesResult":
        """Compute the plane's axes vectors in a specified reference axes."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_axes_metadata, epoch, axes, OutArg())

    _find_in_axes_with_rate_metadata = { "offset" : _find_in_axes_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def find_in_axes_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolPlaneFindInAxesWithRateResult":
        """Compute the plane's axes vectors and their rates in a specified reference axes."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_axes_with_rate_metadata, epoch, axes, OutArg())

    _find_in_system_metadata = { "offset" : _find_in_system_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceOutArg,) }
    def find_in_system(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPlaneFindInSystemResult":
        """Compute the position and X and Y axes in the specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_system_metadata, epoch, system, OutArg())

    _find_in_system_with_rate_metadata = { "offset" : _find_in_system_with_rate_method_offset,
            "arg_types" : (agcom.Variant, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceOutArg,) }
    def find_in_system_with_rate(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPlaneFindInSystemWithRateResult":
        """Compute the position, X and Y axes and their rates of change in the specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_system_with_rate_metadata, epoch, system, OutArg())

    _get_labels_metadata = { "offset" : _get_labels_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def labels(self) -> "VectorGeometryToolPlaneLabels":
        """Allow configuring the plane's X and Y axes labels."""
        return self._intf.get_property(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._get_labels_metadata)

    _property_names[type] = "type"
    _property_names[labels] = "labels"


agcls.AgClassCatalog.add_catalog_entry((4649944266039171678, 14893747184173212307), IVectorGeometryToolPlane)
agcls.AgTypeNameMap["IVectorGeometryToolPlane"] = IVectorGeometryToolPlane

class IAnalysisWorkbenchContext(object):
    """The interface represents a context associated with a VGT component. All VGT components are associated with a valid context. A context can represent a VGT instance or a VGT template."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_template_method_offset = 1
    _metadata = {
        "iid_data" : (4867448151487010560, 8329384048399829653),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchContext."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchContext)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchContext)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchContext, None)
    
    _get_is_template_metadata = { "offset" : _get_is_template_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_template(self) -> bool:
        """Return whether the current instance is a VGT template."""
        return self._intf.get_property(IAnalysisWorkbenchContext._metadata, IAnalysisWorkbenchContext._get_is_template_metadata)

    _property_names[is_template] = "is_template"


agcls.AgClassCatalog.add_catalog_entry((4867448151487010560, 8329384048399829653), IAnalysisWorkbenchContext)
agcls.AgTypeNameMap["IAnalysisWorkbenchContext"] = IAnalysisWorkbenchContext

class IAnalysisWorkbenchComponent(object):
    """A base interface implemented by all VGT components. The methods and properties of the interface provide type information about the VGT component."""

    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_kind_method_offset = 1
    _get_category_method_offset = 2
    _set_category_method_offset = 3
    _get_name_method_offset = 4
    _get_description_method_offset = 5
    _get_path_method_offset = 6
    _get_is_duplicable_method_offset = 7
    _get_context_method_offset = 8
    _get_type_info_method_offset = 9
    _get_qualified_path_method_offset = 10
    _get_is_valid_method_offset = 11
    _get_is_ready_method_offset = 12
    _get_is_read_only_method_offset = 13
    _duplicate_method_offset = 14
    _anonymous_duplicate_method_offset = 15
    _depends_on_method_offset = 16
    _get_embedded_components_method_offset = 17
    _export_method_offset = 18
    _rename_method_offset = 19
    _metadata = {
        "iid_data" : (5666204506719628304, 9309708717126950559),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchComponent."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchComponent)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchComponent)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchComponent, None)
    
    _get_kind_metadata = { "offset" : _get_kind_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_KIND),) }
    @property
    def kind(self) -> "CRDN_KIND":
        """Return the component kind."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_kind_metadata)

    _get_category_metadata = { "offset" : _get_category_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def category(self) -> str:
        """Allow the user to access or change the component category (Folder)."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_category_metadata)

    _set_category_metadata = { "offset" : _set_category_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @category.setter
    def category(self, category:str) -> None:
        return self._intf.set_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._set_category_metadata, category)

    _get_name_metadata = { "offset" : _get_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def name(self) -> str:
        """Return the component name."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_name_metadata)

    _get_description_metadata = { "offset" : _get_description_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def description(self) -> str:
        """Return the component description."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_description_metadata)

    _get_path_metadata = { "offset" : _get_path_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def path(self) -> str:
        """Return the component's fully qualified path (ie. ``CentralBody/Earth Body``, etc.)."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_path_metadata)

    _get_is_duplicable_metadata = { "offset" : _get_is_duplicable_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_duplicable(self) -> bool:
        """Return whether the VGT component can be duplicated."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_duplicable_metadata)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return the context object associated with the instance. The returned object is either an instance of AnalysisWorkbenchInstance or IAnalysisWorkbenchTemplate interface."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_context_metadata)

    _get_type_info_metadata = { "offset" : _get_type_info_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def type_info(self) -> "AnalysisWorkbenchTypeInfo":
        """Return the component type information."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_type_info_metadata)

    _get_qualified_path_metadata = { "offset" : _get_qualified_path_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def qualified_path(self) -> str:
        """An STK-conformant path to the VGT component that can be used to visualize the VGT components in 3D (i.e. ``CentralBody/Earth Body Vector``, etc.)."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_qualified_path_metadata)

    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Return whether the component is valid."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_valid_metadata)

    _get_is_ready_metadata = { "offset" : _get_is_ready_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_ready(self) -> bool:
        """Return whether the component is ready. The component is ready if it's been fully initialized."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_ready_metadata)

    _get_is_read_only_metadata = { "offset" : _get_is_read_only_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_read_only(self) -> bool:
        """Return whether the component is modifiable."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_read_only_metadata)

    _duplicate_metadata = { "offset" : _duplicate_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def duplicate(self, newName:str, description:str) -> "IAnalysisWorkbenchComponent":
        """Create a copy of the instance of a VGT component. The new component is automatically registered and will be persisted or restored when a scenario is saved or loaded."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._duplicate_metadata, newName, description, OutArg())

    _anonymous_duplicate_metadata = { "offset" : _anonymous_duplicate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def anonymous_duplicate(self) -> "IAnalysisWorkbenchComponent":
        """Create an anonymous copy of the instance of a VGT component. The new component is not registered and will not be persisted nor restored when a scenario is saved or loaded."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._anonymous_duplicate_metadata, OutArg())

    _depends_on_metadata = { "offset" : _depends_on_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchComponent"), agmarshall.VariantBoolArg,) }
    def depends_on(self, component:"IAnalysisWorkbenchComponent") -> bool:
        """Test if the instance depends on another component."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._depends_on_metadata, component, OutArg())

    _get_embedded_components_metadata = { "offset" : _get_embedded_components_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def embedded_components(self) -> "AnalysisWorkbenchCollection":
        """Return a collection of embedded components."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_embedded_components_metadata)

    _export_metadata = { "offset" : _export_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def export(self, filename:str, comments:str) -> None:
        """Export the component to a file."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._export_metadata, filename, comments)

    _rename_metadata = { "offset" : _rename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def rename(self, newName:str) -> None:
        """Rename the component."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._rename_metadata, newName)

    _property_names[kind] = "kind"
    _property_names[category] = "category"
    _property_names[name] = "name"
    _property_names[description] = "description"
    _property_names[path] = "path"
    _property_names[is_duplicable] = "is_duplicable"
    _property_names[context] = "context"
    _property_names[type_info] = "type_info"
    _property_names[qualified_path] = "qualified_path"
    _property_names[is_valid] = "is_valid"
    _property_names[is_ready] = "is_ready"
    _property_names[is_read_only] = "is_read_only"
    _property_names[embedded_components] = "embedded_components"


agcls.AgClassCatalog.add_catalog_entry((5666204506719628304, 9309708717126950559), IAnalysisWorkbenchComponent)
agcls.AgTypeNameMap["IAnalysisWorkbenchComponent"] = IAnalysisWorkbenchComponent

class ICalculationToolScalar(object):
    """Any scalar calculation that is not constant by construction."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _evaluate_method_offset = 2
    _quick_evaluate_method_offset = 3
    _evaluate_with_rate_method_offset = 4
    _quick_evaluate_with_rate_method_offset = 5
    _get_availability_method_offset = 6
    _get_unit_of_measure_method_offset = 7
    _quick_evaluate_array_method_offset = 8
    _quick_evaluate_with_rate_array_method_offset = 9
    _quick_evaluate_event_array_method_offset = 10
    _quick_evaluate_with_rate_event_array_method_offset = 11
    _metadata = {
        "iid_data" : (4703695914540684039, 8102226453412927140),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICalculationToolScalar."""
        initialize_from_source_object(self, sourceObject, ICalculationToolScalar)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalar)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICalculationToolScalar, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CALC_SCALAR_TYPE),) }
    @property
    def type(self) -> "CRDN_CALC_SCALAR_TYPE":
        """Return the scalar calculation type."""
        return self._intf.get_property(ICalculationToolScalar._metadata, ICalculationToolScalar._get_type_metadata)

    _evaluate_metadata = { "offset" : _evaluate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def evaluate(self, epoch:typing.Any) -> "CalculationToolEvaluateResult":
        """Evaluate the scalar calculation at the specified time instant."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._evaluate_metadata, epoch, OutArg())

    _quick_evaluate_metadata = { "offset" : _quick_evaluate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.LPSafearrayArg,) }
    def quick_evaluate(self, epoch:typing.Any) -> list:
        """Evaluate the scalar calculation at the specified time instant and returns the results as an array with two elements, the first element being of boolean type indicating whether the computation succeeded, followed by a double-precision value representing..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_metadata, epoch, OutArg())

    _evaluate_with_rate_metadata = { "offset" : _evaluate_with_rate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def evaluate_with_rate(self, epoch:typing.Any) -> "CalculationToolEvaluateWithRateResult":
        """Evaluate the scalar calculation at the specified time instant. The result is a scalar value and its rate of change."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._evaluate_with_rate_metadata, epoch, OutArg())

    _quick_evaluate_with_rate_metadata = { "offset" : _quick_evaluate_with_rate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.LPSafearrayArg,) }
    def quick_evaluate_with_rate(self, epoch:typing.Any) -> list:
        """Evaluate the scalar calculation at the specified time instant and returns the results as an array with three elements, the first element being of boolean type indicating whether the computation succeeded, followed by two double-precision values one rep..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_with_rate_metadata, epoch, OutArg())

    _get_availability_metadata = { "offset" : _get_availability_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_availability(self) -> "TimeToolIntervalCollection":
        """Return a list of availability intervals."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._get_availability_metadata, OutArg())

    _get_unit_of_measure_metadata = { "offset" : _get_unit_of_measure_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def unit_of_measure(self) -> str:
        """Return calc scalar's unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        return self._intf.get_property(ICalculationToolScalar._metadata, ICalculationToolScalar._get_unit_of_measure_metadata)

    _quick_evaluate_array_metadata = { "offset" : _quick_evaluate_array_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def quick_evaluate_array(self, times:list) -> list:
        """Evaluate the scalar calculation, and rate, over an array of times, entered as strings in the Scenario date unit. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_array_metadata, times, OutArg())

    _quick_evaluate_with_rate_array_metadata = { "offset" : _quick_evaluate_with_rate_array_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def quick_evaluate_with_rate_array(self, times:list) -> list:
        """Evaluate the scalar calculation over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_with_rate_array_metadata, times, OutArg())

    _quick_evaluate_event_array_metadata = { "offset" : _quick_evaluate_event_array_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventArray"), agmarshall.LPSafearrayArg,) }
    def quick_evaluate_event_array(self, refArray:"ITimeToolEventArray") -> list:
        """Evaluate the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_event_array_metadata, refArray, OutArg())

    _quick_evaluate_with_rate_event_array_metadata = { "offset" : _quick_evaluate_with_rate_event_array_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventArray"), agmarshall.LPSafearrayArg,) }
    def quick_evaluate_with_rate_event_array(self, refArray:"ITimeToolEventArray") -> list:
        """Evaluate the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_with_rate_event_array_metadata, refArray, OutArg())

    _property_names[type] = "type"
    _property_names[unit_of_measure] = "unit_of_measure"


agcls.AgClassCatalog.add_catalog_entry((4703695914540684039, 8102226453412927140), ICalculationToolScalar)
agcls.AgTypeNameMap["ICalculationToolScalar"] = ICalculationToolScalar

class ICalculationToolCondition(object):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _evaluate_method_offset = 2
    _evaluate_with_rate_method_offset = 3
    _metadata = {
        "iid_data" : (5735161800843082622, 14427694074333278871),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICalculationToolCondition."""
        initialize_from_source_object(self, sourceObject, ICalculationToolCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICalculationToolCondition, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_TYPE),) }
    @property
    def type(self) -> "CRDN_CONDITION_TYPE":
        """Return the type of condition."""
        return self._intf.get_property(ICalculationToolCondition._metadata, ICalculationToolCondition._get_type_metadata)

    _evaluate_metadata = { "offset" : _evaluate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def evaluate(self, epoch:typing.Any) -> "CalculationToolEvaluateResult":
        """Return result of evaluating continuously varying condition metric at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolCondition._metadata, ICalculationToolCondition._evaluate_metadata, epoch, OutArg())

    _evaluate_with_rate_metadata = { "offset" : _evaluate_with_rate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def evaluate_with_rate(self, epoch:typing.Any) -> "CalculationToolEvaluateWithRateResult":
        """Return result of evaluating continuously varying condition metric and its rate of change at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolCondition._metadata, ICalculationToolCondition._evaluate_with_rate_metadata, epoch, OutArg())

    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((5735161800843082622, 14427694074333278871), ICalculationToolCondition)
agcls.AgTypeNameMap["ICalculationToolCondition"] = ICalculationToolCondition

class ICalculationToolConditionSet(object):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _evaluate_method_offset = 2
    _evaluate_with_rate_method_offset = 3
    _metadata = {
        "iid_data" : (4655106964357171455, 14573822137210863791),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICalculationToolConditionSet."""
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionSet)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionSet)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICalculationToolConditionSet, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_SET_TYPE),) }
    @property
    def type(self) -> "CRDN_CONDITION_SET_TYPE":
        """Return the type of condition set."""
        return self._intf.get_property(ICalculationToolConditionSet._metadata, ICalculationToolConditionSet._get_type_metadata)

    _evaluate_metadata = { "offset" : _evaluate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def evaluate(self, epoch:typing.Any) -> "CalculationToolConditionSetEvaluateResult":
        """Return an array of results of evaluating continuously varying condition metrics, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolConditionSet._metadata, ICalculationToolConditionSet._evaluate_metadata, epoch, OutArg())

    _evaluate_with_rate_metadata = { "offset" : _evaluate_with_rate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def evaluate_with_rate(self, epoch:typing.Any) -> "CalculationToolConditionSetEvaluateWithRateResult":
        """Return an array of results of evaluating continuously varying condition metrics and their rates of change, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolConditionSet._metadata, ICalculationToolConditionSet._evaluate_with_rate_metadata, epoch, OutArg())

    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((4655106964357171455, 14573822137210863791), ICalculationToolConditionSet)
agcls.AgTypeNameMap["ICalculationToolConditionSet"] = ICalculationToolConditionSet

class IAnalysisWorkbenchConverge(object):
    """Represents a base class for convergence definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4915568931125686564, 3473459645036490151),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchConverge."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchConverge)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchConverge)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchConverge, None)
    


agcls.AgClassCatalog.add_catalog_entry((4915568931125686564, 3473459645036490151), IAnalysisWorkbenchConverge)
agcls.AgTypeNameMap["IAnalysisWorkbenchConverge"] = IAnalysisWorkbenchConverge

class IAnalysisWorkbenchDerivative(object):
    """Represents a base class for derivative definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5545857981522920125, 18254938137483007413),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchDerivative."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchDerivative)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchDerivative)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchDerivative, None)
    


agcls.AgClassCatalog.add_catalog_entry((5545857981522920125, 18254938137483007413), IAnalysisWorkbenchDerivative)
agcls.AgTypeNameMap["IAnalysisWorkbenchDerivative"] = IAnalysisWorkbenchDerivative

class ITimeToolEvent(object):
    """Define an event (time instant)."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _get_today_method_offset = 2
    _get_tomorrow_method_offset = 3
    _get_noon_today_method_offset = 4
    _get_noon_tomorrow_method_offset = 5
    _find_occurrence_method_offset = 6
    _occurs_before_method_offset = 7
    _metadata = {
        "iid_data" : (5052226534501425744, 2346000977674024115),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeToolEvent."""
        initialize_from_source_object(self, sourceObject, ITimeToolEvent)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEvent)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeToolEvent, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_TYPE":
        """Return the type of time instant."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_type_metadata)

    _get_today_metadata = { "offset" : _get_today_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def today(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to today's GMT midnight."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_today_metadata)

    _get_tomorrow_metadata = { "offset" : _get_tomorrow_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def tomorrow(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to tomorrow's GMT midnight."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_tomorrow_metadata)

    _get_noon_today_metadata = { "offset" : _get_noon_today_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def noon_today(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to today's GMT noon."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_noon_today_metadata)

    _get_noon_tomorrow_metadata = { "offset" : _get_noon_tomorrow_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def noon_tomorrow(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to tomorrow's GMT noon."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_noon_tomorrow_metadata)

    _find_occurrence_metadata = { "offset" : _find_occurrence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def find_occurrence(self) -> "TimeToolEventFindOccurrenceResult":
        """Return computed time instance if it occurs."""
        return self._intf.invoke(ITimeToolEvent._metadata, ITimeToolEvent._find_occurrence_metadata, OutArg())

    _occurs_before_metadata = { "offset" : _occurs_before_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.VariantBoolArg,) }
    def occurs_before(self, epoch:typing.Any) -> bool:
        """Return true if computed time instance occurs before or at specified time, return false otherwise."""
        return self._intf.invoke(ITimeToolEvent._metadata, ITimeToolEvent._occurs_before_metadata, epoch, OutArg())

    _property_names[type] = "type"
    _property_names[today] = "today"
    _property_names[tomorrow] = "tomorrow"
    _property_names[noon_today] = "noon_today"
    _property_names[noon_tomorrow] = "noon_tomorrow"


agcls.AgClassCatalog.add_catalog_entry((5052226534501425744, 2346000977674024115), ITimeToolEvent)
agcls.AgTypeNameMap["ITimeToolEvent"] = ITimeToolEvent

class ITimeToolEventArray(object):
    """An ordered array of times, which may or may not be evenly spaced."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _find_times_method_offset = 2
    _metadata = {
        "iid_data" : (5676478022059654098, 10082373008458811814),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeToolEventArray."""
        initialize_from_source_object(self, sourceObject, ITimeToolEventArray)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArray)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeToolEventArray, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_ARRAY_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_ARRAY_TYPE":
        """Return the type of time array."""
        return self._intf.get_property(ITimeToolEventArray._metadata, ITimeToolEventArray._get_type_metadata)

    _find_times_metadata = { "offset" : _find_times_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def find_times(self) -> "TimeToolFindTimesResult":
        """Return computed array of times."""
        return self._intf.invoke(ITimeToolEventArray._metadata, ITimeToolEventArray._find_times_metadata, OutArg())

    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((5676478022059654098, 10082373008458811814), ITimeToolEventArray)
agcls.AgTypeNameMap["ITimeToolEventArray"] = ITimeToolEventArray

class ITimeToolEventInterval(object):
    """A single time interval."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _get_label_start_description_method_offset = 2
    _get_label_stop_description_method_offset = 3
    _get_label_start_method_offset = 4
    _get_label_stop_method_offset = 5
    _find_interval_method_offset = 6
    _occurred_method_offset = 7
    _metadata = {
        "iid_data" : (5014335522660337085, 11558391138117110205),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeToolEventInterval."""
        initialize_from_source_object(self, sourceObject, ITimeToolEventInterval)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventInterval)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeToolEventInterval, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_INTERVAL_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_INTERVAL_TYPE":
        """Return the type of interval."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_type_metadata)

    _get_label_start_description_metadata = { "offset" : _get_label_start_description_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label_start_description(self) -> str:
        """The start description."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_start_description_metadata)

    _get_label_stop_description_metadata = { "offset" : _get_label_stop_description_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label_stop_description(self) -> str:
        """The stop description."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_stop_description_metadata)

    _get_label_start_metadata = { "offset" : _get_label_start_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label_start(self) -> str:
        """A label associated with the interval start."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_start_metadata)

    _get_label_stop_metadata = { "offset" : _get_label_stop_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label_stop(self) -> str:
        """A label associated with the interval stop."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_stop_metadata)

    _find_interval_metadata = { "offset" : _find_interval_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def find_interval(self) -> "TimeToolEventIntervalResult":
        """Return computed interval if it exists."""
        return self._intf.invoke(ITimeToolEventInterval._metadata, ITimeToolEventInterval._find_interval_metadata, OutArg())

    _occurred_metadata = { "offset" : _occurred_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.VariantBoolArg,) }
    def occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval if it exists."""
        return self._intf.invoke(ITimeToolEventInterval._metadata, ITimeToolEventInterval._occurred_metadata, epoch, OutArg())

    _property_names[type] = "type"
    _property_names[label_start_description] = "label_start_description"
    _property_names[label_stop_description] = "label_stop_description"
    _property_names[label_start] = "label_start"
    _property_names[label_stop] = "label_stop"


agcls.AgClassCatalog.add_catalog_entry((5014335522660337085, 11558391138117110205), ITimeToolEventInterval)
agcls.AgTypeNameMap["ITimeToolEventInterval"] = ITimeToolEventInterval

class ITimeToolEventIntervalCollection(object):
    """A collection of related interval lists."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _get_labels_method_offset = 2
    _find_interval_collection_method_offset = 3
    _occurred_method_offset = 4
    _metadata = {
        "iid_data" : (4802578054528125388, 3471729172666103957),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeToolEventIntervalCollection."""
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollection, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_INTERVAL_COLLECTION_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_INTERVAL_COLLECTION_TYPE":
        """Return the type of collection of interval lists."""
        return self._intf.get_property(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._get_type_metadata)

    _get_labels_metadata = { "offset" : _get_labels_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def labels(self) -> list:
        """Get the labels associated with the interval lists in the collection."""
        return self._intf.get_property(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._get_labels_metadata)

    _find_interval_collection_metadata = { "offset" : _find_interval_collection_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def find_interval_collection(self) -> "TimeToolIntervalsVectorResult":
        """Return computed collection of interval lists."""
        return self._intf.invoke(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._find_interval_collection_metadata, OutArg())

    _occurred_metadata = { "offset" : _occurred_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def occurred(self, epoch:typing.Any) -> "TimeToolEventIntervalCollectionOccurredResult":
        """Determine if specified time falls within any of the computed interval lists in the collection."""
        return self._intf.invoke(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._occurred_metadata, epoch, OutArg())

    _property_names[type] = "type"
    _property_names[labels] = "labels"


agcls.AgClassCatalog.add_catalog_entry((4802578054528125388, 3471729172666103957), ITimeToolEventIntervalCollection)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollection"] = ITimeToolEventIntervalCollection

class ITimeToolEventIntervalList(object):
    """An ordered list of time intervals."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _get_labels_method_offset = 2
    _get_descriptions_method_offset = 3
    _find_intervals_method_offset = 4
    _occurred_method_offset = 5
    _metadata = {
        "iid_data" : (4964372786095352688, 17150178243890460291),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeToolEventIntervalList."""
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalList)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalList)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalList, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_INTERVAL_LIST_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_INTERVAL_LIST_TYPE":
        """Return the type of interval list."""
        return self._intf.get_property(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._get_type_metadata)

    _get_labels_metadata = { "offset" : _get_labels_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def labels(self) -> list:
        """Get the label descriptions associated with the interval list."""
        return self._intf.get_property(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._get_labels_metadata)

    _get_descriptions_metadata = { "offset" : _get_descriptions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def descriptions(self) -> list:
        """Get the labels associated with the interval list."""
        return self._intf.get_property(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._get_descriptions_metadata)

    _find_intervals_metadata = { "offset" : _find_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def find_intervals(self) -> "TimeToolIntervalListResult":
        """Return computed interval list that can be empty."""
        return self._intf.invoke(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._find_intervals_metadata, OutArg())

    _occurred_metadata = { "offset" : _occurred_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.VariantBoolArg,) }
    def occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval list."""
        return self._intf.invoke(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._occurred_metadata, epoch, OutArg())

    _property_names[type] = "type"
    _property_names[labels] = "labels"
    _property_names[descriptions] = "descriptions"


agcls.AgClassCatalog.add_catalog_entry((4964372786095352688, 17150178243890460291), ITimeToolEventIntervalList)
agcls.AgTypeNameMap["ITimeToolEventIntervalList"] = ITimeToolEventIntervalList

class IAnalysisWorkbenchIntegral(object):
    """Represents a base class for integral definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4882407970628127095, 17356507896756110225),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchIntegral."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchIntegral)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchIntegral)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchIntegral, None)
    


agcls.AgClassCatalog.add_catalog_entry((4882407970628127095, 17356507896756110225), IAnalysisWorkbenchIntegral)
agcls.AgTypeNameMap["IAnalysisWorkbenchIntegral"] = IAnalysisWorkbenchIntegral

class IAnalysisWorkbenchInterp(object):
    """Represents a base class for interpolation definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5176727654361637888, 17197923576813057165),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchInterp."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchInterp)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchInterp)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchInterp, None)
    


agcls.AgClassCatalog.add_catalog_entry((5176727654361637888, 17197923576813057165), IAnalysisWorkbenchInterp)
agcls.AgTypeNameMap["IAnalysisWorkbenchInterp"] = IAnalysisWorkbenchInterp

class ICalculationToolParameterSet(object):
    """Parameter set contains various sets of scalar computations."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _get_labels_method_offset = 2
    _get_dimensions_method_offset = 3
    _get_scalar_names_method_offset = 4
    _calculate_method_offset = 5
    _calculate_with_derivative_method_offset = 6
    _metadata = {
        "iid_data" : (5479297772565193960, 11336582244767551646),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICalculationToolParameterSet."""
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSet)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSet)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSet, None)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_PARAMETER_SET_TYPE),) }
    @property
    def type(self) -> "CRDN_PARAMETER_SET_TYPE":
        """Get the type of parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_type_metadata)

    _get_labels_metadata = { "offset" : _get_labels_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def labels(self) -> list:
        """Get the labels identifying hierarchy of representations within parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_labels_metadata)

    _get_dimensions_metadata = { "offset" : _get_dimensions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def dimensions(self) -> list:
        """Get the names identifying types of dimensions of individual scalars within parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_dimensions_metadata)

    _get_scalar_names_metadata = { "offset" : _get_scalar_names_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def scalar_names(self) -> list:
        """Get the names identifying individual scalars within parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_scalar_names_metadata)

    _calculate_metadata = { "offset" : _calculate_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.LPSafearrayArg,) }
    def calculate(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars within parameter set at the specified time."""
        return self._intf.invoke(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._calculate_metadata, epoch, OutArg())

    _calculate_with_derivative_metadata = { "offset" : _calculate_with_derivative_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.LPSafearrayArg,) }
    def calculate_with_derivative(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars and their time derivatives within parameter set at the specified time."""
        return self._intf.invoke(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._calculate_with_derivative_metadata, epoch, OutArg())

    _property_names[type] = "type"
    _property_names[labels] = "labels"
    _property_names[dimensions] = "dimensions"
    _property_names[scalar_names] = "scalar_names"


agcls.AgClassCatalog.add_catalog_entry((5479297772565193960, 11336582244767551646), ICalculationToolParameterSet)
agcls.AgTypeNameMap["ICalculationToolParameterSet"] = ICalculationToolParameterSet

class ITimeToolPruneFilter(object):
    """A filter used with event interval list pruned class to prune interval lists..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filter_type_method_offset = 1
    _metadata = {
        "iid_data" : (5411019644010585303, 8356519221695235998),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeToolPruneFilter."""
        initialize_from_source_object(self, sourceObject, ITimeToolPruneFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolPruneFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeToolPruneFilter, None)
    
    _get_filter_type_metadata = { "offset" : _get_filter_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_PRUNE_FILTER),) }
    @property
    def filter_type(self) -> "CRDN_PRUNE_FILTER":
        """Return a type of the filter."""
        return self._intf.get_property(ITimeToolPruneFilter._metadata, ITimeToolPruneFilter._get_filter_type_metadata)

    _property_names[filter_type] = "filter_type"


agcls.AgClassCatalog.add_catalog_entry((5411019644010585303, 8356519221695235998), ITimeToolPruneFilter)
agcls.AgTypeNameMap["ITimeToolPruneFilter"] = ITimeToolPruneFilter

class IAnalysisWorkbenchSampling(object):
    """Base sampling interface."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5454263766504862323, 6397342263310433470),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchSampling."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchSampling)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchSampling)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchSampling, None)
    


agcls.AgClassCatalog.add_catalog_entry((5454263766504862323, 6397342263310433470), IAnalysisWorkbenchSampling)
agcls.AgTypeNameMap["IAnalysisWorkbenchSampling"] = IAnalysisWorkbenchSampling

class ICalculationToolSamplingMethod(object):
    """A sampling method."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_method_type_method_offset = 1
    _metadata = {
        "iid_data" : (4827843609729710366, 8894356402950175411),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICalculationToolSamplingMethod."""
        initialize_from_source_object(self, sourceObject, ICalculationToolSamplingMethod)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolSamplingMethod)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICalculationToolSamplingMethod, None)
    
    _get_method_type_metadata = { "offset" : _get_method_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAMPLING_METHOD),) }
    @property
    def method_type(self) -> "CRDN_SAMPLING_METHOD":
        """A sampling method type."""
        return self._intf.get_property(ICalculationToolSamplingMethod._metadata, ICalculationToolSamplingMethod._get_method_type_metadata)

    _property_names[method_type] = "method_type"


agcls.AgClassCatalog.add_catalog_entry((4827843609729710366, 8894356402950175411), ICalculationToolSamplingMethod)
agcls.AgTypeNameMap["ICalculationToolSamplingMethod"] = ICalculationToolSamplingMethod

class IAnalysisWorkbenchSignalDelay(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4836052727854610771, 2658301614566846344),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchSignalDelay."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchSignalDelay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchSignalDelay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchSignalDelay, None)
    


agcls.AgClassCatalog.add_catalog_entry((4836052727854610771, 2658301614566846344), IAnalysisWorkbenchSignalDelay)
agcls.AgTypeNameMap["IAnalysisWorkbenchSignalDelay"] = IAnalysisWorkbenchSignalDelay

class ISpatialAnalysisToolGridValuesMethod(object):
    """A grid values method."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_method_type_method_offset = 1
    _metadata = {
        "iid_data" : (4739060787290770026, 755991415117168800),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISpatialAnalysisToolGridValuesMethod."""
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolGridValuesMethod)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolGridValuesMethod)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolGridValuesMethod, None)
    
    _get_method_type_metadata = { "offset" : _get_method_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE),) }
    @property
    def method_type(self) -> "CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE":
        """Grid values method type."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesMethod._metadata, ISpatialAnalysisToolGridValuesMethod._get_method_type_metadata)

    _property_names[method_type] = "method_type"


agcls.AgClassCatalog.add_catalog_entry((4739060787290770026, 755991415117168800), ISpatialAnalysisToolGridValuesMethod)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesMethod"] = ISpatialAnalysisToolGridValuesMethod

class ISpatialAnalysisToolVolume(object):
    """A volume interface. The methods and properties of the interface provide Volume functions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4841356890486692076, 2175121878908514689),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISpatialAnalysisToolVolume."""
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolume)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolume)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolume, None)
    


agcls.AgClassCatalog.add_catalog_entry((4841356890486692076, 2175121878908514689), ISpatialAnalysisToolVolume)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolume"] = ISpatialAnalysisToolVolume

class ISpatialAnalysisToolVolumeCalc(object):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4788088731026599523, 14975002087762860939),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISpatialAnalysisToolVolumeCalc."""
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalc)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalc)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalc, None)
    


agcls.AgClassCatalog.add_catalog_entry((4788088731026599523, 14975002087762860939), ISpatialAnalysisToolVolumeCalc)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalc"] = ISpatialAnalysisToolVolumeCalc

class ISpatialAnalysisToolVolumeGrid(object):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4872197438153942913, 17020680151074665636),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISpatialAnalysisToolVolumeGrid."""
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGrid)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGrid)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGrid, None)
    


agcls.AgClassCatalog.add_catalog_entry((4872197438153942913, 17020680151074665636), ISpatialAnalysisToolVolumeGrid)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGrid"] = ISpatialAnalysisToolVolumeGrid

class ITimeToolTimeProperties(object):
    """Define methods to compute time properties such as availability and special times."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_availability_method_offset = 1
    _metadata = {
        "iid_data" : (4693587397954990762, 1841444941110468780),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeToolTimeProperties."""
        initialize_from_source_object(self, sourceObject, ITimeToolTimeProperties)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolTimeProperties)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeToolTimeProperties, None)
    
    _get_availability_metadata = { "offset" : _get_availability_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_availability(self) -> "TimeToolIntervalCollection":
        """Return a collection of availability intervals."""
        return self._intf.invoke(ITimeToolTimeProperties._metadata, ITimeToolTimeProperties._get_availability_metadata, OutArg())



agcls.AgClassCatalog.add_catalog_entry((4693587397954990762, 1841444941110468780), ITimeToolTimeProperties)
agcls.AgTypeNameMap["ITimeToolTimeProperties"] = ITimeToolTimeProperties

class IAnalysisWorkbenchRefTo(object):
    """A base interface for all VGT component references."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_path_method_offset = 1
    _metadata = {
        "iid_data" : (5000476646516070310, 1217044254048263356),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchRefTo."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchRefTo)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchRefTo)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchRefTo, None)
    
    _get_path_metadata = { "offset" : _get_path_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def path(self) -> str:
        """Return a path to the referenced VGT component."""
        return self._intf.get_property(IAnalysisWorkbenchRefTo._metadata, IAnalysisWorkbenchRefTo._get_path_metadata)

    _property_names[path] = "path"


agcls.AgClassCatalog.add_catalog_entry((5000476646516070310, 1217044254048263356), IAnalysisWorkbenchRefTo)
agcls.AgTypeNameMap["IAnalysisWorkbenchRefTo"] = IAnalysisWorkbenchRefTo

class IVectorGeometryToolAngleFindAngleResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngle method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_angle_method_offset = 2
    _metadata = {
        "iid_data" : (5484695193085506764, 12995272954624926875),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAngleFindAngleResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindAngleResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindAngleResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindAngleResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleResult._metadata, IVectorGeometryToolAngleFindAngleResult._get_is_valid_metadata)

    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleResult._metadata, IVectorGeometryToolAngleFindAngleResult._get_angle_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[angle] = "angle"


agcls.AgClassCatalog.add_catalog_entry((5484695193085506764, 12995272954624926875), IVectorGeometryToolAngleFindAngleResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindAngleResult"] = IVectorGeometryToolAngleFindAngleResult

class IVectorGeometryToolAngleFindAngleWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngleWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_angle_method_offset = 2
    _get_angle_rate_method_offset = 3
    _metadata = {
        "iid_data" : (5292967736344146106, 3501262746512687271),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAngleFindAngleWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindAngleWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindAngleWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindAngleWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleWithRateResult._metadata, IVectorGeometryToolAngleFindAngleWithRateResult._get_is_valid_metadata)

    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleWithRateResult._metadata, IVectorGeometryToolAngleFindAngleWithRateResult._get_angle_metadata)

    _get_angle_rate_metadata = { "offset" : _get_angle_rate_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def angle_rate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleWithRateResult._metadata, IVectorGeometryToolAngleFindAngleWithRateResult._get_angle_rate_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[angle] = "angle"
    _property_names[angle_rate] = "angle_rate"


agcls.AgClassCatalog.add_catalog_entry((5292967736344146106, 3501262746512687271), IVectorGeometryToolAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindAngleWithRateResult"] = IVectorGeometryToolAngleFindAngleWithRateResult

class IVectorGeometryToolAngleFindWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindCoordinatesWithRate method."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_angle_method_offset = 2
    _get_angle_rate_method_offset = 3
    _get_vector_from_method_offset = 4
    _get_vector_to_method_offset = 5
    _get_vector_about_method_offset = 6
    _metadata = {
        "iid_data" : (4856057119568825575, 2109696612937815446),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAngleFindWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_is_valid_metadata)

    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_angle_metadata)

    _get_angle_rate_metadata = { "offset" : _get_angle_rate_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def angle_rate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_angle_rate_metadata)

    _get_vector_from_metadata = { "offset" : _get_vector_from_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_from(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_vector_from_metadata)

    _get_vector_to_metadata = { "offset" : _get_vector_to_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_to(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_vector_to_metadata)

    _get_vector_about_metadata = { "offset" : _get_vector_about_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_about(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_vector_about_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[angle] = "angle"
    _property_names[angle_rate] = "angle_rate"
    _property_names[vector_from] = "vector_from"
    _property_names[vector_to] = "vector_to"
    _property_names[vector_about] = "vector_about"


agcls.AgClassCatalog.add_catalog_entry((4856057119568825575, 2109696612937815446), IVectorGeometryToolAngleFindWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindWithRateResult"] = IVectorGeometryToolAngleFindWithRateResult

class IVectorGeometryToolAngleFindResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindCoordinates method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_angle_method_offset = 2
    _get_vector_from_method_offset = 3
    _get_vector_to_method_offset = 4
    _get_vector_about_method_offset = 5
    _metadata = {
        "iid_data" : (5298240106436331533, 9541969718117272231),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAngleFindResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_is_valid_metadata)

    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_angle_metadata)

    _get_vector_from_metadata = { "offset" : _get_vector_from_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_from(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_vector_from_metadata)

    _get_vector_to_metadata = { "offset" : _get_vector_to_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_to(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_vector_to_metadata)

    _get_vector_about_metadata = { "offset" : _get_vector_about_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_about(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_vector_about_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[angle] = "angle"
    _property_names[vector_from] = "vector_from"
    _property_names[vector_to] = "vector_to"
    _property_names[vector_about] = "vector_about"


agcls.AgClassCatalog.add_catalog_entry((5298240106436331533, 9541969718117272231), IVectorGeometryToolAngleFindResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindResult"] = IVectorGeometryToolAngleFindResult

class IVectorGeometryToolAxesTransformResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFrom method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_vector_method_offset = 2
    _metadata = {
        "iid_data" : (4792970338091440318, 435178607338115222),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAxesTransformResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesTransformResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesTransformResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesTransformResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformResult._metadata, IVectorGeometryToolAxesTransformResult._get_is_valid_metadata)

    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformResult._metadata, IVectorGeometryToolAxesTransformResult._get_vector_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[vector] = "vector"


agcls.AgClassCatalog.add_catalog_entry((4792970338091440318, 435178607338115222), IVectorGeometryToolAxesTransformResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTransformResult"] = IVectorGeometryToolAxesTransformResult

class IVectorGeometryToolAxesTransformWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFromWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_vector_method_offset = 2
    _get_velocity_method_offset = 3
    _metadata = {
        "iid_data" : (5332039326563042843, 17391837893968577945),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAxesTransformWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesTransformWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesTransformWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesTransformWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformWithRateResult._metadata, IVectorGeometryToolAxesTransformWithRateResult._get_is_valid_metadata)

    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformWithRateResult._metadata, IVectorGeometryToolAxesTransformWithRateResult._get_vector_metadata)

    _get_velocity_metadata = { "offset" : _get_velocity_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """The vector velocity."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformWithRateResult._metadata, IVectorGeometryToolAxesTransformWithRateResult._get_velocity_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[vector] = "vector"
    _property_names[velocity] = "velocity"


agcls.AgClassCatalog.add_catalog_entry((5332039326563042843, 17391837893968577945), IVectorGeometryToolAxesTransformWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTransformWithRateResult"] = IVectorGeometryToolAxesTransformWithRateResult

class IVectorGeometryToolPlaneFindInAxesResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxes method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_x_axis_method_offset = 2
    _get_y_axis_method_offset = 3
    _metadata = {
        "iid_data" : (5411394135561936255, 5770799577348852129),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPlaneFindInAxesResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInAxesResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInAxesResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInAxesResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesResult._metadata, IVectorGeometryToolPlaneFindInAxesResult._get_is_valid_metadata)

    _get_x_axis_metadata = { "offset" : _get_x_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesResult._metadata, IVectorGeometryToolPlaneFindInAxesResult._get_x_axis_metadata)

    _get_y_axis_metadata = { "offset" : _get_y_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesResult._metadata, IVectorGeometryToolPlaneFindInAxesResult._get_y_axis_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[x_axis] = "x_axis"
    _property_names[y_axis] = "y_axis"


agcls.AgClassCatalog.add_catalog_entry((5411394135561936255, 5770799577348852129), IVectorGeometryToolPlaneFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInAxesResult"] = IVectorGeometryToolPlaneFindInAxesResult

class IVectorGeometryToolPlaneFindInAxesWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxesWithRate method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_x_axis_method_offset = 2
    _get_x_axis_rate_method_offset = 3
    _get_y_axis_method_offset = 4
    _get_y_axis_rate_method_offset = 5
    _metadata = {
        "iid_data" : (5396764601440543912, 17001129713529799298),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPlaneFindInAxesWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInAxesWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInAxesWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInAxesWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_is_valid_metadata)

    _get_x_axis_metadata = { "offset" : _get_x_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_x_axis_metadata)

    _get_x_axis_rate_metadata = { "offset" : _get_x_axis_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x_axis_rate(self) -> "ICartesian3Vector":
        """The rate of change of X-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_x_axis_rate_metadata)

    _get_y_axis_metadata = { "offset" : _get_y_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_y_axis_metadata)

    _get_y_axis_rate_metadata = { "offset" : _get_y_axis_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y_axis_rate(self) -> "ICartesian3Vector":
        """The rate of change of Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_y_axis_rate_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[x_axis] = "x_axis"
    _property_names[x_axis_rate] = "x_axis_rate"
    _property_names[y_axis] = "y_axis"
    _property_names[y_axis_rate] = "y_axis_rate"


agcls.AgClassCatalog.add_catalog_entry((5396764601440543912, 17001129713529799298), IVectorGeometryToolPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInAxesWithRateResult"] = IVectorGeometryToolPlaneFindInAxesWithRateResult

class IVectorGeometryToolPlaneFindInSystemResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystem method."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_origin_position_method_offset = 2
    _get_x_axis_method_offset = 3
    _get_y_axis_method_offset = 4
    _metadata = {
        "iid_data" : (5012572268011808901, 10907720006031719318),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPlaneFindInSystemResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInSystemResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInSystemResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInSystemResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_is_valid_metadata)

    _get_origin_position_metadata = { "offset" : _get_origin_position_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def origin_position(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_origin_position_metadata)

    _get_x_axis_metadata = { "offset" : _get_x_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_x_axis_metadata)

    _get_y_axis_metadata = { "offset" : _get_y_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_y_axis_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[origin_position] = "origin_position"
    _property_names[x_axis] = "x_axis"
    _property_names[y_axis] = "y_axis"


agcls.AgClassCatalog.add_catalog_entry((5012572268011808901, 10907720006031719318), IVectorGeometryToolPlaneFindInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInSystemResult"] = IVectorGeometryToolPlaneFindInSystemResult

class IVectorGeometryToolPlaneFindInSystemWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystemWithRate method."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_origin_position_method_offset = 2
    _get_origin_velocity_method_offset = 3
    _get_x_axis_method_offset = 4
    _get_x_axis_rate_method_offset = 5
    _get_y_axis_method_offset = 6
    _get_y_axis_rate_method_offset = 7
    _metadata = {
        "iid_data" : (5090839955308321227, 317761085157350305),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPlaneFindInSystemWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInSystemWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInSystemWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInSystemWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_is_valid_metadata)

    _get_origin_position_metadata = { "offset" : _get_origin_position_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def origin_position(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_origin_position_metadata)

    _get_origin_velocity_metadata = { "offset" : _get_origin_velocity_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def origin_velocity(self) -> "ICartesian3Vector":
        """The rate of change of the position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_origin_velocity_metadata)

    _get_x_axis_metadata = { "offset" : _get_x_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_x_axis_metadata)

    _get_x_axis_rate_metadata = { "offset" : _get_x_axis_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x_axis_rate(self) -> "ICartesian3Vector":
        """A rate of change of the X-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_x_axis_rate_metadata)

    _get_y_axis_metadata = { "offset" : _get_y_axis_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_y_axis_metadata)

    _get_y_axis_rate_metadata = { "offset" : _get_y_axis_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y_axis_rate(self) -> "ICartesian3Vector":
        """A rate of change of the Y-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_y_axis_rate_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[origin_position] = "origin_position"
    _property_names[origin_velocity] = "origin_velocity"
    _property_names[x_axis] = "x_axis"
    _property_names[x_axis_rate] = "x_axis_rate"
    _property_names[y_axis] = "y_axis"
    _property_names[y_axis_rate] = "y_axis_rate"


agcls.AgClassCatalog.add_catalog_entry((5090839955308321227, 317761085157350305), IVectorGeometryToolPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInSystemWithRateResult"] = IVectorGeometryToolPlaneFindInSystemWithRateResult

class IVectorGeometryToolAxesFindInAxesResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxes method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_orientation_method_offset = 2
    _metadata = {
        "iid_data" : (5526443865819486130, 6485450650085686414),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAxesFindInAxesResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesFindInAxesResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesFindInAxesResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesFindInAxesResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesResult._metadata, IVectorGeometryToolAxesFindInAxesResult._get_is_valid_metadata)

    _get_orientation_metadata = { "offset" : _get_orientation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def orientation(self) -> "IOrientation":
        """The axes' orientation."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesResult._metadata, IVectorGeometryToolAxesFindInAxesResult._get_orientation_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[orientation] = "orientation"


agcls.AgClassCatalog.add_catalog_entry((5526443865819486130, 6485450650085686414), IVectorGeometryToolAxesFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFindInAxesResult"] = IVectorGeometryToolAxesFindInAxesResult

class IVectorGeometryToolAxesFindInAxesWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxesWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_angular_velocity_method_offset = 2
    _get_orientation_method_offset = 3
    _metadata = {
        "iid_data" : (5583004664022191568, 13635182811892187530),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolAxesFindInAxesWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesFindInAxesWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesFindInAxesWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesFindInAxesWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesWithRateResult._metadata, IVectorGeometryToolAxesFindInAxesWithRateResult._get_is_valid_metadata)

    _get_angular_velocity_metadata = { "offset" : _get_angular_velocity_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def angular_velocity(self) -> "ICartesian3Vector":
        """Axes' angular velocity."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesWithRateResult._metadata, IVectorGeometryToolAxesFindInAxesWithRateResult._get_angular_velocity_metadata)

    _get_orientation_metadata = { "offset" : _get_orientation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def orientation(self) -> "IOrientation":
        """The axes' orientation."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesWithRateResult._metadata, IVectorGeometryToolAxesFindInAxesWithRateResult._get_orientation_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[angular_velocity] = "angular_velocity"
    _property_names[orientation] = "orientation"


agcls.AgClassCatalog.add_catalog_entry((5583004664022191568, 13635182811892187530), IVectorGeometryToolAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFindInAxesWithRateResult"] = IVectorGeometryToolAxesFindInAxesWithRateResult

class IVectorGeometryToolPointLocateInSystemResult(object):
    """Contains the results returned with IVectorGeometryToolPoint.LocateInSystem method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_position_method_offset = 2
    _metadata = {
        "iid_data" : (5568521725362388460, 7875089545265969057),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPointLocateInSystemResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointLocateInSystemResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointLocateInSystemResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointLocateInSystemResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemResult._metadata, IVectorGeometryToolPointLocateInSystemResult._get_is_valid_metadata)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemResult._metadata, IVectorGeometryToolPointLocateInSystemResult._get_position_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[position] = "position"


agcls.AgClassCatalog.add_catalog_entry((5568521725362388460, 7875089545265969057), IVectorGeometryToolPointLocateInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolPointLocateInSystemResult"] = IVectorGeometryToolPointLocateInSystemResult

class IVectorGeometryToolPointLocateInSystemWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolPoint.LocateInSystemWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_position_method_offset = 2
    _get_velocity_method_offset = 3
    _metadata = {
        "iid_data" : (4718438476070115548, 11456293296871538843),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolPointLocateInSystemWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointLocateInSystemWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointLocateInSystemWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointLocateInSystemWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemWithRateResult._metadata, IVectorGeometryToolPointLocateInSystemWithRateResult._get_is_valid_metadata)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemWithRateResult._metadata, IVectorGeometryToolPointLocateInSystemWithRateResult._get_position_metadata)

    _get_velocity_metadata = { "offset" : _get_velocity_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """The point velocity in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemWithRateResult._metadata, IVectorGeometryToolPointLocateInSystemWithRateResult._get_velocity_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[position] = "position"
    _property_names[velocity] = "velocity"


agcls.AgClassCatalog.add_catalog_entry((4718438476070115548, 11456293296871538843), IVectorGeometryToolPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPointLocateInSystemWithRateResult"] = IVectorGeometryToolPointLocateInSystemWithRateResult

class IVectorGeometryToolSystemTransformResult(object):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFrom and IVectorGeometryToolSystem.TransformTo methods."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_vector_method_offset = 2
    _metadata = {
        "iid_data" : (5602727224913179539, 3056221723684415935),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolSystemTransformResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemTransformResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemTransformResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemTransformResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformResult._metadata, IVectorGeometryToolSystemTransformResult._get_is_valid_metadata)

    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformResult._metadata, IVectorGeometryToolSystemTransformResult._get_vector_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[vector] = "vector"


agcls.AgClassCatalog.add_catalog_entry((5602727224913179539, 3056221723684415935), IVectorGeometryToolSystemTransformResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemTransformResult"] = IVectorGeometryToolSystemTransformResult

class IVectorGeometryToolSystemTransformWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFromWithRate and IVectorGeometryToolSystem.TransformToWithRate methods."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_vector_method_offset = 2
    _get_velocity_method_offset = 3
    _metadata = {
        "iid_data" : (5028026059164558160, 8691094400863508390),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolSystemTransformWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemTransformWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemTransformWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemTransformWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformWithRateResult._metadata, IVectorGeometryToolSystemTransformWithRateResult._get_is_valid_metadata)

    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformWithRateResult._metadata, IVectorGeometryToolSystemTransformWithRateResult._get_vector_metadata)

    _get_velocity_metadata = { "offset" : _get_velocity_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """The vector's velocity."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformWithRateResult._metadata, IVectorGeometryToolSystemTransformWithRateResult._get_velocity_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[vector] = "vector"
    _property_names[velocity] = "velocity"


agcls.AgClassCatalog.add_catalog_entry((5028026059164558160, 8691094400863508390), IVectorGeometryToolSystemTransformWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemTransformWithRateResult"] = IVectorGeometryToolSystemTransformWithRateResult

class IVectorGeometryToolSystemFindInSystemResult(object):
    """Contains the results returned with IVectorGeometryToolSystem.FindInSystem method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_position_method_offset = 2
    _get_velocity_method_offset = 3
    _get_rate_method_offset = 4
    _get_orientation_method_offset = 5
    _metadata = {
        "iid_data" : (4961058888294584522, 6819225686450287036),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolSystemFindInSystemResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemFindInSystemResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemFindInSystemResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemFindInSystemResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_is_valid_metadata)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def position(self) -> "ICartesian3Vector":
        """A position vector."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_position_metadata)

    _get_velocity_metadata = { "offset" : _get_velocity_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """A velocity vector."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_velocity_metadata)

    _get_rate_metadata = { "offset" : _get_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def rate(self) -> "ICartesian3Vector":
        """Rate of change."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_rate_metadata)

    _get_orientation_metadata = { "offset" : _get_orientation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def orientation(self) -> "IOrientation":
        """Orientation."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_orientation_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[position] = "position"
    _property_names[velocity] = "velocity"
    _property_names[rate] = "rate"
    _property_names[orientation] = "orientation"


agcls.AgClassCatalog.add_catalog_entry((4961058888294584522, 6819225686450287036), IVectorGeometryToolSystemFindInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemFindInSystemResult"] = IVectorGeometryToolSystemFindInSystemResult

class IVectorGeometryToolVectorFindInAxesResult(object):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxes method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_vector_method_offset = 2
    _metadata = {
        "iid_data" : (5163850874032675488, 11046602307391063209),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolVectorFindInAxesResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFindInAxesResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFindInAxesResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFindInAxesResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesResult._metadata, IVectorGeometryToolVectorFindInAxesResult._get_is_valid_metadata)

    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesResult._metadata, IVectorGeometryToolVectorFindInAxesResult._get_vector_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[vector] = "vector"


agcls.AgClassCatalog.add_catalog_entry((5163850874032675488, 11046602307391063209), IVectorGeometryToolVectorFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFindInAxesResult"] = IVectorGeometryToolVectorFindInAxesResult

class IVectorGeometryToolVectorFindInAxesWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxesWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_vector_method_offset = 2
    _get_rate_method_offset = 3
    _metadata = {
        "iid_data" : (5384991910738500476, 5081428842426900099),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorGeometryToolVectorFindInAxesWithRateResult."""
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFindInAxesWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFindInAxesWithRateResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFindInAxesWithRateResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesWithRateResult._metadata, IVectorGeometryToolVectorFindInAxesWithRateResult._get_is_valid_metadata)

    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesWithRateResult._metadata, IVectorGeometryToolVectorFindInAxesWithRateResult._get_vector_metadata)

    _get_rate_metadata = { "offset" : _get_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def rate(self) -> "ICartesian3Vector":
        """The vector rate in a specified axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesWithRateResult._metadata, IVectorGeometryToolVectorFindInAxesWithRateResult._get_rate_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[vector] = "vector"
    _property_names[rate] = "rate"


agcls.AgClassCatalog.add_catalog_entry((5384991910738500476, 5081428842426900099), IVectorGeometryToolVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFindInAxesWithRateResult"] = IVectorGeometryToolVectorFindInAxesWithRateResult

class IAnalysisWorkbenchMethodCallResult(object):
    """Instances of the interface are used to return the result of a computation."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _metadata = {
        "iid_data" : (4645374652506169535, 9723345654066007957),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAnalysisWorkbenchMethodCallResult."""
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchMethodCallResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchMethodCallResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchMethodCallResult, None)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAnalysisWorkbenchMethodCallResult._metadata, IAnalysisWorkbenchMethodCallResult._get_is_valid_metadata)

    _property_names[is_valid] = "is_valid"


agcls.AgClassCatalog.add_catalog_entry((4645374652506169535, 9723345654066007957), IAnalysisWorkbenchMethodCallResult)
agcls.AgTypeNameMap["IAnalysisWorkbenchMethodCallResult"] = IAnalysisWorkbenchMethodCallResult



class CalculationToolEvaluateResult(SupportsDeleteCallback):
    """Represents the results of evaluating a scalar component using ICalculationToolScalar.Evaluate method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_value_method_offset = 2
    _metadata = {
        "iid_data" : (5614154425131203652, 5944516947886916776),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolEvaluateResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(CalculationToolEvaluateResult._metadata, CalculationToolEvaluateResult._get_is_valid_metadata)

    _get_value_metadata = { "offset" : _get_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def value(self) -> float:
        """The scalar value."""
        return self._intf.get_property(CalculationToolEvaluateResult._metadata, CalculationToolEvaluateResult._get_value_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[value] = "value"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolEvaluateResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolEvaluateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolEvaluateResult, [CalculationToolEvaluateResult, ])

agcls.AgClassCatalog.add_catalog_entry((5522853299729796607, 10609423862588038055), CalculationToolEvaluateResult)
agcls.AgTypeNameMap["CalculationToolEvaluateResult"] = CalculationToolEvaluateResult

class CalculationToolEvaluateWithRateResult(SupportsDeleteCallback):
    """Represents the results of evaluating a scalar component using ICalculationToolScalar.Evaluate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_value_method_offset = 2
    _get_rate_method_offset = 3
    _metadata = {
        "iid_data" : (4891493138703768112, 5257715458728871821),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolEvaluateWithRateResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(CalculationToolEvaluateWithRateResult._metadata, CalculationToolEvaluateWithRateResult._get_is_valid_metadata)

    _get_value_metadata = { "offset" : _get_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def value(self) -> float:
        """Computed scalar value."""
        return self._intf.get_property(CalculationToolEvaluateWithRateResult._metadata, CalculationToolEvaluateWithRateResult._get_value_metadata)

    _get_rate_metadata = { "offset" : _get_rate_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def rate(self) -> float:
        """A rate of change of the computed scalar value."""
        return self._intf.get_property(CalculationToolEvaluateWithRateResult._metadata, CalculationToolEvaluateWithRateResult._get_rate_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[value] = "value"
    _property_names[rate] = "rate"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolEvaluateWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolEvaluateWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolEvaluateWithRateResult, [CalculationToolEvaluateWithRateResult, ])

agcls.AgClassCatalog.add_catalog_entry((5662589128398381369, 18228667425859790763), CalculationToolEvaluateWithRateResult)
agcls.AgTypeNameMap["CalculationToolEvaluateWithRateResult"] = CalculationToolEvaluateWithRateResult

class TimeToolEventIntervalResult(SupportsDeleteCallback):
    """Contains the results returned with ITimeToolEventIntervalList.FindIntervals method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_interval_method_offset = 2
    _metadata = {
        "iid_data" : (4746291031874526350, 12635609897701193394),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolEventIntervalResult._metadata, TimeToolEventIntervalResult._get_is_valid_metadata)

    _get_interval_metadata = { "offset" : _get_interval_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interval(self) -> "TimeToolInterval":
        """An interval."""
        return self._intf.get_property(TimeToolEventIntervalResult._metadata, TimeToolEventIntervalResult._get_interval_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[interval] = "interval"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalResult, [TimeToolEventIntervalResult, ])

agcls.AgClassCatalog.add_catalog_entry((5440144273098326668, 11989278598177568391), TimeToolEventIntervalResult)
agcls.AgTypeNameMap["TimeToolEventIntervalResult"] = TimeToolEventIntervalResult

class TimeToolEventFindOccurrenceResult(SupportsDeleteCallback):
    """Contains the results returned with ITimeToolEvent.FindOccurrence method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_epoch_method_offset = 2
    _metadata = {
        "iid_data" : (4710347834450863344, 12752006829468697747),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventFindOccurrenceResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolEventFindOccurrenceResult._metadata, TimeToolEventFindOccurrenceResult._get_is_valid_metadata)

    _get_epoch_metadata = { "offset" : _get_epoch_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def epoch(self) -> typing.Any:
        """The epoch at which the event occurs."""
        return self._intf.get_property(TimeToolEventFindOccurrenceResult._metadata, TimeToolEventFindOccurrenceResult._get_epoch_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[epoch] = "epoch"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventFindOccurrenceResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventFindOccurrenceResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventFindOccurrenceResult, [TimeToolEventFindOccurrenceResult, ])

agcls.AgClassCatalog.add_catalog_entry((4920266892008173400, 17346109474033320069), TimeToolEventFindOccurrenceResult)
agcls.AgTypeNameMap["TimeToolEventFindOccurrenceResult"] = TimeToolEventFindOccurrenceResult

class TimeToolFindTimesResult(SupportsDeleteCallback):
    """Return a collection of intervals and an array of times."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_intervals_method_offset = 2
    _get_start_method_offset = 3
    _get_stop_method_offset = 4
    _get_times_method_offset = 5
    _metadata = {
        "iid_data" : (4849540246283896048, 6942407106662663820),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolFindTimesResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolFindTimesResult._metadata, TimeToolFindTimesResult._get_is_valid_metadata)

    _get_intervals_metadata = { "offset" : _get_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def intervals(self) -> "TimeToolIntervalCollection":
        """A collection of found intervals."""
        return self._intf.get_property(TimeToolFindTimesResult._metadata, TimeToolFindTimesResult._get_intervals_metadata)

    _get_start_metadata = { "offset" : _get_start_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def start(self) -> typing.Any:
        """The start time of the entire interval span."""
        return self._intf.get_property(TimeToolFindTimesResult._metadata, TimeToolFindTimesResult._get_start_metadata)

    _get_stop_metadata = { "offset" : _get_stop_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def stop(self) -> typing.Any:
        """The stop time of the entire interval span."""
        return self._intf.get_property(TimeToolFindTimesResult._metadata, TimeToolFindTimesResult._get_stop_metadata)

    _get_times_metadata = { "offset" : _get_times_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def times(self) -> list:
        """An array of found times."""
        return self._intf.get_property(TimeToolFindTimesResult._metadata, TimeToolFindTimesResult._get_times_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[intervals] = "intervals"
    _property_names[start] = "start"
    _property_names[stop] = "stop"
    _property_names[times] = "times"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolFindTimesResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolFindTimesResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolFindTimesResult, [TimeToolFindTimesResult, ])

agcls.AgClassCatalog.add_catalog_entry((5536753132893401039, 8791447751690390407), TimeToolFindTimesResult)
agcls.AgTypeNameMap["TimeToolFindTimesResult"] = TimeToolFindTimesResult

class TimeToolIntervalsVectorResult(SupportsDeleteCallback):
    """Contains the results returned with ITimeToolEventIntervalCollection.FindIntervalCollection method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_interval_collections_method_offset = 2
    _metadata = {
        "iid_data" : (5620318592927493953, 3800513619111014055),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolIntervalsVectorResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolIntervalsVectorResult._metadata, TimeToolIntervalsVectorResult._get_is_valid_metadata)

    _get_interval_collections_metadata = { "offset" : _get_interval_collections_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interval_collections(self) -> "TimeToolIntervalVectorCollection":
        """A collection of interval collections."""
        return self._intf.get_property(TimeToolIntervalsVectorResult._metadata, TimeToolIntervalsVectorResult._get_interval_collections_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[interval_collections] = "interval_collections"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolIntervalsVectorResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolIntervalsVectorResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolIntervalsVectorResult, [TimeToolIntervalsVectorResult, ])

agcls.AgClassCatalog.add_catalog_entry((5214899444003868340, 2439419900054653882), TimeToolIntervalsVectorResult)
agcls.AgTypeNameMap["TimeToolIntervalsVectorResult"] = TimeToolIntervalsVectorResult

class TimeToolEventIntervalCollectionOccurredResult(SupportsDeleteCallback):
    """Contains the results returned with ITimeToolEventIntervalCollection.Occurred method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_index_method_offset = 2
    _metadata = {
        "iid_data" : (4984827063323662366, 10431628503200399788),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalCollectionOccurredResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolEventIntervalCollectionOccurredResult._metadata, TimeToolEventIntervalCollectionOccurredResult._get_is_valid_metadata)

    _get_index_metadata = { "offset" : _get_index_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def index(self) -> int:
        """Index of an interval in the collection."""
        return self._intf.get_property(TimeToolEventIntervalCollectionOccurredResult._metadata, TimeToolEventIntervalCollectionOccurredResult._get_index_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[index] = "index"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalCollectionOccurredResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalCollectionOccurredResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionOccurredResult, [TimeToolEventIntervalCollectionOccurredResult, ])

agcls.AgClassCatalog.add_catalog_entry((5449426388650809590, 4955022891265085365), TimeToolEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionOccurredResult"] = TimeToolEventIntervalCollectionOccurredResult

class TimeToolIntervalListResult(SupportsDeleteCallback):
    """Contains the results returned with ITimeToolEventIntervalList.FindIntervals method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_intervals_method_offset = 2
    _metadata = {
        "iid_data" : (4634920377665823855, 14964140121783584654),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolIntervalListResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolIntervalListResult._metadata, TimeToolIntervalListResult._get_is_valid_metadata)

    _get_intervals_metadata = { "offset" : _get_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def intervals(self) -> "TimeToolIntervalCollection":
        """A list of intervals."""
        return self._intf.get_property(TimeToolIntervalListResult._metadata, TimeToolIntervalListResult._get_intervals_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[intervals] = "intervals"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolIntervalListResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolIntervalListResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolIntervalListResult, [TimeToolIntervalListResult, ])

agcls.AgClassCatalog.add_catalog_entry((4749115582065684196, 2274990611771605949), TimeToolIntervalListResult)
agcls.AgTypeNameMap["TimeToolIntervalListResult"] = TimeToolIntervalListResult

class TimeToolIntervalVectorCollection(SupportsDeleteCallback):
    """A collection of interval collections."""

    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5575174488488139361, 17888026257103832750),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolIntervalVectorCollection)
    def __iter__(self):
        """Create an iterator for the TimeToolIntervalVectorCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "TimeToolIntervalCollection":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(TimeToolIntervalVectorCollection._metadata, TimeToolIntervalVectorCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "TimeToolIntervalCollection":
        """Access an element at the specified position."""
        return self._intf.invoke(TimeToolIntervalVectorCollection._metadata, TimeToolIntervalVectorCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolIntervalVectorCollection._metadata, TimeToolIntervalVectorCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolIntervalVectorCollection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolIntervalVectorCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolIntervalVectorCollection, [TimeToolIntervalVectorCollection, ])

agcls.AgClassCatalog.add_catalog_entry((5203412792180924882, 14239251967220039073), TimeToolIntervalVectorCollection)
agcls.AgTypeNameMap["TimeToolIntervalVectorCollection"] = TimeToolIntervalVectorCollection

class TimeToolEventGroup(SupportsDeleteCallback):
    """Access or create VGT events associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5743339348524930415, 13668044487410794916),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventGroup)
    def __iter__(self):
        """Create an iterator for the TimeToolEventGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEvent":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(TimeToolEventGroup._metadata, TimeToolEventGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(TimeToolEventGroup._metadata, TimeToolEventGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(TimeToolEventGroup._metadata, TimeToolEventGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(TimeToolEventGroup._metadata, TimeToolEventGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "TimeToolEventFactory":
        """Return a Factory object used to create custom events."""
        return self._intf.get_property(TimeToolEventGroup._metadata, TimeToolEventGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEvent":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(TimeToolEventGroup._metadata, TimeToolEventGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolEventGroup._metadata, TimeToolEventGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEvent":
        """Retrieve an event from the collection by index."""
        return self._intf.invoke(TimeToolEventGroup._metadata, TimeToolEventGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEvent":
        """Retrieve an event from the collection by name."""
        return self._intf.invoke(TimeToolEventGroup._metadata, TimeToolEventGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventGroup, [TimeToolEventGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5740305381890470273, 8415316688318852744), TimeToolEventGroup)
agcls.AgTypeNameMap["TimeToolEventGroup"] = TimeToolEventGroup

class TimeToolEventIntervalGroup(SupportsDeleteCallback):
    """Access or create VGT event intervals associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5142922729546224873, 11946726056227879853),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalGroup)
    def __iter__(self):
        """Create an iterator for the TimeToolEventIntervalGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventInterval":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventIntervalName:str) -> None:
        """Remove an element by name."""
        return self._intf.invoke(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._remove_metadata, eventIntervalName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "TimeToolEventIntervalFactory":
        """Return a Factory object used to create custom event intervals."""
        return self._intf.get_property(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventInterval":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventInterval":
        """Retrieve an event interval from the collection by index."""
        return self._intf.invoke(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventInterval":
        """Retrieve an event interval from the collection by name."""
        return self._intf.invoke(TimeToolEventIntervalGroup._metadata, TimeToolEventIntervalGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalGroup, [TimeToolEventIntervalGroup, ])

agcls.AgClassCatalog.add_catalog_entry((4639595004900791506, 2670686152777183627), TimeToolEventIntervalGroup)
agcls.AgTypeNameMap["TimeToolEventIntervalGroup"] = TimeToolEventIntervalGroup

class TimeToolEventIntervalListGroup(SupportsDeleteCallback):
    """Access or create VGT event interval lists associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (4938951633900015673, 7195780011008496024),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListGroup)
    def __iter__(self):
        """Create an iterator for the TimeToolEventIntervalListGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventIntervalList":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "TimeToolEventIntervalListFactory":
        """Return a factory object used to create custom event interval lists."""
        return self._intf.get_property(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventIntervalList":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventIntervalList":
        """Retrieve an event interval list from the collection by index."""
        return self._intf.invoke(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventIntervalList":
        """Retrieve an event interval list from the collection by name."""
        return self._intf.invoke(TimeToolEventIntervalListGroup._metadata, TimeToolEventIntervalListGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListGroup, [TimeToolEventIntervalListGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5001426302640578234, 7402032539944503439), TimeToolEventIntervalListGroup)
agcls.AgTypeNameMap["TimeToolEventIntervalListGroup"] = TimeToolEventIntervalListGroup

class TimeToolEventArrayGroup(SupportsDeleteCallback):
    """Access or create VGT event arrays associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5362443867455049139, 5221206169826244786),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayGroup)
    def __iter__(self):
        """Create an iterator for the TimeToolEventArrayGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventArray":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "TimeToolEventArrayFactory":
        """Return a Factory object used to create event arrays."""
        return self._intf.get_property(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventArray":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventArray":
        """Retrieve an event array from the collection by index."""
        return self._intf.invoke(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventArray":
        """Retrieve an event array from the collection by name."""
        return self._intf.invoke(TimeToolEventArrayGroup._metadata, TimeToolEventArrayGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayGroup, [TimeToolEventArrayGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5225191702089452142, 4839624242436753046), TimeToolEventArrayGroup)
agcls.AgTypeNameMap["TimeToolEventArrayGroup"] = TimeToolEventArrayGroup

class CalculationToolScalarGroup(SupportsDeleteCallback):
    """Access or create VGT calculation scalars associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (4659785540148584367, 12814880882912016044),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarGroup)
    def __iter__(self):
        """Create an iterator for the CalculationToolScalarGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolScalar":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "CalculationToolScalarFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolScalar":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolScalar":
        """Retrieve an element from the collection by index."""
        return self._intf.invoke(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolScalar":
        """Retrieve an element from the collection by name."""
        return self._intf.invoke(CalculationToolScalarGroup._metadata, CalculationToolScalarGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarGroup, [CalculationToolScalarGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5048329027604808808, 12927501014310075801), CalculationToolScalarGroup)
agcls.AgTypeNameMap["CalculationToolScalarGroup"] = CalculationToolScalarGroup

class TimeToolEventIntervalCollectionGroup(SupportsDeleteCallback):
    """Access or create VGT event interval collections associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5628253959361021565, 6774093585548149417),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalCollectionGroup)
    def __iter__(self):
        """Create an iterator for the TimeToolEventIntervalCollectionGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventIntervalCollection":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "TimeToolEventIntervalCollectionFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventIntervalCollection":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventIntervalCollection":
        """Retrieve an event interval from the collection by index."""
        return self._intf.invoke(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventIntervalCollection":
        """Retrieve an event interval from the collection by name."""
        return self._intf.invoke(TimeToolEventIntervalCollectionGroup._metadata, TimeToolEventIntervalCollectionGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalCollectionGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalCollectionGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionGroup, [TimeToolEventIntervalCollectionGroup, ])

agcls.AgClassCatalog.add_catalog_entry((4676956353340798946, 4132032579773110454), TimeToolEventIntervalCollectionGroup)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionGroup"] = TimeToolEventIntervalCollectionGroup

class CalculationToolParameterSetGroup(SupportsDeleteCallback):
    """Access or create VGT parameter sets associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5625575995100372233, 5247817078545365909),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolParameterSetGroup)
    def __iter__(self):
        """Create an iterator for the CalculationToolParameterSetGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolParameterSet":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "CalculationToolParameterSetFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolParameterSet":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolParameterSet":
        """Retrieve an element from the collection by index."""
        return self._intf.invoke(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolParameterSet":
        """Retrieve an element from the collection by name."""
        return self._intf.invoke(CalculationToolParameterSetGroup._metadata, CalculationToolParameterSetGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSetGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolParameterSetGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSetGroup, [CalculationToolParameterSetGroup, ])

agcls.AgClassCatalog.add_catalog_entry((4675360958547478665, 15542114842964845204), CalculationToolParameterSetGroup)
agcls.AgTypeNameMap["CalculationToolParameterSetGroup"] = CalculationToolParameterSetGroup

class CalculationToolConditionGroup(SupportsDeleteCallback):
    """Access or create VGT conditions associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5727353733426007755, 13885664073261871009),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionGroup)
    def __iter__(self):
        """Create an iterator for the CalculationToolConditionGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolCondition":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "CalculationToolConditionFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolCondition":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolCondition":
        """Retrieve a condition from the collection by index."""
        return self._intf.invoke(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolCondition":
        """Retrieve a condition from the collection by name."""
        return self._intf.invoke(CalculationToolConditionGroup._metadata, CalculationToolConditionGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionGroup, [CalculationToolConditionGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5750765973699081321, 14571179364062773916), CalculationToolConditionGroup)
agcls.AgTypeNameMap["CalculationToolConditionGroup"] = CalculationToolConditionGroup

class CalculationToolConditionSetGroup(SupportsDeleteCallback):
    """Allow accessing and creating condition set components."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5611826300224457159, 16584276783501574569),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionSetGroup)
    def __iter__(self):
        """Create an iterator for the CalculationToolConditionSetGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolConditionSet":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "CalculationToolConditionSetFactory":
        """Return a factory object used to create condition set components."""
        return self._intf.get_property(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolConditionSet":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolConditionSet":
        """Retrieve a condition set from the collection by index."""
        return self._intf.invoke(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolConditionSet":
        """Retrieve a condition set from the collection by name."""
        return self._intf.invoke(CalculationToolConditionSetGroup._metadata, CalculationToolConditionSetGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionSetGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionSetGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionSetGroup, [CalculationToolConditionSetGroup, ])

agcls.AgClassCatalog.add_catalog_entry((4707405303890402417, 10690097794579297951), CalculationToolConditionSetGroup)
agcls.AgTypeNameMap["CalculationToolConditionSetGroup"] = CalculationToolConditionSetGroup

class CalculationToolConditionSetEvaluateResult(SupportsDeleteCallback):
    """Represents the results returned by ConditionSet.Evaluate."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_values_method_offset = 2
    _metadata = {
        "iid_data" : (5427191482923494608, 3628611338351778977),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionSetEvaluateResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(CalculationToolConditionSetEvaluateResult._metadata, CalculationToolConditionSetEvaluateResult._get_is_valid_metadata)

    _get_values_metadata = { "offset" : _get_values_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def values(self) -> list:
        """Computed values."""
        return self._intf.get_property(CalculationToolConditionSetEvaluateResult._metadata, CalculationToolConditionSetEvaluateResult._get_values_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[values] = "values"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionSetEvaluateResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionSetEvaluateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionSetEvaluateResult, [CalculationToolConditionSetEvaluateResult, ])

agcls.AgClassCatalog.add_catalog_entry((5222756833012542291, 4920051115777198524), CalculationToolConditionSetEvaluateResult)
agcls.AgTypeNameMap["CalculationToolConditionSetEvaluateResult"] = CalculationToolConditionSetEvaluateResult

class CalculationToolConditionSetEvaluateWithRateResult(SupportsDeleteCallback):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_values_method_offset = 2
    _get_rates_method_offset = 3
    _metadata = {
        "iid_data" : (4805407826333748553, 13212141293468544164),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionSetEvaluateWithRateResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(CalculationToolConditionSetEvaluateWithRateResult._metadata, CalculationToolConditionSetEvaluateWithRateResult._get_is_valid_metadata)

    _get_values_metadata = { "offset" : _get_values_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def values(self) -> list:
        """Computed values."""
        return self._intf.get_property(CalculationToolConditionSetEvaluateWithRateResult._metadata, CalculationToolConditionSetEvaluateWithRateResult._get_values_metadata)

    _get_rates_metadata = { "offset" : _get_rates_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def rates(self) -> list:
        """Computed rates."""
        return self._intf.get_property(CalculationToolConditionSetEvaluateWithRateResult._metadata, CalculationToolConditionSetEvaluateWithRateResult._get_rates_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[values] = "values"
    _property_names[rates] = "rates"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionSetEvaluateWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionSetEvaluateWithRateResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionSetEvaluateWithRateResult, [CalculationToolConditionSetEvaluateWithRateResult, ])

agcls.AgClassCatalog.add_catalog_entry((4840393028332232055, 13403874806573712528), CalculationToolConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap["CalculationToolConditionSetEvaluateWithRateResult"] = CalculationToolConditionSetEvaluateWithRateResult

class SpatialAnalysisToolVolumeGridGroup(SupportsDeleteCallback):
    """Access or create VGT volume grids associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5652804191328005584, 15020715553548321674),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridGroup)
    def __iter__(self):
        """Create an iterator for the SpatialAnalysisToolVolumeGridGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolumeGrid":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "SpatialAnalysisToolVolumeGridFactory":
        """Return a factory object used to create volume grid components."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolumeGrid":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ISpatialAnalysisToolVolumeGrid":
        """Retrieve a volume grid from the collection by index."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Retrieve a volume grid from the collection by name."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridGroup._metadata, SpatialAnalysisToolVolumeGridGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridGroup, [SpatialAnalysisToolVolumeGridGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5434667114735017104, 247084353934700168), SpatialAnalysisToolVolumeGridGroup)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridGroup"] = SpatialAnalysisToolVolumeGridGroup

class SpatialAnalysisToolVolumeGroup(SupportsDeleteCallback):
    """Access or create spatial conditions associated with a volume grid."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5105009531150323546, 886691369936677802),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGroup)
    def __iter__(self):
        """Create an iterator for the SpatialAnalysisToolVolumeGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolume":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "SpatialAnalysisToolVolumeFactory":
        """Return a factory object used to create spatial condition components."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolume":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ISpatialAnalysisToolVolume":
        """Retrieve an volume from the collection by index."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ISpatialAnalysisToolVolume":
        """Retrieve volume from the collection by name."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGroup._metadata, SpatialAnalysisToolVolumeGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGroup, [SpatialAnalysisToolVolumeGroup, ])

agcls.AgClassCatalog.add_catalog_entry((4930145607069579046, 10312486085103245186), SpatialAnalysisToolVolumeGroup)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGroup"] = SpatialAnalysisToolVolumeGroup

class SpatialAnalysisToolVolumeCalcGroup(SupportsDeleteCallback):
    """Access or create VGT volume calcs associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5218042406034281573, 13159514031507062161),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcGroup)
    def __iter__(self):
        """Create an iterator for the SpatialAnalysisToolVolumeCalcGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolumeCalc":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._remove_metadata, eventName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "SpatialAnalysisToolVolumeCalcFactory":
        """Return a factory object used to create volume calc components."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolumeCalc":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "ISpatialAnalysisToolVolumeCalc":
        """Retrieve a volume calculation from the collection by index."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Retrieve a volume calculation from the collection by name."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcGroup._metadata, SpatialAnalysisToolVolumeCalcGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcGroup, [SpatialAnalysisToolVolumeCalcGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5357586751106003383, 7462844834759351198), SpatialAnalysisToolVolumeCalcGroup)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcGroup"] = SpatialAnalysisToolVolumeCalcGroup

class CalculationToolScalar(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Any scalar calculation that is not constant by construction."""
    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalar."""
        SupportsDeleteCallback.__init__(self)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalar, [ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5230397928531433355, 10269566397212942242), CalculationToolScalar)
agcls.AgTypeNameMap["CalculationToolScalar"] = CalculationToolScalar

class CalculationToolScalarAngle(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Scalar equal to angular displacement obtained from any angle in VGT."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_angle_method_offset = 1
    _set_input_angle_method_offset = 2
    _metadata = {
        "iid_data" : (4959187984038204723, 1310938748632609426),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarAngle)
    
    _get_input_angle_metadata = { "offset" : _get_input_angle_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_angle(self) -> "IVectorGeometryToolAngle":
        """The input angle, which is a VGT angle component. Note angle computation in VGT may involve more than just angular displacement value: in VGT angles may be drawn in 3D which requires knowledge and evaluation of supporting vectors."""
        return self._intf.get_property(CalculationToolScalarAngle._metadata, CalculationToolScalarAngle._get_input_angle_metadata)

    _set_input_angle_metadata = { "offset" : _set_input_angle_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAngle"),) }
    @input_angle.setter
    def input_angle(self, inputAngle:"IVectorGeometryToolAngle") -> None:
        return self._intf.set_property(CalculationToolScalarAngle._metadata, CalculationToolScalarAngle._set_input_angle_metadata, inputAngle)

    _property_names[input_angle] = "input_angle"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarAngle."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarAngle)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarAngle, [CalculationToolScalarAngle, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4904462145790055437, 5156190887739896966), CalculationToolScalarAngle)
agcls.AgTypeNameMap["CalculationToolScalarAngle"] = CalculationToolScalarAngle

class CalculationToolScalarAverage(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""

    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_scalar_method_offset = 1
    _set_input_scalar_method_offset = 2
    _get_compute_as_average_method_offset = 3
    _set_compute_as_average_method_offset = 4
    _get_integration_window_type_method_offset = 5
    _set_integration_window_type_method_offset = 6
    _get_start_offset_method_offset = 7
    _set_start_offset_method_offset = 8
    _get_stop_offset_method_offset = 9
    _set_stop_offset_method_offset = 10
    _get_use_custom_time_limits_method_offset = 11
    _set_use_custom_time_limits_method_offset = 12
    _get_custom_time_limits_method_offset = 13
    _set_custom_time_limits_method_offset = 14
    _get_save_data_option_method_offset = 15
    _set_save_data_option_method_offset = 16
    _get_interpolation_method_offset = 17
    _set_interpolation_method_offset = 18
    _get_sampling_method_offset = 19
    _set_sampling_method_offset = 20
    _get_integral_method_offset = 21
    _set_integral_method_offset = 22
    _get_keep_constant_outside_time_limits_method_offset = 23
    _set_keep_constant_outside_time_limits_method_offset = 24
    _set_offsets_method_offset = 25
    _metadata = {
        "iid_data" : (5376371496447394548, 11623923147254190485),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarAverage)
    
    _get_input_scalar_metadata = { "offset" : _get_input_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "offset" : _set_input_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_input_scalar_metadata, inputScalar)

    _get_compute_as_average_metadata = { "offset" : _get_compute_as_average_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def compute_as_average(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_compute_as_average_metadata)

    _set_compute_as_average_metadata = { "offset" : _set_compute_as_average_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @compute_as_average.setter
    def compute_as_average(self, computeAsAverage:bool) -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_compute_as_average_metadata, computeAsAverage)

    _get_integration_window_type_metadata = { "offset" : _get_integration_window_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @property
    def integration_window_type(self) -> "CRDN_INTEGRATION_WINDOW_TYPE":
        """The integration window, or accumulation, type."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_integration_window_type_metadata)

    _set_integration_window_type_metadata = { "offset" : _set_integration_window_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @integration_window_type.setter
    def integration_window_type(self, integrationWindowType:"CRDN_INTEGRATION_WINDOW_TYPE") -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_integration_window_type_metadata, integrationWindowType)

    _get_start_offset_metadata = { "offset" : _get_start_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def start_offset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_start_offset_metadata)

    _set_start_offset_metadata = { "offset" : _set_start_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "offset" : _get_stop_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def stop_offset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "offset" : _set_stop_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_stop_offset_metadata, stopOffset)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_custom_time_limits_metadata, customTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_save_data_option_metadata, saveDataOption)

    _get_interpolation_metadata = { "offset" : _get_interpolation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_interpolation_metadata)

    _set_interpolation_metadata = { "offset" : _set_interpolation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchInterp"),) }
    @interpolation.setter
    def interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_interpolation_metadata, interpolation)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_sampling_metadata, sampling)

    _get_integral_metadata = { "offset" : _get_integral_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def integral(self) -> "IAnalysisWorkbenchIntegral":
        """The numerical integration method."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_integral_metadata)

    _set_integral_metadata = { "offset" : _set_integral_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchIntegral"),) }
    @integral.setter
    def integral(self, integral:"IAnalysisWorkbenchIntegral") -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_integral_metadata, integral)

    _get_keep_constant_outside_time_limits_metadata = { "offset" : _get_keep_constant_outside_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def keep_constant_outside_time_limits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        return self._intf.get_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._get_keep_constant_outside_time_limits_metadata)

    _set_keep_constant_outside_time_limits_metadata = { "offset" : _set_keep_constant_outside_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @keep_constant_outside_time_limits.setter
    def keep_constant_outside_time_limits(self, keepConstantOutsideTimeLimits:bool) -> None:
        return self._intf.set_property(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_keep_constant_outside_time_limits_metadata, keepConstantOutsideTimeLimits)

    _set_offsets_metadata = { "offset" : _set_offsets_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg,) }
    def set_offsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.invoke(CalculationToolScalarAverage._metadata, CalculationToolScalarAverage._set_offsets_metadata, startOffset, stopOffset)

    _property_names[input_scalar] = "input_scalar"
    _property_names[compute_as_average] = "compute_as_average"
    _property_names[integration_window_type] = "integration_window_type"
    _property_names[start_offset] = "start_offset"
    _property_names[stop_offset] = "stop_offset"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[interpolation] = "interpolation"
    _property_names[sampling] = "sampling"
    _property_names[integral] = "integral"
    _property_names[keep_constant_outside_time_limits] = "keep_constant_outside_time_limits"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarAverage."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarAverage)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarAverage, [CalculationToolScalarAverage, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5436686424833363725, 875804097364919458), CalculationToolScalarAverage)
agcls.AgTypeNameMap["CalculationToolScalarAverage"] = CalculationToolScalarAverage

class CalculationToolScalarConstant(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Constant scalar value of specified dimension."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_value_method_offset = 1
    _set_value_method_offset = 2
    _get_dimension_method_offset = 3
    _set_dimension_method_offset = 4
    _metadata = {
        "iid_data" : (5533910452542745513, 14034208071237068448),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarConstant)
    
    _get_value_metadata = { "offset" : _get_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def value(self) -> float:
        """A value which can be in any STK supported unit available for selected dimension."""
        return self._intf.get_property(CalculationToolScalarConstant._metadata, CalculationToolScalarConstant._get_value_metadata)

    _set_value_metadata = { "offset" : _set_value_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @value.setter
    def value(self, value:float) -> None:
        return self._intf.set_property(CalculationToolScalarConstant._metadata, CalculationToolScalarConstant._set_value_metadata, value)

    _get_dimension_metadata = { "offset" : _get_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def dimension(self) -> str:
        """The dimension of the constant value, this can be any of the STK supported dimensions."""
        return self._intf.get_property(CalculationToolScalarConstant._metadata, CalculationToolScalarConstant._get_dimension_metadata)

    _set_dimension_metadata = { "offset" : _set_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(CalculationToolScalarConstant._metadata, CalculationToolScalarConstant._set_dimension_metadata, dimension)

    _property_names[value] = "value"
    _property_names[dimension] = "dimension"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarConstant."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarConstant)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarConstant, [CalculationToolScalarConstant, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5761343657246828391, 12742771671638689976), CalculationToolScalarConstant)
agcls.AgTypeNameMap["CalculationToolScalarConstant"] = CalculationToolScalarConstant

class CalculationToolScalarCustom(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filename_method_offset = 1
    _set_filename_method_offset = 2
    _reload_method_offset = 3
    _get_invalidate_on_exec_error_method_offset = 4
    _set_invalidate_on_exec_error_method_offset = 5
    _metadata = {
        "iid_data" : (5409179971415946885, 10112159419728251554),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarCustom)
    
    _get_filename_metadata = { "offset" : _get_filename_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def filename(self) -> str:
        """A path to MATLAB (.m or .dll), Perl or VBScript file."""
        return self._intf.get_property(CalculationToolScalarCustom._metadata, CalculationToolScalarCustom._get_filename_metadata)

    _set_filename_metadata = { "offset" : _set_filename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(CalculationToolScalarCustom._metadata, CalculationToolScalarCustom._set_filename_metadata, filename)

    _reload_metadata = { "offset" : _reload_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the file specified with Filename property."""
        return self._intf.invoke(CalculationToolScalarCustom._metadata, CalculationToolScalarCustom._reload_metadata, )

    _get_invalidate_on_exec_error_metadata = { "offset" : _get_invalidate_on_exec_error_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def invalidate_on_exec_error(self) -> bool:
        """Specify InvalidOnExecError flag for a custom scalar."""
        return self._intf.get_property(CalculationToolScalarCustom._metadata, CalculationToolScalarCustom._get_invalidate_on_exec_error_metadata)

    _set_invalidate_on_exec_error_metadata = { "offset" : _set_invalidate_on_exec_error_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @invalidate_on_exec_error.setter
    def invalidate_on_exec_error(self, invalidateOnExecError:bool) -> None:
        return self._intf.set_property(CalculationToolScalarCustom._metadata, CalculationToolScalarCustom._set_invalidate_on_exec_error_metadata, invalidateOnExecError)

    _property_names[filename] = "filename"
    _property_names[invalidate_on_exec_error] = "invalidate_on_exec_error"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarCustom."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarCustom)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarCustom, [CalculationToolScalarCustom, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5177995385747099113, 10709837510467460012), CalculationToolScalarCustom)
agcls.AgTypeNameMap["CalculationToolScalarCustom"] = CalculationToolScalarCustom

class CalculationToolScalarCustomInline(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A calc scalar based on using an inline scripted algorithm in MATLAB, Perl, VBScript or JScript to define its value and rate."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_script_type_method_offset = 1
    _set_script_type_method_offset = 2
    _get_value_function_method_offset = 3
    _set_value_function_method_offset = 4
    _get_derivative_function_method_offset = 5
    _set_derivative_function_method_offset = 6
    _get_dimension_method_offset = 7
    _set_dimension_method_offset = 8
    _get_all_arguments_method_offset = 9
    _set_all_arguments_method_offset = 10
    _metadata = {
        "iid_data" : (4764386451504013000, 3625316982411733925),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarCustomInline)
    
    _get_script_type_metadata = { "offset" : _get_script_type_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def script_type(self) -> str:
        """Script type allowed {JScript | Matlab | VBScript}."""
        return self._intf.get_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._get_script_type_metadata)

    _set_script_type_metadata = { "offset" : _set_script_type_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @script_type.setter
    def script_type(self, scriptType:str) -> None:
        return self._intf.set_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._set_script_type_metadata, scriptType)

    _get_value_function_metadata = { "offset" : _get_value_function_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def value_function(self) -> str:
        """The Value function to be evaluated."""
        return self._intf.get_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._get_value_function_metadata)

    _set_value_function_metadata = { "offset" : _set_value_function_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @value_function.setter
    def value_function(self, valueFunction:str) -> None:
        return self._intf.set_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._set_value_function_metadata, valueFunction)

    _get_derivative_function_metadata = { "offset" : _get_derivative_function_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def derivative_function(self) -> str:
        """The Derivative function to be evaluated."""
        return self._intf.get_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._get_derivative_function_metadata)

    _set_derivative_function_metadata = { "offset" : _set_derivative_function_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @derivative_function.setter
    def derivative_function(self, derivativeFunction:str) -> None:
        return self._intf.set_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._set_derivative_function_metadata, derivativeFunction)

    _get_dimension_metadata = { "offset" : _get_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def dimension(self) -> str:
        """Dimension name."""
        return self._intf.get_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._get_dimension_metadata)

    _set_dimension_metadata = { "offset" : _set_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._set_dimension_metadata, dimension)

    _get_all_arguments_metadata = { "offset" : _get_all_arguments_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def get_all_arguments(self) -> list:
        """Return the list of arguments."""
        return self._intf.invoke(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._get_all_arguments_metadata, OutArg())

    _set_all_arguments_metadata = { "offset" : _set_all_arguments_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_all_arguments(self, calcList:list) -> None:
        """Set the list of arguments."""
        return self._intf.invoke(CalculationToolScalarCustomInline._metadata, CalculationToolScalarCustomInline._set_all_arguments_metadata, calcList)

    _property_names[script_type] = "script_type"
    _property_names[value_function] = "value_function"
    _property_names[derivative_function] = "derivative_function"
    _property_names[dimension] = "dimension"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarCustomInline."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarCustomInline)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarCustomInline, [CalculationToolScalarCustomInline, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5758632709114625099, 1419255989428412582), CalculationToolScalarCustomInline)
agcls.AgTypeNameMap["CalculationToolScalarCustomInline"] = CalculationToolScalarCustomInline

class CalculationToolScalarDataElement(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Any time-dependent data element from STK data providers available for parent STK object."""

    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_data_provider_method_offset = 1
    _get_element_name_method_offset = 2
    _get_group_method_offset = 3
    _get_interpolation_method_offset = 4
    _set_interpolation_method_offset = 5
    _get_sampling_method_offset = 6
    _set_sampling_method_offset = 7
    _get_use_samples_method_offset = 8
    _set_use_samples_method_offset = 9
    _get_save_data_option_method_offset = 10
    _set_save_data_option_method_offset = 11
    _set_method_offset = 12
    _set_with_group_method_offset = 13
    _get_invalid_data_indicator_method_offset = 14
    _set_invalid_data_indicator_method_offset = 15
    _metadata = {
        "iid_data" : (5684166753534512598, 14848638846349344702),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarDataElement)
    
    _get_data_provider_metadata = { "offset" : _get_data_provider_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def data_provider(self) -> str:
        """The name of the data provider."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_data_provider_metadata)

    _get_element_name_metadata = { "offset" : _get_element_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def element_name(self) -> str:
        """The name of the data element within the data provider."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_element_name_metadata)

    _get_group_metadata = { "offset" : _get_group_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def group(self) -> str:
        """A group name the data element is a part of. If the element is not a part of a group, the property will return an empty string."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_group_metadata)

    _get_interpolation_metadata = { "offset" : _get_interpolation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_interpolation_metadata)

    _set_interpolation_metadata = { "offset" : _set_interpolation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchInterp"),) }
    @interpolation.setter
    def interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        return self._intf.set_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._set_interpolation_metadata, interpolation)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """Relative tolerance uses a combination of relative and absolute changes in scalar values between samples. Curvature tolerance also uses changes in slope between samples."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._set_sampling_metadata, sampling)

    _get_use_samples_metadata = { "offset" : _get_use_samples_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_samples(self) -> bool:
        """If set to true, selected data provider is presampled over its entire availability span using sampling method specified in Advanced options..."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_use_samples_metadata)

    _set_use_samples_metadata = { "offset" : _set_use_samples_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_samples.setter
    def use_samples(self, useSamples:bool) -> None:
        return self._intf.set_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._set_use_samples_metadata, useSamples)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed samples are saved/loaded, otherwise if using samples they are recomputed on load."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._set_save_data_option_metadata, saveDataOption)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def set(self, dataProvider:str, elementName:str) -> None:
        """Set the data provider and the element name."""
        return self._intf.invoke(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._set_metadata, dataProvider, elementName)

    _set_with_group_metadata = { "offset" : _set_with_group_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg,) }
    def set_with_group(self, dataProvider:str, typeName:str, elementName:str) -> None:
        """Set the data provider name, the element name, and data provider type name."""
        return self._intf.invoke(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._set_with_group_metadata, dataProvider, typeName, elementName)

    _get_invalid_data_indicator_metadata = { "offset" : _get_invalid_data_indicator_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def invalid_data_indicator(self) -> float:
        """Set the value to display in a report or graph when the actual value is not a valid real number."""
        return self._intf.get_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._get_invalid_data_indicator_metadata)

    _set_invalid_data_indicator_metadata = { "offset" : _set_invalid_data_indicator_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @invalid_data_indicator.setter
    def invalid_data_indicator(self, invalidDataIndicator:float) -> None:
        return self._intf.set_property(CalculationToolScalarDataElement._metadata, CalculationToolScalarDataElement._set_invalid_data_indicator_metadata, invalidDataIndicator)

    _property_names[data_provider] = "data_provider"
    _property_names[element_name] = "element_name"
    _property_names[group] = "group"
    _property_names[interpolation] = "interpolation"
    _property_names[sampling] = "sampling"
    _property_names[use_samples] = "use_samples"
    _property_names[save_data_option] = "save_data_option"
    _property_names[invalid_data_indicator] = "invalid_data_indicator"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarDataElement."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarDataElement)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarDataElement, [CalculationToolScalarDataElement, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5321856052550789231, 6123381429176273038), CalculationToolScalarDataElement)
agcls.AgTypeNameMap["CalculationToolScalarDataElement"] = CalculationToolScalarDataElement

class CalculationToolScalarDerivative(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Derivative of an input scalar calculation."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_scalar_method_offset = 1
    _set_scalar_method_offset = 2
    _get_differencing_time_step_method_offset = 3
    _set_differencing_time_step_method_offset = 4
    _get_force_use_of_numerical_differences_method_offset = 5
    _set_force_use_of_numerical_differences_method_offset = 6
    _metadata = {
        "iid_data" : (5439408000144674159, 16540285713240218546),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarDerivative)
    
    _get_scalar_metadata = { "offset" : _get_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """The input scalar component used to compute the derivative."""
        return self._intf.get_property(CalculationToolScalarDerivative._metadata, CalculationToolScalarDerivative._get_scalar_metadata)

    _set_scalar_metadata = { "offset" : _set_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarDerivative._metadata, CalculationToolScalarDerivative._set_scalar_metadata, scalar)

    _get_differencing_time_step_metadata = { "offset" : _get_differencing_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def differencing_time_step(self) -> float:
        """The time step used, if necessary, in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(CalculationToolScalarDerivative._metadata, CalculationToolScalarDerivative._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "offset" : _set_differencing_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(CalculationToolScalarDerivative._metadata, CalculationToolScalarDerivative._set_differencing_time_step_metadata, differencingTimeStep)

    _get_force_use_of_numerical_differences_metadata = { "offset" : _get_force_use_of_numerical_differences_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def force_use_of_numerical_differences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        return self._intf.get_property(CalculationToolScalarDerivative._metadata, CalculationToolScalarDerivative._get_force_use_of_numerical_differences_metadata)

    _set_force_use_of_numerical_differences_metadata = { "offset" : _set_force_use_of_numerical_differences_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @force_use_of_numerical_differences.setter
    def force_use_of_numerical_differences(self, forceUseOfNumericalDifferences:bool) -> None:
        return self._intf.set_property(CalculationToolScalarDerivative._metadata, CalculationToolScalarDerivative._set_force_use_of_numerical_differences_metadata, forceUseOfNumericalDifferences)

    _property_names[scalar] = "scalar"
    _property_names[differencing_time_step] = "differencing_time_step"
    _property_names[force_use_of_numerical_differences] = "force_use_of_numerical_differences"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarDerivative."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarDerivative)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarDerivative, [CalculationToolScalarDerivative, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5415006546127808424, 17328826830833065386), CalculationToolScalarDerivative)
agcls.AgTypeNameMap["CalculationToolScalarDerivative"] = CalculationToolScalarDerivative

class CalculationToolScalarDotProduct(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Dot product between two vectors."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_vector_a_method_offset = 1
    _set_vector_a_method_offset = 2
    _get_normalize_vector_a_method_offset = 3
    _set_normalize_vector_a_method_offset = 4
    _get_vector_b_method_offset = 5
    _set_vector_b_method_offset = 6
    _get_normalize_vector_b_method_offset = 7
    _set_normalize_vector_b_method_offset = 8
    _get_dimension_method_offset = 9
    _set_dimension_method_offset = 10
    _metadata = {
        "iid_data" : (4701425013565595554, 16894540468255929531),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarDotProduct)
    
    _get_vector_a_metadata = { "offset" : _get_vector_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_a(self) -> "IVectorGeometryToolVector":
        """First vector."""
        return self._intf.get_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._get_vector_a_metadata)

    _set_vector_a_metadata = { "offset" : _set_vector_a_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @vector_a.setter
    def vector_a(self, vectorA:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._set_vector_a_metadata, vectorA)

    _get_normalize_vector_a_metadata = { "offset" : _get_normalize_vector_a_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def normalize_vector_a(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._get_normalize_vector_a_metadata)

    _set_normalize_vector_a_metadata = { "offset" : _set_normalize_vector_a_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @normalize_vector_a.setter
    def normalize_vector_a(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._set_normalize_vector_a_metadata, normalizeVectorA)

    _get_vector_b_metadata = { "offset" : _get_vector_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_b(self) -> "IVectorGeometryToolVector":
        """Second vector."""
        return self._intf.get_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._get_vector_b_metadata)

    _set_vector_b_metadata = { "offset" : _set_vector_b_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @vector_b.setter
    def vector_b(self, vectorB:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._set_vector_b_metadata, vectorB)

    _get_normalize_vector_b_metadata = { "offset" : _get_normalize_vector_b_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def normalize_vector_b(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._get_normalize_vector_b_metadata)

    _set_normalize_vector_b_metadata = { "offset" : _set_normalize_vector_b_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @normalize_vector_b.setter
    def normalize_vector_b(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._set_normalize_vector_b_metadata, normalizeVectorB)

    _get_dimension_metadata = { "offset" : _get_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def dimension(self) -> str:
        """Return a unit of measure, i.e. 'Angle', 'Distance', etc."""
        return self._intf.get_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._get_dimension_metadata)

    _set_dimension_metadata = { "offset" : _set_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(CalculationToolScalarDotProduct._metadata, CalculationToolScalarDotProduct._set_dimension_metadata, dimension)

    _property_names[vector_a] = "vector_a"
    _property_names[normalize_vector_a] = "normalize_vector_a"
    _property_names[vector_b] = "vector_b"
    _property_names[normalize_vector_b] = "normalize_vector_b"
    _property_names[dimension] = "dimension"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarDotProduct."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarDotProduct)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarDotProduct, [CalculationToolScalarDotProduct, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4792387092728447134, 3158224088086022029), CalculationToolScalarDotProduct)
agcls.AgTypeNameMap["CalculationToolScalarDotProduct"] = CalculationToolScalarDotProduct

class CalculationToolScalarElapsedTime(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Time elapsed since the reference time instant. Negative if in the past."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_time_instant_method_offset = 1
    _set_reference_time_instant_method_offset = 2
    _metadata = {
        "iid_data" : (5303668177545430544, 4808828999605306252),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarElapsedTime)
    
    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(CalculationToolScalarElapsedTime._metadata, CalculationToolScalarElapsedTime._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(CalculationToolScalarElapsedTime._metadata, CalculationToolScalarElapsedTime._set_reference_time_instant_metadata, referenceTimeInstant)

    _property_names[reference_time_instant] = "reference_time_instant"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarElapsedTime."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarElapsedTime)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarElapsedTime, [CalculationToolScalarElapsedTime, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4848170193154715426, 2061643609355890078), CalculationToolScalarElapsedTime)
agcls.AgTypeNameMap["CalculationToolScalarElapsedTime"] = CalculationToolScalarElapsedTime

class CalculationToolScalarFactory(SupportsDeleteCallback):
    """The factory creates scalar calculation components."""

    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_available_calc_scalar_plugin_display_names_method_offset = 1
    _create_method_offset = 2
    _create_calc_scalar_angle_method_offset = 3
    _create_calc_scalar_fixed_at_time_instant_method_offset = 4
    _create_calc_scalar_constant_method_offset = 5
    _create_calc_scalar_data_element_method_offset = 6
    _create_calc_scalar_data_element_with_group_method_offset = 7
    _create_calc_scalar_derivative_method_offset = 8
    _create_calc_scalar_elapsed_time_method_offset = 9
    _create_calc_scalar_file_method_offset = 10
    _create_calc_scalar_function_method_offset = 11
    _create_calc_scalar_integral_method_offset = 12
    _create_calc_scalar_function2_var_method_offset = 13
    _create_calc_scalar_vector_magnitude_method_offset = 14
    _create_calc_scalar_plugin_from_display_name_method_offset = 15
    _is_type_supported_method_offset = 16
    _create_calc_scalar_from_custom_script_method_offset = 17
    _create_calc_scalar_surface_distance_between_points_method_offset = 18
    _create_calc_scalar_dot_product_method_offset = 19
    _create_calc_scalar_vector_component_method_offset = 20
    _create_calc_scalar_average_method_offset = 21
    _create_calc_scalar_standard_deviation_method_offset = 22
    _create_calc_scalar_point_in_volume_calc_method_offset = 23
    _create_calc_scalar_custom_inline_script_method_offset = 24
    _metadata = {
        "iid_data" : (5499352364829801528, 7117583500936800935),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarFactory)
    
    _get_available_calc_scalar_plugin_display_names_metadata = { "offset" : _get_available_calc_scalar_plugin_display_names_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_calc_scalar_plugin_display_names(self) -> list:
        """An array of display names associated with available scalar calculation plugins. The elements of the array are strings. Display names are used to create Calc scalars based on COM plugins using CreateCalcScalarPluginFromDisplayName method."""
        return self._intf.get_property(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._get_available_calc_scalar_plugin_display_names_metadata)

    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_CALC_SCALAR_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_CALC_SCALAR_TYPE") -> "ICalculationToolScalar":
        """Create and registers a scalar calculation using specified name, description, and type."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_metadata, name, description, type, OutArg())

    _create_calc_scalar_angle_metadata = { "offset" : _create_calc_scalar_angle_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_angle(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation equal to angular displacement obtained from any angle in VGT."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_angle_metadata, name, description, OutArg())

    _create_calc_scalar_fixed_at_time_instant_metadata = { "offset" : _create_calc_scalar_fixed_at_time_instant_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_fixed_at_time_instant(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined by evaluating the input scalar calculation at the specified reference time instant."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_fixed_at_time_instant_metadata, name, description, OutArg())

    _create_calc_scalar_constant_metadata = { "offset" : _create_calc_scalar_constant_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_constant(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation of constant value of the specified dimension."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_constant_metadata, name, description, OutArg())

    _create_calc_scalar_data_element_metadata = { "offset" : _create_calc_scalar_data_element_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_data_element(self, name:str, description:str, dataProvider:str, elementName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_data_element_metadata, name, description, dataProvider, elementName, OutArg())

    _create_calc_scalar_data_element_with_group_metadata = { "offset" : _create_calc_scalar_data_element_with_group_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_data_element_with_group(self, name:str, description:str, dataProvider:str, groupName:str, elementName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_data_element_with_group_metadata, name, description, dataProvider, groupName, elementName, OutArg())

    _create_calc_scalar_derivative_metadata = { "offset" : _create_calc_scalar_derivative_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_derivative(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the derivative of an input scalar calculation."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_derivative_metadata, name, description, OutArg())

    _create_calc_scalar_elapsed_time_metadata = { "offset" : _create_calc_scalar_elapsed_time_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_elapsed_time(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the time elapsed since a reference time instant."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_elapsed_time_metadata, name, description, OutArg())

    _create_calc_scalar_file_metadata = { "offset" : _create_calc_scalar_file_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_file(self, name:str, description:str, filepath:str) -> "ICalculationToolScalar":
        """Create scalar calculation specified by external data file."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_file_metadata, name, description, filepath, OutArg())

    _create_calc_scalar_function_metadata = { "offset" : _create_calc_scalar_function_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_function(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by performing the specified function on the input scalar or time instant."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_function_metadata, name, description, OutArg())

    _create_calc_scalar_integral_metadata = { "offset" : _create_calc_scalar_integral_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_integral(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the integral of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_integral_metadata, name, description, OutArg())

    _create_calc_scalar_function2_var_metadata = { "offset" : _create_calc_scalar_function2_var_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_function2_var(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by performing a function(x,y) on two scalar arguments."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_function2_var_metadata, name, description, OutArg())

    _create_calc_scalar_vector_magnitude_metadata = { "offset" : _create_calc_scalar_vector_magnitude_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_vector_magnitude(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation equal to the magnitude of a specified vector."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_vector_magnitude_metadata, name, description, OutArg())

    _create_calc_scalar_plugin_from_display_name_metadata = { "offset" : _create_calc_scalar_plugin_from_display_name_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_plugin_from_display_name(self, name:str, description:str, displayName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation based on a COM plugin. For information how to implement and register VGT plugins, see <topic name='Engine Plugins: COM-based Engine Plugin Components'>COM-based Engine Plugins.</topic>."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_plugin_from_display_name_metadata, name, description, displayName, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CALC_SCALAR_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_CALC_SCALAR_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._is_type_supported_metadata, eType, OutArg())

    _create_calc_scalar_from_custom_script_metadata = { "offset" : _create_calc_scalar_from_custom_script_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_from_custom_script(self, name:str, description:str, filepath:str) -> "ICalculationToolScalar":
        """Create a calc scalar calculation that uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_from_custom_script_metadata, name, description, filepath, OutArg())

    _create_calc_scalar_surface_distance_between_points_metadata = { "offset" : _create_calc_scalar_surface_distance_between_points_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_surface_distance_between_points(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a calc scalar calculation that is surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_surface_distance_between_points_metadata, name, description, OutArg())

    _create_calc_scalar_dot_product_metadata = { "offset" : _create_calc_scalar_dot_product_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_dot_product(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by a dot product between two vectors."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_dot_product_metadata, name, description, OutArg())

    _create_calc_scalar_vector_component_metadata = { "offset" : _create_calc_scalar_vector_component_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_vector_component(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by a specified component of a vector when resolved in specified axes."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_vector_component_metadata, name, description, OutArg())

    _create_calc_scalar_average_metadata = { "offset" : _create_calc_scalar_average_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_average(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the average of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_average_metadata, name, description, OutArg())

    _create_calc_scalar_standard_deviation_metadata = { "offset" : _create_calc_scalar_standard_deviation_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_standard_deviation(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the standard deviation of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_standard_deviation_metadata, name, description, OutArg())

    _create_calc_scalar_point_in_volume_calc_metadata = { "offset" : _create_calc_scalar_point_in_volume_calc_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_point_in_volume_calc(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation along trajectory."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_point_in_volume_calc_metadata, name, description, OutArg())

    _create_calc_scalar_custom_inline_script_metadata = { "offset" : _create_calc_scalar_custom_inline_script_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_calc_scalar_custom_inline_script(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a custom inline script scalar."""
        return self._intf.invoke(CalculationToolScalarFactory._metadata, CalculationToolScalarFactory._create_calc_scalar_custom_inline_script_metadata, name, description, OutArg())

    _property_names[available_calc_scalar_plugin_display_names] = "available_calc_scalar_plugin_display_names"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarFactory, [CalculationToolScalarFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5603183957251412242, 16723870511898521754), CalculationToolScalarFactory)
agcls.AgTypeNameMap["CalculationToolScalarFactory"] = CalculationToolScalarFactory

class CalculationToolScalarFile(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filename_method_offset = 1
    _set_filename_method_offset = 2
    _reload_method_offset = 3
    _get_file_span_method_offset = 4
    _get_file_interpolation_type_method_offset = 5
    _set_file_interpolation_type_method_offset = 6
    _get_file_interpolation_order_method_offset = 7
    _set_file_interpolation_order_method_offset = 8
    _get_use_native_file_interpolation_settings_method_offset = 9
    _set_use_native_file_interpolation_settings_method_offset = 10
    _metadata = {
        "iid_data" : (5153202141983971278, 8810191830175553723),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarFile)
    
    _get_filename_metadata = { "offset" : _get_filename_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def filename(self) -> str:
        """The path to an ASCII file with .csc extension."""
        return self._intf.get_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._get_filename_metadata)

    _set_filename_metadata = { "offset" : _set_filename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._set_filename_metadata, filename)

    _reload_metadata = { "offset" : _reload_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the file specified with Filename property."""
        return self._intf.invoke(CalculationToolScalarFile._metadata, CalculationToolScalarFile._reload_metadata, )

    _get_file_span_metadata = { "offset" : _get_file_span_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_file_span(self) -> "TimeToolEventIntervalResult":
        """Compute the interval time span of the file."""
        return self._intf.invoke(CalculationToolScalarFile._metadata, CalculationToolScalarFile._get_file_span_metadata, OutArg())

    _get_file_interpolation_type_metadata = { "offset" : _get_file_interpolation_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_FILE_INTERPOLATOR_TYPE),) }
    @property
    def file_interpolation_type(self) -> "CRDN_FILE_INTERPOLATOR_TYPE":
        """The interpolation method used with the data."""
        return self._intf.get_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._get_file_interpolation_type_metadata)

    _set_file_interpolation_type_metadata = { "offset" : _set_file_interpolation_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_FILE_INTERPOLATOR_TYPE),) }
    @file_interpolation_type.setter
    def file_interpolation_type(self, fileInterpolationType:"CRDN_FILE_INTERPOLATOR_TYPE") -> None:
        return self._intf.set_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._set_file_interpolation_type_metadata, fileInterpolationType)

    _get_file_interpolation_order_metadata = { "offset" : _get_file_interpolation_order_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def file_interpolation_order(self) -> int:
        """The interpolation order used with the interpolation method to interrogate the data."""
        return self._intf.get_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._get_file_interpolation_order_metadata)

    _set_file_interpolation_order_metadata = { "offset" : _set_file_interpolation_order_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @file_interpolation_order.setter
    def file_interpolation_order(self, fileInterpolationOrder:int) -> None:
        return self._intf.set_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._set_file_interpolation_order_metadata, fileInterpolationOrder)

    _get_use_native_file_interpolation_settings_metadata = { "offset" : _get_use_native_file_interpolation_settings_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_native_file_interpolation_settings(self) -> bool:
        """Flag indicating whether the interpolation method and order settings specified within the file, if any, will be honored."""
        return self._intf.get_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._get_use_native_file_interpolation_settings_metadata)

    _set_use_native_file_interpolation_settings_metadata = { "offset" : _set_use_native_file_interpolation_settings_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_native_file_interpolation_settings.setter
    def use_native_file_interpolation_settings(self, useNativeFileInterpolationSettings:bool) -> None:
        return self._intf.set_property(CalculationToolScalarFile._metadata, CalculationToolScalarFile._set_use_native_file_interpolation_settings_metadata, useNativeFileInterpolationSettings)

    _property_names[filename] = "filename"
    _property_names[file_interpolation_type] = "file_interpolation_type"
    _property_names[file_interpolation_order] = "file_interpolation_order"
    _property_names[use_native_file_interpolation_settings] = "use_native_file_interpolation_settings"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarFile."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarFile)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarFile, [CalculationToolScalarFile, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5148097650078253983, 10233293468354629821), CalculationToolScalarFile)
agcls.AgTypeNameMap["CalculationToolScalarFile"] = CalculationToolScalarFile

class CalculationToolScalarFixedAtTimeInstant(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_scalar_method_offset = 1
    _set_input_scalar_method_offset = 2
    _get_reference_time_instant_method_offset = 3
    _set_reference_time_instant_method_offset = 4
    _metadata = {
        "iid_data" : (5116980743969883807, 14308846120555093929),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarFixedAtTimeInstant)
    
    _get_input_scalar_metadata = { "offset" : _get_input_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar component."""
        return self._intf.get_property(CalculationToolScalarFixedAtTimeInstant._metadata, CalculationToolScalarFixedAtTimeInstant._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "offset" : _set_input_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarFixedAtTimeInstant._metadata, CalculationToolScalarFixedAtTimeInstant._set_input_scalar_metadata, inputScalar)

    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(CalculationToolScalarFixedAtTimeInstant._metadata, CalculationToolScalarFixedAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(CalculationToolScalarFixedAtTimeInstant._metadata, CalculationToolScalarFixedAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)

    _property_names[input_scalar] = "input_scalar"
    _property_names[reference_time_instant] = "reference_time_instant"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarFixedAtTimeInstant."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarFixedAtTimeInstant)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarFixedAtTimeInstant, [CalculationToolScalarFixedAtTimeInstant, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4932699577219865707, 13915785772631940010), CalculationToolScalarFixedAtTimeInstant)
agcls.AgTypeNameMap["CalculationToolScalarFixedAtTimeInstant"] = CalculationToolScalarFixedAtTimeInstant

class CalculationToolScalarFunction(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by performing the specified function on the input scalar or time instant."""

    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_use_scalar_method_offset = 1
    _set_use_scalar_method_offset = 2
    _get_input_scalar_method_offset = 3
    _set_input_scalar_method_offset = 4
    _get_input_time_method_offset = 5
    _set_input_time_method_offset = 6
    _get_input_unit_method_offset = 7
    _set_input_unit_method_offset = 8
    _get_a_method_offset = 9
    _set_a_method_offset = 10
    _get_b_method_offset = 11
    _set_b_method_offset = 12
    _get_c_method_offset = 13
    _set_c_method_offset = 14
    _get_d_method_offset = 15
    _set_d_method_offset = 16
    _get_coefficients_method_offset = 17
    _set_coefficients_method_offset = 18
    _get_selected_function_method_offset = 19
    _set_selected_function_method_offset = 20
    _get_available_functions_method_offset = 21
    _get_inherit_dimension_from_input_method_offset = 22
    _set_inherit_dimension_from_input_method_offset = 23
    _get_output_dimension_method_offset = 24
    _set_output_dimension_method_offset = 25
    _get_output_unit_method_offset = 26
    _set_output_unit_method_offset = 27
    _get_sampling_method_offset = 28
    _set_sampling_method_offset = 29
    _get_convergence_method_offset = 30
    _set_convergence_method_offset = 31
    _metadata = {
        "iid_data" : (5290175361666189224, 17475337594760058546),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarFunction)
    
    _get_use_scalar_metadata = { "offset" : _get_use_scalar_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_scalar(self) -> bool:
        """Specify whether to use the input scalar calculation or the time elapsed from the input time instant. Set to true to use the scalar."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_use_scalar_metadata)

    _set_use_scalar_metadata = { "offset" : _set_use_scalar_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_scalar.setter
    def use_scalar(self, useScalar:bool) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_use_scalar_metadata, useScalar)

    _get_input_scalar_metadata = { "offset" : _get_input_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation (used if UseScalar is true). The UseScalar property should be set to true before this property can be set."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "offset" : _set_input_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_input_scalar_metadata, inputScalar)

    _get_input_time_metadata = { "offset" : _get_input_time_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_time(self) -> "ITimeToolEvent":
        """The input time instant (used if UseScalar is false)."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_input_time_metadata)

    _set_input_time_metadata = { "offset" : _set_input_time_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @input_time.setter
    def input_time(self, inputTime:"ITimeToolEvent") -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_input_time_metadata, inputTime)

    _get_input_unit_metadata = { "offset" : _get_input_unit_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def input_unit(self) -> str:
        """The input time unit to interpret input time."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_input_unit_metadata)

    _set_input_unit_metadata = { "offset" : _set_input_unit_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @input_unit.setter
    def input_unit(self, inputUnit:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_input_unit_metadata, inputUnit)

    _get_a_metadata = { "offset" : _get_a_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def a(self) -> float:
        """The constant coefficient A."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_a_metadata)

    _set_a_metadata = { "offset" : _set_a_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @a.setter
    def a(self, a:float) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_a_metadata, a)

    _get_b_metadata = { "offset" : _get_b_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def b(self) -> float:
        """The constant coefficient B."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_b_metadata)

    _set_b_metadata = { "offset" : _set_b_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @b.setter
    def b(self, b:float) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_b_metadata, b)

    _get_c_metadata = { "offset" : _get_c_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def c(self) -> float:
        """The constant coefficient C."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_c_metadata)

    _set_c_metadata = { "offset" : _set_c_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @c.setter
    def c(self, c:float) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_c_metadata, c)

    _get_d_metadata = { "offset" : _get_d_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def d(self) -> float:
        """The constant coefficient D."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_d_metadata)

    _set_d_metadata = { "offset" : _set_d_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @d.setter
    def d(self, d:float) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_d_metadata, d)

    _get_coefficients_metadata = { "offset" : _get_coefficients_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def coefficients(self) -> list:
        """The array of constant coefficients, whose dimension and units are determined by those of input and output."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_coefficients_metadata)

    _set_coefficients_metadata = { "offset" : _set_coefficients_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @coefficients.setter
    def coefficients(self, coefficients:list) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_coefficients_metadata, coefficients)

    _get_selected_function_metadata = { "offset" : _get_selected_function_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def selected_function(self) -> str:
        """The function which will use the input scalar or time instant in some combination with the constant coefficients A, B, C, D."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_selected_function_metadata)

    _set_selected_function_metadata = { "offset" : _set_selected_function_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @selected_function.setter
    def selected_function(self, selectedFunction:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_selected_function_metadata, selectedFunction)

    _get_available_functions_metadata = { "offset" : _get_available_functions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_functions(self) -> list:
        """Get the available function names."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_available_functions_metadata)

    _get_inherit_dimension_from_input_metadata = { "offset" : _get_inherit_dimension_from_input_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def inherit_dimension_from_input(self) -> bool:
        """Specify whether to inherit the output dimension from the input scalar or time instant."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_inherit_dimension_from_input_metadata)

    _set_inherit_dimension_from_input_metadata = { "offset" : _set_inherit_dimension_from_input_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @inherit_dimension_from_input.setter
    def inherit_dimension_from_input(self, inheritDimensionFromInput:bool) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_inherit_dimension_from_input_metadata, inheritDimensionFromInput)

    _get_output_dimension_metadata = { "offset" : _get_output_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def output_dimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if InheritDimensionFromInput is false. The InheritDimensionFromInput property should be set to false before this property can be fixed."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "offset" : _set_output_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_output_dimension_metadata, outputDimension)

    _get_output_unit_metadata = { "offset" : _get_output_unit_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def output_unit(self) -> str:
        """Specify a unit for the selected output dimension. This is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_output_unit_metadata)

    _set_output_unit_metadata = { "offset" : _set_output_unit_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @output_unit.setter
    def output_unit(self, outputUnit:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_output_unit_metadata, outputUnit)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "offset" : _get_convergence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._get_convergence_metadata)

    _set_convergence_metadata = { "offset" : _set_convergence_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(CalculationToolScalarFunction._metadata, CalculationToolScalarFunction._set_convergence_metadata, convergence)

    _property_names[use_scalar] = "use_scalar"
    _property_names[input_scalar] = "input_scalar"
    _property_names[input_time] = "input_time"
    _property_names[input_unit] = "input_unit"
    _property_names[a] = "a"
    _property_names[b] = "b"
    _property_names[c] = "c"
    _property_names[d] = "d"
    _property_names[coefficients] = "coefficients"
    _property_names[selected_function] = "selected_function"
    _property_names[available_functions] = "available_functions"
    _property_names[inherit_dimension_from_input] = "inherit_dimension_from_input"
    _property_names[output_dimension] = "output_dimension"
    _property_names[output_unit] = "output_unit"
    _property_names[sampling] = "sampling"
    _property_names[convergence] = "convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarFunction."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarFunction)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarFunction, [CalculationToolScalarFunction, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4712789712859139993, 16973698019291607179), CalculationToolScalarFunction)
agcls.AgTypeNameMap["CalculationToolScalarFunction"] = CalculationToolScalarFunction

class CalculationToolScalarFunction2Var(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by performing a function(x,y) on two scalar arguments."""

    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_x_method_offset = 1
    _set_x_method_offset = 2
    _get_unit_x_method_offset = 3
    _set_unit_x_method_offset = 4
    _get_a_method_offset = 5
    _set_a_method_offset = 6
    _get_y_method_offset = 7
    _set_y_method_offset = 8
    _get_unit_y_method_offset = 9
    _set_unit_y_method_offset = 10
    _get_b_method_offset = 11
    _set_b_method_offset = 12
    _get_c_method_offset = 13
    _set_c_method_offset = 14
    _get_output_dimension_inheritance_method_offset = 15
    _set_output_dimension_inheritance_method_offset = 16
    _get_output_dimension_method_offset = 17
    _set_output_dimension_method_offset = 18
    _get_available_functions_method_offset = 19
    _get_selected_function_method_offset = 20
    _set_selected_function_method_offset = 21
    _get_output_unit_method_offset = 22
    _set_output_unit_method_offset = 23
    _metadata = {
        "iid_data" : (5385933067987517982, 1513144451347807877),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarFunction2Var)
    
    _get_x_metadata = { "offset" : _get_x_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x(self) -> "ICalculationToolScalar":
        """The scalar argument X."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_x_metadata)

    _set_x_metadata = { "offset" : _set_x_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @x.setter
    def x(self, x:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_x_metadata, x)

    _get_unit_x_metadata = { "offset" : _get_unit_x_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def unit_x(self) -> str:
        """The unit used to interpret numerical values of scalar argument X."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_unit_x_metadata)

    _set_unit_x_metadata = { "offset" : _set_unit_x_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @unit_x.setter
    def unit_x(self, unitX:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_unit_x_metadata, unitX)

    _get_a_metadata = { "offset" : _get_a_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def a(self) -> float:
        """The constant coefficient A."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_a_metadata)

    _set_a_metadata = { "offset" : _set_a_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @a.setter
    def a(self, a:float) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_a_metadata, a)

    _get_y_metadata = { "offset" : _get_y_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y(self) -> "ICalculationToolScalar":
        """The scalar argument Y."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_y_metadata)

    _set_y_metadata = { "offset" : _set_y_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @y.setter
    def y(self, y:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_y_metadata, y)

    _get_unit_y_metadata = { "offset" : _get_unit_y_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def unit_y(self) -> str:
        """The unit used to interpret numerical values of scalar argument Y."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_unit_y_metadata)

    _set_unit_y_metadata = { "offset" : _set_unit_y_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @unit_y.setter
    def unit_y(self, unitY:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_unit_y_metadata, unitY)

    _get_b_metadata = { "offset" : _get_b_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def b(self) -> float:
        """The constant coefficient B."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_b_metadata)

    _set_b_metadata = { "offset" : _set_b_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @b.setter
    def b(self, b:float) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_b_metadata, b)

    _get_c_metadata = { "offset" : _get_c_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def c(self) -> float:
        """The constant coefficient C."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_c_metadata)

    _set_c_metadata = { "offset" : _set_c_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @c.setter
    def c(self, c:float) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_c_metadata, c)

    _get_output_dimension_inheritance_metadata = { "offset" : _get_output_dimension_inheritance_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIMENSION_INHERITANCE),) }
    @property
    def output_dimension_inheritance(self) -> "CRDN_DIMENSION_INHERITANCE":
        """Specify whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_output_dimension_inheritance_metadata)

    _set_output_dimension_inheritance_metadata = { "offset" : _set_output_dimension_inheritance_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIMENSION_INHERITANCE),) }
    @output_dimension_inheritance.setter
    def output_dimension_inheritance(self, outputDimensionInheritance:"CRDN_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_output_dimension_inheritance_metadata, outputDimensionInheritance)

    _get_output_dimension_metadata = { "offset" : _get_output_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def output_dimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if OutputDimensionInheritance is false."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "offset" : _set_output_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_output_dimension_metadata, outputDimension)

    _get_available_functions_metadata = { "offset" : _get_available_functions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_functions(self) -> list:
        """The available functions. A function(x,y) uses some combination of two scalar arguments x and y as well as one to three constant coefficients a, b, c."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_available_functions_metadata)

    _get_selected_function_metadata = { "offset" : _get_selected_function_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def selected_function(self) -> str:
        """The selected function."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_selected_function_metadata)

    _set_selected_function_metadata = { "offset" : _set_selected_function_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @selected_function.setter
    def selected_function(self, selectedFunction:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_selected_function_metadata, selectedFunction)

    _get_output_unit_metadata = { "offset" : _get_output_unit_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def output_unit(self) -> str:
        """The unit for the selected dimension. The unit is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        return self._intf.get_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._get_output_unit_metadata)

    _set_output_unit_metadata = { "offset" : _set_output_unit_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @output_unit.setter
    def output_unit(self, outputUnit:str) -> None:
        return self._intf.set_property(CalculationToolScalarFunction2Var._metadata, CalculationToolScalarFunction2Var._set_output_unit_metadata, outputUnit)

    _property_names[x] = "x"
    _property_names[unit_x] = "unit_x"
    _property_names[a] = "a"
    _property_names[y] = "y"
    _property_names[unit_y] = "unit_y"
    _property_names[b] = "b"
    _property_names[c] = "c"
    _property_names[output_dimension_inheritance] = "output_dimension_inheritance"
    _property_names[output_dimension] = "output_dimension"
    _property_names[available_functions] = "available_functions"
    _property_names[selected_function] = "selected_function"
    _property_names[output_unit] = "output_unit"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarFunction2Var."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarFunction2Var)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarFunction2Var, [CalculationToolScalarFunction2Var, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4967368611246770084, 41349991072973977), CalculationToolScalarFunction2Var)
agcls.AgTypeNameMap["CalculationToolScalarFunction2Var"] = CalculationToolScalarFunction2Var

class CalculationToolScalarIntegral(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""

    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_scalar_method_offset = 1
    _set_input_scalar_method_offset = 2
    _get_compute_as_average_method_offset = 3
    _set_compute_as_average_method_offset = 4
    _get_integration_window_type_method_offset = 5
    _set_integration_window_type_method_offset = 6
    _get_start_offset_method_offset = 7
    _set_start_offset_method_offset = 8
    _get_stop_offset_method_offset = 9
    _set_stop_offset_method_offset = 10
    _get_use_custom_time_limits_method_offset = 11
    _set_use_custom_time_limits_method_offset = 12
    _get_custom_time_limits_method_offset = 13
    _set_custom_time_limits_method_offset = 14
    _get_save_data_option_method_offset = 15
    _set_save_data_option_method_offset = 16
    _get_interpolation_method_offset = 17
    _set_interpolation_method_offset = 18
    _get_sampling_method_offset = 19
    _set_sampling_method_offset = 20
    _get_integral_method_offset = 21
    _set_integral_method_offset = 22
    _get_keep_constant_outside_time_limits_method_offset = 23
    _set_keep_constant_outside_time_limits_method_offset = 24
    _set_offsets_method_offset = 25
    _metadata = {
        "iid_data" : (5056256084423666488, 2219291357061330108),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarIntegral)
    
    _get_input_scalar_metadata = { "offset" : _get_input_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "offset" : _set_input_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_input_scalar_metadata, inputScalar)

    _get_compute_as_average_metadata = { "offset" : _get_compute_as_average_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def compute_as_average(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_compute_as_average_metadata)

    _set_compute_as_average_metadata = { "offset" : _set_compute_as_average_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @compute_as_average.setter
    def compute_as_average(self, computeAsAverage:bool) -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_compute_as_average_metadata, computeAsAverage)

    _get_integration_window_type_metadata = { "offset" : _get_integration_window_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @property
    def integration_window_type(self) -> "CRDN_INTEGRATION_WINDOW_TYPE":
        """The integration window, or accumulation, type."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_integration_window_type_metadata)

    _set_integration_window_type_metadata = { "offset" : _set_integration_window_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @integration_window_type.setter
    def integration_window_type(self, integrationWindowType:"CRDN_INTEGRATION_WINDOW_TYPE") -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_integration_window_type_metadata, integrationWindowType)

    _get_start_offset_metadata = { "offset" : _get_start_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def start_offset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_start_offset_metadata)

    _set_start_offset_metadata = { "offset" : _set_start_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "offset" : _get_stop_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def stop_offset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "offset" : _set_stop_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_stop_offset_metadata, stopOffset)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_custom_time_limits_metadata, customTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_save_data_option_metadata, saveDataOption)

    _get_interpolation_metadata = { "offset" : _get_interpolation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_interpolation_metadata)

    _set_interpolation_metadata = { "offset" : _set_interpolation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchInterp"),) }
    @interpolation.setter
    def interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_interpolation_metadata, interpolation)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_sampling_metadata, sampling)

    _get_integral_metadata = { "offset" : _get_integral_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def integral(self) -> "IAnalysisWorkbenchIntegral":
        """The numerical integration method."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_integral_metadata)

    _set_integral_metadata = { "offset" : _set_integral_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchIntegral"),) }
    @integral.setter
    def integral(self, integral:"IAnalysisWorkbenchIntegral") -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_integral_metadata, integral)

    _get_keep_constant_outside_time_limits_metadata = { "offset" : _get_keep_constant_outside_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def keep_constant_outside_time_limits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        return self._intf.get_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._get_keep_constant_outside_time_limits_metadata)

    _set_keep_constant_outside_time_limits_metadata = { "offset" : _set_keep_constant_outside_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @keep_constant_outside_time_limits.setter
    def keep_constant_outside_time_limits(self, keepConstantOutsideTimeLimits:bool) -> None:
        return self._intf.set_property(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_keep_constant_outside_time_limits_metadata, keepConstantOutsideTimeLimits)

    _set_offsets_metadata = { "offset" : _set_offsets_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg,) }
    def set_offsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.invoke(CalculationToolScalarIntegral._metadata, CalculationToolScalarIntegral._set_offsets_metadata, startOffset, stopOffset)

    _property_names[input_scalar] = "input_scalar"
    _property_names[compute_as_average] = "compute_as_average"
    _property_names[integration_window_type] = "integration_window_type"
    _property_names[start_offset] = "start_offset"
    _property_names[stop_offset] = "stop_offset"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[interpolation] = "interpolation"
    _property_names[sampling] = "sampling"
    _property_names[integral] = "integral"
    _property_names[keep_constant_outside_time_limits] = "keep_constant_outside_time_limits"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarIntegral."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarIntegral)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarIntegral, [CalculationToolScalarIntegral, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5398899900186130554, 246171721776597151), CalculationToolScalarIntegral)
agcls.AgTypeNameMap["CalculationToolScalarIntegral"] = CalculationToolScalarIntegral

class CalculationToolScalarPlugin(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Use a scalar calculation plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_prog_id_method_offset = 1
    _get_display_name_method_offset = 2
    _get_available_properties_method_offset = 3
    _reset_method_offset = 4
    _set_property_method_offset = 5
    _get_property_method_offset = 6
    _metadata = {
        "iid_data" : (4827675994189541692, 5493812121129913759),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarPlugin)
    
    _get_prog_id_metadata = { "offset" : _get_prog_id_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(CalculationToolScalarPlugin._metadata, CalculationToolScalarPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "offset" : _get_display_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def display_name(self) -> str:
        """The plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(CalculationToolScalarPlugin._metadata, CalculationToolScalarPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "offset" : _get_available_properties_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(CalculationToolScalarPlugin._metadata, CalculationToolScalarPlugin._get_available_properties_metadata)

    _reset_metadata = { "offset" : _reset_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(CalculationToolScalarPlugin._metadata, CalculationToolScalarPlugin._reset_metadata, )

    _set_property_metadata = { "offset" : _set_property_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def set_property(self, name:str, value:str) -> None:
        """Set the plugin properties. This method throws an exception if the specified property does not exist, an invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(CalculationToolScalarPlugin._metadata, CalculationToolScalarPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "offset" : _get_property_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def get_property(self, name:str) -> str:
        """Read a value of the specified plugin property. This method throws an exception if the property does not exist."""
        return self._intf.invoke(CalculationToolScalarPlugin._metadata, CalculationToolScalarPlugin._get_property_metadata, name, OutArg())

    _property_names[prog_id] = "prog_id"
    _property_names[display_name] = "display_name"
    _property_names[available_properties] = "available_properties"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarPlugin."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarPlugin)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarPlugin, [CalculationToolScalarPlugin, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5691400509382320907, 9517433290752141957), CalculationToolScalarPlugin)
agcls.AgTypeNameMap["CalculationToolScalarPlugin"] = CalculationToolScalarPlugin

class CalculationToolScalarPointInVolumeCalc(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Scalar value of spatial calculation evaluated along trajectory of point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_trajectory_point_method_offset = 1
    _set_trajectory_point_method_offset = 2
    _get_spatial_calculation_method_offset = 3
    _set_spatial_calculation_method_offset = 4
    _metadata = {
        "iid_data" : (5169596386408591497, 10944394653958111876),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarPointInVolumeCalc)
    
    _get_trajectory_point_metadata = { "offset" : _get_trajectory_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def trajectory_point(self) -> "IVectorGeometryToolPoint":
        """Trajectory point."""
        return self._intf.get_property(CalculationToolScalarPointInVolumeCalc._metadata, CalculationToolScalarPointInVolumeCalc._get_trajectory_point_metadata)

    _set_trajectory_point_metadata = { "offset" : _set_trajectory_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @trajectory_point.setter
    def trajectory_point(self, trajectoryPoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(CalculationToolScalarPointInVolumeCalc._metadata, CalculationToolScalarPointInVolumeCalc._set_trajectory_point_metadata, trajectoryPoint)

    _get_spatial_calculation_metadata = { "offset" : _get_spatial_calculation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def spatial_calculation(self) -> "ISpatialAnalysisToolVolumeCalc":
        """Spatial Calculation."""
        return self._intf.get_property(CalculationToolScalarPointInVolumeCalc._metadata, CalculationToolScalarPointInVolumeCalc._get_spatial_calculation_metadata)

    _set_spatial_calculation_metadata = { "offset" : _set_spatial_calculation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolumeCalc"),) }
    @spatial_calculation.setter
    def spatial_calculation(self, spatialCalculation:"ISpatialAnalysisToolVolumeCalc") -> None:
        return self._intf.set_property(CalculationToolScalarPointInVolumeCalc._metadata, CalculationToolScalarPointInVolumeCalc._set_spatial_calculation_metadata, spatialCalculation)

    _property_names[trajectory_point] = "trajectory_point"
    _property_names[spatial_calculation] = "spatial_calculation"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarPointInVolumeCalc."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarPointInVolumeCalc)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarPointInVolumeCalc, [CalculationToolScalarPointInVolumeCalc, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4648048658061411939, 12881727305934950065), CalculationToolScalarPointInVolumeCalc)
agcls.AgTypeNameMap["CalculationToolScalarPointInVolumeCalc"] = CalculationToolScalarPointInVolumeCalc

class CalculationToolScalarStandardDeviation(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""

    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_scalar_method_offset = 1
    _set_input_scalar_method_offset = 2
    _get_compute_as_average_method_offset = 3
    _set_compute_as_average_method_offset = 4
    _get_integration_window_type_method_offset = 5
    _set_integration_window_type_method_offset = 6
    _get_start_offset_method_offset = 7
    _set_start_offset_method_offset = 8
    _get_stop_offset_method_offset = 9
    _set_stop_offset_method_offset = 10
    _get_use_custom_time_limits_method_offset = 11
    _set_use_custom_time_limits_method_offset = 12
    _get_custom_time_limits_method_offset = 13
    _set_custom_time_limits_method_offset = 14
    _get_save_data_option_method_offset = 15
    _set_save_data_option_method_offset = 16
    _get_interpolation_method_offset = 17
    _set_interpolation_method_offset = 18
    _get_sampling_method_offset = 19
    _set_sampling_method_offset = 20
    _get_integral_method_offset = 21
    _set_integral_method_offset = 22
    _get_keep_constant_outside_time_limits_method_offset = 23
    _set_keep_constant_outside_time_limits_method_offset = 24
    _set_offsets_method_offset = 25
    _metadata = {
        "iid_data" : (4867937565024961078, 7959695188043257759),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarStandardDeviation)
    
    _get_input_scalar_metadata = { "offset" : _get_input_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "offset" : _set_input_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_input_scalar_metadata, inputScalar)

    _get_compute_as_average_metadata = { "offset" : _get_compute_as_average_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def compute_as_average(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate StandardDeviation value instead of integral."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_compute_as_average_metadata)

    _set_compute_as_average_metadata = { "offset" : _set_compute_as_average_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @compute_as_average.setter
    def compute_as_average(self, computeAsAverage:bool) -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_compute_as_average_metadata, computeAsAverage)

    _get_integration_window_type_metadata = { "offset" : _get_integration_window_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @property
    def integration_window_type(self) -> "CRDN_INTEGRATION_WINDOW_TYPE":
        """The integration window, or accumulation, type."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_integration_window_type_metadata)

    _set_integration_window_type_metadata = { "offset" : _set_integration_window_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @integration_window_type.setter
    def integration_window_type(self, integrationWindowType:"CRDN_INTEGRATION_WINDOW_TYPE") -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_integration_window_type_metadata, integrationWindowType)

    _get_start_offset_metadata = { "offset" : _get_start_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def start_offset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_start_offset_metadata)

    _set_start_offset_metadata = { "offset" : _set_start_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "offset" : _get_stop_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def stop_offset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "offset" : _set_stop_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_stop_offset_metadata, stopOffset)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_custom_time_limits_metadata, customTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_save_data_option_metadata, saveDataOption)

    _get_interpolation_metadata = { "offset" : _get_interpolation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_interpolation_metadata)

    _set_interpolation_metadata = { "offset" : _set_interpolation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchInterp"),) }
    @interpolation.setter
    def interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_interpolation_metadata, interpolation)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_sampling_metadata, sampling)

    _get_integral_metadata = { "offset" : _get_integral_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def integral(self) -> "IAnalysisWorkbenchIntegral":
        """The numerical integration method."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_integral_metadata)

    _set_integral_metadata = { "offset" : _set_integral_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchIntegral"),) }
    @integral.setter
    def integral(self, integral:"IAnalysisWorkbenchIntegral") -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_integral_metadata, integral)

    _get_keep_constant_outside_time_limits_metadata = { "offset" : _get_keep_constant_outside_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def keep_constant_outside_time_limits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        return self._intf.get_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._get_keep_constant_outside_time_limits_metadata)

    _set_keep_constant_outside_time_limits_metadata = { "offset" : _set_keep_constant_outside_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @keep_constant_outside_time_limits.setter
    def keep_constant_outside_time_limits(self, keepConstantOutsideTimeLimits:bool) -> None:
        return self._intf.set_property(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_keep_constant_outside_time_limits_metadata, keepConstantOutsideTimeLimits)

    _set_offsets_metadata = { "offset" : _set_offsets_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg,) }
    def set_offsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.invoke(CalculationToolScalarStandardDeviation._metadata, CalculationToolScalarStandardDeviation._set_offsets_metadata, startOffset, stopOffset)

    _property_names[input_scalar] = "input_scalar"
    _property_names[compute_as_average] = "compute_as_average"
    _property_names[integration_window_type] = "integration_window_type"
    _property_names[start_offset] = "start_offset"
    _property_names[stop_offset] = "stop_offset"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[interpolation] = "interpolation"
    _property_names[sampling] = "sampling"
    _property_names[integral] = "integral"
    _property_names[keep_constant_outside_time_limits] = "keep_constant_outside_time_limits"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarStandardDeviation."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarStandardDeviation)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarStandardDeviation, [CalculationToolScalarStandardDeviation, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4728970761222061821, 15128931790916762790), CalculationToolScalarStandardDeviation)
agcls.AgTypeNameMap["CalculationToolScalarStandardDeviation"] = CalculationToolScalarStandardDeviation

class CalculationToolScalarSurfaceDistanceBetweenPoints(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_point1_method_offset = 1
    _set_point1_method_offset = 2
    _get_point2_method_offset = 3
    _set_point2_method_offset = 4
    _get_surface_central_body_method_offset = 5
    _set_surface_central_body_method_offset = 6
    _get_differencing_time_step_method_offset = 7
    _set_differencing_time_step_method_offset = 8
    _metadata = {
        "iid_data" : (5659354710283125094, 1259219978826109078),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarSurfaceDistanceBetweenPoints)
    
    _get_point1_metadata = { "offset" : _get_point1_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point1(self) -> "IVectorGeometryToolPoint":
        """Starting point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        return self._intf.get_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._get_point1_metadata)

    _set_point1_metadata = { "offset" : _set_point1_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @point1.setter
    def point1(self, point1:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._set_point1_metadata, point1)

    _get_point2_metadata = { "offset" : _get_point2_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point2(self) -> "IVectorGeometryToolPoint":
        """Terminating point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        return self._intf.get_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._get_point2_metadata)

    _set_point2_metadata = { "offset" : _set_point2_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @point2.setter
    def point2(self, point2:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._set_point2_metadata, point2)

    _get_surface_central_body_metadata = { "offset" : _get_surface_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def surface_central_body(self) -> str:
        """Central body on which the surface distance between points is to be calculated."""
        return self._intf.get_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._get_surface_central_body_metadata)

    _set_surface_central_body_metadata = { "offset" : _set_surface_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @surface_central_body.setter
    def surface_central_body(self, surfaceCentralBody:str) -> None:
        return self._intf.set_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._set_surface_central_body_metadata, surfaceCentralBody)

    _get_differencing_time_step_metadata = { "offset" : _get_differencing_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of scalar calculation time rate of change (derivatives using central differencing)."""
        return self._intf.get_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "offset" : _set_differencing_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(CalculationToolScalarSurfaceDistanceBetweenPoints._metadata, CalculationToolScalarSurfaceDistanceBetweenPoints._set_differencing_time_step_metadata, differencingTimeStep)

    _property_names[point1] = "point1"
    _property_names[point2] = "point2"
    _property_names[surface_central_body] = "surface_central_body"
    _property_names[differencing_time_step] = "differencing_time_step"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarSurfaceDistanceBetweenPoints."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarSurfaceDistanceBetweenPoints)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarSurfaceDistanceBetweenPoints, [CalculationToolScalarSurfaceDistanceBetweenPoints, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5458481980404184200, 1068397851801295271), CalculationToolScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap["CalculationToolScalarSurfaceDistanceBetweenPoints"] = CalculationToolScalarSurfaceDistanceBetweenPoints

class CalculationToolScalarVectorComponent(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """The specified component of a vector when resolved in the specified axes."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_vector_method_offset = 1
    _set_input_vector_method_offset = 2
    _get_reference_axes_method_offset = 3
    _set_reference_axes_method_offset = 4
    _get_component_method_offset = 5
    _set_component_method_offset = 6
    _metadata = {
        "iid_data" : (5021364283583990465, 9706837447278064055),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarVectorComponent)
    
    _get_input_vector_metadata = { "offset" : _get_input_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_vector(self) -> "IVectorGeometryToolVector":
        """Vector."""
        return self._intf.get_property(CalculationToolScalarVectorComponent._metadata, CalculationToolScalarVectorComponent._get_input_vector_metadata)

    _set_input_vector_metadata = { "offset" : _set_input_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @input_vector.setter
    def input_vector(self, inputVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(CalculationToolScalarVectorComponent._metadata, CalculationToolScalarVectorComponent._set_input_vector_metadata, inputVector)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """Axes used to resolve the vector's components."""
        return self._intf.get_property(CalculationToolScalarVectorComponent._metadata, CalculationToolScalarVectorComponent._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "offset" : _set_reference_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(CalculationToolScalarVectorComponent._metadata, CalculationToolScalarVectorComponent._set_reference_axes_metadata, referenceAxes)

    _get_component_metadata = { "offset" : _get_component_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE),) }
    @property
    def component(self) -> "VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE":
        """The component of the vector to return as the value of the scalar."""
        return self._intf.get_property(CalculationToolScalarVectorComponent._metadata, CalculationToolScalarVectorComponent._get_component_metadata)

    _set_component_metadata = { "offset" : _set_component_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE),) }
    @component.setter
    def component(self, component:"VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE") -> None:
        return self._intf.set_property(CalculationToolScalarVectorComponent._metadata, CalculationToolScalarVectorComponent._set_component_metadata, component)

    _property_names[input_vector] = "input_vector"
    _property_names[reference_axes] = "reference_axes"
    _property_names[component] = "component"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarVectorComponent."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarVectorComponent)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarVectorComponent, [CalculationToolScalarVectorComponent, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5434681583091997855, 8195345628688496798), CalculationToolScalarVectorComponent)
agcls.AgTypeNameMap["CalculationToolScalarVectorComponent"] = CalculationToolScalarVectorComponent

class CalculationToolScalarVectorMagnitude(ICalculationToolScalar, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Scalar equal to the magnitude of a specified vector."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_vector_method_offset = 1
    _set_input_vector_method_offset = 2
    _metadata = {
        "iid_data" : (5342859323934275233, 16435141540105004707),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolScalarVectorMagnitude)
    
    _get_input_vector_metadata = { "offset" : _get_input_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_vector(self) -> "IVectorGeometryToolVector":
        """Specify any vector in VGT. Note that its magnitude is reference axes independent which is why it is not specified."""
        return self._intf.get_property(CalculationToolScalarVectorMagnitude._metadata, CalculationToolScalarVectorMagnitude._get_input_vector_metadata)

    _set_input_vector_metadata = { "offset" : _set_input_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @input_vector.setter
    def input_vector(self, inputVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(CalculationToolScalarVectorMagnitude._metadata, CalculationToolScalarVectorMagnitude._set_input_vector_metadata, inputVector)

    _property_names[input_vector] = "input_vector"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolScalarVectorMagnitude."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolScalarVectorMagnitude)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolScalarVectorMagnitude, [CalculationToolScalarVectorMagnitude, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5718680998699535592, 13838468874888393908), CalculationToolScalarVectorMagnitude)
agcls.AgTypeNameMap["CalculationToolScalarVectorMagnitude"] = CalculationToolScalarVectorMagnitude

class CalculationToolCondition(ICalculationToolCondition, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolCondition."""
        SupportsDeleteCallback.__init__(self)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolCondition, [ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4627729760611390020, 5273234787457922734), CalculationToolCondition)
agcls.AgTypeNameMap["CalculationToolCondition"] = CalculationToolCondition

class CalculationToolConditionCombined(ICalculationToolCondition, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Define a condition which combines multiple conditions."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_combine_operation_method_offset = 1
    _set_combine_operation_method_offset = 2
    _get_condition_count_method_offset = 3
    _get_all_conditions_method_offset = 4
    _set_all_conditions_method_offset = 5
    _get_condition_method_offset = 6
    _set_condition_method_offset = 7
    _remove_condition_method_offset = 8
    _add_condition_method_offset = 9
    _metadata = {
        "iid_data" : (5384348199380707650, 11046299175776141490),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionCombined)
    
    _get_combine_operation_metadata = { "offset" : _get_combine_operation_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_COMBINED_OPERATION_TYPE),) }
    @property
    def combine_operation(self) -> "CRDN_CONDITION_COMBINED_OPERATION_TYPE":
        """Get the operation from the condition that determines how the conditions are combined. The operation can be set to AND, OR, XOR, MINUS."""
        return self._intf.get_property(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._get_combine_operation_metadata)

    _set_combine_operation_metadata = { "offset" : _set_combine_operation_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_COMBINED_OPERATION_TYPE),) }
    @combine_operation.setter
    def combine_operation(self, combineOperation:"CRDN_CONDITION_COMBINED_OPERATION_TYPE") -> None:
        return self._intf.set_property(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._set_combine_operation_metadata, combineOperation)

    _get_condition_count_metadata = { "offset" : _get_condition_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def condition_count(self) -> int:
        """Get the number of conditions in the combined condition."""
        return self._intf.get_property(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._get_condition_count_metadata)

    _get_all_conditions_metadata = { "offset" : _get_all_conditions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def get_all_conditions(self) -> list:
        """Get all conditions that are being combined."""
        return self._intf.invoke(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._get_all_conditions_metadata, OutArg())

    _set_all_conditions_metadata = { "offset" : _set_all_conditions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_all_conditions(self, conditions:list) -> None:
        """Set all conditions to be combined."""
        return self._intf.invoke(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._set_all_conditions_metadata, conditions)

    _get_condition_metadata = { "offset" : _get_condition_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_condition(self, pos:int) -> "ICalculationToolCondition":
        """Get the condition at the position specified."""
        return self._intf.invoke(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._get_condition_metadata, pos, OutArg())

    _set_condition_metadata = { "offset" : _set_condition_method_offset,
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolCondition"), agmarshall.IntArg,) }
    def set_condition(self, ref:"ICalculationToolCondition", pos:int) -> None:
        """Set the condition at the position specified."""
        return self._intf.invoke(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._set_condition_metadata, ref, pos)

    _remove_condition_metadata = { "offset" : _remove_condition_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    def remove_condition(self, pos:int) -> None:
        """Remove the condition at the position specified."""
        return self._intf.invoke(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._remove_condition_metadata, pos)

    _add_condition_metadata = { "offset" : _add_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolCondition"),) }
    def add_condition(self, ref:"ICalculationToolCondition") -> None:
        """Add a condition at the end of the list."""
        return self._intf.invoke(CalculationToolConditionCombined._metadata, CalculationToolConditionCombined._add_condition_metadata, ref)

    _property_names[combine_operation] = "combine_operation"
    _property_names[condition_count] = "condition_count"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionCombined."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionCombined)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionCombined, [CalculationToolConditionCombined, ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4767400244892944523, 13373757026237479857), CalculationToolConditionCombined)
agcls.AgTypeNameMap["CalculationToolConditionCombined"] = CalculationToolConditionCombined

class CalculationToolConditionFactory(SupportsDeleteCallback):
    """The factory creates condition components."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_condition_scalar_bounds_method_offset = 2
    _is_type_supported_method_offset = 3
    _create_condition_combined_method_offset = 4
    _create_condition_point_in_volume_method_offset = 5
    _metadata = {
        "iid_data" : (4908222899827327698, 13471708632999045260),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_CONDITION_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_CONDITION_TYPE") -> "ICalculationToolCondition":
        """Create and registers a condition using specified name, description and type."""
        return self._intf.invoke(CalculationToolConditionFactory._metadata, CalculationToolConditionFactory._create_metadata, name, description, type, OutArg())

    _create_condition_scalar_bounds_metadata = { "offset" : _create_condition_scalar_bounds_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_condition_scalar_bounds(self, name:str, description:str) -> "ICalculationToolCondition":
        """Create a condition placing bounds on specified scalar."""
        return self._intf.invoke(CalculationToolConditionFactory._metadata, CalculationToolConditionFactory._create_condition_scalar_bounds_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_CONDITION_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(CalculationToolConditionFactory._metadata, CalculationToolConditionFactory._is_type_supported_metadata, eType, OutArg())

    _create_condition_combined_metadata = { "offset" : _create_condition_combined_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_condition_combined(self, name:str, description:str) -> "ICalculationToolCondition":
        """Create a condition which combines multiple conditions."""
        return self._intf.invoke(CalculationToolConditionFactory._metadata, CalculationToolConditionFactory._create_condition_combined_metadata, name, description, OutArg())

    _create_condition_point_in_volume_metadata = { "offset" : _create_condition_point_in_volume_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_condition_point_in_volume(self, name:str, description:str) -> "ICalculationToolCondition":
        """Create a condition for point in volume."""
        return self._intf.invoke(CalculationToolConditionFactory._metadata, CalculationToolConditionFactory._create_condition_point_in_volume_metadata, name, description, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionFactory, [CalculationToolConditionFactory, ])

agcls.AgClassCatalog.add_catalog_entry((4995204375913048056, 16018337718719146118), CalculationToolConditionFactory)
agcls.AgTypeNameMap["CalculationToolConditionFactory"] = CalculationToolConditionFactory

class CalculationToolConditionPointInVolume(ICalculationToolCondition, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_point_method_offset = 1
    _set_point_method_offset = 2
    _get_constraint_method_offset = 3
    _set_constraint_method_offset = 4
    _metadata = {
        "iid_data" : (4990807610198674937, 11839537235231187358),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionPointInVolume)
    
    _get_point_metadata = { "offset" : _get_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point(self) -> "IVectorGeometryToolPoint":
        """Get the trajectory point from the condition."""
        return self._intf.get_property(CalculationToolConditionPointInVolume._metadata, CalculationToolConditionPointInVolume._get_point_metadata)

    _set_point_metadata = { "offset" : _set_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @point.setter
    def point(self, point:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(CalculationToolConditionPointInVolume._metadata, CalculationToolConditionPointInVolume._set_point_metadata, point)

    _get_constraint_metadata = { "offset" : _get_constraint_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def constraint(self) -> "ISpatialAnalysisToolVolume":
        """Get the volume constraint on trajectory point."""
        return self._intf.get_property(CalculationToolConditionPointInVolume._metadata, CalculationToolConditionPointInVolume._get_constraint_metadata)

    _set_constraint_metadata = { "offset" : _set_constraint_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolume"),) }
    @constraint.setter
    def constraint(self, constraint:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(CalculationToolConditionPointInVolume._metadata, CalculationToolConditionPointInVolume._set_constraint_metadata, constraint)

    _property_names[point] = "point"
    _property_names[constraint] = "constraint"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionPointInVolume."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionPointInVolume)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionPointInVolume, [CalculationToolConditionPointInVolume, ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4949089905743702745, 12125459046762185093), CalculationToolConditionPointInVolume)
agcls.AgTypeNameMap["CalculationToolConditionPointInVolume"] = CalculationToolConditionPointInVolume

class CalculationToolConditionScalarBounds(ICalculationToolCondition, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""

    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_scalar_method_offset = 1
    _set_scalar_method_offset = 2
    _get_operation_method_offset = 3
    _set_operation_method_offset = 4
    _get_minimum_method_offset = 5
    _set_minimum_method_offset = 6
    _get_maximum_method_offset = 7
    _set_maximum_method_offset = 8
    _set_method_offset = 9
    _get_minimum_unitless_method_offset = 10
    _set_minimum_unitless_method_offset = 11
    _get_maximum_unitless_method_offset = 12
    _set_maximum_unitless_method_offset = 13
    _set_unitless_method_offset = 14
    _metadata = {
        "iid_data" : (5118226098986923307, 15094161467708565122),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionScalarBounds)
    
    _get_scalar_metadata = { "offset" : _get_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """Get the scalar calculation from the condition."""
        return self._intf.get_property(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._get_scalar_metadata)

    _set_scalar_metadata = { "offset" : _set_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_scalar_metadata, scalar)

    _get_operation_metadata = { "offset" : _get_operation_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @property
    def operation(self) -> "CRDN_CONDITION_THRESHOLD_OPTION":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        return self._intf.get_property(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._get_operation_metadata)

    _set_operation_metadata = { "offset" : _set_operation_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @operation.setter
    def operation(self, operation:"CRDN_CONDITION_THRESHOLD_OPTION") -> None:
        return self._intf.set_property(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_operation_metadata, operation)

    _get_minimum_metadata = { "offset" : _get_minimum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_minimum(self) -> "Quantity":
        """Get the minimum bound value from the condition. Call SetMinimum to apply changes."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._get_minimum_metadata, OutArg())

    _set_minimum_metadata = { "offset" : _set_minimum_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"),) }
    def set_minimum(self, value:"Quantity") -> None:
        """Set the minimum bound value for the condition."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_minimum_metadata, value)

    _get_maximum_metadata = { "offset" : _get_maximum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_maximum(self) -> "Quantity":
        """Get the maximum bound value from the condition. Call SetMaximum to apply changes."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._get_maximum_metadata, OutArg())

    _set_maximum_metadata = { "offset" : _set_maximum_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"),) }
    def set_maximum(self, value:"Quantity") -> None:
        """Set the maximum bound value for the condition."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_maximum_metadata, value)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"), agmarshall.InterfaceInArg("Quantity"),) }
    def set(self, min:"Quantity", max:"Quantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_metadata, min, max)

    _get_minimum_unitless_metadata = { "offset" : _get_minimum_unitless_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    def get_minimum_unitless(self) -> float:
        """Get the unitless minimum bound value from the condition. Call SetMinimum to apply changes."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._get_minimum_unitless_metadata, OutArg())

    _set_minimum_unitless_metadata = { "offset" : _set_minimum_unitless_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    def set_minimum_unitless(self, value:float) -> None:
        """Set the unitless minimum bound value for the condition."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_minimum_unitless_metadata, value)

    _get_maximum_unitless_metadata = { "offset" : _get_maximum_unitless_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    def get_maximum_unitless(self) -> float:
        """Get the unitless maximum bound value from the condition. Call SetMaximum to apply changes."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._get_maximum_unitless_metadata, OutArg())

    _set_maximum_unitless_metadata = { "offset" : _set_maximum_unitless_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    def set_maximum_unitless(self, value:float) -> None:
        """Set the unitless maximum bound value for the condition."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_maximum_unitless_metadata, value)

    _set_unitless_metadata = { "offset" : _set_unitless_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg,) }
    def set_unitless(self, min:float, max:float) -> None:
        """Set the unitless min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(CalculationToolConditionScalarBounds._metadata, CalculationToolConditionScalarBounds._set_unitless_metadata, min, max)

    _property_names[scalar] = "scalar"
    _property_names[operation] = "operation"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionScalarBounds."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionScalarBounds)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionScalarBounds, [CalculationToolConditionScalarBounds, ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5647988579309068664, 11530525339333461889), CalculationToolConditionScalarBounds)
agcls.AgTypeNameMap["CalculationToolConditionScalarBounds"] = CalculationToolConditionScalarBounds

class CalculationToolConditionSet(ICalculationToolConditionSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionSet."""
        SupportsDeleteCallback.__init__(self)
        ICalculationToolConditionSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionSet, [ICalculationToolConditionSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5331250789123914523, 14006917373386840708), CalculationToolConditionSet)
agcls.AgTypeNameMap["CalculationToolConditionSet"] = CalculationToolConditionSet

class CalculationToolConditionSetFactory(SupportsDeleteCallback):
    """The factory creates condition set components."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_scalar_thresholds_method_offset = 2
    _is_type_supported_method_offset = 3
    _metadata = {
        "iid_data" : (4786678123302050092, 4967157609886676869),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionSetFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_CONDITION_SET_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_CONDITION_SET_TYPE") -> "ICalculationToolConditionSet":
        """Create and registers a condition set using specified name, description, and type."""
        return self._intf.invoke(CalculationToolConditionSetFactory._metadata, CalculationToolConditionSetFactory._create_metadata, name, description, type, OutArg())

    _create_scalar_thresholds_metadata = { "offset" : _create_scalar_thresholds_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_scalar_thresholds(self, name:str, description:str) -> "ICalculationToolConditionSet":
        """Create a scalar thresholds condition set."""
        return self._intf.invoke(CalculationToolConditionSetFactory._metadata, CalculationToolConditionSetFactory._create_scalar_thresholds_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_SET_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_CONDITION_SET_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(CalculationToolConditionSetFactory._metadata, CalculationToolConditionSetFactory._is_type_supported_metadata, eType, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionSetFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionSetFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionSetFactory, [CalculationToolConditionSetFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5012399328141270168, 11113123877685848731), CalculationToolConditionSetFactory)
agcls.AgTypeNameMap["CalculationToolConditionSetFactory"] = CalculationToolConditionSetFactory

class CalculationToolConditionSetScalarThresholds(ICalculationToolConditionSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Condition set based on single scalar calculation compared to set of threshold values."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_scalar_method_offset = 1
    _set_scalar_method_offset = 2
    _get_thresholds_method_offset = 3
    _get_threshold_labels_method_offset = 4
    _get_include_above_highest_threshold_method_offset = 5
    _set_include_above_highest_threshold_method_offset = 6
    _get_include_below_lowest_threshold_method_offset = 7
    _set_include_below_lowest_threshold_method_offset = 8
    _set_thresholds_and_labels_method_offset = 9
    _metadata = {
        "iid_data" : (5264840048988725368, 15687740403874149559),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConditionSetScalarThresholds)
    
    _get_scalar_metadata = { "offset" : _get_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        return self._intf.get_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._get_scalar_metadata)

    _set_scalar_metadata = { "offset" : _set_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._set_scalar_metadata, scalar)

    _get_thresholds_metadata = { "offset" : _get_thresholds_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def thresholds(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        return self._intf.get_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._get_thresholds_metadata)

    _get_threshold_labels_metadata = { "offset" : _get_threshold_labels_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def threshold_labels(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        return self._intf.get_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._get_threshold_labels_metadata)

    _get_include_above_highest_threshold_metadata = { "offset" : _get_include_above_highest_threshold_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def include_above_highest_threshold(self) -> bool:
        """The threshold indicates whether to include conditions above the highest threhsold."""
        return self._intf.get_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._get_include_above_highest_threshold_metadata)

    _set_include_above_highest_threshold_metadata = { "offset" : _set_include_above_highest_threshold_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @include_above_highest_threshold.setter
    def include_above_highest_threshold(self, includeAboveHighestThreshold:bool) -> None:
        return self._intf.set_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._set_include_above_highest_threshold_metadata, includeAboveHighestThreshold)

    _get_include_below_lowest_threshold_metadata = { "offset" : _get_include_below_lowest_threshold_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def include_below_lowest_threshold(self) -> bool:
        """The threshold indicates whether to include conditions below the lowest threhsolds."""
        return self._intf.get_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._get_include_below_lowest_threshold_metadata)

    _set_include_below_lowest_threshold_metadata = { "offset" : _set_include_below_lowest_threshold_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @include_below_lowest_threshold.setter
    def include_below_lowest_threshold(self, includeBelowLowestThreshold:bool) -> None:
        return self._intf.set_property(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._set_include_below_lowest_threshold_metadata, includeBelowLowestThreshold)

    _set_thresholds_and_labels_metadata = { "offset" : _set_thresholds_and_labels_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_thresholds_and_labels(self, thresholds:list, thresholdLabels:list) -> None:
        """Set thresholds and threshold labels."""
        return self._intf.invoke(CalculationToolConditionSetScalarThresholds._metadata, CalculationToolConditionSetScalarThresholds._set_thresholds_and_labels_metadata, thresholds, thresholdLabels)

    _property_names[scalar] = "scalar"
    _property_names[thresholds] = "thresholds"
    _property_names[threshold_labels] = "threshold_labels"
    _property_names[include_above_highest_threshold] = "include_above_highest_threshold"
    _property_names[include_below_lowest_threshold] = "include_below_lowest_threshold"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConditionSetScalarThresholds."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConditionSetScalarThresholds)
        ICalculationToolConditionSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConditionSetScalarThresholds, [CalculationToolConditionSetScalarThresholds, ICalculationToolConditionSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5572445424587947883, 5673353751277832377), CalculationToolConditionSetScalarThresholds)
agcls.AgTypeNameMap["CalculationToolConditionSetScalarThresholds"] = CalculationToolConditionSetScalarThresholds

class AnalysisWorkbenchConverge(IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Represents a base class for convergence definitions."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchConverge."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchConverge.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchConverge._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchConverge, [IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4882492916629755513, 15853984640358895501), AnalysisWorkbenchConverge)
agcls.AgTypeNameMap["AnalysisWorkbenchConverge"] = AnalysisWorkbenchConverge

class CalculationToolConvergeBasic(IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_sense_method_offset = 1
    _set_sense_method_offset = 2
    _get_time_tolerance_method_offset = 3
    _set_time_tolerance_method_offset = 4
    _get_absolute_tolerance_method_offset = 5
    _set_absolute_tolerance_method_offset = 6
    _get_relative_tolerance_method_offset = 7
    _set_relative_tolerance_method_offset = 8
    _metadata = {
        "iid_data" : (5085862782014627789, 13842813656478947762),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolConvergeBasic)
    
    _get_sense_metadata = { "offset" : _get_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_THRESH_CONVERGE_SENSE),) }
    @property
    def sense(self) -> "CRDN_THRESH_CONVERGE_SENSE":
        """Get the convergence sense which determines whether the converged value should be limited to just within or just outside of condition boundaries."""
        return self._intf.get_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._get_sense_metadata)

    _set_sense_metadata = { "offset" : _set_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_THRESH_CONVERGE_SENSE),) }
    @sense.setter
    def sense(self, sense:"CRDN_THRESH_CONVERGE_SENSE") -> None:
        return self._intf.set_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._set_sense_metadata, sense)

    _get_time_tolerance_metadata = { "offset" : _get_time_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_tolerance(self) -> float:
        """Get the time tolerance which determines the time accuracy of the converged value."""
        return self._intf.get_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._get_time_tolerance_metadata)

    _set_time_tolerance_metadata = { "offset" : _set_time_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_tolerance.setter
    def time_tolerance(self, timeTolerance:float) -> None:
        return self._intf.set_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._set_time_tolerance_metadata, timeTolerance)

    _get_absolute_tolerance_metadata = { "offset" : _get_absolute_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def absolute_tolerance(self) -> float:
        """Get the absolute tolerance which determines the distance between the value and the boundaries within which the value is considered converged."""
        return self._intf.get_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._get_absolute_tolerance_metadata)

    _set_absolute_tolerance_metadata = { "offset" : _set_absolute_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @absolute_tolerance.setter
    def absolute_tolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._set_absolute_tolerance_metadata, absoluteTolerance)

    _get_relative_tolerance_metadata = { "offset" : _get_relative_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def relative_tolerance(self) -> float:
        """Get the relative tolerance which determines the relative distance between the value and the boundaries within which the value is considered converged."""
        return self._intf.get_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._get_relative_tolerance_metadata)

    _set_relative_tolerance_metadata = { "offset" : _set_relative_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @relative_tolerance.setter
    def relative_tolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(CalculationToolConvergeBasic._metadata, CalculationToolConvergeBasic._set_relative_tolerance_metadata, relativeTolerance)

    _property_names[sense] = "sense"
    _property_names[time_tolerance] = "time_tolerance"
    _property_names[absolute_tolerance] = "absolute_tolerance"
    _property_names[relative_tolerance] = "relative_tolerance"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolConvergeBasic."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolConvergeBasic)
        IAnalysisWorkbenchConverge.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchConverge._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolConvergeBasic, [CalculationToolConvergeBasic, IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5514954824464931267, 18409877581449644180), CalculationToolConvergeBasic)
agcls.AgTypeNameMap["CalculationToolConvergeBasic"] = CalculationToolConvergeBasic

class AnalysisWorkbenchDerivative(IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Represents a base class for derivative definitions."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchDerivative."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchDerivative.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchDerivative._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchDerivative, [IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5587768146652831139, 5043452618809804181), AnalysisWorkbenchDerivative)
agcls.AgTypeNameMap["AnalysisWorkbenchDerivative"] = AnalysisWorkbenchDerivative

class CalculationToolDerivativeBasic(IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_time_step_method_offset = 1
    _set_time_step_method_offset = 2
    _metadata = {
        "iid_data" : (5698636090077154234, 12182121597687392176),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolDerivativeBasic)
    
    _get_time_step_metadata = { "offset" : _get_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_step(self) -> float:
        """Get the time step used for numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(CalculationToolDerivativeBasic._metadata, CalculationToolDerivativeBasic._get_time_step_metadata)

    _set_time_step_metadata = { "offset" : _set_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_step.setter
    def time_step(self, timeStep:float) -> None:
        return self._intf.set_property(CalculationToolDerivativeBasic._metadata, CalculationToolDerivativeBasic._set_time_step_metadata, timeStep)

    _property_names[time_step] = "time_step"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolDerivativeBasic."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolDerivativeBasic)
        IAnalysisWorkbenchDerivative.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchDerivative._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolDerivativeBasic, [CalculationToolDerivativeBasic, IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4922997640042415299, 3689582741653722007), CalculationToolDerivativeBasic)
agcls.AgTypeNameMap["CalculationToolDerivativeBasic"] = CalculationToolDerivativeBasic

class TimeToolEvent(ITimeToolEvent, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Define an event (time instant)."""
    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEvent."""
        SupportsDeleteCallback.__init__(self)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEvent, [ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5398793057979554597, 7356352219388702598), TimeToolEvent)
agcls.AgTypeNameMap["TimeToolEvent"] = TimeToolEvent

class TimeToolEventArray(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An ordered array of times, which may or may not be evenly spaced."""
    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArray."""
        SupportsDeleteCallback.__init__(self)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArray, [ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5332777741257833242, 4202084266511321478), TimeToolEventArray)
agcls.AgTypeNameMap["TimeToolEventArray"] = TimeToolEventArray

class TimeToolEventArrayConditionCrossings(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""

    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_satisfaction_crossing_method_offset = 1
    _set_satisfaction_crossing_method_offset = 2
    _get_condition_method_offset = 3
    _set_condition_method_offset = 4
    _get_custom_time_limits_method_offset = 5
    _set_custom_time_limits_method_offset = 6
    _get_use_custom_time_limits_method_offset = 7
    _set_use_custom_time_limits_method_offset = 8
    _get_save_data_option_method_offset = 9
    _set_save_data_option_method_offset = 10
    _get_sampling_method_offset = 11
    _set_sampling_method_offset = 12
    _get_convergence_method_offset = 13
    _set_convergence_method_offset = 14
    _metadata = {
        "iid_data" : (5613889423687348587, 15384622870918658997),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayConditionCrossings)
    
    _get_satisfaction_crossing_metadata = { "offset" : _get_satisfaction_crossing_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SATISFACTION_CROSSING),) }
    @property
    def satisfaction_crossing(self) -> "CRDN_SATISFACTION_CROSSING":
        """The direction of interest for satisfaction crossing."""
        return self._intf.get_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._get_satisfaction_crossing_metadata)

    _set_satisfaction_crossing_metadata = { "offset" : _set_satisfaction_crossing_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SATISFACTION_CROSSING),) }
    @satisfaction_crossing.setter
    def satisfaction_crossing(self, satisfactionCrossing:"CRDN_SATISFACTION_CROSSING") -> None:
        return self._intf.set_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._set_satisfaction_crossing_metadata, satisfactionCrossing)

    _get_condition_metadata = { "offset" : _get_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        return self._intf.get_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._get_condition_metadata)

    _set_condition_metadata = { "offset" : _set_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._set_condition_metadata, condition)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """Specify the interval list within which satisfaction crossing times are sought. The default is set to overall availability of host object. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed satisfaction crossing times are saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "offset" : _get_convergence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when crossing times are found."""
        return self._intf.get_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._get_convergence_metadata)

    _set_convergence_metadata = { "offset" : _set_convergence_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(TimeToolEventArrayConditionCrossings._metadata, TimeToolEventArrayConditionCrossings._set_convergence_metadata, convergence)

    _property_names[satisfaction_crossing] = "satisfaction_crossing"
    _property_names[condition] = "condition"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[sampling] = "sampling"
    _property_names[convergence] = "convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayConditionCrossings."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayConditionCrossings)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayConditionCrossings, [TimeToolEventArrayConditionCrossings, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5396215197440132353, 5751529864914655407), TimeToolEventArrayConditionCrossings)
agcls.AgTypeNameMap["TimeToolEventArrayConditionCrossings"] = TimeToolEventArrayConditionCrossings

class TimeToolEventArrayExtrema(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Determine times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_extremum_type_method_offset = 1
    _set_extremum_type_method_offset = 2
    _get_is_global_method_offset = 3
    _set_is_global_method_offset = 4
    _get_calculation_method_offset = 5
    _set_calculation_method_offset = 6
    _get_custom_time_limits_method_offset = 7
    _set_custom_time_limits_method_offset = 8
    _get_use_custom_time_limits_method_offset = 9
    _set_use_custom_time_limits_method_offset = 10
    _get_save_data_option_method_offset = 11
    _set_save_data_option_method_offset = 12
    _get_sampling_method_offset = 13
    _set_sampling_method_offset = 14
    _get_convergence_method_offset = 15
    _set_convergence_method_offset = 16
    _metadata = {
        "iid_data" : (5206648834428252232, 967315087763540632),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayExtrema)
    
    _get_extremum_type_metadata = { "offset" : _get_extremum_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EXTREMUM_CONSTANTS),) }
    @property
    def extremum_type(self) -> "CRDN_EXTREMUM_CONSTANTS":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_extremum_type_metadata)

    _set_extremum_type_metadata = { "offset" : _set_extremum_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_EXTREMUM_CONSTANTS),) }
    @extremum_type.setter
    def extremum_type(self, extremumType:"CRDN_EXTREMUM_CONSTANTS") -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_extremum_type_metadata, extremumType)

    _get_is_global_metadata = { "offset" : _get_is_global_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_global(self) -> bool:
        """Indicate whether to perform local or global search. The default is false."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_is_global_metadata)

    _set_is_global_metadata = { "offset" : _set_is_global_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @is_global.setter
    def is_global(self, isGlobal:bool) -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_is_global_metadata, isGlobal)

    _get_calculation_metadata = { "offset" : _get_calculation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def calculation(self) -> "ICalculationToolScalar":
        """The scalar calculation."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_calculation_metadata)

    _set_calculation_metadata = { "offset" : _set_calculation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @calculation.setter
    def calculation(self, calculation:"ICalculationToolScalar") -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_calculation_metadata, calculation)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Specify whether computed times of extrema are saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "offset" : _get_convergence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        return self._intf.get_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._get_convergence_metadata)

    _set_convergence_metadata = { "offset" : _set_convergence_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(TimeToolEventArrayExtrema._metadata, TimeToolEventArrayExtrema._set_convergence_metadata, convergence)

    _property_names[extremum_type] = "extremum_type"
    _property_names[is_global] = "is_global"
    _property_names[calculation] = "calculation"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[sampling] = "sampling"
    _property_names[convergence] = "convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayExtrema."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayExtrema)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayExtrema, [TimeToolEventArrayExtrema, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4895652447947847564, 10544338283664157372), TimeToolEventArrayExtrema)
agcls.AgTypeNameMap["TimeToolEventArrayExtrema"] = TimeToolEventArrayExtrema

class TimeToolEventArrayFactory(SupportsDeleteCallback):
    """The factory creates event arrays."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_event_array_extrema_method_offset = 2
    _create_event_array_start_stop_times_method_offset = 3
    _create_event_array_merged_method_offset = 4
    _create_event_array_filtered_method_offset = 5
    _create_event_array_fixed_step_method_offset = 6
    _create_event_array_condition_crossings_method_offset = 7
    _create_event_array_signaled_method_offset = 8
    _is_type_supported_method_offset = 9
    _create_event_array_fixed_times_method_offset = 10
    _metadata = {
        "iid_data" : (5542319423916064894, 16004686220202616230),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_EVENT_ARRAY_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_ARRAY_TYPE") -> "ITimeToolEventArray":
        """Create and register an event array using specified name, description, and type."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_metadata, name, description, type, OutArg())

    _create_event_array_extrema_metadata = { "offset" : _create_event_array_extrema_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_extrema(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by determining times of local minimum and/or maximum of specified scalar calculation."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_extrema_metadata, name, description, OutArg())

    _create_event_array_start_stop_times_metadata = { "offset" : _create_event_array_start_stop_times_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_start_stop_times(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by taking start and/or stop times of every interval in the specified reference interval list and adding them to array."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_start_stop_times_metadata, name, description, OutArg())

    _create_event_array_merged_metadata = { "offset" : _create_event_array_merged_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_merged(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_merged_metadata, name, description, OutArg())

    _create_event_array_filtered_metadata = { "offset" : _create_event_array_filtered_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_filtered(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by filtering times from an original time array according to specified filtering method."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_filtered_metadata, name, description, OutArg())

    _create_event_array_fixed_step_metadata = { "offset" : _create_event_array_fixed_step_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_fixed_step(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array using fixed time steps from the specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_fixed_step_metadata, name, description, OutArg())

    _create_event_array_condition_crossings_metadata = { "offset" : _create_event_array_condition_crossings_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_condition_crossings(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array containing times at which the specified condition will change its satisfaction status."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_condition_crossings_metadata, name, description, OutArg())

    _create_event_array_signaled_metadata = { "offset" : _create_event_array_signaled_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_signaled(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_signaled_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_ARRAY_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_ARRAY_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._is_type_supported_metadata, eType, OutArg())

    _create_event_array_fixed_times_metadata = { "offset" : _create_event_array_fixed_times_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_array_fixed_times(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array using specified times."""
        return self._intf.invoke(TimeToolEventArrayFactory._metadata, TimeToolEventArrayFactory._create_event_array_fixed_times_metadata, name, description, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayFactory, [TimeToolEventArrayFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5458075538004504061, 2067516564496506015), TimeToolEventArrayFactory)
agcls.AgTypeNameMap["TimeToolEventArrayFactory"] = TimeToolEventArrayFactory

class TimeToolEventArrayFiltered(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by filtering times from original time array according to specified filtering method."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_time_array_method_offset = 1
    _set_original_time_array_method_offset = 2
    _get_filter_type_method_offset = 3
    _set_filter_type_method_offset = 4
    _get_count_method_offset = 5
    _set_count_method_offset = 6
    _get_step_method_offset = 7
    _set_step_method_offset = 8
    _get_include_interval_stop_times_method_offset = 9
    _set_include_interval_stop_times_method_offset = 10
    _get_filter_interval_list_method_offset = 11
    _set_filter_interval_list_method_offset = 12
    _metadata = {
        "iid_data" : (4807678415758810560, 13966026461879800744),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayFiltered)
    
    _get_original_time_array_metadata = { "offset" : _get_original_time_array_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_time_array(self) -> "ITimeToolEventArray":
        """The original time array."""
        return self._intf.get_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._get_original_time_array_metadata)

    _set_original_time_array_metadata = { "offset" : _set_original_time_array_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventArray"),) }
    @original_time_array.setter
    def original_time_array(self, originalTimeArray:"ITimeToolEventArray") -> None:
        return self._intf.set_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._set_original_time_array_metadata, originalTimeArray)

    _get_filter_type_metadata = { "offset" : _get_filter_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_ARRAY_FILTER_TYPE),) }
    @property
    def filter_type(self) -> "CRDN_EVENT_ARRAY_FILTER_TYPE":
        """Skip Time Steps filter type omits from filtered time array any times that fall within specified time step of last accepted time sample. Skip Count filter type omits specified number of time samples since last accepted time sample..."""
        return self._intf.get_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._get_filter_type_metadata)

    _set_filter_type_metadata = { "offset" : _set_filter_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_ARRAY_FILTER_TYPE),) }
    @filter_type.setter
    def filter_type(self, filterType:"CRDN_EVENT_ARRAY_FILTER_TYPE") -> None:
        return self._intf.set_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._set_filter_type_metadata, filterType)

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Specify the number of times skipped between accepted samples when FilterType is set to Skip Count..."""
        return self._intf.get_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._get_count_metadata)

    _set_count_metadata = { "offset" : _set_count_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @count.setter
    def count(self, count:int) -> None:
        return self._intf.set_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._set_count_metadata, count)

    _get_step_metadata = { "offset" : _get_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def step(self) -> float:
        """The number of steps skipped between accepted samples when FilterType is set to Skip Time Steps."""
        return self._intf.get_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._get_step_metadata)

    _set_step_metadata = { "offset" : _set_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @step.setter
    def step(self, step:float) -> None:
        return self._intf.set_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._set_step_metadata, step)

    _get_include_interval_stop_times_metadata = { "offset" : _get_include_interval_stop_times_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def include_interval_stop_times(self) -> bool:
        """If set to true, includes stop times of each interval from original time array."""
        return self._intf.get_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._get_include_interval_stop_times_metadata)

    _set_include_interval_stop_times_metadata = { "offset" : _set_include_interval_stop_times_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @include_interval_stop_times.setter
    def include_interval_stop_times(self, includeIntervalStopTimes:bool) -> None:
        return self._intf.set_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._set_include_interval_stop_times_metadata, includeIntervalStopTimes)

    _get_filter_interval_list_metadata = { "offset" : _get_filter_interval_list_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def filter_interval_list(self) -> "ITimeToolEventIntervalList":
        """The interval list used to filter samples when FilterType is set to Skip Intervals."""
        return self._intf.get_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._get_filter_interval_list_metadata)

    _set_filter_interval_list_metadata = { "offset" : _set_filter_interval_list_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @filter_interval_list.setter
    def filter_interval_list(self, filterIntervalList:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventArrayFiltered._metadata, TimeToolEventArrayFiltered._set_filter_interval_list_metadata, filterIntervalList)

    _property_names[original_time_array] = "original_time_array"
    _property_names[filter_type] = "filter_type"
    _property_names[count] = "count"
    _property_names[step] = "step"
    _property_names[include_interval_stop_times] = "include_interval_stop_times"
    _property_names[filter_interval_list] = "filter_interval_list"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayFiltered."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayFiltered)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayFiltered, [TimeToolEventArrayFiltered, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4642904597198643175, 4377576397480008330), TimeToolEventArrayFiltered)
agcls.AgTypeNameMap["TimeToolEventArrayFiltered"] = TimeToolEventArrayFiltered

class TimeToolEventArrayFixedStep(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_bounding_interval_list_method_offset = 1
    _set_bounding_interval_list_method_offset = 2
    _get_sampling_time_step_method_offset = 3
    _set_sampling_time_step_method_offset = 4
    _get_include_interval_edges_method_offset = 5
    _set_include_interval_edges_method_offset = 6
    _get_reference_type_method_offset = 7
    _set_reference_type_method_offset = 8
    _get_reference_time_instant_method_offset = 9
    _set_reference_time_instant_method_offset = 10
    _metadata = {
        "iid_data" : (5206395693562101053, 5734909382665571514),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayFixedStep)
    
    _get_bounding_interval_list_metadata = { "offset" : _get_bounding_interval_list_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def bounding_interval_list(self) -> "ITimeToolEventIntervalList":
        """The bounding interval list."""
        return self._intf.get_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._get_bounding_interval_list_metadata)

    _set_bounding_interval_list_metadata = { "offset" : _set_bounding_interval_list_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @bounding_interval_list.setter
    def bounding_interval_list(self, boundingIntervalList:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._set_bounding_interval_list_metadata, boundingIntervalList)

    _get_sampling_time_step_metadata = { "offset" : _get_sampling_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def sampling_time_step(self) -> float:
        """The sampling time step."""
        return self._intf.get_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._get_sampling_time_step_metadata)

    _set_sampling_time_step_metadata = { "offset" : _set_sampling_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @sampling_time_step.setter
    def sampling_time_step(self, samplingTimeStep:float) -> None:
        return self._intf.set_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._set_sampling_time_step_metadata, samplingTimeStep)

    _get_include_interval_edges_metadata = { "offset" : _get_include_interval_edges_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def include_interval_edges(self) -> bool:
        """Specify whether to include interval edges."""
        return self._intf.get_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._get_include_interval_edges_metadata)

    _set_include_interval_edges_metadata = { "offset" : _set_include_interval_edges_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @include_interval_edges.setter
    def include_interval_edges(self, includeIntervalEdges:bool) -> None:
        return self._intf.set_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._set_include_interval_edges_metadata, includeIntervalEdges)

    _get_reference_type_metadata = { "offset" : _get_reference_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAMPLED_REFERENCE_TIME),) }
    @property
    def reference_type(self) -> "CRDN_SAMPLED_REFERENCE_TIME":
        """Specify the time reference from which fixed sampling time steps are taken. Note: selecting Start/Stop of each Interval resets the time reference for each interval, whereas other types maintain single reference for entire array."""
        return self._intf.get_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._get_reference_type_metadata)

    _set_reference_type_metadata = { "offset" : _set_reference_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAMPLED_REFERENCE_TIME),) }
    @reference_type.setter
    def reference_type(self, referenceType:"CRDN_SAMPLED_REFERENCE_TIME") -> None:
        return self._intf.set_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._set_reference_type_metadata, referenceType)

    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant. Only applicable if the ReferenceType is set to time instant."""
        return self._intf.get_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(TimeToolEventArrayFixedStep._metadata, TimeToolEventArrayFixedStep._set_reference_time_instant_metadata, referenceTimeInstant)

    _property_names[bounding_interval_list] = "bounding_interval_list"
    _property_names[sampling_time_step] = "sampling_time_step"
    _property_names[include_interval_edges] = "include_interval_edges"
    _property_names[reference_type] = "reference_type"
    _property_names[reference_time_instant] = "reference_time_instant"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayFixedStep."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayFixedStep)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayFixedStep, [TimeToolEventArrayFixedStep, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5291295331531848140, 1885669106906320519), TimeToolEventArrayFixedStep)
agcls.AgTypeNameMap["TimeToolEventArrayFixedStep"] = TimeToolEventArrayFixedStep

class TimeToolEventArrayFixedTimes(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Array defined by time ordered instants each explicitly specified."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_array_times_method_offset = 1
    _set_array_times_method_offset = 2
    _metadata = {
        "iid_data" : (5074323306179123922, 16054451061673617558),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayFixedTimes)
    
    _get_array_times_metadata = { "offset" : _get_array_times_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def array_times(self) -> list:
        """The array of times."""
        return self._intf.get_property(TimeToolEventArrayFixedTimes._metadata, TimeToolEventArrayFixedTimes._get_array_times_metadata)

    _set_array_times_metadata = { "offset" : _set_array_times_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_array_times(self, times:list) -> None:
        """Set array of times."""
        return self._intf.invoke(TimeToolEventArrayFixedTimes._metadata, TimeToolEventArrayFixedTimes._set_array_times_metadata, times)

    _property_names[array_times] = "array_times"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayFixedTimes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayFixedTimes)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayFixedTimes, [TimeToolEventArrayFixedTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5593791433450696394, 1539321884068845490), TimeToolEventArrayFixedTimes)
agcls.AgTypeNameMap["TimeToolEventArrayFixedTimes"] = TimeToolEventArrayFixedTimes

class TimeToolEventArrayMerged(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_time_array_a_method_offset = 1
    _set_time_array_a_method_offset = 2
    _get_time_array_b_method_offset = 3
    _set_time_array_b_method_offset = 4
    _metadata = {
        "iid_data" : (4780019232320281739, 780076398979475114),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayMerged)
    
    _get_time_array_a_metadata = { "offset" : _get_time_array_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def time_array_a(self) -> "ITimeToolEventArray":
        """The first time array."""
        return self._intf.get_property(TimeToolEventArrayMerged._metadata, TimeToolEventArrayMerged._get_time_array_a_metadata)

    _set_time_array_a_metadata = { "offset" : _set_time_array_a_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventArray"),) }
    @time_array_a.setter
    def time_array_a(self, timeArrayA:"ITimeToolEventArray") -> None:
        return self._intf.set_property(TimeToolEventArrayMerged._metadata, TimeToolEventArrayMerged._set_time_array_a_metadata, timeArrayA)

    _get_time_array_b_metadata = { "offset" : _get_time_array_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def time_array_b(self) -> "ITimeToolEventArray":
        """The second time array."""
        return self._intf.get_property(TimeToolEventArrayMerged._metadata, TimeToolEventArrayMerged._get_time_array_b_metadata)

    _set_time_array_b_metadata = { "offset" : _set_time_array_b_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventArray"),) }
    @time_array_b.setter
    def time_array_b(self, timeArrayB:"ITimeToolEventArray") -> None:
        return self._intf.set_property(TimeToolEventArrayMerged._metadata, TimeToolEventArrayMerged._set_time_array_b_metadata, timeArrayB)

    _property_names[time_array_a] = "time_array_a"
    _property_names[time_array_b] = "time_array_b"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayMerged."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayMerged)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayMerged, [TimeToolEventArrayMerged, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4782774864999860286, 3889233035658327469), TimeToolEventArrayMerged)
agcls.AgTypeNameMap["TimeToolEventArrayMerged"] = TimeToolEventArrayMerged

class TimeToolEventArraySignaled(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Determine what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_time_array_method_offset = 1
    _set_original_time_array_method_offset = 2
    _get_signal_sense_method_offset = 3
    _set_signal_sense_method_offset = 4
    _get_base_clock_location_method_offset = 5
    _set_base_clock_location_method_offset = 6
    _get_target_clock_location_method_offset = 7
    _set_target_clock_location_method_offset = 8
    _get_signal_delay_method_offset = 9
    _set_signal_delay_method_offset = 10
    _metadata = {
        "iid_data" : (5436916865848414632, 14446293692646829208),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArraySignaled)
    
    _get_original_time_array_metadata = { "offset" : _get_original_time_array_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_time_array(self) -> "ITimeToolEventArray":
        """The original time array."""
        return self._intf.get_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._get_original_time_array_metadata)

    _set_original_time_array_metadata = { "offset" : _set_original_time_array_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventArray"),) }
    @original_time_array.setter
    def original_time_array(self, originalTimeArray:"ITimeToolEventArray") -> None:
        return self._intf.set_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._set_original_time_array_metadata, originalTimeArray)

    _get_signal_sense_metadata = { "offset" : _get_signal_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "offset" : _set_signal_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "offset" : _get_base_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "offset" : _set_base_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "offset" : _get_target_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "offset" : _set_target_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "offset" : _get_signal_delay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "offset" : _set_signal_delay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(TimeToolEventArraySignaled._metadata, TimeToolEventArraySignaled._set_signal_delay_metadata, signalDelay)

    _property_names[original_time_array] = "original_time_array"
    _property_names[signal_sense] = "signal_sense"
    _property_names[base_clock_location] = "base_clock_location"
    _property_names[target_clock_location] = "target_clock_location"
    _property_names[signal_delay] = "signal_delay"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArraySignaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArraySignaled)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArraySignaled, [TimeToolEventArraySignaled, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5435814862915860050, 12317878345385448122), TimeToolEventArraySignaled)
agcls.AgTypeNameMap["TimeToolEventArraySignaled"] = TimeToolEventArraySignaled

class TimeToolEventArrayStartStopTimes(ITimeToolEventArray, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_start_stop_option_method_offset = 1
    _set_start_stop_option_method_offset = 2
    _get_reference_intervals_method_offset = 3
    _set_reference_intervals_method_offset = 4
    _metadata = {
        "iid_data" : (4846567064350463042, 16499803777902134457),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventArrayStartStopTimes)
    
    _get_start_stop_option_metadata = { "offset" : _get_start_stop_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_START_STOP_OPTION),) }
    @property
    def start_stop_option(self) -> "CRDN_START_STOP_OPTION":
        """The edge type. At least one of the two edge types must be selected."""
        return self._intf.get_property(TimeToolEventArrayStartStopTimes._metadata, TimeToolEventArrayStartStopTimes._get_start_stop_option_metadata)

    _set_start_stop_option_metadata = { "offset" : _set_start_stop_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_START_STOP_OPTION),) }
    @start_stop_option.setter
    def start_stop_option(self, startStopOption:"CRDN_START_STOP_OPTION") -> None:
        return self._intf.set_property(TimeToolEventArrayStartStopTimes._metadata, TimeToolEventArrayStartStopTimes._set_start_stop_option_metadata, startStopOption)

    _get_reference_intervals_metadata = { "offset" : _get_reference_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(TimeToolEventArrayStartStopTimes._metadata, TimeToolEventArrayStartStopTimes._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "offset" : _set_reference_intervals_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventArrayStartStopTimes._metadata, TimeToolEventArrayStartStopTimes._set_reference_intervals_metadata, referenceIntervals)

    _property_names[start_stop_option] = "start_stop_option"
    _property_names[reference_intervals] = "reference_intervals"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventArrayStartStopTimes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventArrayStartStopTimes)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventArrayStartStopTimes, [TimeToolEventArrayStartStopTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4860958271402795436, 3117480943035526832), TimeToolEventArrayStartStopTimes)
agcls.AgTypeNameMap["TimeToolEventArrayStartStopTimes"] = TimeToolEventArrayStartStopTimes

class TimeToolEventEpoch(ITimeToolEvent, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Event set at specified date/time."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_epoch_method_offset = 1
    _set_epoch_method_offset = 2
    _metadata = {
        "iid_data" : (5361126161618754498, 11546813527429934240),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventEpoch)
    
    _get_epoch_metadata = { "offset" : _get_epoch_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def epoch(self) -> typing.Any:
        """An explicit date/time, set using any STK date format."""
        return self._intf.get_property(TimeToolEventEpoch._metadata, TimeToolEventEpoch._get_epoch_metadata)

    _set_epoch_metadata = { "offset" : _set_epoch_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(TimeToolEventEpoch._metadata, TimeToolEventEpoch._set_epoch_metadata, epoch)

    _property_names[epoch] = "epoch"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventEpoch."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventEpoch)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventEpoch, [TimeToolEventEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5435356060854789844, 4067587155681333929), TimeToolEventEpoch)
agcls.AgTypeNameMap["TimeToolEventEpoch"] = TimeToolEventEpoch

class TimeToolEventExtremum(ITimeToolEvent, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Determine time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_extremum_type_method_offset = 1
    _set_extremum_type_method_offset = 2
    _get_calculation_method_offset = 3
    _set_calculation_method_offset = 4
    _get_custom_time_limits_method_offset = 5
    _set_custom_time_limits_method_offset = 6
    _get_use_custom_time_limits_method_offset = 7
    _set_use_custom_time_limits_method_offset = 8
    _get_save_data_option_method_offset = 9
    _set_save_data_option_method_offset = 10
    _get_sampling_method_offset = 11
    _set_sampling_method_offset = 12
    _get_convergence_method_offset = 13
    _set_convergence_method_offset = 14
    _metadata = {
        "iid_data" : (5490767592740683220, 17574270972815238058),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventExtremum)
    
    _get_extremum_type_metadata = { "offset" : _get_extremum_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EXTREMUM_CONSTANTS),) }
    @property
    def extremum_type(self) -> "CRDN_EXTREMUM_CONSTANTS":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        return self._intf.get_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._get_extremum_type_metadata)

    _set_extremum_type_metadata = { "offset" : _set_extremum_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_EXTREMUM_CONSTANTS),) }
    @extremum_type.setter
    def extremum_type(self, extremumType:"CRDN_EXTREMUM_CONSTANTS") -> None:
        return self._intf.set_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._set_extremum_type_metadata, extremumType)

    _get_calculation_metadata = { "offset" : _get_calculation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def calculation(self) -> "ICalculationToolScalar":
        """The scalar calculation."""
        return self._intf.get_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._get_calculation_metadata)

    _set_calculation_metadata = { "offset" : _set_calculation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @calculation.setter
    def calculation(self, calculation:"ICalculationToolScalar") -> None:
        return self._intf.set_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._set_calculation_metadata, calculation)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "offset" : _get_convergence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._get_convergence_metadata)

    _set_convergence_metadata = { "offset" : _set_convergence_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(TimeToolEventExtremum._metadata, TimeToolEventExtremum._set_convergence_metadata, convergence)

    _property_names[extremum_type] = "extremum_type"
    _property_names[calculation] = "calculation"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[sampling] = "sampling"
    _property_names[convergence] = "convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventExtremum."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventExtremum)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventExtremum, [TimeToolEventExtremum, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5389385592881205397, 339728145862133895), TimeToolEventExtremum)
agcls.AgTypeNameMap["TimeToolEventExtremum"] = TimeToolEventExtremum

class TimeToolEventFactory(SupportsDeleteCallback):
    """The factory creates events."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_today_method_offset = 1
    _get_tomorrow_method_offset = 2
    _create_method_offset = 3
    _create_event_epoch_method_offset = 4
    _create_event_extremum_method_offset = 5
    _create_event_start_stop_time_method_offset = 6
    _create_event_signaled_method_offset = 7
    _create_event_time_offset_method_offset = 8
    _create_smart_epoch_from_time_method_offset = 9
    _create_smart_epoch_from_event_method_offset = 10
    _is_type_supported_method_offset = 11
    _metadata = {
        "iid_data" : (5177435815935857475, 9742177550060253581),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventFactory)
    
    _get_today_metadata = { "offset" : _get_today_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def today(self) -> "ITimeToolEvent":
        """Return Today time instant."""
        return self._intf.get_property(TimeToolEventFactory._metadata, TimeToolEventFactory._get_today_metadata)

    _get_tomorrow_metadata = { "offset" : _get_tomorrow_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def tomorrow(self) -> "ITimeToolEvent":
        """Return Tomorrow time instant."""
        return self._intf.get_property(TimeToolEventFactory._metadata, TimeToolEventFactory._get_tomorrow_metadata)

    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_EVENT_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_TYPE") -> "ITimeToolEvent":
        """Create and registers an event using specified name, description, and type."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_metadata, name, description, type, OutArg())

    _create_event_epoch_metadata = { "offset" : _create_event_epoch_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_epoch(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event set at a specified date/time."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_event_epoch_metadata, name, description, OutArg())

    _create_event_extremum_metadata = { "offset" : _create_event_extremum_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_extremum(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event that determines the time of global minimum or maximum of specified scalar calculation."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_event_extremum_metadata, name, description, OutArg())

    _create_event_start_stop_time_metadata = { "offset" : _create_event_start_stop_time_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_start_stop_time(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event that is either the start or stop time selected from a reference interval."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_event_start_stop_time_metadata, name, description, OutArg())

    _create_event_signaled_metadata = { "offset" : _create_event_signaled_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_signaled(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event recorded on a specified clock via signal transmission from an original time instant recorded on different clock."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_event_signaled_metadata, name, description, OutArg())

    _create_event_time_offset_metadata = { "offset" : _create_event_time_offset_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_time_offset(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event at fixed offset from specified reference event."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_event_time_offset_metadata, name, description, OutArg())

    _create_smart_epoch_from_time_metadata = { "offset" : _create_smart_epoch_from_time_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def create_smart_epoch_from_time(self, epoch:typing.Any) -> "TimeToolEventSmartEpoch":
        """Create a smart epoch from STK epoch."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_smart_epoch_from_time_metadata, epoch, OutArg())

    _create_smart_epoch_from_event_metadata = { "offset" : _create_smart_epoch_from_event_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"), agmarshall.InterfaceOutArg,) }
    def create_smart_epoch_from_event(self, refEvent:"ITimeToolEvent") -> "TimeToolEventSmartEpoch":
        """Create a smart epoch from an event."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._create_smart_epoch_from_event_metadata, refEvent, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(TimeToolEventFactory._metadata, TimeToolEventFactory._is_type_supported_metadata, eType, OutArg())

    _property_names[today] = "today"
    _property_names[tomorrow] = "tomorrow"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventFactory, [TimeToolEventFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5272300824979797026, 16498667286970460562), TimeToolEventFactory)
agcls.AgTypeNameMap["TimeToolEventFactory"] = TimeToolEventFactory

class TimeToolEventInterval(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A single time interval."""
    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventInterval."""
        SupportsDeleteCallback.__init__(self)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventInterval, [ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4907362365384322524, 7697029984187487375), TimeToolEventInterval)
agcls.AgTypeNameMap["TimeToolEventInterval"] = TimeToolEventInterval

class TimeToolEventIntervalBetweenTimeInstants(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_start_time_instant_method_offset = 1
    _set_start_time_instant_method_offset = 2
    _get_stop_time_instant_method_offset = 3
    _set_stop_time_instant_method_offset = 4
    _metadata = {
        "iid_data" : (5763963832395591361, 8213926450025946009),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalBetweenTimeInstants)
    
    _get_start_time_instant_metadata = { "offset" : _get_start_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def start_time_instant(self) -> "ITimeToolEvent":
        """The start time instant of the interval."""
        return self._intf.get_property(TimeToolEventIntervalBetweenTimeInstants._metadata, TimeToolEventIntervalBetweenTimeInstants._get_start_time_instant_metadata)

    _set_start_time_instant_metadata = { "offset" : _set_start_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @start_time_instant.setter
    def start_time_instant(self, startTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(TimeToolEventIntervalBetweenTimeInstants._metadata, TimeToolEventIntervalBetweenTimeInstants._set_start_time_instant_metadata, startTimeInstant)

    _get_stop_time_instant_metadata = { "offset" : _get_stop_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def stop_time_instant(self) -> "ITimeToolEvent":
        """The stop time instant of the interval."""
        return self._intf.get_property(TimeToolEventIntervalBetweenTimeInstants._metadata, TimeToolEventIntervalBetweenTimeInstants._get_stop_time_instant_metadata)

    _set_stop_time_instant_metadata = { "offset" : _set_stop_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @stop_time_instant.setter
    def stop_time_instant(self, stopTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(TimeToolEventIntervalBetweenTimeInstants._metadata, TimeToolEventIntervalBetweenTimeInstants._set_stop_time_instant_metadata, stopTimeInstant)

    _property_names[start_time_instant] = "start_time_instant"
    _property_names[stop_time_instant] = "stop_time_instant"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalBetweenTimeInstants."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalBetweenTimeInstants)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalBetweenTimeInstants, [TimeToolEventIntervalBetweenTimeInstants, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5441730547251256494, 11273521191384897433), TimeToolEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap["TimeToolEventIntervalBetweenTimeInstants"] = TimeToolEventIntervalBetweenTimeInstants

class TimeToolEventIntervalCollection(ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A collection of related interval lists."""
    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalCollection."""
        SupportsDeleteCallback.__init__(self)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollection, [ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5320390972149596139, 11612889387071709314), TimeToolEventIntervalCollection)
agcls.AgTypeNameMap["TimeToolEventIntervalCollection"] = TimeToolEventIntervalCollection

class TimeToolEventIntervalCollectionCondition(ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_condition_set_method_offset = 1
    _set_condition_set_method_offset = 2
    _get_custom_time_limits_method_offset = 3
    _set_custom_time_limits_method_offset = 4
    _get_use_custom_time_limits_method_offset = 5
    _set_use_custom_time_limits_method_offset = 6
    _get_save_data_option_method_offset = 7
    _set_save_data_option_method_offset = 8
    _get_sampling_method_offset = 9
    _set_sampling_method_offset = 10
    _get_convergence_method_offset = 11
    _set_convergence_method_offset = 12
    _metadata = {
        "iid_data" : (5695491852784106006, 14645292488236401817),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalCollectionCondition)
    
    _get_condition_set_metadata = { "offset" : _get_condition_set_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def condition_set(self) -> "ICalculationToolConditionSet":
        """Get/set the condition set object."""
        return self._intf.get_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._get_condition_set_metadata)

    _set_condition_set_metadata = { "offset" : _set_condition_set_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolConditionSet"),) }
    @condition_set.setter
    def condition_set(self, conditionSet:"ICalculationToolConditionSet") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._set_condition_set_metadata, conditionSet)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Specify whether to use specified custom interval list (see CustomTimeLimits)."""
        return self._intf.get_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "offset" : _get_convergence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._get_convergence_metadata)

    _set_convergence_metadata = { "offset" : _set_convergence_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionCondition._metadata, TimeToolEventIntervalCollectionCondition._set_convergence_metadata, convergence)

    _property_names[condition_set] = "condition_set"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[sampling] = "sampling"
    _property_names[convergence] = "convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalCollectionCondition."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalCollectionCondition)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionCondition, [TimeToolEventIntervalCollectionCondition, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5096431107182997469, 15497237714408753540), TimeToolEventIntervalCollectionCondition)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionCondition"] = TimeToolEventIntervalCollectionCondition

class TimeToolEventIntervalCollectionFactory(SupportsDeleteCallback):
    """The factory creates collections of event interval lists."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_event_interval_collection_lighting_method_offset = 2
    _create_event_interval_collection_signaled_method_offset = 3
    _is_type_supported_method_offset = 4
    _create_event_interval_collection_satisfaction_method_offset = 5
    _metadata = {
        "iid_data" : (4929297514598945487, 10137873554628665765),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalCollectionFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_EVENT_INTERVAL_COLLECTION_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_INTERVAL_COLLECTION_TYPE") -> "ITimeToolEventIntervalCollection":
        """Create and register an event interval collection using specified name, description, and type."""
        return self._intf.invoke(TimeToolEventIntervalCollectionFactory._metadata, TimeToolEventIntervalCollectionFactory._create_metadata, name, description, type, OutArg())

    _create_event_interval_collection_lighting_metadata = { "offset" : _create_event_interval_collection_lighting_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_collection_lighting(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
        return self._intf.invoke(TimeToolEventIntervalCollectionFactory._metadata, TimeToolEventIntervalCollectionFactory._create_event_interval_collection_lighting_metadata, name, description, OutArg())

    _create_event_interval_collection_signaled_metadata = { "offset" : _create_event_interval_collection_signaled_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_collection_signaled(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
        return self._intf.invoke(TimeToolEventIntervalCollectionFactory._metadata, TimeToolEventIntervalCollectionFactory._create_event_interval_collection_signaled_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_INTERVAL_COLLECTION_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_INTERVAL_COLLECTION_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(TimeToolEventIntervalCollectionFactory._metadata, TimeToolEventIntervalCollectionFactory._is_type_supported_metadata, eType, OutArg())

    _create_event_interval_collection_satisfaction_metadata = { "offset" : _create_event_interval_collection_satisfaction_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_collection_satisfaction(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection containing intervals during which condition set is satisfied."""
        return self._intf.invoke(TimeToolEventIntervalCollectionFactory._metadata, TimeToolEventIntervalCollectionFactory._create_event_interval_collection_satisfaction_metadata, name, description, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalCollectionFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalCollectionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionFactory, [TimeToolEventIntervalCollectionFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5176155607638442896, 7177596217140786077), TimeToolEventIntervalCollectionFactory)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionFactory"] = TimeToolEventIntervalCollectionFactory

class TimeToolEventIntervalCollectionLighting(ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_location_method_offset = 1
    _set_location_method_offset = 2
    _get_eclipsing_bodies_method_offset = 3
    _set_eclipsing_bodies_method_offset = 4
    _get_use_object_eclipsing_bodies_method_offset = 5
    _set_use_object_eclipsing_bodies_method_offset = 6
    _metadata = {
        "iid_data" : (5361006311311084485, 10468446585511132859),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalCollectionLighting)
    
    _get_location_metadata = { "offset" : _get_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def location(self) -> "IVectorGeometryToolPoint":
        """The location point to compute sunlight, penumbra and umbra."""
        return self._intf.get_property(TimeToolEventIntervalCollectionLighting._metadata, TimeToolEventIntervalCollectionLighting._get_location_metadata)

    _set_location_metadata = { "offset" : _set_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @location.setter
    def location(self, location:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionLighting._metadata, TimeToolEventIntervalCollectionLighting._set_location_metadata, location)

    _get_eclipsing_bodies_metadata = { "offset" : _get_eclipsing_bodies_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def eclipsing_bodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(TimeToolEventIntervalCollectionLighting._metadata, TimeToolEventIntervalCollectionLighting._get_eclipsing_bodies_metadata)

    _set_eclipsing_bodies_metadata = { "offset" : _set_eclipsing_bodies_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @eclipsing_bodies.setter
    def eclipsing_bodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionLighting._metadata, TimeToolEventIntervalCollectionLighting._set_eclipsing_bodies_metadata, eclipsingBodies)

    _get_use_object_eclipsing_bodies_metadata = { "offset" : _get_use_object_eclipsing_bodies_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_object_eclipsing_bodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(TimeToolEventIntervalCollectionLighting._metadata, TimeToolEventIntervalCollectionLighting._get_use_object_eclipsing_bodies_metadata)

    _set_use_object_eclipsing_bodies_metadata = { "offset" : _set_use_object_eclipsing_bodies_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_object_eclipsing_bodies.setter
    def use_object_eclipsing_bodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionLighting._metadata, TimeToolEventIntervalCollectionLighting._set_use_object_eclipsing_bodies_metadata, useObjectEclipsingBodies)

    _property_names[location] = "location"
    _property_names[eclipsing_bodies] = "eclipsing_bodies"
    _property_names[use_object_eclipsing_bodies] = "use_object_eclipsing_bodies"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalCollectionLighting."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalCollectionLighting)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionLighting, [TimeToolEventIntervalCollectionLighting, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4778372489419407290, 1841925492488396976), TimeToolEventIntervalCollectionLighting)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionLighting"] = TimeToolEventIntervalCollectionLighting

class TimeToolEventIntervalCollectionSignaled(ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Determine what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_collection_method_offset = 1
    _set_original_collection_method_offset = 2
    _get_signal_sense_method_offset = 3
    _set_signal_sense_method_offset = 4
    _get_base_clock_location_method_offset = 5
    _set_base_clock_location_method_offset = 6
    _get_target_clock_location_method_offset = 7
    _set_target_clock_location_method_offset = 8
    _get_signal_delay_method_offset = 9
    _set_signal_delay_method_offset = 10
    _metadata = {
        "iid_data" : (5102559603137595011, 6446915665441949320),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalCollectionSignaled)
    
    _get_original_collection_metadata = { "offset" : _get_original_collection_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_collection(self) -> "ITimeToolEventIntervalCollection":
        """The original interval list collection."""
        return self._intf.get_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._get_original_collection_metadata)

    _set_original_collection_metadata = { "offset" : _set_original_collection_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalCollection"),) }
    @original_collection.setter
    def original_collection(self, originalCollection:"ITimeToolEventIntervalCollection") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._set_original_collection_metadata, originalCollection)

    _get_signal_sense_metadata = { "offset" : _get_signal_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "offset" : _set_signal_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "offset" : _get_base_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "offset" : _set_base_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "offset" : _get_target_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "offset" : _set_target_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "offset" : _get_signal_delay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "offset" : _set_signal_delay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(TimeToolEventIntervalCollectionSignaled._metadata, TimeToolEventIntervalCollectionSignaled._set_signal_delay_metadata, signalDelay)

    _property_names[original_collection] = "original_collection"
    _property_names[signal_sense] = "signal_sense"
    _property_names[base_clock_location] = "base_clock_location"
    _property_names[target_clock_location] = "target_clock_location"
    _property_names[signal_delay] = "signal_delay"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalCollectionSignaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalCollectionSignaled)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionSignaled, [TimeToolEventIntervalCollectionSignaled, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4681123355224258665, 3519235201891138198), TimeToolEventIntervalCollectionSignaled)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionSignaled"] = TimeToolEventIntervalCollectionSignaled

class TimeToolEventIntervalFactory(SupportsDeleteCallback):
    """The factory creates event intervals."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_event_interval_fixed_method_offset = 2
    _create_event_interval_fixed_duration_method_offset = 3
    _create_event_interval_between_time_instants_method_offset = 4
    _create_event_interval_from_interval_list_method_offset = 5
    _create_event_interval_scaled_method_offset = 6
    _create_event_interval_signaled_method_offset = 7
    _create_event_interval_time_offset_method_offset = 8
    _is_type_supported_method_offset = 9
    _metadata = {
        "iid_data" : (4781822647992058058, 10338186051262684820),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_EVENT_INTERVAL_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_INTERVAL_TYPE") -> "ITimeToolEventInterval":
        """Create and register an interval using specified name, description, and type."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_metadata, name, description, type, OutArg())

    _create_event_interval_fixed_metadata = { "offset" : _create_event_interval_fixed_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_fixed(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval defined between two explicitly specified start and stop times."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_event_interval_fixed_metadata, name, description, OutArg())

    _create_event_interval_fixed_duration_metadata = { "offset" : _create_event_interval_fixed_duration_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_fixed_duration(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_event_interval_fixed_duration_metadata, name, description, OutArg())

    _create_event_interval_between_time_instants_metadata = { "offset" : _create_event_interval_between_time_instants_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_between_time_instants(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval using specified start and stop time instants."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_event_interval_between_time_instants_metadata, name, description, OutArg())

    _create_event_interval_from_interval_list_metadata = { "offset" : _create_event_interval_from_interval_list_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_from_interval_list(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval from a specified interval list by using one of several selection methods."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_event_interval_from_interval_list_metadata, name, description, OutArg())

    _create_event_interval_scaled_metadata = { "offset" : _create_event_interval_scaled_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_scaled(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval by scaling an original interval using either absolute or relative scale."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_event_interval_scaled_metadata, name, description, OutArg())

    _create_event_interval_signaled_metadata = { "offset" : _create_event_interval_signaled_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_signaled(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval that is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_event_interval_signaled_metadata, name, description, OutArg())

    _create_event_interval_time_offset_metadata = { "offset" : _create_event_interval_time_offset_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_time_offset(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval defined by shifting the specified reference interval by a fixed time offset."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._create_event_interval_time_offset_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_INTERVAL_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_INTERVAL_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(TimeToolEventIntervalFactory._metadata, TimeToolEventIntervalFactory._is_type_supported_metadata, eType, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFactory, [TimeToolEventIntervalFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5271144977203828184, 14422681085791257527), TimeToolEventIntervalFactory)
agcls.AgTypeNameMap["TimeToolEventIntervalFactory"] = TimeToolEventIntervalFactory

class TimeToolEventIntervalFixed(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_start_time_method_offset = 1
    _get_stop_time_method_offset = 2
    _set_interval_method_offset = 3
    _metadata = {
        "iid_data" : (4700629706653582627, 17112466619207988153),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalFixed)
    
    _get_start_time_metadata = { "offset" : _get_start_time_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def start_time(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(TimeToolEventIntervalFixed._metadata, TimeToolEventIntervalFixed._get_start_time_metadata)

    _get_stop_time_metadata = { "offset" : _get_stop_time_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def stop_time(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(TimeToolEventIntervalFixed._metadata, TimeToolEventIntervalFixed._get_stop_time_metadata)

    _set_interval_metadata = { "offset" : _set_interval_method_offset,
            "arg_types" : (agcom.Variant, agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg, agmarshall.VariantArg,) }
    def set_interval(self, startEpoch:typing.Any, stopEpoch:typing.Any) -> None:
        """Set interval's start and stop times."""
        return self._intf.invoke(TimeToolEventIntervalFixed._metadata, TimeToolEventIntervalFixed._set_interval_metadata, startEpoch, stopEpoch)

    _property_names[start_time] = "start_time"
    _property_names[stop_time] = "stop_time"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalFixed."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalFixed)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFixed, [TimeToolEventIntervalFixed, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5434382701560354571, 17399214976131420314), TimeToolEventIntervalFixed)
agcls.AgTypeNameMap["TimeToolEventIntervalFixed"] = TimeToolEventIntervalFixed

class TimeToolEventIntervalFixedDuration(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_time_instant_method_offset = 1
    _set_reference_time_instant_method_offset = 2
    _get_start_offset_method_offset = 3
    _set_start_offset_method_offset = 4
    _get_stop_offset_method_offset = 5
    _set_stop_offset_method_offset = 6
    _metadata = {
        "iid_data" : (5616504913797350155, 4594426271094609308),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalFixedDuration)
    
    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(TimeToolEventIntervalFixedDuration._metadata, TimeToolEventIntervalFixedDuration._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(TimeToolEventIntervalFixedDuration._metadata, TimeToolEventIntervalFixedDuration._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_start_offset_metadata = { "offset" : _get_start_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def start_offset(self) -> float:
        """The start time offset value."""
        return self._intf.get_property(TimeToolEventIntervalFixedDuration._metadata, TimeToolEventIntervalFixedDuration._get_start_offset_metadata)

    _set_start_offset_metadata = { "offset" : _set_start_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalFixedDuration._metadata, TimeToolEventIntervalFixedDuration._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "offset" : _get_stop_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def stop_offset(self) -> float:
        """The stop time offset value."""
        return self._intf.get_property(TimeToolEventIntervalFixedDuration._metadata, TimeToolEventIntervalFixedDuration._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "offset" : _set_stop_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalFixedDuration._metadata, TimeToolEventIntervalFixedDuration._set_stop_offset_metadata, stopOffset)

    _property_names[reference_time_instant] = "reference_time_instant"
    _property_names[start_offset] = "start_offset"
    _property_names[stop_offset] = "stop_offset"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalFixedDuration."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalFixedDuration)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFixedDuration, [TimeToolEventIntervalFixedDuration, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5617013323472138033, 5900512052836164536), TimeToolEventIntervalFixedDuration)
agcls.AgTypeNameMap["TimeToolEventIntervalFixedDuration"] = TimeToolEventIntervalFixedDuration

class TimeToolEventIntervalFromIntervalList(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval created from specified interval list by using one of several selection methods."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_intervals_method_offset = 1
    _set_reference_intervals_method_offset = 2
    _get_interval_selection_method_offset = 3
    _set_interval_selection_method_offset = 4
    _get_interval_number_method_offset = 5
    _set_interval_number_method_offset = 6
    _metadata = {
        "iid_data" : (5212467572212542000, 10268755993903263125),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalFromIntervalList)
    
    _get_reference_intervals_metadata = { "offset" : _get_reference_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(TimeToolEventIntervalFromIntervalList._metadata, TimeToolEventIntervalFromIntervalList._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "offset" : _set_reference_intervals_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventIntervalFromIntervalList._metadata, TimeToolEventIntervalFromIntervalList._set_reference_intervals_metadata, referenceIntervals)

    _get_interval_selection_metadata = { "offset" : _get_interval_selection_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_SELECTION),) }
    @property
    def interval_selection(self) -> "CRDN_INTERVAL_SELECTION":
        """The method used to select an interval from the reference interval list."""
        return self._intf.get_property(TimeToolEventIntervalFromIntervalList._metadata, TimeToolEventIntervalFromIntervalList._get_interval_selection_metadata)

    _set_interval_selection_metadata = { "offset" : _set_interval_selection_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_SELECTION),) }
    @interval_selection.setter
    def interval_selection(self, intervalSelection:"CRDN_INTERVAL_SELECTION") -> None:
        return self._intf.set_property(TimeToolEventIntervalFromIntervalList._metadata, TimeToolEventIntervalFromIntervalList._set_interval_selection_metadata, intervalSelection)

    _get_interval_number_metadata = { "offset" : _get_interval_number_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def interval_number(self) -> int:
        """An interval number. Applicable only if IntervalSelection is IntervalSelectionFromStart or IntervalSelectionFromEnd."""
        return self._intf.get_property(TimeToolEventIntervalFromIntervalList._metadata, TimeToolEventIntervalFromIntervalList._get_interval_number_metadata)

    _set_interval_number_metadata = { "offset" : _set_interval_number_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @interval_number.setter
    def interval_number(self, intervalNumber:int) -> None:
        return self._intf.set_property(TimeToolEventIntervalFromIntervalList._metadata, TimeToolEventIntervalFromIntervalList._set_interval_number_metadata, intervalNumber)

    _property_names[reference_intervals] = "reference_intervals"
    _property_names[interval_selection] = "interval_selection"
    _property_names[interval_number] = "interval_number"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalFromIntervalList."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalFromIntervalList)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFromIntervalList, [TimeToolEventIntervalFromIntervalList, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5605488631452751831, 17424609706075019906), TimeToolEventIntervalFromIntervalList)
agcls.AgTypeNameMap["TimeToolEventIntervalFromIntervalList"] = TimeToolEventIntervalFromIntervalList

class TimeToolEventIntervalList(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An ordered list of time intervals."""
    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalList."""
        SupportsDeleteCallback.__init__(self)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalList, [ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4931610229651409517, 5176676340500202392), TimeToolEventIntervalList)
agcls.AgTypeNameMap["TimeToolEventIntervalList"] = TimeToolEventIntervalList

class TimeToolEventIntervalListCondition(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_condition_method_offset = 1
    _set_condition_method_offset = 2
    _get_custom_time_limits_method_offset = 3
    _set_custom_time_limits_method_offset = 4
    _get_use_custom_time_limits_method_offset = 5
    _set_use_custom_time_limits_method_offset = 6
    _get_save_data_option_method_offset = 7
    _set_save_data_option_method_offset = 8
    _get_sampling_method_offset = 9
    _set_sampling_method_offset = 10
    _get_convergence_method_offset = 11
    _set_convergence_method_offset = 12
    _metadata = {
        "iid_data" : (5026707234268337802, 16142642421116537497),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListCondition)
    
    _get_condition_metadata = { "offset" : _get_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        return self._intf.get_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._get_condition_metadata)

    _set_condition_metadata = { "offset" : _set_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._set_condition_metadata, condition)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """The interval list or single interval within which intervals of satisfaction are sought. The specified value is used if UseCustomTimeLimits is true. The default is set to overall availability of host object..."""
        return self._intf.get_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "offset" : _get_save_data_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed intervals of satisfaction are saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "offset" : _set_save_data_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "offset" : _get_convergence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times for intervals of satisfaction are found."""
        return self._intf.get_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._get_convergence_metadata)

    _set_convergence_metadata = { "offset" : _set_convergence_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(TimeToolEventIntervalListCondition._metadata, TimeToolEventIntervalListCondition._set_convergence_metadata, convergence)

    _property_names[condition] = "condition"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[save_data_option] = "save_data_option"
    _property_names[sampling] = "sampling"
    _property_names[convergence] = "convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListCondition."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListCondition)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListCondition, [TimeToolEventIntervalListCondition, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5695291326310786302, 3161624783042523292), TimeToolEventIntervalListCondition)
agcls.AgTypeNameMap["TimeToolEventIntervalListCondition"] = TimeToolEventIntervalListCondition

class TimeToolEventIntervalListFactory(SupportsDeleteCallback):
    """The factory creates event interval lists."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_event_interval_list_merged_method_offset = 2
    _create_event_interval_list_filtered_method_offset = 3
    _create_event_interval_list_condition_method_offset = 4
    _create_event_interval_list_scaled_method_offset = 5
    _create_event_interval_list_signaled_method_offset = 6
    _create_event_interval_list_time_offset_method_offset = 7
    _is_type_supported_method_offset = 8
    _create_event_interval_list_file_method_offset = 9
    _create_event_interval_list_fixed_method_offset = 10
    _metadata = {
        "iid_data" : (4817877923312545831, 15527202984233884858),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_EVENT_INTERVAL_LIST_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_INTERVAL_LIST_TYPE") -> "ITimeToolEventIntervalList":
        """Create and register an interval list using specified name, description, and type."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_metadata, name, description, type, OutArg())

    _create_event_interval_list_merged_metadata = { "offset" : _create_event_interval_list_merged_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_merged(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list by merging two constituent interval lists using specified logical operation."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_merged_metadata, name, description, OutArg())

    _create_event_interval_list_filtered_metadata = { "offset" : _create_event_interval_list_filtered_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_filtered(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list by filtering intervals from original interval list using specified filtering method."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_filtered_metadata, name, description, OutArg())

    _create_event_interval_list_condition_metadata = { "offset" : _create_event_interval_list_condition_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_condition(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list containing intervals during which specified condition is satisfied."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_condition_metadata, name, description, OutArg())

    _create_event_interval_list_scaled_metadata = { "offset" : _create_event_interval_list_scaled_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_scaled(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list defined by scaling every interval in original interval list using either absolute or relative scale."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_scaled_metadata, name, description, OutArg())

    _create_event_interval_list_signaled_metadata = { "offset" : _create_event_interval_list_signaled_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_signaled(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list recorded at the target clock location by performing signal transmission of original interval list between base and target clock locations."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_signaled_metadata, name, description, OutArg())

    _create_event_interval_list_time_offset_metadata = { "offset" : _create_event_interval_list_time_offset_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_time_offset(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list defined by shifting the specified reference interval list by a fixed time offset."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_time_offset_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_INTERVAL_LIST_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_INTERVAL_LIST_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._is_type_supported_metadata, eType, OutArg())

    _create_event_interval_list_file_metadata = { "offset" : _create_event_interval_list_file_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_file(self, name:str, description:str, filePath:str) -> "ITimeToolEventIntervalList":
        """Create an interval list based on specified interval file."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_file_metadata, name, description, filePath, OutArg())

    _create_event_interval_list_fixed_metadata = { "offset" : _create_event_interval_list_fixed_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_event_interval_list_fixed(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
        return self._intf.invoke(TimeToolEventIntervalListFactory._metadata, TimeToolEventIntervalListFactory._create_event_interval_list_fixed_metadata, name, description, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFactory, [TimeToolEventIntervalListFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5520594195372287577, 9965002346799811229), TimeToolEventIntervalListFactory)
agcls.AgTypeNameMap["TimeToolEventIntervalListFactory"] = TimeToolEventIntervalListFactory

class TimeToolEventIntervalListFile(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filename_method_offset = 1
    _set_filename_method_offset = 2
    _reload_method_offset = 3
    _get_file_span_method_offset = 4
    _metadata = {
        "iid_data" : (4969943485407135988, 4215037281840912568),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListFile)
    
    _get_filename_metadata = { "offset" : _get_filename_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def filename(self) -> str:
        """The path of an external file that contains the time interval list."""
        return self._intf.get_property(TimeToolEventIntervalListFile._metadata, TimeToolEventIntervalListFile._get_filename_metadata)

    _set_filename_metadata = { "offset" : _set_filename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(TimeToolEventIntervalListFile._metadata, TimeToolEventIntervalListFile._set_filename_metadata, filename)

    _reload_metadata = { "offset" : _reload_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the interval list file."""
        return self._intf.invoke(TimeToolEventIntervalListFile._metadata, TimeToolEventIntervalListFile._reload_metadata, )

    _get_file_span_metadata = { "offset" : _get_file_span_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_file_span(self) -> "TimeToolEventIntervalResult":
        """Compute the interval list file span."""
        return self._intf.invoke(TimeToolEventIntervalListFile._metadata, TimeToolEventIntervalListFile._get_file_span_metadata, OutArg())

    _property_names[filename] = "filename"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListFile."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListFile)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFile, [TimeToolEventIntervalListFile, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4939698509197330113, 12995431996803870356), TimeToolEventIntervalListFile)
agcls.AgTypeNameMap["TimeToolEventIntervalListFile"] = TimeToolEventIntervalListFile

class TimeToolEventIntervalListFiltered(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined by filtering intervals from original interval list using specified filtering method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_intervals_method_offset = 1
    _set_original_intervals_method_offset = 2
    _get_filter_factory_method_offset = 3
    _get_filter_method_offset = 4
    _set_filter_method_offset = 5
    _metadata = {
        "iid_data" : (5362704445766881861, 6912538458780151178),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListFiltered)
    
    _get_original_intervals_metadata = { "offset" : _get_original_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_intervals(self) -> "ITimeToolEventIntervalList":
        """The original interval list."""
        return self._intf.get_property(TimeToolEventIntervalListFiltered._metadata, TimeToolEventIntervalListFiltered._get_original_intervals_metadata)

    _set_original_intervals_metadata = { "offset" : _set_original_intervals_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @original_intervals.setter
    def original_intervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventIntervalListFiltered._metadata, TimeToolEventIntervalListFiltered._set_original_intervals_metadata, originalIntervals)

    _get_filter_factory_metadata = { "offset" : _get_filter_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def filter_factory(self) -> "TimeToolPruneFilterFactory":
        """Get the prune filter factory."""
        return self._intf.get_property(TimeToolEventIntervalListFiltered._metadata, TimeToolEventIntervalListFiltered._get_filter_factory_metadata)

    _get_filter_metadata = { "offset" : _get_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def filter(self) -> "ITimeToolPruneFilter":
        """The pruning filter."""
        return self._intf.get_property(TimeToolEventIntervalListFiltered._metadata, TimeToolEventIntervalListFiltered._get_filter_metadata)

    _set_filter_metadata = { "offset" : _set_filter_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolPruneFilter"),) }
    @filter.setter
    def filter(self, filter:"ITimeToolPruneFilter") -> None:
        return self._intf.set_property(TimeToolEventIntervalListFiltered._metadata, TimeToolEventIntervalListFiltered._set_filter_metadata, filter)

    _property_names[original_intervals] = "original_intervals"
    _property_names[filter_factory] = "filter_factory"
    _property_names[filter] = "filter"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListFiltered."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListFiltered)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFiltered, [TimeToolEventIntervalListFiltered, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4625969561133636137, 1394880749826965914), TimeToolEventIntervalListFiltered)
agcls.AgTypeNameMap["TimeToolEventIntervalListFiltered"] = TimeToolEventIntervalListFiltered

class TimeToolEventIntervalListFixed(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_intervals_method_offset = 1
    _set_intervals_method_offset = 2
    _metadata = {
        "iid_data" : (5035651772834666939, 4266315594091686530),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListFixed)
    
    _get_intervals_metadata = { "offset" : _get_intervals_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def get_intervals(self) -> list:
        """Get intervals with explicitly specified start and stop times from interval list. The method returns a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        return self._intf.invoke(TimeToolEventIntervalListFixed._metadata, TimeToolEventIntervalListFixed._get_intervals_metadata, OutArg())

    _set_intervals_metadata = { "offset" : _set_intervals_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_intervals(self, intervals:list) -> None:
        """Set interval list from intervals with explicitly specified start and stop times. The method takes a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        return self._intf.invoke(TimeToolEventIntervalListFixed._metadata, TimeToolEventIntervalListFixed._set_intervals_metadata, intervals)


    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListFixed."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListFixed)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFixed, [TimeToolEventIntervalListFixed, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5035876072746351075, 10259654735031477925), TimeToolEventIntervalListFixed)
agcls.AgTypeNameMap["TimeToolEventIntervalListFixed"] = TimeToolEventIntervalListFixed

class TimeToolEventIntervalListMerged(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""

    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_interval_list_or_interval_a_method_offset = 1
    _get_interval_list_or_interval_b_method_offset = 2
    _get_merge_operation_method_offset = 3
    _set_merge_operation_method_offset = 4
    _set_interval_list_a_method_offset = 5
    _set_interval_a_method_offset = 6
    _set_interval_list_b_method_offset = 7
    _set_interval_b_method_offset = 8
    _add_interval_method_offset = 9
    _add_interval_list_method_offset = 10
    _set_interval_method_offset = 11
    _set_interval_list_method_offset = 12
    _get_time_component_method_offset = 13
    _get_time_component_size_method_offset = 14
    _remove_time_component_method_offset = 15
    _metadata = {
        "iid_data" : (5336865813588725345, 16270761028594191753),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListMerged)
    
    _get_interval_list_or_interval_a_metadata = { "offset" : _get_interval_list_or_interval_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interval_list_or_interval_a(self) -> "IAnalysisWorkbenchComponent":
        """The interval list or interval A."""
        return self._intf.get_property(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._get_interval_list_or_interval_a_metadata)

    _get_interval_list_or_interval_b_metadata = { "offset" : _get_interval_list_or_interval_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interval_list_or_interval_b(self) -> "IAnalysisWorkbenchComponent":
        """The interval list or interval B."""
        return self._intf.get_property(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._get_interval_list_or_interval_b_metadata)

    _get_merge_operation_metadata = { "offset" : _get_merge_operation_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_LIST_MERGE_OPERATION),) }
    @property
    def merge_operation(self) -> "CRDN_EVENT_LIST_MERGE_OPERATION":
        """The merge operation."""
        return self._intf.get_property(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._get_merge_operation_metadata)

    _set_merge_operation_metadata = { "offset" : _set_merge_operation_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_EVENT_LIST_MERGE_OPERATION),) }
    @merge_operation.setter
    def merge_operation(self, mergeOperation:"CRDN_EVENT_LIST_MERGE_OPERATION") -> None:
        return self._intf.set_property(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._set_merge_operation_metadata, mergeOperation)

    _set_interval_list_a_metadata = { "offset" : _set_interval_list_a_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    def set_interval_list_a(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Set the interval list A."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._set_interval_list_a_metadata, refIntervals)

    _set_interval_a_metadata = { "offset" : _set_interval_a_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    def set_interval_a(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Set the interval A."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._set_interval_a_metadata, refIntervals)

    _set_interval_list_b_metadata = { "offset" : _set_interval_list_b_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    def set_interval_list_b(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Set the interval list B."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._set_interval_list_b_metadata, refIntervals)

    _set_interval_b_metadata = { "offset" : _set_interval_b_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    def set_interval_b(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Set the interval B."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._set_interval_b_metadata, refIntervals)

    _add_interval_metadata = { "offset" : _add_interval_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    def add_interval(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Add interval."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._add_interval_metadata, refIntervals)

    _add_interval_list_metadata = { "offset" : _add_interval_list_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    def add_interval_list(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Add interval list."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._add_interval_list_metadata, refIntervals)

    _set_interval_metadata = { "offset" : _set_interval_method_offset,
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"), agmarshall.IntArg,) }
    def set_interval(self, refIntervals:"ITimeToolEventInterval", pos:int) -> None:
        """Set the interval at given index."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._set_interval_metadata, refIntervals, pos)

    _set_interval_list_metadata = { "offset" : _set_interval_list_method_offset,
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"), agmarshall.IntArg,) }
    def set_interval_list(self, refIntervals:"ITimeToolEventIntervalList", pos:int) -> None:
        """Set the interval list at given index."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._set_interval_list_metadata, refIntervals, pos)

    _get_time_component_metadata = { "offset" : _get_time_component_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.IntArg, agmarshall.BStrArg,) }
    def get_time_component(self, pos:int) -> str:
        """Get time component at given position."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._get_time_component_metadata, pos, OutArg())

    _get_time_component_size_metadata = { "offset" : _get_time_component_size_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    def get_time_component_size(self) -> int:
        """Get time component list size."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._get_time_component_size_metadata, OutArg())

    _remove_time_component_metadata = { "offset" : _remove_time_component_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    def remove_time_component(self, pos:int) -> None:
        """Remove time component at given position."""
        return self._intf.invoke(TimeToolEventIntervalListMerged._metadata, TimeToolEventIntervalListMerged._remove_time_component_metadata, pos)

    _property_names[interval_list_or_interval_a] = "interval_list_or_interval_a"
    _property_names[interval_list_or_interval_b] = "interval_list_or_interval_b"
    _property_names[merge_operation] = "merge_operation"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListMerged."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListMerged)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListMerged, [TimeToolEventIntervalListMerged, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5271487708003070052, 15898448361769664948), TimeToolEventIntervalListMerged)
agcls.AgTypeNameMap["TimeToolEventIntervalListMerged"] = TimeToolEventIntervalListMerged

class TimeToolEventIntervalListScaled(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_intervals_method_offset = 1
    _set_original_intervals_method_offset = 2
    _get_absolute_increment_method_offset = 3
    _set_absolute_increment_method_offset = 4
    _get_relative_increment_method_offset = 5
    _set_relative_increment_method_offset = 6
    _get_use_absolute_increment_method_offset = 7
    _set_use_absolute_increment_method_offset = 8
    _metadata = {
        "iid_data" : (5066170491909867768, 15012607590605642908),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListScaled)
    
    _get_original_intervals_metadata = { "offset" : _get_original_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_intervals(self) -> "ITimeToolEventIntervalList":
        """The original interval list."""
        return self._intf.get_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._get_original_intervals_metadata)

    _set_original_intervals_metadata = { "offset" : _set_original_intervals_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @original_intervals.setter
    def original_intervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._set_original_intervals_metadata, originalIntervals)

    _get_absolute_increment_metadata = { "offset" : _get_absolute_increment_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def absolute_increment(self) -> float:
        """The absolute increment value which creates a new interval list by expanding (or shortening if negative) every interval in the original interval list by shifting interval's start/stop times equally by half of specified increment value."""
        return self._intf.get_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._get_absolute_increment_metadata)

    _set_absolute_increment_metadata = { "offset" : _set_absolute_increment_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @absolute_increment.setter
    def absolute_increment(self, absoluteIncrement:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._set_absolute_increment_metadata, absoluteIncrement)

    _get_relative_increment_metadata = { "offset" : _get_relative_increment_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def relative_increment(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        return self._intf.get_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._get_relative_increment_metadata)

    _set_relative_increment_metadata = { "offset" : _set_relative_increment_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @relative_increment.setter
    def relative_increment(self, relativeIncrement:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._set_relative_increment_metadata, relativeIncrement)

    _get_use_absolute_increment_metadata = { "offset" : _get_use_absolute_increment_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_absolute_increment(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        return self._intf.get_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._get_use_absolute_increment_metadata)

    _set_use_absolute_increment_metadata = { "offset" : _set_use_absolute_increment_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_absolute_increment.setter
    def use_absolute_increment(self, useAbsoluteIncrement:bool) -> None:
        return self._intf.set_property(TimeToolEventIntervalListScaled._metadata, TimeToolEventIntervalListScaled._set_use_absolute_increment_metadata, useAbsoluteIncrement)

    _property_names[original_intervals] = "original_intervals"
    _property_names[absolute_increment] = "absolute_increment"
    _property_names[relative_increment] = "relative_increment"
    _property_names[use_absolute_increment] = "use_absolute_increment"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListScaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListScaled)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListScaled, [TimeToolEventIntervalListScaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5135112674452953850, 13376159879454619046), TimeToolEventIntervalListScaled)
agcls.AgTypeNameMap["TimeToolEventIntervalListScaled"] = TimeToolEventIntervalListScaled

class TimeToolEventIntervalListSignaled(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Determine what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_intervals_method_offset = 1
    _set_original_intervals_method_offset = 2
    _get_signal_sense_method_offset = 3
    _set_signal_sense_method_offset = 4
    _get_base_clock_location_method_offset = 5
    _set_base_clock_location_method_offset = 6
    _get_target_clock_location_method_offset = 7
    _set_target_clock_location_method_offset = 8
    _get_signal_delay_method_offset = 9
    _set_signal_delay_method_offset = 10
    _metadata = {
        "iid_data" : (5408509073392837198, 4033135434938257290),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListSignaled)
    
    _get_original_intervals_metadata = { "offset" : _get_original_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_intervals(self) -> "ITimeToolEventIntervalList":
        """The original time interval list."""
        return self._intf.get_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._get_original_intervals_metadata)

    _set_original_intervals_metadata = { "offset" : _set_original_intervals_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @original_intervals.setter
    def original_intervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._set_original_intervals_metadata, originalIntervals)

    _get_signal_sense_metadata = { "offset" : _get_signal_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "offset" : _set_signal_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "offset" : _get_base_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "offset" : _set_base_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "offset" : _get_target_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "offset" : _set_target_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "offset" : _get_signal_delay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "offset" : _set_signal_delay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(TimeToolEventIntervalListSignaled._metadata, TimeToolEventIntervalListSignaled._set_signal_delay_metadata, signalDelay)

    _property_names[original_intervals] = "original_intervals"
    _property_names[signal_sense] = "signal_sense"
    _property_names[base_clock_location] = "base_clock_location"
    _property_names[target_clock_location] = "target_clock_location"
    _property_names[signal_delay] = "signal_delay"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListSignaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListSignaled)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListSignaled, [TimeToolEventIntervalListSignaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5092160389376989615, 317323019564379040), TimeToolEventIntervalListSignaled)
agcls.AgTypeNameMap["TimeToolEventIntervalListSignaled"] = TimeToolEventIntervalListSignaled

class TimeToolEventIntervalListTimeOffset(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_intervals_method_offset = 1
    _set_reference_intervals_method_offset = 2
    _get_time_offset_method_offset = 3
    _set_time_offset_method_offset = 4
    _metadata = {
        "iid_data" : (4727529051409948883, 15038220645091515569),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalListTimeOffset)
    
    _get_reference_intervals_metadata = { "offset" : _get_reference_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(TimeToolEventIntervalListTimeOffset._metadata, TimeToolEventIntervalListTimeOffset._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "offset" : _set_reference_intervals_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(TimeToolEventIntervalListTimeOffset._metadata, TimeToolEventIntervalListTimeOffset._set_reference_intervals_metadata, referenceIntervals)

    _get_time_offset_metadata = { "offset" : _get_time_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_offset(self) -> float:
        """The time offset."""
        return self._intf.get_property(TimeToolEventIntervalListTimeOffset._metadata, TimeToolEventIntervalListTimeOffset._get_time_offset_metadata)

    _set_time_offset_metadata = { "offset" : _set_time_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_offset.setter
    def time_offset(self, timeOffset:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalListTimeOffset._metadata, TimeToolEventIntervalListTimeOffset._set_time_offset_metadata, timeOffset)

    _property_names[reference_intervals] = "reference_intervals"
    _property_names[time_offset] = "time_offset"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalListTimeOffset."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalListTimeOffset)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListTimeOffset, [TimeToolEventIntervalListTimeOffset, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5150624900174320789, 5541852546161415593), TimeToolEventIntervalListTimeOffset)
agcls.AgTypeNameMap["TimeToolEventIntervalListTimeOffset"] = TimeToolEventIntervalListTimeOffset

class TimeToolEventIntervalScaled(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_interval_method_offset = 1
    _set_original_interval_method_offset = 2
    _get_absolute_increment_method_offset = 3
    _set_absolute_increment_method_offset = 4
    _get_relative_increment_method_offset = 5
    _set_relative_increment_method_offset = 6
    _get_use_absolute_increment_method_offset = 7
    _set_use_absolute_increment_method_offset = 8
    _metadata = {
        "iid_data" : (5153652075809608699, 13548435864393192877),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalScaled)
    
    _get_original_interval_metadata = { "offset" : _get_original_interval_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_interval(self) -> "ITimeToolEventInterval":
        """The original interval."""
        return self._intf.get_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._get_original_interval_metadata)

    _set_original_interval_metadata = { "offset" : _set_original_interval_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    @original_interval.setter
    def original_interval(self, originalInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._set_original_interval_metadata, originalInterval)

    _get_absolute_increment_metadata = { "offset" : _get_absolute_increment_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def absolute_increment(self) -> float:
        """The absolute increment value which creates a interval by expanding (or shortening if negative) the original interval by shifting its start/stop times equally by half of specified increment value."""
        return self._intf.get_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._get_absolute_increment_metadata)

    _set_absolute_increment_metadata = { "offset" : _set_absolute_increment_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @absolute_increment.setter
    def absolute_increment(self, absoluteIncrement:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._set_absolute_increment_metadata, absoluteIncrement)

    _get_relative_increment_metadata = { "offset" : _get_relative_increment_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def relative_increment(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        return self._intf.get_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._get_relative_increment_metadata)

    _set_relative_increment_metadata = { "offset" : _set_relative_increment_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @relative_increment.setter
    def relative_increment(self, relativeIncrement:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._set_relative_increment_metadata, relativeIncrement)

    _get_use_absolute_increment_metadata = { "offset" : _get_use_absolute_increment_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_absolute_increment(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        return self._intf.get_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._get_use_absolute_increment_metadata)

    _set_use_absolute_increment_metadata = { "offset" : _set_use_absolute_increment_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_absolute_increment.setter
    def use_absolute_increment(self, useAbsoluteIncrement:bool) -> None:
        return self._intf.set_property(TimeToolEventIntervalScaled._metadata, TimeToolEventIntervalScaled._set_use_absolute_increment_metadata, useAbsoluteIncrement)

    _property_names[original_interval] = "original_interval"
    _property_names[absolute_increment] = "absolute_increment"
    _property_names[relative_increment] = "relative_increment"
    _property_names[use_absolute_increment] = "use_absolute_increment"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalScaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalScaled)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalScaled, [TimeToolEventIntervalScaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5407853737749222524, 4515930083547027092), TimeToolEventIntervalScaled)
agcls.AgTypeNameMap["TimeToolEventIntervalScaled"] = TimeToolEventIntervalScaled

class TimeToolEventIntervalSignaled(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Determine what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_interval_method_offset = 1
    _set_original_interval_method_offset = 2
    _get_signal_sense_method_offset = 3
    _set_signal_sense_method_offset = 4
    _get_base_clock_location_method_offset = 5
    _set_base_clock_location_method_offset = 6
    _get_target_clock_location_method_offset = 7
    _set_target_clock_location_method_offset = 8
    _get_signal_delay_method_offset = 9
    _set_signal_delay_method_offset = 10
    _metadata = {
        "iid_data" : (4661949231789629063, 5033190062846728106),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalSignaled)
    
    _get_original_interval_metadata = { "offset" : _get_original_interval_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_interval(self) -> "ITimeToolEventInterval":
        """The original interval."""
        return self._intf.get_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._get_original_interval_metadata)

    _set_original_interval_metadata = { "offset" : _set_original_interval_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    @original_interval.setter
    def original_interval(self, originalInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._set_original_interval_metadata, originalInterval)

    _get_signal_sense_metadata = { "offset" : _get_signal_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        return self._intf.get_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "offset" : _set_signal_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "offset" : _get_base_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "offset" : _set_base_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "offset" : _get_target_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "offset" : _set_target_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "offset" : _get_signal_delay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "offset" : _set_signal_delay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(TimeToolEventIntervalSignaled._metadata, TimeToolEventIntervalSignaled._set_signal_delay_metadata, signalDelay)

    _property_names[original_interval] = "original_interval"
    _property_names[signal_sense] = "signal_sense"
    _property_names[base_clock_location] = "base_clock_location"
    _property_names[target_clock_location] = "target_clock_location"
    _property_names[signal_delay] = "signal_delay"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalSignaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalSignaled)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalSignaled, [TimeToolEventIntervalSignaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5146912718400089076, 7977322097241354916), TimeToolEventIntervalSignaled)
agcls.AgTypeNameMap["TimeToolEventIntervalSignaled"] = TimeToolEventIntervalSignaled

class TimeToolEventIntervalSmartInterval(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A smart interval."""

    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_interval_method_offset = 1
    _get_duration_as_string_method_offset = 2
    _set_duration_as_string_method_offset = 3
    _get_state_method_offset = 4
    _set_state_method_offset = 5
    _set_implicit_interval_method_offset = 6
    _find_start_time_method_offset = 7
    _find_stop_time_method_offset = 8
    _get_start_epoch_method_offset = 9
    _set_start_epoch_method_offset = 10
    _get_stop_epoch_method_offset = 11
    _set_stop_epoch_method_offset = 12
    _set_explicit_interval_method_offset = 13
    _set_start_and_stop_epochs_method_offset = 14
    _set_start_and_stop_times_method_offset = 15
    _set_start_epoch_and_duration_method_offset = 16
    _set_start_time_and_duration_method_offset = 17
    _metadata = {
        "iid_data" : (4625607466421251572, 4331861431364410030),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalSmartInterval)
    
    _get_reference_interval_metadata = { "offset" : _get_reference_interval_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_interval(self) -> "ITimeToolEventInterval":
        """The reference interval used to compute start/stop times of this interval if the state of the interval is set to implicit."""
        return self._intf.get_property(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._get_reference_interval_metadata)

    _get_duration_as_string_metadata = { "offset" : _get_duration_as_string_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def duration_as_string(self) -> str:
        """The duration of the interval."""
        return self._intf.get_property(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._get_duration_as_string_metadata)

    _set_duration_as_string_metadata = { "offset" : _set_duration_as_string_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @duration_as_string.setter
    def duration_as_string(self, durationAsString:str) -> None:
        return self._intf.set_property(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_duration_as_string_metadata, durationAsString)

    _get_state_metadata = { "offset" : _get_state_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SMART_INTERVAL_STATE),) }
    @property
    def state(self) -> "CRDN_SMART_INTERVAL_STATE":
        """A state of the smart interval."""
        return self._intf.get_property(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._get_state_metadata)

    _set_state_metadata = { "offset" : _set_state_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SMART_INTERVAL_STATE),) }
    @state.setter
    def state(self, state:"CRDN_SMART_INTERVAL_STATE") -> None:
        return self._intf.set_property(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_state_metadata, state)

    _set_implicit_interval_metadata = { "offset" : _set_implicit_interval_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    def set_implicit_interval(self, eventInterval:"ITimeToolEventInterval") -> None:
        """Set the reference interval and changes the state to Implicit."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_implicit_interval_metadata, eventInterval)

    _find_start_time_metadata = { "offset" : _find_start_time_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    def find_start_time(self) -> typing.Any:
        """Find a start time of the interval. An exception is thrown if the start time cannot be determined from the interval's current state."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._find_start_time_metadata, OutArg())

    _find_stop_time_metadata = { "offset" : _find_stop_time_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    def find_stop_time(self) -> typing.Any:
        """Find a stop time of the interval. An exception is thrown if the stop time cannot be determined from the interval's current state."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._find_stop_time_metadata, OutArg())

    _get_start_epoch_metadata = { "offset" : _get_start_epoch_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_start_epoch(self) -> "TimeToolEventSmartEpoch":
        """Return a copy of the start epoch. Changes to the epoch will not affect the state of the interval."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._get_start_epoch_metadata, OutArg())

    _set_start_epoch_metadata = { "offset" : _set_start_epoch_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("TimeToolEventSmartEpoch"),) }
    def set_start_epoch(self, startEpoch:"TimeToolEventSmartEpoch") -> None:
        """Set a start of the interval using specified epoch component."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_start_epoch_metadata, startEpoch)

    _get_stop_epoch_metadata = { "offset" : _get_stop_epoch_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_stop_epoch(self) -> "TimeToolEventSmartEpoch":
        """Return a copy of the stop epoch. Changes to the epoch will not affect the state of the interval."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._get_stop_epoch_metadata, OutArg())

    _set_stop_epoch_metadata = { "offset" : _set_stop_epoch_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("TimeToolEventSmartEpoch"),) }
    def set_stop_epoch(self, stopEpoch:"TimeToolEventSmartEpoch") -> None:
        """Set a stop of the interval using specified epoch component."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_stop_epoch_metadata, stopEpoch)

    _set_explicit_interval_metadata = { "offset" : _set_explicit_interval_method_offset,
            "arg_types" : (agcom.Variant, agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg, agmarshall.VariantArg,) }
    def set_explicit_interval(self, start:typing.Any, stop:typing.Any) -> None:
        """Set the interval's start and the stop times changes the interval's state to explicit. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_explicit_interval_metadata, start, stop)

    _set_start_and_stop_epochs_metadata = { "offset" : _set_start_and_stop_epochs_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("TimeToolEventSmartEpoch"), agmarshall.InterfaceInArg("TimeToolEventSmartEpoch"),) }
    def set_start_and_stop_epochs(self, refStartEpoch:"TimeToolEventSmartEpoch", refStopEpoch:"TimeToolEventSmartEpoch") -> None:
        """Set the interval's start and stop epochs as two smart epoch components. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_start_and_stop_epochs_metadata, refStartEpoch, refStopEpoch)

    _set_start_and_stop_times_metadata = { "offset" : _set_start_and_stop_times_method_offset,
            "arg_types" : (agcom.Variant, agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg, agmarshall.VariantArg,) }
    def set_start_and_stop_times(self, startTime:typing.Any, stopTime:typing.Any) -> None:
        """Set the interval's start and stop epochs as explicit times. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_start_and_stop_times_metadata, startTime, stopTime)

    _set_start_epoch_and_duration_metadata = { "offset" : _set_start_epoch_and_duration_method_offset,
            "arg_types" : (agcom.PVOID, agcom.BSTR,),
            "marshallers" : (agmarshall.InterfaceInArg("TimeToolEventSmartEpoch"), agmarshall.BStrArg,) }
    def set_start_epoch_and_duration(self, refStartEpoch:"TimeToolEventSmartEpoch", durationStr:str) -> None:
        """Set the interval's start epoch and the interval's duration."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_start_epoch_and_duration_metadata, refStartEpoch, durationStr)

    _set_start_time_and_duration_metadata = { "offset" : _set_start_time_and_duration_method_offset,
            "arg_types" : (agcom.Variant, agcom.BSTR,),
            "marshallers" : (agmarshall.VariantArg, agmarshall.BStrArg,) }
    def set_start_time_and_duration(self, epoch:typing.Any, durationStr:str) -> None:
        """Set the interval's start time and the interval's duration."""
        return self._intf.invoke(TimeToolEventIntervalSmartInterval._metadata, TimeToolEventIntervalSmartInterval._set_start_time_and_duration_metadata, epoch, durationStr)

    _property_names[reference_interval] = "reference_interval"
    _property_names[duration_as_string] = "duration_as_string"
    _property_names[state] = "state"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalSmartInterval."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalSmartInterval)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalSmartInterval, [TimeToolEventIntervalSmartInterval, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5123187924205363884, 5573303980465739693), TimeToolEventIntervalSmartInterval)
agcls.AgTypeNameMap["TimeToolEventIntervalSmartInterval"] = TimeToolEventIntervalSmartInterval

class TimeToolEventIntervalTimeOffset(ITimeToolEventInterval, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interval defined by shifting specified reference interval by fixed time offset."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_interval_method_offset = 1
    _set_reference_interval_method_offset = 2
    _get_time_offset_method_offset = 3
    _set_time_offset_method_offset = 4
    _metadata = {
        "iid_data" : (4829788478522900189, 18194221658270060953),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventIntervalTimeOffset)
    
    _get_reference_interval_metadata = { "offset" : _get_reference_interval_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_interval(self) -> "ITimeToolEventInterval":
        """The reference interval."""
        return self._intf.get_property(TimeToolEventIntervalTimeOffset._metadata, TimeToolEventIntervalTimeOffset._get_reference_interval_metadata)

    _set_reference_interval_metadata = { "offset" : _set_reference_interval_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    @reference_interval.setter
    def reference_interval(self, referenceInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(TimeToolEventIntervalTimeOffset._metadata, TimeToolEventIntervalTimeOffset._set_reference_interval_metadata, referenceInterval)

    _get_time_offset_metadata = { "offset" : _get_time_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_offset(self) -> float:
        """The time offset value."""
        return self._intf.get_property(TimeToolEventIntervalTimeOffset._metadata, TimeToolEventIntervalTimeOffset._get_time_offset_metadata)

    _set_time_offset_metadata = { "offset" : _set_time_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_offset.setter
    def time_offset(self, timeOffset:float) -> None:
        return self._intf.set_property(TimeToolEventIntervalTimeOffset._metadata, TimeToolEventIntervalTimeOffset._set_time_offset_metadata, timeOffset)

    _property_names[reference_interval] = "reference_interval"
    _property_names[time_offset] = "time_offset"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventIntervalTimeOffset."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventIntervalTimeOffset)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventIntervalTimeOffset, [TimeToolEventIntervalTimeOffset, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5594696185291586304, 7469384033316253831), TimeToolEventIntervalTimeOffset)
agcls.AgTypeNameMap["TimeToolEventIntervalTimeOffset"] = TimeToolEventIntervalTimeOffset

class TimeToolEventSignaled(ITimeToolEvent, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_original_time_instant_method_offset = 1
    _set_original_time_instant_method_offset = 2
    _get_signal_sense_method_offset = 3
    _set_signal_sense_method_offset = 4
    _get_base_clock_location_method_offset = 5
    _set_base_clock_location_method_offset = 6
    _get_target_clock_location_method_offset = 7
    _set_target_clock_location_method_offset = 8
    _get_signal_delay_method_offset = 9
    _set_signal_delay_method_offset = 10
    _metadata = {
        "iid_data" : (5072103158722034880, 4341972865712102555),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventSignaled)
    
    _get_original_time_instant_metadata = { "offset" : _get_original_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def original_time_instant(self) -> "ITimeToolEvent":
        """The original time instant."""
        return self._intf.get_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._get_original_time_instant_metadata)

    _set_original_time_instant_metadata = { "offset" : _set_original_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @original_time_instant.setter
    def original_time_instant(self, originalTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._set_original_time_instant_metadata, originalTimeInstant)

    _get_signal_sense_metadata = { "offset" : _get_signal_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        return self._intf.get_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "offset" : _set_signal_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "offset" : _get_base_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "offset" : _set_base_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "offset" : _get_target_clock_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "offset" : _set_target_clock_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "offset" : _get_signal_delay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "offset" : _set_signal_delay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(TimeToolEventSignaled._metadata, TimeToolEventSignaled._set_signal_delay_metadata, signalDelay)

    _property_names[original_time_instant] = "original_time_instant"
    _property_names[signal_sense] = "signal_sense"
    _property_names[base_clock_location] = "base_clock_location"
    _property_names[target_clock_location] = "target_clock_location"
    _property_names[signal_delay] = "signal_delay"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventSignaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventSignaled)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventSignaled, [TimeToolEventSignaled, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5693916528422022973, 3263658904170695863), TimeToolEventSignaled)
agcls.AgTypeNameMap["TimeToolEventSignaled"] = TimeToolEventSignaled

class TimeToolEventSmartEpoch(ITimeToolEvent, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A smart epoch."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_time_instant_method_offset = 1
    _get_reference_event_method_offset = 2
    _get_state_method_offset = 3
    _set_state_method_offset = 4
    _set_explicit_time_method_offset = 5
    _set_implicit_time_method_offset = 6
    _metadata = {
        "iid_data" : (5299430079025464053, 2983292493577895056),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventSmartEpoch)
    
    _get_time_instant_metadata = { "offset" : _get_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def time_instant(self) -> typing.Any:
        """Represents the time instant if the state is set to explicit."""
        return self._intf.get_property(TimeToolEventSmartEpoch._metadata, TimeToolEventSmartEpoch._get_time_instant_metadata)

    _get_reference_event_metadata = { "offset" : _get_reference_event_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_event(self) -> "ITimeToolEvent":
        """A reference event object used to compute time instant if the state is set to implicit."""
        return self._intf.get_property(TimeToolEventSmartEpoch._metadata, TimeToolEventSmartEpoch._get_reference_event_metadata)

    _get_state_metadata = { "offset" : _get_state_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SMART_EPOCH_STATE),) }
    @property
    def state(self) -> "CRDN_SMART_EPOCH_STATE":
        """State of the event."""
        return self._intf.get_property(TimeToolEventSmartEpoch._metadata, TimeToolEventSmartEpoch._get_state_metadata)

    _set_state_metadata = { "offset" : _set_state_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SMART_EPOCH_STATE),) }
    @state.setter
    def state(self, state:"CRDN_SMART_EPOCH_STATE") -> None:
        return self._intf.set_property(TimeToolEventSmartEpoch._metadata, TimeToolEventSmartEpoch._set_state_metadata, state)

    _set_explicit_time_metadata = { "offset" : _set_explicit_time_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    def set_explicit_time(self, epoch:typing.Any) -> None:
        """Set explicit time instant and the smart epoch's state to Explicit."""
        return self._intf.invoke(TimeToolEventSmartEpoch._metadata, TimeToolEventSmartEpoch._set_explicit_time_metadata, epoch)

    _set_implicit_time_metadata = { "offset" : _set_implicit_time_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    def set_implicit_time(self, eventEpoch:"ITimeToolEvent") -> None:
        """Set the reference event and the smart epoch's state to Implicit."""
        return self._intf.invoke(TimeToolEventSmartEpoch._metadata, TimeToolEventSmartEpoch._set_implicit_time_metadata, eventEpoch)

    _property_names[time_instant] = "time_instant"
    _property_names[reference_event] = "reference_event"
    _property_names[state] = "state"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventSmartEpoch."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventSmartEpoch)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventSmartEpoch, [TimeToolEventSmartEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5284572681912631891, 10588360420919622552), TimeToolEventSmartEpoch)
agcls.AgTypeNameMap["TimeToolEventSmartEpoch"] = TimeToolEventSmartEpoch

class TimeToolEventStartStopTime(ITimeToolEvent, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Event is either start or stop time selected from a reference interval."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_use_start_method_offset = 1
    _set_use_start_method_offset = 2
    _get_reference_event_interval_method_offset = 3
    _set_reference_event_interval_method_offset = 4
    _metadata = {
        "iid_data" : (4785383463426884876, 6466418643845985677),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventStartStopTime)
    
    _get_use_start_metadata = { "offset" : _get_use_start_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_start(self) -> bool:
        """Indicate whether to use start (true) or stop (false)."""
        return self._intf.get_property(TimeToolEventStartStopTime._metadata, TimeToolEventStartStopTime._get_use_start_metadata)

    _set_use_start_metadata = { "offset" : _set_use_start_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_start.setter
    def use_start(self, useStart:bool) -> None:
        return self._intf.set_property(TimeToolEventStartStopTime._metadata, TimeToolEventStartStopTime._set_use_start_metadata, useStart)

    _get_reference_event_interval_metadata = { "offset" : _get_reference_event_interval_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_event_interval(self) -> "ITimeToolEventInterval":
        """The reference interval."""
        return self._intf.get_property(TimeToolEventStartStopTime._metadata, TimeToolEventStartStopTime._get_reference_event_interval_metadata)

    _set_reference_event_interval_metadata = { "offset" : _set_reference_event_interval_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventInterval"),) }
    @reference_event_interval.setter
    def reference_event_interval(self, referenceEventInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(TimeToolEventStartStopTime._metadata, TimeToolEventStartStopTime._set_reference_event_interval_metadata, referenceEventInterval)

    _property_names[use_start] = "use_start"
    _property_names[reference_event_interval] = "reference_event_interval"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventStartStopTime."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventStartStopTime)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventStartStopTime, [TimeToolEventStartStopTime, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5286281606334682631, 1156813953277887129), TimeToolEventStartStopTime)
agcls.AgTypeNameMap["TimeToolEventStartStopTime"] = TimeToolEventStartStopTime

class TimeToolEventTimeOffset(ITimeToolEvent, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Event at fixed offset from specified reference event."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_time_instant_method_offset = 1
    _set_reference_time_instant_method_offset = 2
    _get_time_offset2_method_offset = 3
    _set_time_offset2_method_offset = 4
    _metadata = {
        "iid_data" : (4849369508245529166, 13064483229774346402),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolEventTimeOffset)
    
    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(TimeToolEventTimeOffset._metadata, TimeToolEventTimeOffset._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(TimeToolEventTimeOffset._metadata, TimeToolEventTimeOffset._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_time_offset2_metadata = { "offset" : _get_time_offset2_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_offset2(self) -> float:
        """The time offset from the ReferenceTimeInstant. The value is in ``TimeUnit`` dimension."""
        return self._intf.get_property(TimeToolEventTimeOffset._metadata, TimeToolEventTimeOffset._get_time_offset2_metadata)

    _set_time_offset2_metadata = { "offset" : _set_time_offset2_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_offset2.setter
    def time_offset2(self, timeOffset2:float) -> None:
        return self._intf.set_property(TimeToolEventTimeOffset._metadata, TimeToolEventTimeOffset._set_time_offset2_metadata, timeOffset2)

    _property_names[reference_time_instant] = "reference_time_instant"
    _property_names[time_offset2] = "time_offset2"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolEventTimeOffset."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolEventTimeOffset)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolEventTimeOffset, [TimeToolEventTimeOffset, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4631038835821414856, 7748244684488556208), TimeToolEventTimeOffset)
agcls.AgTypeNameMap["TimeToolEventTimeOffset"] = TimeToolEventTimeOffset

class TimeToolFirstIntervalsFilter(ITimeToolPruneFilter, SupportsDeleteCallback):
    """The filter selects a portion of first intervals."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_maximum_number_of_intervals_method_offset = 1
    _set_maximum_number_of_intervals_method_offset = 2
    _metadata = {
        "iid_data" : (5238555741080133400, 9243782524213090747),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolFirstIntervalsFilter)
    
    _get_maximum_number_of_intervals_metadata = { "offset" : _get_maximum_number_of_intervals_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_number_of_intervals(self) -> int:
        """Maximum number of intervals."""
        return self._intf.get_property(TimeToolFirstIntervalsFilter._metadata, TimeToolFirstIntervalsFilter._get_maximum_number_of_intervals_metadata)

    _set_maximum_number_of_intervals_metadata = { "offset" : _set_maximum_number_of_intervals_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_number_of_intervals.setter
    def maximum_number_of_intervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(TimeToolFirstIntervalsFilter._metadata, TimeToolFirstIntervalsFilter._set_maximum_number_of_intervals_metadata, maximumNumberOfIntervals)

    _property_names[maximum_number_of_intervals] = "maximum_number_of_intervals"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolFirstIntervalsFilter."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolFirstIntervalsFilter)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolFirstIntervalsFilter, [TimeToolFirstIntervalsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry((4841739463115949456, 12213426980424696479), TimeToolFirstIntervalsFilter)
agcls.AgTypeNameMap["TimeToolFirstIntervalsFilter"] = TimeToolFirstIntervalsFilter

class TimeToolGapsFilter(ITimeToolPruneFilter, SupportsDeleteCallback):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_duration_kind_method_offset = 1
    _set_duration_kind_method_offset = 2
    _get_gap_duration_method_offset = 3
    _set_gap_duration_method_offset = 4
    _metadata = {
        "iid_data" : (5577530501196125174, 17516988796283437440),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolGapsFilter)
    
    _get_duration_kind_metadata = { "offset" : _get_duration_kind_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(TimeToolGapsFilter._metadata, TimeToolGapsFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "offset" : _set_duration_kind_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(TimeToolGapsFilter._metadata, TimeToolGapsFilter._set_duration_kind_metadata, durationKind)

    _get_gap_duration_metadata = { "offset" : _get_gap_duration_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def gap_duration(self) -> float:
        """Duration of the gap."""
        return self._intf.get_property(TimeToolGapsFilter._metadata, TimeToolGapsFilter._get_gap_duration_metadata)

    _set_gap_duration_metadata = { "offset" : _set_gap_duration_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @gap_duration.setter
    def gap_duration(self, gapDuration:float) -> None:
        return self._intf.set_property(TimeToolGapsFilter._metadata, TimeToolGapsFilter._set_gap_duration_metadata, gapDuration)

    _property_names[duration_kind] = "duration_kind"
    _property_names[gap_duration] = "gap_duration"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolGapsFilter."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolGapsFilter)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolGapsFilter, [TimeToolGapsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry((4915234003613464599, 13847403613333364110), TimeToolGapsFilter)
agcls.AgTypeNameMap["TimeToolGapsFilter"] = TimeToolGapsFilter

class AnalysisWorkbenchIntegral(IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Represents a base class for integral definitions."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchIntegral."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchIntegral.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchIntegral._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchIntegral, [IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5141699313388952889, 439554261460355240), AnalysisWorkbenchIntegral)
agcls.AgTypeNameMap["AnalysisWorkbenchIntegral"] = AnalysisWorkbenchIntegral

class CalculationToolIntegralBasic(IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Integral definition determines how scalar calculation is numerically integrated."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _set_type_method_offset = 2
    _get_tolerance_method_offset = 3
    _set_tolerance_method_offset = 4
    _get_maximum_iterations_method_offset = 5
    _set_maximum_iterations_method_offset = 6
    _metadata = {
        "iid_data" : (5223039038232914469, 8592596877327925126),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolIntegralBasic)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRAL_TYPE),) }
    @property
    def type(self) -> "CRDN_INTEGRAL_TYPE":
        """Get the integral type which determines the method of integration and can be set to trapezoidal, Simplson or adaptive Lobatto."""
        return self._intf.get_property(CalculationToolIntegralBasic._metadata, CalculationToolIntegralBasic._get_type_metadata)

    _set_type_metadata = { "offset" : _set_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTEGRAL_TYPE),) }
    @type.setter
    def type(self, type:"CRDN_INTEGRAL_TYPE") -> None:
        return self._intf.set_property(CalculationToolIntegralBasic._metadata, CalculationToolIntegralBasic._set_type_metadata, type)

    _get_tolerance_metadata = { "offset" : _get_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def tolerance(self) -> float:
        """Get the tolerance which determines how accurate integral is computed by finding relative difference between refined and unrefined integral evaluations. Only available if Adaptive Lobatto is selected as the integral type."""
        return self._intf.get_property(CalculationToolIntegralBasic._metadata, CalculationToolIntegralBasic._get_tolerance_metadata)

    _set_tolerance_metadata = { "offset" : _set_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @tolerance.setter
    def tolerance(self, tolerance:float) -> None:
        return self._intf.set_property(CalculationToolIntegralBasic._metadata, CalculationToolIntegralBasic._set_tolerance_metadata, tolerance)

    _get_maximum_iterations_metadata = { "offset" : _get_maximum_iterations_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_iterations(self) -> int:
        """Get the number of iteration which determines how many refinement iterations are allowed. Only available if Adaptive Lobatto is selected as the integral type."""
        return self._intf.get_property(CalculationToolIntegralBasic._metadata, CalculationToolIntegralBasic._get_maximum_iterations_metadata)

    _set_maximum_iterations_metadata = { "offset" : _set_maximum_iterations_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_iterations.setter
    def maximum_iterations(self, maximumIterations:int) -> None:
        return self._intf.set_property(CalculationToolIntegralBasic._metadata, CalculationToolIntegralBasic._set_maximum_iterations_metadata, maximumIterations)

    _property_names[type] = "type"
    _property_names[tolerance] = "tolerance"
    _property_names[maximum_iterations] = "maximum_iterations"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolIntegralBasic."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolIntegralBasic)
        IAnalysisWorkbenchIntegral.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchIntegral._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolIntegralBasic, [CalculationToolIntegralBasic, IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4728253546109001966, 9993082615726594997), CalculationToolIntegralBasic)
agcls.AgTypeNameMap["CalculationToolIntegralBasic"] = CalculationToolIntegralBasic

class AnalysisWorkbenchInterp(IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Represents a base class for interpolation definitions."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchInterp."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchInterp.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchInterp._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchInterp, [IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4634326977035843189, 527318962673378965), AnalysisWorkbenchInterp)
agcls.AgTypeNameMap["AnalysisWorkbenchInterp"] = AnalysisWorkbenchInterp

class CalculationToolInterpBasic(IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_method_offset = 1
    _set_type_method_offset = 2
    _get_order_method_offset = 3
    _set_order_method_offset = 4
    _metadata = {
        "iid_data" : (5619549411845612202, 16364875609665918339),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolInterpBasic)
    
    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERPOLATOR_TYPE),) }
    @property
    def type(self) -> "CRDN_INTERPOLATOR_TYPE":
        """Get the interpolation type, which can be Lagrange or Hermite interpolation. See STK help on interpolation for further details."""
        return self._intf.get_property(CalculationToolInterpBasic._metadata, CalculationToolInterpBasic._get_type_metadata)

    _set_type_metadata = { "offset" : _set_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERPOLATOR_TYPE),) }
    @type.setter
    def type(self, type:"CRDN_INTERPOLATOR_TYPE") -> None:
        return self._intf.set_property(CalculationToolInterpBasic._metadata, CalculationToolInterpBasic._set_type_metadata, type)

    _get_order_metadata = { "offset" : _get_order_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def order(self) -> int:
        """Get the interpolation order, which determines the order of interpolation polynomial and is related to how many samples are used during interpolation. See STK help on interpolation for further details."""
        return self._intf.get_property(CalculationToolInterpBasic._metadata, CalculationToolInterpBasic._get_order_metadata)

    _set_order_metadata = { "offset" : _set_order_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @order.setter
    def order(self, order:int) -> None:
        return self._intf.set_property(CalculationToolInterpBasic._metadata, CalculationToolInterpBasic._set_order_metadata, order)

    _property_names[type] = "type"
    _property_names[order] = "order"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolInterpBasic."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolInterpBasic)
        IAnalysisWorkbenchInterp.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchInterp._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolInterpBasic, [CalculationToolInterpBasic, IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5710680427636003903, 2230165650911561406), CalculationToolInterpBasic)
agcls.AgTypeNameMap["CalculationToolInterpBasic"] = CalculationToolInterpBasic

class TimeToolIntervalsFilter(ITimeToolPruneFilter, SupportsDeleteCallback):
    """The filter selects intervals of at least/most certain duration."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_duration_kind_method_offset = 1
    _set_duration_kind_method_offset = 2
    _get_interval_duration_method_offset = 3
    _set_interval_duration_method_offset = 4
    _metadata = {
        "iid_data" : (5450995978684978217, 16753011116458334649),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolIntervalsFilter)
    
    _get_duration_kind_metadata = { "offset" : _get_duration_kind_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(TimeToolIntervalsFilter._metadata, TimeToolIntervalsFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "offset" : _set_duration_kind_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(TimeToolIntervalsFilter._metadata, TimeToolIntervalsFilter._set_duration_kind_metadata, durationKind)

    _get_interval_duration_metadata = { "offset" : _get_interval_duration_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def interval_duration(self) -> float:
        """The interval duration."""
        return self._intf.get_property(TimeToolIntervalsFilter._metadata, TimeToolIntervalsFilter._get_interval_duration_metadata)

    _set_interval_duration_metadata = { "offset" : _set_interval_duration_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @interval_duration.setter
    def interval_duration(self, intervalDuration:float) -> None:
        return self._intf.set_property(TimeToolIntervalsFilter._metadata, TimeToolIntervalsFilter._set_interval_duration_metadata, intervalDuration)

    _property_names[duration_kind] = "duration_kind"
    _property_names[interval_duration] = "interval_duration"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolIntervalsFilter."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolIntervalsFilter)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolIntervalsFilter, [TimeToolIntervalsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry((5615056885707293863, 4921065534759074228), TimeToolIntervalsFilter)
agcls.AgTypeNameMap["TimeToolIntervalsFilter"] = TimeToolIntervalsFilter

class TimeToolLastIntervalsFilter(ITimeToolPruneFilter, SupportsDeleteCallback):
    """The filter selects a portion of last intervals."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_maximum_number_of_intervals_method_offset = 1
    _set_maximum_number_of_intervals_method_offset = 2
    _metadata = {
        "iid_data" : (5298781469380646786, 4200496564274675643),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolLastIntervalsFilter)
    
    _get_maximum_number_of_intervals_metadata = { "offset" : _get_maximum_number_of_intervals_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_number_of_intervals(self) -> int:
        """Maximum number of intervals."""
        return self._intf.get_property(TimeToolLastIntervalsFilter._metadata, TimeToolLastIntervalsFilter._get_maximum_number_of_intervals_metadata)

    _set_maximum_number_of_intervals_metadata = { "offset" : _set_maximum_number_of_intervals_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_number_of_intervals.setter
    def maximum_number_of_intervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(TimeToolLastIntervalsFilter._metadata, TimeToolLastIntervalsFilter._set_maximum_number_of_intervals_metadata, maximumNumberOfIntervals)

    _property_names[maximum_number_of_intervals] = "maximum_number_of_intervals"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolLastIntervalsFilter."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolLastIntervalsFilter)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolLastIntervalsFilter, [TimeToolLastIntervalsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry((5370173919127882269, 172199397625736352), TimeToolLastIntervalsFilter)
agcls.AgTypeNameMap["TimeToolLastIntervalsFilter"] = TimeToolLastIntervalsFilter

class CalculationToolParameterSet(ICalculationToolParameterSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Parameter set contains various sets of scalar computations."""
    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSet."""
        SupportsDeleteCallback.__init__(self)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSet, [ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5211800288647545596, 7543106923046475154), CalculationToolParameterSet)
agcls.AgTypeNameMap["CalculationToolParameterSet"] = CalculationToolParameterSet

class CalculationToolParameterSetAttitude(ICalculationToolParameterSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_axes_method_offset = 1
    _set_axes_method_offset = 2
    _get_reference_axes_method_offset = 3
    _set_reference_axes_method_offset = 4
    _metadata = {
        "iid_data" : (5157814150658641714, 4846008862630832260),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolParameterSetAttitude)
    
    _get_axes_metadata = { "offset" : _get_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def axes(self) -> "IVectorGeometryToolAxes":
        """Get the axes for which attitude representations are computed."""
        return self._intf.get_property(CalculationToolParameterSetAttitude._metadata, CalculationToolParameterSetAttitude._get_axes_metadata)

    _set_axes_metadata = { "offset" : _set_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @axes.setter
    def axes(self, axes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(CalculationToolParameterSetAttitude._metadata, CalculationToolParameterSetAttitude._set_axes_metadata, axes)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """Get the reference axes relative to which attitude representations are computed."""
        return self._intf.get_property(CalculationToolParameterSetAttitude._metadata, CalculationToolParameterSetAttitude._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "offset" : _set_reference_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(CalculationToolParameterSetAttitude._metadata, CalculationToolParameterSetAttitude._set_reference_axes_metadata, referenceAxes)

    _property_names[axes] = "axes"
    _property_names[reference_axes] = "reference_axes"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSetAttitude."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolParameterSetAttitude)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSetAttitude, [CalculationToolParameterSetAttitude, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5089636213011434244, 12709160544851939744), CalculationToolParameterSetAttitude)
agcls.AgTypeNameMap["CalculationToolParameterSetAttitude"] = CalculationToolParameterSetAttitude

class CalculationToolParameterSetFactory(SupportsDeleteCallback):
    """The factory is used to create instances of available parameter set types."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_parameter_set_attitude_method_offset = 2
    _create_parameter_set_ground_trajectory_method_offset = 3
    _create_parameter_set_trajectory_method_offset = 4
    _create_parameter_set_orbit_method_offset = 5
    _create_parameter_set_vector_method_offset = 6
    _is_type_supported_method_offset = 7
    _metadata = {
        "iid_data" : (5288103279616649311, 6790554156469523601),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolParameterSetFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_PARAMETER_SET_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_PARAMETER_SET_TYPE") -> "ICalculationToolParameterSet":
        """Create and registers a parameter set using specified name and description."""
        return self._intf.invoke(CalculationToolParameterSetFactory._metadata, CalculationToolParameterSetFactory._create_metadata, name, description, type, OutArg())

    _create_parameter_set_attitude_metadata = { "offset" : _create_parameter_set_attitude_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_parameter_set_attitude(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying one set of axes in reference to another."""
        return self._intf.invoke(CalculationToolParameterSetFactory._metadata, CalculationToolParameterSetFactory._create_parameter_set_attitude_metadata, name, description, OutArg())

    _create_parameter_set_ground_trajectory_metadata = { "offset" : _create_parameter_set_ground_trajectory_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_parameter_set_ground_trajectory(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying location in reference central body."""
        return self._intf.invoke(CalculationToolParameterSetFactory._metadata, CalculationToolParameterSetFactory._create_parameter_set_ground_trajectory_metadata, name, description, OutArg())

    _create_parameter_set_trajectory_metadata = { "offset" : _create_parameter_set_trajectory_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_parameter_set_trajectory(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying location in reference coordinate system."""
        return self._intf.invoke(CalculationToolParameterSetFactory._metadata, CalculationToolParameterSetFactory._create_parameter_set_trajectory_metadata, name, description, OutArg())

    _create_parameter_set_orbit_metadata = { "offset" : _create_parameter_set_orbit_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_parameter_set_orbit(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying orbiting point and its central body."""
        return self._intf.invoke(CalculationToolParameterSetFactory._metadata, CalculationToolParameterSetFactory._create_parameter_set_orbit_metadata, name, description, OutArg())

    _create_parameter_set_vector_metadata = { "offset" : _create_parameter_set_vector_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_parameter_set_vector(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying vector in reference axes."""
        return self._intf.invoke(CalculationToolParameterSetFactory._metadata, CalculationToolParameterSetFactory._create_parameter_set_vector_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_PARAMETER_SET_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_PARAMETER_SET_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(CalculationToolParameterSetFactory._metadata, CalculationToolParameterSetFactory._is_type_supported_metadata, eType, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSetFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolParameterSetFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSetFactory, [CalculationToolParameterSetFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5191271020123231030, 13615349136520883352), CalculationToolParameterSetFactory)
agcls.AgTypeNameMap["CalculationToolParameterSetFactory"] = CalculationToolParameterSetFactory

class CalculationToolParameterSetGroundTrajectory(ICalculationToolParameterSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_location_method_offset = 1
    _set_location_method_offset = 2
    _get_central_body_method_offset = 3
    _set_central_body_method_offset = 4
    _metadata = {
        "iid_data" : (5004898066850638741, 11511760438073722810),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolParameterSetGroundTrajectory)
    
    _get_location_metadata = { "offset" : _get_location_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def location(self) -> "IVectorGeometryToolPoint":
        """Get the point for which ground trajectory representations are computed."""
        return self._intf.get_property(CalculationToolParameterSetGroundTrajectory._metadata, CalculationToolParameterSetGroundTrajectory._get_location_metadata)

    _set_location_metadata = { "offset" : _set_location_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @location.setter
    def location(self, location:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(CalculationToolParameterSetGroundTrajectory._metadata, CalculationToolParameterSetGroundTrajectory._set_location_metadata, location)

    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get the central body relative to which ground trajectory representations are computed. Both the central body reference shape and its CBF (central body centered fixed) system are used by this parameter set."""
        return self._intf.get_property(CalculationToolParameterSetGroundTrajectory._metadata, CalculationToolParameterSetGroundTrajectory._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(CalculationToolParameterSetGroundTrajectory._metadata, CalculationToolParameterSetGroundTrajectory._set_central_body_metadata, centralBody)

    _property_names[location] = "location"
    _property_names[central_body] = "central_body"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSetGroundTrajectory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolParameterSetGroundTrajectory)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSetGroundTrajectory, [CalculationToolParameterSetGroundTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5476359557675953687, 12818036812419277696), CalculationToolParameterSetGroundTrajectory)
agcls.AgTypeNameMap["CalculationToolParameterSetGroundTrajectory"] = CalculationToolParameterSetGroundTrajectory

class CalculationToolParameterSetOrbit(ICalculationToolParameterSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_orbiting_point_method_offset = 1
    _set_orbiting_point_method_offset = 2
    _get_reference_system_method_offset = 3
    _set_reference_system_method_offset = 4
    _get_gravitational_parameter_method_offset = 5
    _set_gravitational_parameter_method_offset = 6
    _get_central_body_method_offset = 7
    _set_central_body_method_offset = 8
    _get_use_central_body_gravitational_parameter_method_offset = 9
    _set_use_central_body_gravitational_parameter_method_offset = 10
    _get_use_central_body_inertial_method_offset = 11
    _set_use_central_body_inertial_method_offset = 12
    _metadata = {
        "iid_data" : (4631037522197801655, 2468098686994820286),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolParameterSetOrbit)
    
    _get_orbiting_point_metadata = { "offset" : _get_orbiting_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def orbiting_point(self) -> "IVectorGeometryToolPoint":
        """Get the point for which orbital parameters are computed."""
        return self._intf.get_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._get_orbiting_point_metadata)

    _set_orbiting_point_metadata = { "offset" : _set_orbiting_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @orbiting_point.setter
    def orbiting_point(self, orbitingPoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._set_orbiting_point_metadata, orbitingPoint)

    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which orbital parameters are computed. Only used if the option to specify reference system is selected."""
        return self._intf.get_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._set_reference_system_metadata, referenceSystem)

    _get_gravitational_parameter_metadata = { "offset" : _get_gravitational_parameter_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def gravitational_parameter(self) -> float:
        """Get the gravitational parameter for the mass relative to which orbital parameters are computed. Only used if the option to specify gravitational parameter is selected."""
        return self._intf.get_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._get_gravitational_parameter_metadata)

    _set_gravitational_parameter_metadata = { "offset" : _set_gravitational_parameter_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @gravitational_parameter.setter
    def gravitational_parameter(self, gravitationalParameter:float) -> None:
        return self._intf.set_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._set_gravitational_parameter_metadata, gravitationalParameter)

    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get the central body relative to which orbital parameters are computed."""
        return self._intf.get_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._set_central_body_metadata, centralBody)

    _get_use_central_body_gravitational_parameter_metadata = { "offset" : _get_use_central_body_gravitational_parameter_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_central_body_gravitational_parameter(self) -> bool:
        """Get the option that determines whether to specify the gravitational parameter value or to inherit it from the central body."""
        return self._intf.get_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._get_use_central_body_gravitational_parameter_metadata)

    _set_use_central_body_gravitational_parameter_metadata = { "offset" : _set_use_central_body_gravitational_parameter_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_central_body_gravitational_parameter.setter
    def use_central_body_gravitational_parameter(self, useCentralBodyGravitationalParameter:bool) -> None:
        return self._intf.set_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._set_use_central_body_gravitational_parameter_metadata, useCentralBodyGravitationalParameter)

    _get_use_central_body_inertial_metadata = { "offset" : _get_use_central_body_inertial_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_central_body_inertial(self) -> bool:
        """Get the option that determines whether to specify the reference coordinate system or to the inherit inertial reference system from the central body."""
        return self._intf.get_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._get_use_central_body_inertial_metadata)

    _set_use_central_body_inertial_metadata = { "offset" : _set_use_central_body_inertial_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_central_body_inertial.setter
    def use_central_body_inertial(self, useCentralBodyInertial:bool) -> None:
        return self._intf.set_property(CalculationToolParameterSetOrbit._metadata, CalculationToolParameterSetOrbit._set_use_central_body_inertial_metadata, useCentralBodyInertial)

    _property_names[orbiting_point] = "orbiting_point"
    _property_names[reference_system] = "reference_system"
    _property_names[gravitational_parameter] = "gravitational_parameter"
    _property_names[central_body] = "central_body"
    _property_names[use_central_body_gravitational_parameter] = "use_central_body_gravitational_parameter"
    _property_names[use_central_body_inertial] = "use_central_body_inertial"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSetOrbit."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolParameterSetOrbit)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSetOrbit, [CalculationToolParameterSetOrbit, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4611801354393510048, 12183196691739788168), CalculationToolParameterSetOrbit)
agcls.AgTypeNameMap["CalculationToolParameterSetOrbit"] = CalculationToolParameterSetOrbit

class CalculationToolParameterSetTrajectory(ICalculationToolParameterSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_point_method_offset = 1
    _set_point_method_offset = 2
    _get_reference_system_method_offset = 3
    _set_reference_system_method_offset = 4
    _metadata = {
        "iid_data" : (5006139916852774401, 13019652784963788729),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolParameterSetTrajectory)
    
    _get_point_metadata = { "offset" : _get_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point(self) -> "IVectorGeometryToolPoint":
        """Get the point for which trajectory representations are computed."""
        return self._intf.get_property(CalculationToolParameterSetTrajectory._metadata, CalculationToolParameterSetTrajectory._get_point_metadata)

    _set_point_metadata = { "offset" : _set_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @point.setter
    def point(self, point:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(CalculationToolParameterSetTrajectory._metadata, CalculationToolParameterSetTrajectory._set_point_metadata, point)

    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system relative to which trajectory representations are computed."""
        return self._intf.get_property(CalculationToolParameterSetTrajectory._metadata, CalculationToolParameterSetTrajectory._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(CalculationToolParameterSetTrajectory._metadata, CalculationToolParameterSetTrajectory._set_reference_system_metadata, referenceSystem)

    _property_names[point] = "point"
    _property_names[reference_system] = "reference_system"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSetTrajectory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolParameterSetTrajectory)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSetTrajectory, [CalculationToolParameterSetTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5733434664696181485, 15500898216521877646), CalculationToolParameterSetTrajectory)
agcls.AgTypeNameMap["CalculationToolParameterSetTrajectory"] = CalculationToolParameterSetTrajectory

class CalculationToolParameterSetVector(ICalculationToolParameterSet, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_vector_method_offset = 1
    _set_vector_method_offset = 2
    _get_reference_axes_method_offset = 3
    _set_reference_axes_method_offset = 4
    _metadata = {
        "iid_data" : (5239130838684790465, 17380030367494480022),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolParameterSetVector)
    
    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "IVectorGeometryToolVector":
        """Get the vector for which representations are computed."""
        return self._intf.get_property(CalculationToolParameterSetVector._metadata, CalculationToolParameterSetVector._get_vector_metadata)

    _set_vector_metadata = { "offset" : _set_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @vector.setter
    def vector(self, vector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(CalculationToolParameterSetVector._metadata, CalculationToolParameterSetVector._set_vector_metadata, vector)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """Get the reference axes relative to which representations are computed."""
        return self._intf.get_property(CalculationToolParameterSetVector._metadata, CalculationToolParameterSetVector._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "offset" : _set_reference_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(CalculationToolParameterSetVector._metadata, CalculationToolParameterSetVector._set_reference_axes_metadata, referenceAxes)

    _property_names[vector] = "vector"
    _property_names[reference_axes] = "reference_axes"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolParameterSetVector."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolParameterSetVector)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolParameterSetVector, [CalculationToolParameterSetVector, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5342518829739884757, 14433235443967563942), CalculationToolParameterSetVector)
agcls.AgTypeNameMap["CalculationToolParameterSetVector"] = CalculationToolParameterSetVector

class TimeToolPruneFilter(ITimeToolPruneFilter, SupportsDeleteCallback):
    """A filter used with event interval list pruned class to prune interval lists..."""
    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolPruneFilter."""
        SupportsDeleteCallback.__init__(self)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolPruneFilter, [ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry((4753774320714343401, 2720215011582395827), TimeToolPruneFilter)
agcls.AgTypeNameMap["TimeToolPruneFilter"] = TimeToolPruneFilter

class TimeToolPruneFilterFactory(SupportsDeleteCallback):
    """The factory creates pruning filters."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _metadata = {
        "iid_data" : (5042513438281501086, 13689364354501709749),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolPruneFilterFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(CRDN_PRUNE_FILTER), agmarshall.InterfaceOutArg,) }
    def create(self, eFilter:"CRDN_PRUNE_FILTER") -> "ITimeToolPruneFilter":
        """Create and initializes a new prune filter using default configuration."""
        return self._intf.invoke(TimeToolPruneFilterFactory._metadata, TimeToolPruneFilterFactory._create_metadata, eFilter, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolPruneFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolPruneFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolPruneFilterFactory, [TimeToolPruneFilterFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5226485936241673410, 17861777124087912090), TimeToolPruneFilterFactory)
agcls.AgTypeNameMap["TimeToolPruneFilterFactory"] = TimeToolPruneFilterFactory

class TimeToolRelativeSatisfactionConditionFilter(ITimeToolPruneFilter, SupportsDeleteCallback):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_condition_method_offset = 1
    _set_condition_method_offset = 2
    _get_duration_kind_method_offset = 3
    _set_duration_kind_method_offset = 4
    _get_relative_interval_duration_method_offset = 5
    _set_relative_interval_duration_method_offset = 6
    _metadata = {
        "iid_data" : (4708733116692114035, 8453241099873031043),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolRelativeSatisfactionConditionFilter)
    
    _get_condition_metadata = { "offset" : _get_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """Get or set the additional condition to be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        return self._intf.get_property(TimeToolRelativeSatisfactionConditionFilter._metadata, TimeToolRelativeSatisfactionConditionFilter._get_condition_metadata)

    _set_condition_metadata = { "offset" : _set_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(TimeToolRelativeSatisfactionConditionFilter._metadata, TimeToolRelativeSatisfactionConditionFilter._set_condition_metadata, condition)

    _get_duration_kind_metadata = { "offset" : _get_duration_kind_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(TimeToolRelativeSatisfactionConditionFilter._metadata, TimeToolRelativeSatisfactionConditionFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "offset" : _set_duration_kind_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(TimeToolRelativeSatisfactionConditionFilter._metadata, TimeToolRelativeSatisfactionConditionFilter._set_duration_kind_metadata, durationKind)

    _get_relative_interval_duration_metadata = { "offset" : _get_relative_interval_duration_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def relative_interval_duration(self) -> float:
        """A percentage of time the condition must be satisfied."""
        return self._intf.get_property(TimeToolRelativeSatisfactionConditionFilter._metadata, TimeToolRelativeSatisfactionConditionFilter._get_relative_interval_duration_metadata)

    _set_relative_interval_duration_metadata = { "offset" : _set_relative_interval_duration_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @relative_interval_duration.setter
    def relative_interval_duration(self, relativeIntervalDuration:float) -> None:
        return self._intf.set_property(TimeToolRelativeSatisfactionConditionFilter._metadata, TimeToolRelativeSatisfactionConditionFilter._set_relative_interval_duration_metadata, relativeIntervalDuration)

    _property_names[condition] = "condition"
    _property_names[duration_kind] = "duration_kind"
    _property_names[relative_interval_duration] = "relative_interval_duration"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolRelativeSatisfactionConditionFilter."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolRelativeSatisfactionConditionFilter)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolRelativeSatisfactionConditionFilter, [TimeToolRelativeSatisfactionConditionFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry((5599006480069411520, 196698249444219283), TimeToolRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap["TimeToolRelativeSatisfactionConditionFilter"] = TimeToolRelativeSatisfactionConditionFilter

class AnalysisWorkbenchSampling(IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Base sampling interface."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchSampling."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchSampling.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchSampling._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchSampling, [IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5764026328462147817, 7669428216318596746), AnalysisWorkbenchSampling)
agcls.AgTypeNameMap["AnalysisWorkbenchSampling"] = AnalysisWorkbenchSampling

class CalculationToolSamplingBasic(IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_sampling_method_method_offset = 1
    _set_sampling_method_method_offset = 2
    _get_method_factory_method_offset = 3
    _metadata = {
        "iid_data" : (4878478022758053645, 16585190424563731886),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolSamplingBasic)
    
    _get_sampling_method_metadata = { "offset" : _get_sampling_method_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling_method(self) -> "ICalculationToolSamplingMethod":
        """Get the sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(CalculationToolSamplingBasic._metadata, CalculationToolSamplingBasic._get_sampling_method_metadata)

    _set_sampling_method_metadata = { "offset" : _set_sampling_method_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolSamplingMethod"),) }
    @sampling_method.setter
    def sampling_method(self, samplingMethod:"ICalculationToolSamplingMethod") -> None:
        return self._intf.set_property(CalculationToolSamplingBasic._metadata, CalculationToolSamplingBasic._set_sampling_method_metadata, samplingMethod)

    _get_method_factory_metadata = { "offset" : _get_method_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def method_factory(self) -> "CalculationToolSamplingMethodFactory":
        """Create sampling definitions, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(CalculationToolSamplingBasic._metadata, CalculationToolSamplingBasic._get_method_factory_metadata)

    _property_names[sampling_method] = "sampling_method"
    _property_names[method_factory] = "method_factory"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolSamplingBasic."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolSamplingBasic)
        IAnalysisWorkbenchSampling.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchSampling._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolSamplingBasic, [CalculationToolSamplingBasic, IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4842369728921496656, 433140158192125353), CalculationToolSamplingBasic)
agcls.AgTypeNameMap["CalculationToolSamplingBasic"] = CalculationToolSamplingBasic

class CalculationToolSamplingCurvatureTolerance(ICalculationToolSamplingMethod, SupportsDeleteCallback):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minimum_time_step_method_offset = 1
    _set_minimum_time_step_method_offset = 2
    _get_maximum_time_step_method_offset = 3
    _set_maximum_time_step_method_offset = 4
    _get_step_at_boundaries_method_offset = 5
    _set_step_at_boundaries_method_offset = 6
    _get_relative_tolerance_method_offset = 7
    _set_relative_tolerance_method_offset = 8
    _get_absolute_tolerance_method_offset = 9
    _set_absolute_tolerance_method_offset = 10
    _get_curvature_tolerance_method_offset = 11
    _set_curvature_tolerance_method_offset = 12
    _metadata = {
        "iid_data" : (5542979227852921429, 14660439002322066049),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolSamplingCurvatureTolerance)
    
    _get_minimum_time_step_metadata = { "offset" : _get_minimum_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_time_step(self) -> float:
        """Get the minimum allowed time step."""
        return self._intf.get_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._get_minimum_time_step_metadata)

    _set_minimum_time_step_metadata = { "offset" : _set_minimum_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_time_step.setter
    def minimum_time_step(self, minimumTimeStep:float) -> None:
        return self._intf.set_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._set_minimum_time_step_metadata, minimumTimeStep)

    _get_maximum_time_step_metadata = { "offset" : _get_maximum_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_time_step(self) -> float:
        """Get the maximum allowed time step."""
        return self._intf.get_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._get_maximum_time_step_metadata)

    _set_maximum_time_step_metadata = { "offset" : _set_maximum_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_time_step.setter
    def maximum_time_step(self, maximumTimeStep:float) -> None:
        return self._intf.set_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._set_maximum_time_step_metadata, maximumTimeStep)

    _get_step_at_boundaries_metadata = { "offset" : _get_step_at_boundaries_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def step_at_boundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        return self._intf.get_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._get_step_at_boundaries_metadata)

    _set_step_at_boundaries_metadata = { "offset" : _set_step_at_boundaries_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @step_at_boundaries.setter
    def step_at_boundaries(self, stepAtBoundaries:float) -> None:
        return self._intf.set_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._set_step_at_boundaries_metadata, stepAtBoundaries)

    _get_relative_tolerance_metadata = { "offset" : _get_relative_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def relative_tolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values."""
        return self._intf.get_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._get_relative_tolerance_metadata)

    _set_relative_tolerance_metadata = { "offset" : _set_relative_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @relative_tolerance.setter
    def relative_tolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._set_relative_tolerance_metadata, relativeTolerance)

    _get_absolute_tolerance_metadata = { "offset" : _get_absolute_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def absolute_tolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step."""
        return self._intf.get_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._get_absolute_tolerance_metadata)

    _set_absolute_tolerance_metadata = { "offset" : _set_absolute_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @absolute_tolerance.setter
    def absolute_tolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._set_absolute_tolerance_metadata, absoluteTolerance)

    _get_curvature_tolerance_metadata = { "offset" : _get_curvature_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def curvature_tolerance(self) -> float:
        """Get the curvature tolerance which determines acceptable angular difference between slopes over consecutive steps."""
        return self._intf.get_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._get_curvature_tolerance_metadata)

    _set_curvature_tolerance_metadata = { "offset" : _set_curvature_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @curvature_tolerance.setter
    def curvature_tolerance(self, curvatureTolerance:float) -> None:
        return self._intf.set_property(CalculationToolSamplingCurvatureTolerance._metadata, CalculationToolSamplingCurvatureTolerance._set_curvature_tolerance_metadata, curvatureTolerance)

    _property_names[minimum_time_step] = "minimum_time_step"
    _property_names[maximum_time_step] = "maximum_time_step"
    _property_names[step_at_boundaries] = "step_at_boundaries"
    _property_names[relative_tolerance] = "relative_tolerance"
    _property_names[absolute_tolerance] = "absolute_tolerance"
    _property_names[curvature_tolerance] = "curvature_tolerance"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolSamplingCurvatureTolerance."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolSamplingCurvatureTolerance)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolSamplingCurvatureTolerance, [CalculationToolSamplingCurvatureTolerance, ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry((5387756316129866756, 2484055402072399547), CalculationToolSamplingCurvatureTolerance)
agcls.AgTypeNameMap["CalculationToolSamplingCurvatureTolerance"] = CalculationToolSamplingCurvatureTolerance

class CalculationToolSamplingFixedStep(ICalculationToolSamplingMethod, SupportsDeleteCallback):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_time_step_method_offset = 1
    _set_time_step_method_offset = 2
    _metadata = {
        "iid_data" : (4760999063576923422, 2852563063428767411),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolSamplingFixedStep)
    
    _get_time_step_metadata = { "offset" : _get_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_step(self) -> float:
        """Get the fixed time step."""
        return self._intf.get_property(CalculationToolSamplingFixedStep._metadata, CalculationToolSamplingFixedStep._get_time_step_metadata)

    _set_time_step_metadata = { "offset" : _set_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_step.setter
    def time_step(self, timeStep:float) -> None:
        return self._intf.set_property(CalculationToolSamplingFixedStep._metadata, CalculationToolSamplingFixedStep._set_time_step_metadata, timeStep)

    _property_names[time_step] = "time_step"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolSamplingFixedStep."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolSamplingFixedStep)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolSamplingFixedStep, [CalculationToolSamplingFixedStep, ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry((5657779203521466895, 699813618720941244), CalculationToolSamplingFixedStep)
agcls.AgTypeNameMap["CalculationToolSamplingFixedStep"] = CalculationToolSamplingFixedStep

class CalculationToolSamplingMethod(ICalculationToolSamplingMethod, SupportsDeleteCallback):
    """A sampling method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolSamplingMethod."""
        SupportsDeleteCallback.__init__(self)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolSamplingMethod, [ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry((5520509056155849796, 13270445498439148177), CalculationToolSamplingMethod)
agcls.AgTypeNameMap["CalculationToolSamplingMethod"] = CalculationToolSamplingMethod

class CalculationToolSamplingMethodFactory(SupportsDeleteCallback):
    """The factory creates sampling method components."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_fixed_step_method_offset = 1
    _create_curvature_tolerance_method_offset = 2
    _create_relative_tolerance_method_offset = 3
    _metadata = {
        "iid_data" : (4621614585912529563, 1951602854656295068),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolSamplingMethodFactory)
    
    _create_fixed_step_metadata = { "offset" : _create_fixed_step_method_offset,
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_fixed_step(self, fixedStep:float) -> "ICalculationToolSamplingMethod":
        """Create a fixed time step sampling definition."""
        return self._intf.invoke(CalculationToolSamplingMethodFactory._metadata, CalculationToolSamplingMethodFactory._create_fixed_step_metadata, fixedStep, OutArg())

    _create_curvature_tolerance_metadata = { "offset" : _create_curvature_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_curvature_tolerance(self, curvatureTolerance:float) -> "ICalculationToolSamplingMethod":
        """Create a curvature tolerance sampling definition. Curvature tolerance uses changes in slope between samples."""
        return self._intf.invoke(CalculationToolSamplingMethodFactory._metadata, CalculationToolSamplingMethodFactory._create_curvature_tolerance_metadata, curvatureTolerance, OutArg())

    _create_relative_tolerance_metadata = { "offset" : _create_relative_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_relative_tolerance(self, relativeTolerance:float) -> "ICalculationToolSamplingMethod":
        """Create a relative tolerance sampling definition. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples."""
        return self._intf.invoke(CalculationToolSamplingMethodFactory._metadata, CalculationToolSamplingMethodFactory._create_relative_tolerance_metadata, relativeTolerance, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolSamplingMethodFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolSamplingMethodFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolSamplingMethodFactory, [CalculationToolSamplingMethodFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5108812290465688521, 9237146689306794658), CalculationToolSamplingMethodFactory)
agcls.AgTypeNameMap["CalculationToolSamplingMethodFactory"] = CalculationToolSamplingMethodFactory

class CalculationToolSamplingRelativeTolerance(ICalculationToolSamplingMethod, SupportsDeleteCallback):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minimum_time_step_method_offset = 1
    _set_minimum_time_step_method_offset = 2
    _get_maximum_time_step_method_offset = 3
    _set_maximum_time_step_method_offset = 4
    _get_step_at_boundaries_method_offset = 5
    _set_step_at_boundaries_method_offset = 6
    _get_relative_tolerance_method_offset = 7
    _set_relative_tolerance_method_offset = 8
    _get_absolute_tolerance_method_offset = 9
    _set_absolute_tolerance_method_offset = 10
    _metadata = {
        "iid_data" : (4753454007727116326, 13557865281292527789),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, CalculationToolSamplingRelativeTolerance)
    
    _get_minimum_time_step_metadata = { "offset" : _get_minimum_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_time_step(self) -> float:
        """Get the minimum allowed time step."""
        return self._intf.get_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._get_minimum_time_step_metadata)

    _set_minimum_time_step_metadata = { "offset" : _set_minimum_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_time_step.setter
    def minimum_time_step(self, minimumTimeStep:float) -> None:
        return self._intf.set_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._set_minimum_time_step_metadata, minimumTimeStep)

    _get_maximum_time_step_metadata = { "offset" : _get_maximum_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_time_step(self) -> float:
        """Get the maximum allowed time step."""
        return self._intf.get_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._get_maximum_time_step_metadata)

    _set_maximum_time_step_metadata = { "offset" : _set_maximum_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_time_step.setter
    def maximum_time_step(self, maximumTimeStep:float) -> None:
        return self._intf.set_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._set_maximum_time_step_metadata, maximumTimeStep)

    _get_step_at_boundaries_metadata = { "offset" : _get_step_at_boundaries_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def step_at_boundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        return self._intf.get_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._get_step_at_boundaries_metadata)

    _set_step_at_boundaries_metadata = { "offset" : _set_step_at_boundaries_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @step_at_boundaries.setter
    def step_at_boundaries(self, stepAtBoundaries:float) -> None:
        return self._intf.set_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._set_step_at_boundaries_metadata, stepAtBoundaries)

    _get_relative_tolerance_metadata = { "offset" : _get_relative_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def relative_tolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values."""
        return self._intf.get_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._get_relative_tolerance_metadata)

    _set_relative_tolerance_metadata = { "offset" : _set_relative_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @relative_tolerance.setter
    def relative_tolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._set_relative_tolerance_metadata, relativeTolerance)

    _get_absolute_tolerance_metadata = { "offset" : _get_absolute_tolerance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def absolute_tolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step."""
        return self._intf.get_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._get_absolute_tolerance_metadata)

    _set_absolute_tolerance_metadata = { "offset" : _set_absolute_tolerance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @absolute_tolerance.setter
    def absolute_tolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(CalculationToolSamplingRelativeTolerance._metadata, CalculationToolSamplingRelativeTolerance._set_absolute_tolerance_metadata, absoluteTolerance)

    _property_names[minimum_time_step] = "minimum_time_step"
    _property_names[maximum_time_step] = "maximum_time_step"
    _property_names[step_at_boundaries] = "step_at_boundaries"
    _property_names[relative_tolerance] = "relative_tolerance"
    _property_names[absolute_tolerance] = "absolute_tolerance"

    def __init__(self, sourceObject=None):
        """Construct an object of type CalculationToolSamplingRelativeTolerance."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, CalculationToolSamplingRelativeTolerance)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CalculationToolSamplingRelativeTolerance, [CalculationToolSamplingRelativeTolerance, ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry((4936649529186074219, 353883352016272033), CalculationToolSamplingRelativeTolerance)
agcls.AgTypeNameMap["CalculationToolSamplingRelativeTolerance"] = CalculationToolSamplingRelativeTolerance

class TimeToolSatisfactionConditionFilter(ITimeToolPruneFilter, SupportsDeleteCallback):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_condition_method_offset = 1
    _set_condition_method_offset = 2
    _get_duration_kind_method_offset = 3
    _set_duration_kind_method_offset = 4
    _get_interval_duration_method_offset = 5
    _set_interval_duration_method_offset = 6
    _metadata = {
        "iid_data" : (5756195466743196097, 11251701537728199608),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolSatisfactionConditionFilter)
    
    _get_condition_metadata = { "offset" : _get_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """Get or set the additional condition to be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        return self._intf.get_property(TimeToolSatisfactionConditionFilter._metadata, TimeToolSatisfactionConditionFilter._get_condition_metadata)

    _set_condition_metadata = { "offset" : _set_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(TimeToolSatisfactionConditionFilter._metadata, TimeToolSatisfactionConditionFilter._set_condition_metadata, condition)

    _get_duration_kind_metadata = { "offset" : _get_duration_kind_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(TimeToolSatisfactionConditionFilter._metadata, TimeToolSatisfactionConditionFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "offset" : _set_duration_kind_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(TimeToolSatisfactionConditionFilter._metadata, TimeToolSatisfactionConditionFilter._set_duration_kind_metadata, durationKind)

    _get_interval_duration_metadata = { "offset" : _get_interval_duration_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def interval_duration(self) -> float:
        """A duration of time the condition must be satisfied."""
        return self._intf.get_property(TimeToolSatisfactionConditionFilter._metadata, TimeToolSatisfactionConditionFilter._get_interval_duration_metadata)

    _set_interval_duration_metadata = { "offset" : _set_interval_duration_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @interval_duration.setter
    def interval_duration(self, intervalDuration:float) -> None:
        return self._intf.set_property(TimeToolSatisfactionConditionFilter._metadata, TimeToolSatisfactionConditionFilter._set_interval_duration_metadata, intervalDuration)

    _property_names[condition] = "condition"
    _property_names[duration_kind] = "duration_kind"
    _property_names[interval_duration] = "interval_duration"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolSatisfactionConditionFilter."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolSatisfactionConditionFilter)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolSatisfactionConditionFilter, [TimeToolSatisfactionConditionFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry((4851832596060338991, 14965342242796491937), TimeToolSatisfactionConditionFilter)
agcls.AgTypeNameMap["TimeToolSatisfactionConditionFilter"] = TimeToolSatisfactionConditionFilter

class AnalysisWorkbenchSignalDelay(IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchSignalDelay."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchSignalDelay.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchSignalDelay._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchSignalDelay, [IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4953635476598966337, 4896658474318640771), AnalysisWorkbenchSignalDelay)
agcls.AgTypeNameMap["AnalysisWorkbenchSignalDelay"] = AnalysisWorkbenchSignalDelay

class TimeToolSignalDelayBasic(IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_signal_path_reference_system_method_offset = 1
    _set_signal_path_reference_system_method_offset = 2
    _get_reference_system_method_offset = 3
    _set_reference_system_method_offset = 4
    _get_speed_option_method_offset = 5
    _set_speed_option_method_offset = 6
    _get_transfer_speed_method_offset = 7
    _set_transfer_speed_method_offset = 8
    _get_time_delay_convergence_method_offset = 9
    _set_time_delay_convergence_method_offset = 10
    _metadata = {
        "iid_data" : (5705418358163775767, 12397507959819827338),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolSignalDelayBasic)
    
    _get_signal_path_reference_system_metadata = { "offset" : _get_signal_path_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_PATH_REFERENCE_SYSTEM),) }
    @property
    def signal_path_reference_system(self) -> "CRDN_SIGNAL_PATH_REFERENCE_SYSTEM":
        """Get the type of signal path reference system which can be set to use STK Access default (see STK Help for further details), Solar system barycenter inertial reference, central body inertial reference or custom reference system..."""
        return self._intf.get_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._get_signal_path_reference_system_metadata)

    _set_signal_path_reference_system_metadata = { "offset" : _set_signal_path_reference_system_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_PATH_REFERENCE_SYSTEM),) }
    @signal_path_reference_system.setter
    def signal_path_reference_system(self, signalPathReferenceSystem:"CRDN_SIGNAL_PATH_REFERENCE_SYSTEM") -> None:
        return self._intf.set_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._set_signal_path_reference_system_metadata, signalPathReferenceSystem)

    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the custom reference system which is used as a reference for signal path if the signal path reference option is set to Custom."""
        return self._intf.get_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._set_reference_system_metadata, referenceSystem)

    _get_speed_option_metadata = { "offset" : _get_speed_option_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SPEED_OPTIONS),) }
    @property
    def speed_option(self) -> "CRDN_SPEED_OPTIONS":
        """Get the speed option which determines whether to use the speed of light or a custom speed value."""
        return self._intf.get_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._get_speed_option_metadata)

    _set_speed_option_metadata = { "offset" : _set_speed_option_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SPEED_OPTIONS),) }
    @speed_option.setter
    def speed_option(self, speedOption:"CRDN_SPEED_OPTIONS") -> None:
        return self._intf.set_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._set_speed_option_metadata, speedOption)

    _get_transfer_speed_metadata = { "offset" : _get_transfer_speed_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def transfer_speed(self) -> float:
        """Get the signal propagation speed value which is used if the speed option is set to Custom."""
        return self._intf.get_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._get_transfer_speed_metadata)

    _set_transfer_speed_metadata = { "offset" : _set_transfer_speed_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @transfer_speed.setter
    def transfer_speed(self, transferSpeed:float) -> None:
        return self._intf.set_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._set_transfer_speed_metadata, transferSpeed)

    _get_time_delay_convergence_metadata = { "offset" : _get_time_delay_convergence_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_delay_convergence(self) -> float:
        """Get the time delay convergence which determines the accuracy of computed propagation time between the two locations."""
        return self._intf.get_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._get_time_delay_convergence_metadata)

    _set_time_delay_convergence_metadata = { "offset" : _set_time_delay_convergence_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_delay_convergence.setter
    def time_delay_convergence(self, timeDelayConvergence:float) -> None:
        return self._intf.set_property(TimeToolSignalDelayBasic._metadata, TimeToolSignalDelayBasic._set_time_delay_convergence_metadata, timeDelayConvergence)

    _property_names[signal_path_reference_system] = "signal_path_reference_system"
    _property_names[reference_system] = "reference_system"
    _property_names[speed_option] = "speed_option"
    _property_names[transfer_speed] = "transfer_speed"
    _property_names[time_delay_convergence] = "time_delay_convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolSignalDelayBasic."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolSignalDelayBasic)
        IAnalysisWorkbenchSignalDelay.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchSignalDelay._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolSignalDelayBasic, [TimeToolSignalDelayBasic, IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5642525835138409264, 10528515051945010859), TimeToolSignalDelayBasic)
agcls.AgTypeNameMap["TimeToolSignalDelayBasic"] = TimeToolSignalDelayBasic

class SpatialAnalysisToolVolumeCalcFactory(SupportsDeleteCallback):
    """The factory is used to create instances of volume calcs."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _is_type_supported_method_offset = 1
    _create_method_offset = 2
    _create_volume_calc_altitude_method_offset = 3
    _create_volume_calc_angle_off_vector_method_offset = 4
    _create_volume_calc_file_method_offset = 5
    _create_volume_calc_from_scalar_method_offset = 6
    _create_volume_calc_solar_intensity_method_offset = 7
    _create_volume_calc_volume_satisfaction_metric_method_offset = 8
    _create_volume_calc_range_method_offset = 9
    _create_volume_calc_delay_range_method_offset = 10
    _metadata = {
        "iid_data" : (5124917152380054858, 1631627205173804441),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcFactory)
    
    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_VOLUME_CALC_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._is_type_supported_metadata, eType, OutArg())

    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_VOLUME_CALC_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_VOLUME_CALC_TYPE") -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a volume calc using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_metadata, name, description, type, OutArg())

    _create_volume_calc_altitude_metadata = { "offset" : _create_volume_calc_altitude_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_altitude(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a altitude to location volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_altitude_metadata, name, description, OutArg())

    _create_volume_calc_angle_off_vector_metadata = { "offset" : _create_volume_calc_angle_off_vector_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_angle_off_vector(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a angle to location volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_angle_off_vector_metadata, name, description, OutArg())

    _create_volume_calc_file_metadata = { "offset" : _create_volume_calc_file_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_file(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a file volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_file_metadata, name, description, OutArg())

    _create_volume_calc_from_scalar_metadata = { "offset" : _create_volume_calc_from_scalar_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_from_scalar(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a scalar to location volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_from_scalar_metadata, name, description, OutArg())

    _create_volume_calc_solar_intensity_metadata = { "offset" : _create_volume_calc_solar_intensity_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_solar_intensity(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a solar intensity volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_solar_intensity_metadata, name, description, OutArg())

    _create_volume_calc_volume_satisfaction_metric_metadata = { "offset" : _create_volume_calc_volume_satisfaction_metric_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_volume_satisfaction_metric(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a spatial condition satisfaction metric volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_volume_satisfaction_metric_metadata, name, description, OutArg())

    _create_volume_calc_range_metadata = { "offset" : _create_volume_calc_range_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_range(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a distance to location volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_range_metadata, name, description, OutArg())

    _create_volume_calc_delay_range_metadata = { "offset" : _create_volume_calc_delay_range_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_calc_delay_range(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a distance to location volume calc type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFactory._metadata, SpatialAnalysisToolVolumeCalcFactory._create_volume_calc_delay_range_metadata, name, description, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcFactory, [SpatialAnalysisToolVolumeCalcFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5540830022443821797, 17040724212397248403), SpatialAnalysisToolVolumeCalcFactory)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcFactory"] = SpatialAnalysisToolVolumeCalcFactory

class SpatialAnalysisToolVolumeFactory(SupportsDeleteCallback):
    """The factory is used to create instances of volumes."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _is_type_supported_method_offset = 2
    _create_volume_combined_method_offset = 3
    _create_volume_lighting_method_offset = 4
    _create_volume_over_time_method_offset = 5
    _create_volume_from_grid_method_offset = 6
    _create_volume_from_calc_method_offset = 7
    _create_volume_from_time_satisfaction_method_offset = 8
    _create_volume_from_condition_method_offset = 9
    _create_volume_inview_method_offset = 10
    _metadata = {
        "iid_data" : (4718823887408175374, 1421370750746771080),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_VOLUME_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_VOLUME_TYPE") -> "ISpatialAnalysisToolVolume":
        """Create and registers a volume using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_metadata, name, description, type, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_VOLUME_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._is_type_supported_metadata, eType, OutArg())

    _create_volume_combined_metadata = { "offset" : _create_volume_combined_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_combined(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type combined."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_combined_metadata, name, description, OutArg())

    _create_volume_lighting_metadata = { "offset" : _create_volume_lighting_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_lighting(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type lighting."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_lighting_metadata, name, description, OutArg())

    _create_volume_over_time_metadata = { "offset" : _create_volume_over_time_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_over_time(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type over time."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_over_time_metadata, name, description, OutArg())

    _create_volume_from_grid_metadata = { "offset" : _create_volume_from_grid_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_from_grid(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type from grid."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_from_grid_metadata, name, description, OutArg())

    _create_volume_from_calc_metadata = { "offset" : _create_volume_from_calc_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_from_calc(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type from calc."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_from_calc_metadata, name, description, OutArg())

    _create_volume_from_time_satisfaction_metadata = { "offset" : _create_volume_from_time_satisfaction_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_from_time_satisfaction(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type from time satisfaction."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_from_time_satisfaction_metadata, name, description, OutArg())

    _create_volume_from_condition_metadata = { "offset" : _create_volume_from_condition_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_from_condition(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type condition."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_from_condition_metadata, name, description, OutArg())

    _create_volume_inview_metadata = { "offset" : _create_volume_inview_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_inview(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type Inview."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFactory._metadata, SpatialAnalysisToolVolumeFactory._create_volume_inview_metadata, name, description, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFactory, [SpatialAnalysisToolVolumeFactory, ])

agcls.AgClassCatalog.add_catalog_entry((4635516309349170136, 6850651087969509002), SpatialAnalysisToolVolumeFactory)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFactory"] = SpatialAnalysisToolVolumeFactory

class SpatialAnalysisToolVolumeGridFactory(SupportsDeleteCallback):
    """The factory is used to create instances of volume grids."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _create_volume_grid_cartesian_method_offset = 2
    _is_type_supported_method_offset = 3
    _create_volume_grid_cylindrical_method_offset = 4
    _create_volume_grid_spherical_method_offset = 5
    _create_volume_grid_constrained_method_offset = 6
    _create_volume_grid_lat_lon_altitude_method_offset = 7
    _create_volume_grid_bearing_altitude_method_offset = 8
    _metadata = {
        "iid_data" : (5006269217737268897, 4165198783253421479),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_VOLUME_GRID_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, name:str, description:str, type:"CRDN_VOLUME_GRID_TYPE") -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a volume grid using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._create_metadata, name, description, type, OutArg())

    _create_volume_grid_cartesian_metadata = { "offset" : _create_volume_grid_cartesian_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_grid_cartesian(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a cartesian volume grid type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._create_volume_grid_cartesian_metadata, name, description, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_GRID_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, eType:"CRDN_VOLUME_GRID_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._is_type_supported_metadata, eType, OutArg())

    _create_volume_grid_cylindrical_metadata = { "offset" : _create_volume_grid_cylindrical_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_grid_cylindrical(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a cylindrical volume grid type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._create_volume_grid_cylindrical_metadata, name, description, OutArg())

    _create_volume_grid_spherical_metadata = { "offset" : _create_volume_grid_spherical_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_grid_spherical(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a spherical volume grid type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._create_volume_grid_spherical_metadata, name, description, OutArg())

    _create_volume_grid_constrained_metadata = { "offset" : _create_volume_grid_constrained_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_grid_constrained(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a volume grid of type that can be constrained by conditions using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._create_volume_grid_constrained_metadata, name, description, OutArg())

    _create_volume_grid_lat_lon_altitude_metadata = { "offset" : _create_volume_grid_lat_lon_altitude_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_grid_lat_lon_altitude(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers cartographic volume grid type using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._create_volume_grid_lat_lon_altitude_metadata, name, description, OutArg())

    _create_volume_grid_bearing_altitude_metadata = { "offset" : _create_volume_grid_bearing_altitude_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_volume_grid_bearing_altitude(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a volume grid of type surface bearing using specified name and description."""
        return self._intf.invoke(SpatialAnalysisToolVolumeGridFactory._metadata, SpatialAnalysisToolVolumeGridFactory._create_volume_grid_bearing_altitude_metadata, name, description, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridFactory, [SpatialAnalysisToolVolumeGridFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5404595843631519249, 16534451179732670352), SpatialAnalysisToolVolumeGridFactory)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridFactory"] = SpatialAnalysisToolVolumeGridFactory

class SpatialAnalysisToolGridCoordinateDefinition(SupportsDeleteCallback):
    """Define a set of coordinate values."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_method_type_method_offset = 1
    _get_grid_values_method_method_offset = 2
    _set_grid_values_fixed_step_method_offset = 3
    _set_grid_values_fixed_number_of_steps_method_offset = 4
    _set_grid_values_custom_method_offset = 5
    _set_grid_values_fixed_number_of_steps_ex_method_offset = 6
    _metadata = {
        "iid_data" : (5130335259321654556, 16843626956261718182),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolGridCoordinateDefinition)
    
    _get_method_type_metadata = { "offset" : _get_method_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE),) }
    @property
    def method_type(self) -> "CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE":
        """Grid values method type."""
        return self._intf.get_property(SpatialAnalysisToolGridCoordinateDefinition._metadata, SpatialAnalysisToolGridCoordinateDefinition._get_method_type_metadata)

    _get_grid_values_method_metadata = { "offset" : _get_grid_values_method_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def grid_values_method(self) -> "ISpatialAnalysisToolGridValuesMethod":
        """Get or set the grid values interface."""
        return self._intf.get_property(SpatialAnalysisToolGridCoordinateDefinition._metadata, SpatialAnalysisToolGridCoordinateDefinition._get_grid_values_method_metadata)

    _set_grid_values_fixed_step_metadata = { "offset" : _set_grid_values_fixed_step_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT_BOOL, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.VariantBoolArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def set_grid_values_fixed_step(self, min:float, max:float, includeMinMax:bool, refValue:float, fixedStep:float) -> "SpatialAnalysisToolGridValuesFixedStep":
        """Set grid values type to fixed step."""
        return self._intf.invoke(SpatialAnalysisToolGridCoordinateDefinition._metadata, SpatialAnalysisToolGridCoordinateDefinition._set_grid_values_fixed_step_metadata, min, max, includeMinMax, refValue, fixedStep, OutArg())

    _set_grid_values_fixed_number_of_steps_metadata = { "offset" : _set_grid_values_fixed_number_of_steps_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def set_grid_values_fixed_number_of_steps(self, min:float, max:float, numSteps:int) -> "SpatialAnalysisToolGridValuesFixedNumberOfSteps":
        """Do not use this method, as it is deprecated. Use SetGridValuesFixedNumberOfStepsEx."""
        return self._intf.invoke(SpatialAnalysisToolGridCoordinateDefinition._metadata, SpatialAnalysisToolGridCoordinateDefinition._set_grid_values_fixed_number_of_steps_metadata, min, max, numSteps, OutArg())

    _set_grid_values_custom_metadata = { "offset" : _set_grid_values_custom_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def set_grid_values_custom(self, values:list) -> "SpatialAnalysisToolGridValuesCustom":
        """Set grid values type to custom values."""
        return self._intf.invoke(SpatialAnalysisToolGridCoordinateDefinition._metadata, SpatialAnalysisToolGridCoordinateDefinition._set_grid_values_custom_metadata, values, OutArg())

    _set_grid_values_fixed_number_of_steps_ex_metadata = { "offset" : _set_grid_values_fixed_number_of_steps_ex_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"), agmarshall.InterfaceInArg("Quantity"), agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def set_grid_values_fixed_number_of_steps_ex(self, min:"Quantity", max:"Quantity", numSteps:int) -> "SpatialAnalysisToolGridValuesFixedNumberOfSteps":
        """Set grid values type to fixed number of steps with min and max as Quantity."""
        return self._intf.invoke(SpatialAnalysisToolGridCoordinateDefinition._metadata, SpatialAnalysisToolGridCoordinateDefinition._set_grid_values_fixed_number_of_steps_ex_metadata, min, max, numSteps, OutArg())

    _property_names[method_type] = "method_type"
    _property_names[grid_values_method] = "grid_values_method"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolGridCoordinateDefinition."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolGridCoordinateDefinition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridCoordinateDefinition, [SpatialAnalysisToolGridCoordinateDefinition, ])

agcls.AgClassCatalog.add_catalog_entry((4908749182944525328, 3082335439345659541), SpatialAnalysisToolGridCoordinateDefinition)
agcls.AgTypeNameMap["SpatialAnalysisToolGridCoordinateDefinition"] = SpatialAnalysisToolGridCoordinateDefinition

class SpatialAnalysisToolGridValuesCustom(ISpatialAnalysisToolGridValuesMethod, SupportsDeleteCallback):
    """Fixed step grid values."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_values_method_offset = 1
    _set_values_method_offset = 2
    _metadata = {
        "iid_data" : (5079967470133000247, 1440374130877273486),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolGridValuesCustom)
    
    _get_values_metadata = { "offset" : _get_values_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def values(self) -> list:
        """Custom set of coordinate values."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesCustom._metadata, SpatialAnalysisToolGridValuesCustom._get_values_metadata)

    _set_values_metadata = { "offset" : _set_values_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @values.setter
    def values(self, values:list) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesCustom._metadata, SpatialAnalysisToolGridValuesCustom._set_values_metadata, values)

    _property_names[values] = "values"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolGridValuesCustom."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolGridValuesCustom)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesCustom, [SpatialAnalysisToolGridValuesCustom, ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry((4675204159661460389, 16403186152470131590), SpatialAnalysisToolGridValuesCustom)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesCustom"] = SpatialAnalysisToolGridValuesCustom

class SpatialAnalysisToolGridValuesFixedNumberOfSteps(ISpatialAnalysisToolGridValuesMethod, SupportsDeleteCallback):
    """Fixed step grid values."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_min_method_offset = 1
    _set_min_method_offset = 2
    _get_max_method_offset = 3
    _set_max_method_offset = 4
    _get_number_of_steps_method_offset = 5
    _set_number_of_steps_method_offset = 6
    _get_min_ex_method_offset = 7
    _set_min_ex_method_offset = 8
    _get_max_ex_method_offset = 9
    _set_max_ex_method_offset = 10
    _metadata = {
        "iid_data" : (5139481416355729146, 10630847657046153914),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolGridValuesFixedNumberOfSteps)
    
    _get_min_metadata = { "offset" : _get_min_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def min(self) -> float:
        """Do not use this property, as it is deprecated. Use MinEx."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._get_min_metadata)

    _set_min_metadata = { "offset" : _set_min_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @min.setter
    def min(self, min:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._set_min_metadata, min)

    _get_max_metadata = { "offset" : _get_max_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def max(self) -> float:
        """Do not use this property, as it is deprecated. Use MaxEx."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._get_max_metadata)

    _set_max_metadata = { "offset" : _set_max_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @max.setter
    def max(self, max:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._set_max_metadata, max)

    _get_number_of_steps_metadata = { "offset" : _get_number_of_steps_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def number_of_steps(self) -> int:
        """The number of steps between coordinate values."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._get_number_of_steps_metadata)

    _set_number_of_steps_metadata = { "offset" : _set_number_of_steps_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @number_of_steps.setter
    def number_of_steps(self, numberOfSteps:int) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._set_number_of_steps_metadata, numberOfSteps)

    _get_min_ex_metadata = { "offset" : _get_min_ex_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def min_ex(self) -> "Quantity":
        """Minimum coordinate value as Quantity."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._get_min_ex_metadata)

    _set_min_ex_metadata = { "offset" : _set_min_ex_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"),) }
    @min_ex.setter
    def min_ex(self, minEx:"Quantity") -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._set_min_ex_metadata, minEx)

    _get_max_ex_metadata = { "offset" : _get_max_ex_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def max_ex(self) -> "Quantity":
        """Maximum coordinate value as Quantity."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._get_max_ex_metadata)

    _set_max_ex_metadata = { "offset" : _set_max_ex_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"),) }
    @max_ex.setter
    def max_ex(self, maxEx:"Quantity") -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, SpatialAnalysisToolGridValuesFixedNumberOfSteps._set_max_ex_metadata, maxEx)

    _property_names[min] = "min"
    _property_names[max] = "max"
    _property_names[number_of_steps] = "number_of_steps"
    _property_names[min_ex] = "min_ex"
    _property_names[max_ex] = "max_ex"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolGridValuesFixedNumberOfSteps."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolGridValuesFixedNumberOfSteps)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesFixedNumberOfSteps, [SpatialAnalysisToolGridValuesFixedNumberOfSteps, ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry((4906412158379095950, 18165921868605089162), SpatialAnalysisToolGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesFixedNumberOfSteps"] = SpatialAnalysisToolGridValuesFixedNumberOfSteps

class SpatialAnalysisToolGridValuesFixedStep(ISpatialAnalysisToolGridValuesMethod, SupportsDeleteCallback):
    """Fixed step grid values."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_min_method_offset = 1
    _set_min_method_offset = 2
    _get_max_method_offset = 3
    _set_max_method_offset = 4
    _get_include_min_max_method_offset = 5
    _set_include_min_max_method_offset = 6
    _get_reference_value_method_offset = 7
    _set_reference_value_method_offset = 8
    _get_step_method_offset = 9
    _set_step_method_offset = 10
    _metadata = {
        "iid_data" : (5343659644451078017, 5778378386165949108),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolGridValuesFixedStep)
    
    _get_min_metadata = { "offset" : _get_min_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def min(self) -> float:
        """Minimum coordinate value."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._get_min_metadata)

    _set_min_metadata = { "offset" : _set_min_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @min.setter
    def min(self, min:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._set_min_metadata, min)

    _get_max_metadata = { "offset" : _get_max_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def max(self) -> float:
        """Maximum coordinate value."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._get_max_metadata)

    _set_max_metadata = { "offset" : _set_max_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @max.setter
    def max(self, max:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._set_max_metadata, max)

    _get_include_min_max_metadata = { "offset" : _get_include_min_max_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def include_min_max(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._get_include_min_max_metadata)

    _set_include_min_max_metadata = { "offset" : _set_include_min_max_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @include_min_max.setter
    def include_min_max(self, includeMinMax:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._set_include_min_max_metadata, includeMinMax)

    _get_reference_value_metadata = { "offset" : _get_reference_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def reference_value(self) -> float:
        """Reference coordinate value from which steps are taken."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._get_reference_value_metadata)

    _set_reference_value_metadata = { "offset" : _set_reference_value_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @reference_value.setter
    def reference_value(self, referenceValue:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._set_reference_value_metadata, referenceValue)

    _get_step_metadata = { "offset" : _get_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def step(self) -> float:
        """Step between subsequent coordinate values."""
        return self._intf.get_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._get_step_metadata)

    _set_step_metadata = { "offset" : _set_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @step.setter
    def step(self, step:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolGridValuesFixedStep._metadata, SpatialAnalysisToolGridValuesFixedStep._set_step_metadata, step)

    _property_names[min] = "min"
    _property_names[max] = "max"
    _property_names[include_min_max] = "include_min_max"
    _property_names[reference_value] = "reference_value"
    _property_names[step] = "step"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolGridValuesFixedStep."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolGridValuesFixedStep)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesFixedStep, [SpatialAnalysisToolGridValuesFixedStep, ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry((4734747611981081133, 2146139380126170776), SpatialAnalysisToolGridValuesFixedStep)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesFixedStep"] = SpatialAnalysisToolGridValuesFixedStep

class SpatialAnalysisToolGridValuesMethod(ISpatialAnalysisToolGridValuesMethod, SupportsDeleteCallback):
    """A grid values method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolGridValuesMethod."""
        SupportsDeleteCallback.__init__(self)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesMethod, [ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry((4916369434262782655, 3989956864512378539), SpatialAnalysisToolGridValuesMethod)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesMethod"] = SpatialAnalysisToolGridValuesMethod

class TimeToolLightTimeDelay(SupportsDeleteCallback):
    """Manage Light Time Delay options.."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_use_light_time_delay_method_offset = 1
    _set_use_light_time_delay_method_offset = 2
    _get_time_delay_convergence_method_offset = 3
    _set_time_delay_convergence_method_offset = 4
    _get_aberration_type_method_offset = 5
    _set_aberration_type_method_offset = 6
    _get_clock_host_method_offset = 7
    _set_clock_host_method_offset = 8
    _get_time_sense_method_offset = 9
    _set_time_sense_method_offset = 10
    _metadata = {
        "iid_data" : (5571719835290065762, 15016412572713881232),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolLightTimeDelay)
    
    _get_use_light_time_delay_metadata = { "offset" : _get_use_light_time_delay_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_light_time_delay(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        return self._intf.get_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._get_use_light_time_delay_metadata)

    _set_use_light_time_delay_metadata = { "offset" : _set_use_light_time_delay_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_light_time_delay.setter
    def use_light_time_delay(self, useLightTimeDelay:bool) -> None:
        return self._intf.set_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._set_use_light_time_delay_metadata, useLightTimeDelay)

    _get_time_delay_convergence_metadata = { "offset" : _get_time_delay_convergence_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_delay_convergence(self) -> float:
        """Set light Time Delay Convergence."""
        return self._intf.get_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._get_time_delay_convergence_metadata)

    _set_time_delay_convergence_metadata = { "offset" : _set_time_delay_convergence_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @time_delay_convergence.setter
    def time_delay_convergence(self, timeDelayConvergence:float) -> None:
        return self._intf.set_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._set_time_delay_convergence_metadata, timeDelayConvergence)

    _get_aberration_type_metadata = { "offset" : _get_aberration_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_ABERRATION_TYPE),) }
    @property
    def aberration_type(self) -> "CRDN_VOLUME_ABERRATION_TYPE":
        """Method used to Aberration Type."""
        return self._intf.get_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._get_aberration_type_metadata)

    _set_aberration_type_metadata = { "offset" : _set_aberration_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_ABERRATION_TYPE),) }
    @aberration_type.setter
    def aberration_type(self, aberrationType:"CRDN_VOLUME_ABERRATION_TYPE") -> None:
        return self._intf.set_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._set_aberration_type_metadata, aberrationType)

    _get_clock_host_metadata = { "offset" : _get_clock_host_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CLOCK_HOST_TYPE),) }
    @property
    def clock_host(self) -> "CRDN_VOLUME_CLOCK_HOST_TYPE":
        """Indicate whether object1 or object2 of an Access instance holds the clock for Access times."""
        return self._intf.get_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._get_clock_host_metadata)

    _set_clock_host_metadata = { "offset" : _set_clock_host_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CLOCK_HOST_TYPE),) }
    @clock_host.setter
    def clock_host(self, clockHost:"CRDN_VOLUME_CLOCK_HOST_TYPE") -> None:
        return self._intf.set_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._set_clock_host_metadata, clockHost)

    _get_time_sense_metadata = { "offset" : _get_time_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_TIME_SENSE_TYPE),) }
    @property
    def time_sense(self) -> "CRDN_VOLUME_TIME_SENSE_TYPE":
        """Indicate whether apparent position is computed in a transmit or receive sense."""
        return self._intf.get_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._get_time_sense_metadata)

    _set_time_sense_metadata = { "offset" : _set_time_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_TIME_SENSE_TYPE),) }
    @time_sense.setter
    def time_sense(self, timeSense:"CRDN_VOLUME_TIME_SENSE_TYPE") -> None:
        return self._intf.set_property(TimeToolLightTimeDelay._metadata, TimeToolLightTimeDelay._set_time_sense_metadata, timeSense)

    _property_names[use_light_time_delay] = "use_light_time_delay"
    _property_names[time_delay_convergence] = "time_delay_convergence"
    _property_names[aberration_type] = "aberration_type"
    _property_names[clock_host] = "clock_host"
    _property_names[time_sense] = "time_sense"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolLightTimeDelay."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolLightTimeDelay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolLightTimeDelay, [TimeToolLightTimeDelay, ])

agcls.AgClassCatalog.add_catalog_entry((5707542397246644802, 8133195754214030981), TimeToolLightTimeDelay)
agcls.AgTypeNameMap["TimeToolLightTimeDelay"] = TimeToolLightTimeDelay

class SpatialAnalysisToolVolume(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolume."""
        SupportsDeleteCallback.__init__(self)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolume, [ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5136212516512030015, 17210711229734835135), SpatialAnalysisToolVolume)
agcls.AgTypeNameMap["SpatialAnalysisToolVolume"] = SpatialAnalysisToolVolume

class SpatialAnalysisToolVolumeCalc(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalc."""
        SupportsDeleteCallback.__init__(self)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalc, [ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5603624786402262993, 11281447092007354792), SpatialAnalysisToolVolumeCalc)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalc"] = SpatialAnalysisToolVolumeCalc

class SpatialAnalysisToolVolumeCalcAltitude(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc altitude interface."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _set_central_body_method_offset = 2
    _get_shape_model_method_offset = 3
    _set_shape_model_method_offset = 4
    _get_use_custom_reference_method_offset = 5
    _set_use_custom_reference_method_offset = 6
    _get_reference_point_method_offset = 7
    _set_reference_point_method_offset = 8
    _metadata = {
        "iid_data" : (5267149886846502538, 15246089171375647638),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcAltitude)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get the central body for the volume calc. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume calc."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._set_central_body_metadata, centralBody)

    _get_shape_model_metadata = { "offset" : _get_shape_model_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE),) }
    @property
    def shape_model(self) -> "CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE":
        """The Volume Calc Altitude Reference Type."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._get_shape_model_metadata)

    _set_shape_model_metadata = { "offset" : _set_shape_model_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE),) }
    @shape_model.setter
    def shape_model(self, shapeModel:"CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._set_shape_model_metadata, shapeModel)

    _get_use_custom_reference_metadata = { "offset" : _get_use_custom_reference_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_reference(self) -> bool:
        """Whether to use custom reference."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._get_use_custom_reference_metadata)

    _set_use_custom_reference_metadata = { "offset" : _set_use_custom_reference_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_reference.setter
    def use_custom_reference(self, useCustomReference:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._set_use_custom_reference_metadata, useCustomReference)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """A reference point. Can be any point from VGT."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._get_reference_point_metadata)

    _set_reference_point_metadata = { "offset" : _set_reference_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAltitude._metadata, SpatialAnalysisToolVolumeCalcAltitude._set_reference_point_metadata, referencePoint)

    _property_names[central_body] = "central_body"
    _property_names[shape_model] = "shape_model"
    _property_names[use_custom_reference] = "use_custom_reference"
    _property_names[reference_point] = "reference_point"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcAltitude."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcAltitude)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcAltitude, [SpatialAnalysisToolVolumeCalcAltitude, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5246343411400455836, 13693915155416519566), SpatialAnalysisToolVolumeCalcAltitude)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcAltitude"] = SpatialAnalysisToolVolumeCalcAltitude

class SpatialAnalysisToolVolumeCalcAngleOffVector(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc angle off vector interface."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_angle_method_offset = 1
    _set_angle_method_offset = 2
    _get_reference_plane_method_offset = 3
    _set_reference_plane_method_offset = 4
    _get_reference_point_method_offset = 5
    _set_reference_point_method_offset = 6
    _get_reference_vector_method_offset = 7
    _set_reference_vector_method_offset = 8
    _get_about_vector_method_offset = 9
    _set_about_vector_method_offset = 10
    _metadata = {
        "iid_data" : (5168636768733921460, 8889143688558765241),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcAngleOffVector)
    
    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE),) }
    @property
    def angle(self) -> "CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE":
        """The Volume Calc Angle Off Vector Type."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._get_angle_metadata)

    _set_angle_metadata = { "offset" : _set_angle_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE),) }
    @angle.setter
    def angle(self, angle:"CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._set_angle_metadata, angle)

    _get_reference_plane_metadata = { "offset" : _get_reference_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_plane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Angle Off Vector reference plane."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._get_reference_plane_metadata)

    _set_reference_plane_metadata = { "offset" : _set_reference_plane_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPlane"),) }
    @reference_plane.setter
    def reference_plane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._set_reference_plane_metadata, referencePlane)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Angle Off Vector reference point."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._get_reference_point_metadata)

    _set_reference_point_metadata = { "offset" : _set_reference_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._set_reference_point_metadata, referencePoint)

    _get_reference_vector_metadata = { "offset" : _get_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Angle Off Vector reference vector."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._get_reference_vector_metadata)

    _set_reference_vector_metadata = { "offset" : _set_reference_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @reference_vector.setter
    def reference_vector(self, referenceVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._set_reference_vector_metadata, referenceVector)

    _get_about_vector_metadata = { "offset" : _get_about_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def about_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Angle Off Vector reference about vector."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._get_about_vector_metadata)

    _set_about_vector_metadata = { "offset" : _set_about_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @about_vector.setter
    def about_vector(self, aboutVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcAngleOffVector._metadata, SpatialAnalysisToolVolumeCalcAngleOffVector._set_about_vector_metadata, aboutVector)

    _property_names[angle] = "angle"
    _property_names[reference_plane] = "reference_plane"
    _property_names[reference_point] = "reference_point"
    _property_names[reference_vector] = "reference_vector"
    _property_names[about_vector] = "about_vector"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcAngleOffVector."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcAngleOffVector)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcAngleOffVector, [SpatialAnalysisToolVolumeCalcAngleOffVector, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5561615505447228747, 2307594500702910097), SpatialAnalysisToolVolumeCalcAngleOffVector)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcAngleOffVector"] = SpatialAnalysisToolVolumeCalcAngleOffVector

class SpatialAnalysisToolVolumeCalcConditionSatMetric(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc condition satisfaction interface."""

    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_spatial_condition_method_offset = 1
    _set_spatial_condition_method_offset = 2
    _get_satisfaction_metric_method_offset = 3
    _set_satisfaction_metric_method_offset = 4
    _get_accumulation_type_method_offset = 5
    _set_accumulation_type_method_offset = 6
    _get_duration_type_method_offset = 7
    _set_duration_type_method_offset = 8
    _get_filter_method_offset = 9
    _set_filter_method_offset = 10
    _get_maximum_number_of_intervals_method_offset = 11
    _set_maximum_number_of_intervals_method_offset = 12
    _get_use_minimum_duration_method_offset = 13
    _set_use_minimum_duration_method_offset = 14
    _get_use_maximum_duration_method_offset = 15
    _set_use_maximum_duration_method_offset = 16
    _get_minimum_duration_time_method_offset = 17
    _set_minimum_duration_time_method_offset = 18
    _get_maximum_duration_time_method_offset = 19
    _set_maximum_duration_time_method_offset = 20
    _metadata = {
        "iid_data" : (4773877820582895346, 18047239333924917439),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcConditionSatMetric)
    
    _get_spatial_condition_metadata = { "offset" : _get_spatial_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def spatial_condition(self) -> "ISpatialAnalysisToolVolume":
        """A spatial condition for satisfaction metric."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_spatial_condition_metadata)

    _set_spatial_condition_metadata = { "offset" : _set_spatial_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolume"),) }
    @spatial_condition.setter
    def spatial_condition(self, spatialCondition:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_spatial_condition_metadata, spatialCondition)

    _get_satisfaction_metric_metadata = { "offset" : _get_satisfaction_metric_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE),) }
    @property
    def satisfaction_metric(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE":
        """Spatial condition satisfaction metric types."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_satisfaction_metric_metadata)

    _set_satisfaction_metric_metadata = { "offset" : _set_satisfaction_metric_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE),) }
    @satisfaction_metric.setter
    def satisfaction_metric(self, satisfactionMetric:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_satisfaction_metric_metadata, satisfactionMetric)

    _get_accumulation_type_metadata = { "offset" : _get_accumulation_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE),) }
    @property
    def accumulation_type(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE":
        """Spatial condition satisfaction accumulation types."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_accumulation_type_metadata)

    _set_accumulation_type_metadata = { "offset" : _set_accumulation_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE),) }
    @accumulation_type.setter
    def accumulation_type(self, accumulationType:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_accumulation_type_metadata, accumulationType)

    _get_duration_type_metadata = { "offset" : _get_duration_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE),) }
    @property
    def duration_type(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE":
        """Spatial condition satisfaction duration types."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_duration_type_metadata)

    _set_duration_type_metadata = { "offset" : _set_duration_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE),) }
    @duration_type.setter
    def duration_type(self, durationType:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_duration_type_metadata, durationType)

    _get_filter_metadata = { "offset" : _get_filter_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE),) }
    @property
    def filter(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE":
        """Spatial condition satisfaction duration types."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_filter_metadata)

    _set_filter_metadata = { "offset" : _set_filter_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE),) }
    @filter.setter
    def filter(self, filter:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_filter_metadata, filter)

    _get_maximum_number_of_intervals_metadata = { "offset" : _get_maximum_number_of_intervals_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_number_of_intervals(self) -> int:
        """Spatial condition satisfaction Maximum number of intervals."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_maximum_number_of_intervals_metadata)

    _set_maximum_number_of_intervals_metadata = { "offset" : _set_maximum_number_of_intervals_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_number_of_intervals.setter
    def maximum_number_of_intervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_maximum_number_of_intervals_metadata, maximumNumberOfIntervals)

    _get_use_minimum_duration_metadata = { "offset" : _get_use_minimum_duration_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_minimum_duration(self) -> bool:
        """Spatial condition satisfaction enable minimum duration."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_use_minimum_duration_metadata)

    _set_use_minimum_duration_metadata = { "offset" : _set_use_minimum_duration_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_minimum_duration.setter
    def use_minimum_duration(self, useMinimumDuration:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_use_minimum_duration_metadata, useMinimumDuration)

    _get_use_maximum_duration_metadata = { "offset" : _get_use_maximum_duration_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_maximum_duration(self) -> bool:
        """Spatial condition satisfaction enable maximum duration."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_use_maximum_duration_metadata)

    _set_use_maximum_duration_metadata = { "offset" : _set_use_maximum_duration_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_maximum_duration.setter
    def use_maximum_duration(self, useMaximumDuration:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_use_maximum_duration_metadata, useMaximumDuration)

    _get_minimum_duration_time_metadata = { "offset" : _get_minimum_duration_time_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_duration_time(self) -> float:
        """Spatial condition satisfaction minimum duration time."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_minimum_duration_time_metadata)

    _set_minimum_duration_time_metadata = { "offset" : _set_minimum_duration_time_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_duration_time.setter
    def minimum_duration_time(self, minimumDurationTime:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_minimum_duration_time_metadata, minimumDurationTime)

    _get_maximum_duration_time_metadata = { "offset" : _get_maximum_duration_time_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_duration_time(self) -> float:
        """Spatial condition satisfaction maximum duration time."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._get_maximum_duration_time_metadata)

    _set_maximum_duration_time_metadata = { "offset" : _set_maximum_duration_time_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_duration_time.setter
    def maximum_duration_time(self, maximumDurationTime:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, SpatialAnalysisToolVolumeCalcConditionSatMetric._set_maximum_duration_time_metadata, maximumDurationTime)

    _property_names[spatial_condition] = "spatial_condition"
    _property_names[satisfaction_metric] = "satisfaction_metric"
    _property_names[accumulation_type] = "accumulation_type"
    _property_names[duration_type] = "duration_type"
    _property_names[filter] = "filter"
    _property_names[maximum_number_of_intervals] = "maximum_number_of_intervals"
    _property_names[use_minimum_duration] = "use_minimum_duration"
    _property_names[use_maximum_duration] = "use_maximum_duration"
    _property_names[minimum_duration_time] = "minimum_duration_time"
    _property_names[maximum_duration_time] = "maximum_duration_time"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcConditionSatMetric."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcConditionSatMetric)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcConditionSatMetric, [SpatialAnalysisToolVolumeCalcConditionSatMetric, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5757987867521137107, 16897264315178726031), SpatialAnalysisToolVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcConditionSatMetric"] = SpatialAnalysisToolVolumeCalcConditionSatMetric

class SpatialAnalysisToolVolumeCalcDelayRange(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc propagation delay to location interface."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_distance_method_offset = 1
    _set_distance_method_offset = 2
    _get_reference_point_method_offset = 3
    _set_reference_point_method_offset = 4
    _get_reference_plane_method_offset = 5
    _set_reference_plane_method_offset = 6
    _get_along_vector_method_offset = 7
    _set_along_vector_method_offset = 8
    _get_speed_type_method_offset = 9
    _set_speed_type_method_offset = 10
    _get_speed_method_offset = 11
    _set_speed_method_offset = 12
    _metadata = {
        "iid_data" : (5218582178275522249, 11135030506945546897),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcDelayRange)
    
    _get_distance_metadata = { "offset" : _get_distance_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @property
    def distance(self) -> "CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE":
        """The Volume Calc range distance types."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._get_distance_metadata)

    _set_distance_metadata = { "offset" : _set_distance_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @distance.setter
    def distance(self, distance:"CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._set_distance_metadata, distance)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Range reference point."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._get_reference_point_metadata)

    _set_reference_point_metadata = { "offset" : _set_reference_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._set_reference_point_metadata, referencePoint)

    _get_reference_plane_metadata = { "offset" : _get_reference_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_plane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Range reference plane."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._get_reference_plane_metadata)

    _set_reference_plane_metadata = { "offset" : _set_reference_plane_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPlane"),) }
    @reference_plane.setter
    def reference_plane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._set_reference_plane_metadata, referencePlane)

    _get_along_vector_metadata = { "offset" : _get_along_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def along_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Range Along Vector."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._get_along_vector_metadata)

    _set_along_vector_metadata = { "offset" : _set_along_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @along_vector.setter
    def along_vector(self, alongVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._set_along_vector_metadata, alongVector)

    _get_speed_type_metadata = { "offset" : _get_speed_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_RANGE_SPEED_TYPE),) }
    @property
    def speed_type(self) -> "CRDN_VOLUME_CALC_RANGE_SPEED_TYPE":
        """The Volume Calc range speed types."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._get_speed_type_metadata)

    _set_speed_type_metadata = { "offset" : _set_speed_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_RANGE_SPEED_TYPE),) }
    @speed_type.setter
    def speed_type(self, speedType:"CRDN_VOLUME_CALC_RANGE_SPEED_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._set_speed_type_metadata, speedType)

    _get_speed_metadata = { "offset" : _get_speed_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def speed(self) -> float:
        """The Volume Calc range speed value."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._get_speed_metadata)

    _set_speed_metadata = { "offset" : _set_speed_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @speed.setter
    def speed(self, speed:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcDelayRange._metadata, SpatialAnalysisToolVolumeCalcDelayRange._set_speed_metadata, speed)

    _property_names[distance] = "distance"
    _property_names[reference_point] = "reference_point"
    _property_names[reference_plane] = "reference_plane"
    _property_names[along_vector] = "along_vector"
    _property_names[speed_type] = "speed_type"
    _property_names[speed] = "speed"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcDelayRange."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcDelayRange)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcDelayRange, [SpatialAnalysisToolVolumeCalcDelayRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5452141680403908840, 4382880934208172435), SpatialAnalysisToolVolumeCalcDelayRange)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcDelayRange"] = SpatialAnalysisToolVolumeCalcDelayRange

class SpatialAnalysisToolVolumeCalcFile(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filename_method_offset = 1
    _set_filename_method_offset = 2
    _reload_method_offset = 3
    _metadata = {
        "iid_data" : (5218807709942117381, 22719842710704015),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcFile)
    
    _get_filename_metadata = { "offset" : _get_filename_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def filename(self) -> str:
        """The path of an external file that contains the volume calc data."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcFile._metadata, SpatialAnalysisToolVolumeCalcFile._get_filename_metadata)

    _set_filename_metadata = { "offset" : _set_filename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcFile._metadata, SpatialAnalysisToolVolumeCalcFile._set_filename_metadata, filename)

    _reload_metadata = { "offset" : _reload_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the volume calc file."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCalcFile._metadata, SpatialAnalysisToolVolumeCalcFile._reload_metadata, )

    _property_names[filename] = "filename"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcFile."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcFile)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcFile, [SpatialAnalysisToolVolumeCalcFile, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5046729131766552262, 14215457174500361369), SpatialAnalysisToolVolumeCalcFile)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcFile"] = SpatialAnalysisToolVolumeCalcFile

class SpatialAnalysisToolVolumeCalcFromScalar(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc scalar to location interface."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_scalar_method_offset = 1
    _set_scalar_method_offset = 2
    _metadata = {
        "iid_data" : (4955629015681694503, 13135773078564024969),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcFromScalar)
    
    _get_scalar_metadata = { "offset" : _get_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """The Volume calc scalar to location Type."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcFromScalar._metadata, SpatialAnalysisToolVolumeCalcFromScalar._get_scalar_metadata)

    _set_scalar_metadata = { "offset" : _set_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcFromScalar._metadata, SpatialAnalysisToolVolumeCalcFromScalar._set_scalar_metadata, scalar)

    _property_names[scalar] = "scalar"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcFromScalar."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcFromScalar)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcFromScalar, [SpatialAnalysisToolVolumeCalcFromScalar, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5507501849095280163, 3788369914884987542), SpatialAnalysisToolVolumeCalcFromScalar)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcFromScalar"] = SpatialAnalysisToolVolumeCalcFromScalar

class SpatialAnalysisToolVolumeCalcRange(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc distance to location interface."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_distance_method_offset = 1
    _set_distance_method_offset = 2
    _get_reference_point_method_offset = 3
    _set_reference_point_method_offset = 4
    _get_reference_plane_method_offset = 5
    _set_reference_plane_method_offset = 6
    _get_along_vector_method_offset = 7
    _set_along_vector_method_offset = 8
    _metadata = {
        "iid_data" : (4785811411061355726, 9627460967860643760),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcRange)
    
    _get_distance_metadata = { "offset" : _get_distance_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @property
    def distance(self) -> "CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE":
        """The Volume Calc range distance types."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._get_distance_metadata)

    _set_distance_metadata = { "offset" : _set_distance_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @distance.setter
    def distance(self, distance:"CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._set_distance_metadata, distance)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Range reference point."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._get_reference_point_metadata)

    _set_reference_point_metadata = { "offset" : _set_reference_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._set_reference_point_metadata, referencePoint)

    _get_reference_plane_metadata = { "offset" : _get_reference_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_plane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Range reference plane."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._get_reference_plane_metadata)

    _set_reference_plane_metadata = { "offset" : _set_reference_plane_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPlane"),) }
    @reference_plane.setter
    def reference_plane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._set_reference_plane_metadata, referencePlane)

    _get_along_vector_metadata = { "offset" : _get_along_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def along_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Range Along Vector."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._get_along_vector_metadata)

    _set_along_vector_metadata = { "offset" : _set_along_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @along_vector.setter
    def along_vector(self, alongVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcRange._metadata, SpatialAnalysisToolVolumeCalcRange._set_along_vector_metadata, alongVector)

    _property_names[distance] = "distance"
    _property_names[reference_point] = "reference_point"
    _property_names[reference_plane] = "reference_plane"
    _property_names[along_vector] = "along_vector"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcRange."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcRange)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcRange, [SpatialAnalysisToolVolumeCalcRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5742064057873770847, 7474360553064389522), SpatialAnalysisToolVolumeCalcRange)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcRange"] = SpatialAnalysisToolVolumeCalcRange

class SpatialAnalysisToolVolumeCalcSolarIntensity(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume calc solar intensityn interface."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_eclipsing_bodies_method_offset = 1
    _set_eclipsing_bodies_method_offset = 2
    _get_use_object_eclipsing_bodies_method_offset = 3
    _set_use_object_eclipsing_bodies_method_offset = 4
    _metadata = {
        "iid_data" : (4943433429512576811, 6998738882333593242),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCalcSolarIntensity)
    
    _get_eclipsing_bodies_metadata = { "offset" : _get_eclipsing_bodies_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def eclipsing_bodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcSolarIntensity._metadata, SpatialAnalysisToolVolumeCalcSolarIntensity._get_eclipsing_bodies_metadata)

    _set_eclipsing_bodies_metadata = { "offset" : _set_eclipsing_bodies_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @eclipsing_bodies.setter
    def eclipsing_bodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcSolarIntensity._metadata, SpatialAnalysisToolVolumeCalcSolarIntensity._set_eclipsing_bodies_metadata, eclipsingBodies)

    _get_use_object_eclipsing_bodies_metadata = { "offset" : _get_use_object_eclipsing_bodies_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_object_eclipsing_bodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCalcSolarIntensity._metadata, SpatialAnalysisToolVolumeCalcSolarIntensity._get_use_object_eclipsing_bodies_metadata)

    _set_use_object_eclipsing_bodies_metadata = { "offset" : _set_use_object_eclipsing_bodies_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_object_eclipsing_bodies.setter
    def use_object_eclipsing_bodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCalcSolarIntensity._metadata, SpatialAnalysisToolVolumeCalcSolarIntensity._set_use_object_eclipsing_bodies_metadata, useObjectEclipsingBodies)

    _property_names[eclipsing_bodies] = "eclipsing_bodies"
    _property_names[use_object_eclipsing_bodies] = "use_object_eclipsing_bodies"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCalcSolarIntensity."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCalcSolarIntensity)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcSolarIntensity, [SpatialAnalysisToolVolumeCalcSolarIntensity, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5721214495491549297, 15401307401531350179), SpatialAnalysisToolVolumeCalcSolarIntensity)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcSolarIntensity"] = SpatialAnalysisToolVolumeCalcSolarIntensity

class SpatialAnalysisToolVolumeCombined(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A combined volume interface."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_combine_operation_method_offset = 1
    _set_combine_operation_method_offset = 2
    _get_condition_count_method_offset = 3
    _get_all_conditions_method_offset = 4
    _set_all_conditions_method_offset = 5
    _set_condition_method_offset = 6
    _get_condition_method_offset = 7
    _remove_condition_method_offset = 8
    _metadata = {
        "iid_data" : (4961621234466443188, 11142847482331365549),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeCombined)
    
    _get_combine_operation_metadata = { "offset" : _get_combine_operation_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_COMBINED_OPERATION_TYPE),) }
    @property
    def combine_operation(self) -> "CRDN_VOLUME_COMBINED_OPERATION_TYPE":
        """Get or set volume combined operation."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._get_combine_operation_metadata)

    _set_combine_operation_metadata = { "offset" : _set_combine_operation_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_COMBINED_OPERATION_TYPE),) }
    @combine_operation.setter
    def combine_operation(self, combineOperation:"CRDN_VOLUME_COMBINED_OPERATION_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._set_combine_operation_metadata, combineOperation)

    _get_condition_count_metadata = { "offset" : _get_condition_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def condition_count(self) -> int:
        """Return the spatial condition vector size."""
        return self._intf.get_property(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._get_condition_count_metadata)

    _get_all_conditions_metadata = { "offset" : _get_all_conditions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def get_all_conditions(self) -> list:
        """Get all spatial conditions."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._get_all_conditions_metadata, OutArg())

    _set_all_conditions_metadata = { "offset" : _set_all_conditions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_all_conditions(self, conditions:list) -> None:
        """Set all spatial conditions."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._set_all_conditions_metadata, conditions)

    _set_condition_metadata = { "offset" : _set_condition_method_offset,
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolume"), agmarshall.IntArg,) }
    def set_condition(self, ref:"ISpatialAnalysisToolVolume", pos:int) -> None:
        """Set spatial conditions at a position."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._set_condition_metadata, ref, pos)

    _get_condition_metadata = { "offset" : _get_condition_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_condition(self, pos:int) -> "ISpatialAnalysisToolVolume":
        """Get spatial conditions at a position."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._get_condition_metadata, pos, OutArg())

    _remove_condition_metadata = { "offset" : _remove_condition_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    def remove_condition(self, pos:int) -> None:
        """Remove spatial conditions at a position."""
        return self._intf.invoke(SpatialAnalysisToolVolumeCombined._metadata, SpatialAnalysisToolVolumeCombined._remove_condition_metadata, pos)

    _property_names[combine_operation] = "combine_operation"
    _property_names[condition_count] = "condition_count"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeCombined."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeCombined)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCombined, [SpatialAnalysisToolVolumeCombined, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5171174926120201865, 5073276570713395112), SpatialAnalysisToolVolumeCombined)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCombined"] = SpatialAnalysisToolVolumeCombined

class SpatialAnalysisToolVolumeFromCalc(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An volume from calc volume interface."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_operation_method_offset = 1
    _set_operation_method_offset = 2
    _get_volume_calc_method_offset = 3
    _set_volume_calc_method_offset = 4
    _get_minimum_method_offset = 5
    _set_minimum_method_offset = 6
    _get_maximum_method_offset = 7
    _set_maximum_method_offset = 8
    _set_method_offset = 9
    _metadata = {
        "iid_data" : (5113486521026373345, 17542713240087790246),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeFromCalc)
    
    _get_operation_metadata = { "offset" : _get_operation_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @property
    def operation(self) -> "CRDN_CONDITION_THRESHOLD_OPTION":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._get_operation_metadata)

    _set_operation_metadata = { "offset" : _set_operation_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @operation.setter
    def operation(self, operation:"CRDN_CONDITION_THRESHOLD_OPTION") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._set_operation_metadata, operation)

    _get_volume_calc_metadata = { "offset" : _get_volume_calc_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def volume_calc(self) -> "ISpatialAnalysisToolVolumeCalc":
        """Get the volume calc from the bounds."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._get_volume_calc_metadata)

    _set_volume_calc_metadata = { "offset" : _set_volume_calc_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolumeCalc"),) }
    @volume_calc.setter
    def volume_calc(self, volumeCalc:"ISpatialAnalysisToolVolumeCalc") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._set_volume_calc_metadata, volumeCalc)

    _get_minimum_metadata = { "offset" : _get_minimum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_minimum(self) -> "Quantity":
        """Get the minimum bound value from the bounds. Call SetMinimum to apply changes."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._get_minimum_metadata, OutArg())

    _set_minimum_metadata = { "offset" : _set_minimum_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"),) }
    def set_minimum(self, value:"Quantity") -> None:
        """Set the minimum bound value for the bounds."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._set_minimum_metadata, value)

    _get_maximum_metadata = { "offset" : _get_maximum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_maximum(self) -> "Quantity":
        """Get the maximum bound value from the bounds. Call SetMaximum to apply changes."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._get_maximum_metadata, OutArg())

    _set_maximum_metadata = { "offset" : _set_maximum_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"),) }
    def set_maximum(self, value:"Quantity") -> None:
        """Set the maximum bound value for the condition."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._set_maximum_metadata, value)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("Quantity"), agmarshall.InterfaceInArg("Quantity"),) }
    def set(self, min:"Quantity", max:"Quantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(SpatialAnalysisToolVolumeFromCalc._metadata, SpatialAnalysisToolVolumeFromCalc._set_metadata, min, max)

    _property_names[operation] = "operation"
    _property_names[volume_calc] = "volume_calc"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeFromCalc."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeFromCalc)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromCalc, [SpatialAnalysisToolVolumeFromCalc, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5512201731345924287, 6484453261337714838), SpatialAnalysisToolVolumeFromCalc)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromCalc"] = SpatialAnalysisToolVolumeFromCalc

class SpatialAnalysisToolVolumeFromCondition(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume from conditioninterface."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_condition_method_offset = 1
    _set_condition_method_offset = 2
    _get_use_custom_time_limits_method_offset = 3
    _set_use_custom_time_limits_method_offset = 4
    _get_custom_time_limits_method_offset = 5
    _set_custom_time_limits_method_offset = 6
    _get_sampling_method_offset = 7
    _set_sampling_method_offset = 8
    _get_convergence_method_offset = 9
    _set_convergence_method_offset = 10
    _metadata = {
        "iid_data" : (5736056999764241897, 7584263815208061614),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeFromCondition)
    
    _get_condition_metadata = { "offset" : _get_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._get_condition_metadata)

    _set_condition_metadata = { "offset" : _set_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._set_condition_metadata, condition)

    _get_use_custom_time_limits_metadata = { "offset" : _get_use_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "offset" : _set_use_custom_time_limits_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_custom_time_limits_metadata = { "offset" : _get_custom_time_limits_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "offset" : _set_custom_time_limits_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._set_custom_time_limits_metadata, customTimeLimits)

    _get_sampling_metadata = { "offset" : _get_sampling_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._get_sampling_metadata)

    _set_sampling_metadata = { "offset" : _set_sampling_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "offset" : _get_convergence_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._get_convergence_metadata)

    _set_convergence_metadata = { "offset" : _set_convergence_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromCondition._metadata, SpatialAnalysisToolVolumeFromCondition._set_convergence_metadata, convergence)

    _property_names[condition] = "condition"
    _property_names[use_custom_time_limits] = "use_custom_time_limits"
    _property_names[custom_time_limits] = "custom_time_limits"
    _property_names[sampling] = "sampling"
    _property_names[convergence] = "convergence"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeFromCondition."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeFromCondition)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromCondition, [SpatialAnalysisToolVolumeFromCondition, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5732933615123458834, 6568177297179918983), SpatialAnalysisToolVolumeFromCondition)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromCondition"] = SpatialAnalysisToolVolumeFromCondition

class SpatialAnalysisToolVolumeFromGrid(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An over time volume interface."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_edge_type_method_offset = 1
    _set_edge_type_method_offset = 2
    _get_volume_grid_method_offset = 3
    _set_volume_grid_method_offset = 4
    _metadata = {
        "iid_data" : (5627691767138338627, 10213818062973684896),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeFromGrid)
    
    _get_edge_type_metadata = { "offset" : _get_edge_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_FROM_GRID_EDGE_TYPE),) }
    @property
    def edge_type(self) -> "CRDN_VOLUME_FROM_GRID_EDGE_TYPE":
        """Get or set the edge type."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromGrid._metadata, SpatialAnalysisToolVolumeFromGrid._get_edge_type_metadata)

    _set_edge_type_metadata = { "offset" : _set_edge_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_FROM_GRID_EDGE_TYPE),) }
    @edge_type.setter
    def edge_type(self, edgeType:"CRDN_VOLUME_FROM_GRID_EDGE_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromGrid._metadata, SpatialAnalysisToolVolumeFromGrid._set_edge_type_metadata, edgeType)

    _get_volume_grid_metadata = { "offset" : _get_volume_grid_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def volume_grid(self) -> "ISpatialAnalysisToolVolumeGrid":
        """Get or set the volume grid for bounding."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromGrid._metadata, SpatialAnalysisToolVolumeFromGrid._get_volume_grid_metadata)

    _set_volume_grid_metadata = { "offset" : _set_volume_grid_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolumeGrid"),) }
    @volume_grid.setter
    def volume_grid(self, volumeGrid:"ISpatialAnalysisToolVolumeGrid") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromGrid._metadata, SpatialAnalysisToolVolumeFromGrid._set_volume_grid_metadata, volumeGrid)

    _property_names[edge_type] = "edge_type"
    _property_names[volume_grid] = "volume_grid"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeFromGrid."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeFromGrid)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromGrid, [SpatialAnalysisToolVolumeFromGrid, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4654272327836492418, 16823323511191899287), SpatialAnalysisToolVolumeFromGrid)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromGrid"] = SpatialAnalysisToolVolumeFromGrid

class SpatialAnalysisToolVolumeFromTimeSatisfaction(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An volume from time satisfaction volume interface."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_time_satisfaction_method_offset = 1
    _set_time_satisfaction_method_offset = 2
    _metadata = {
        "iid_data" : (4640101470789229080, 5461984207440300163),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeFromTimeSatisfaction)
    
    _get_time_satisfaction_metadata = { "offset" : _get_time_satisfaction_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def time_satisfaction(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(SpatialAnalysisToolVolumeFromTimeSatisfaction._metadata, SpatialAnalysisToolVolumeFromTimeSatisfaction._get_time_satisfaction_metadata)

    _set_time_satisfaction_metadata = { "offset" : _set_time_satisfaction_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @time_satisfaction.setter
    def time_satisfaction(self, timeSatisfaction:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeFromTimeSatisfaction._metadata, SpatialAnalysisToolVolumeFromTimeSatisfaction._set_time_satisfaction_metadata, timeSatisfaction)

    _property_names[time_satisfaction] = "time_satisfaction"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeFromTimeSatisfaction."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeFromTimeSatisfaction)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromTimeSatisfaction, [SpatialAnalysisToolVolumeFromTimeSatisfaction, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5627140386690235637, 13821308809228561049), SpatialAnalysisToolVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromTimeSatisfaction"] = SpatialAnalysisToolVolumeFromTimeSatisfaction

class SpatialAnalysisToolVolumeGrid(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGrid."""
        SupportsDeleteCallback.__init__(self)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGrid, [ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5702248548041919544, 8355142271349343408), SpatialAnalysisToolVolumeGrid)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGrid"] = SpatialAnalysisToolVolumeGrid

class SpatialAnalysisToolVolumeGridBearingAlt(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume grid bearing alt (Surface Bearing) interface."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_central_body_method_offset = 1
    _set_reference_central_body_method_offset = 2
    _get_along_bearing_coordinates_method_offset = 3
    _get_cross_bearing_coordinates_method_offset = 4
    _get_altitude_coordinates_method_offset = 5
    _get_auto_fit_bounds_method_offset = 6
    _set_auto_fit_bounds_method_offset = 7
    _get_bearing_angle_method_offset = 8
    _set_bearing_angle_method_offset = 9
    _get_reference_location_method_offset = 10
    _set_reference_location_method_offset = 11
    _metadata = {
        "iid_data" : (4730723923926493328, 14653163782190743734),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridBearingAlt)
    
    _get_reference_central_body_metadata = { "offset" : _get_reference_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def reference_central_body(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._get_reference_central_body_metadata)

    _set_reference_central_body_metadata = { "offset" : _set_reference_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @reference_central_body.setter
    def reference_central_body(self, referenceCentralBody:str) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._set_reference_central_body_metadata, referenceCentralBody)

    _get_along_bearing_coordinates_metadata = { "offset" : _get_along_bearing_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def along_bearing_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return AlongBearing Coordinates parameters for the surface bearing."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._get_along_bearing_coordinates_metadata)

    _get_cross_bearing_coordinates_metadata = { "offset" : _get_cross_bearing_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def cross_bearing_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return CrossBearing Coordinates parameters for the surface bearing."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._get_cross_bearing_coordinates_metadata)

    _get_altitude_coordinates_metadata = { "offset" : _get_altitude_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def altitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return altitude Coordinates parameters for the surface bearing."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._get_altitude_coordinates_metadata)

    _get_auto_fit_bounds_metadata = { "offset" : _get_auto_fit_bounds_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def auto_fit_bounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._get_auto_fit_bounds_metadata)

    _set_auto_fit_bounds_metadata = { "offset" : _set_auto_fit_bounds_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @auto_fit_bounds.setter
    def auto_fit_bounds(self, autoFitBounds:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._set_auto_fit_bounds_metadata, autoFitBounds)

    _get_bearing_angle_metadata = { "offset" : _get_bearing_angle_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def bearing_angle(self) -> float:
        """Specify the Bearing Angle."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._get_bearing_angle_metadata)

    _set_bearing_angle_metadata = { "offset" : _set_bearing_angle_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @bearing_angle.setter
    def bearing_angle(self, bearingAngle:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._set_bearing_angle_metadata, bearingAngle)

    _get_reference_location_metadata = { "offset" : _get_reference_location_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def reference_location(self) -> list:
        """Get lat/lon for reference location."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._get_reference_location_metadata)

    _set_reference_location_metadata = { "offset" : _set_reference_location_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @reference_location.setter
    def reference_location(self, referenceLocation:list) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridBearingAlt._metadata, SpatialAnalysisToolVolumeGridBearingAlt._set_reference_location_metadata, referenceLocation)

    _property_names[reference_central_body] = "reference_central_body"
    _property_names[along_bearing_coordinates] = "along_bearing_coordinates"
    _property_names[cross_bearing_coordinates] = "cross_bearing_coordinates"
    _property_names[altitude_coordinates] = "altitude_coordinates"
    _property_names[auto_fit_bounds] = "auto_fit_bounds"
    _property_names[bearing_angle] = "bearing_angle"
    _property_names[reference_location] = "reference_location"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridBearingAlt."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridBearingAlt)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridBearingAlt, [SpatialAnalysisToolVolumeGridBearingAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5623451090371518830, 6528069848114595743), SpatialAnalysisToolVolumeGridBearingAlt)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridBearingAlt"] = SpatialAnalysisToolVolumeGridBearingAlt

class SpatialAnalysisToolVolumeGridCartesian(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume grid Cartesian interface."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_system_method_offset = 1
    _set_reference_system_method_offset = 2
    _get_x_coordinates_method_offset = 3
    _get_y_coordinates_method_offset = 4
    _get_z_coordinates_method_offset = 5
    _metadata = {
        "iid_data" : (4756107278377678929, 3260092988906345356),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridCartesian)
    
    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which Cartesian parameters are computed."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCartesian._metadata, SpatialAnalysisToolVolumeGridCartesian._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridCartesian._metadata, SpatialAnalysisToolVolumeGridCartesian._set_reference_system_metadata, referenceSystem)

    _get_x_coordinates_metadata = { "offset" : _get_x_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def x_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return X Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCartesian._metadata, SpatialAnalysisToolVolumeGridCartesian._get_x_coordinates_metadata)

    _get_y_coordinates_metadata = { "offset" : _get_y_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def y_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return Y Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCartesian._metadata, SpatialAnalysisToolVolumeGridCartesian._get_y_coordinates_metadata)

    _get_z_coordinates_metadata = { "offset" : _get_z_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def z_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return Z Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCartesian._metadata, SpatialAnalysisToolVolumeGridCartesian._get_z_coordinates_metadata)

    _property_names[reference_system] = "reference_system"
    _property_names[x_coordinates] = "x_coordinates"
    _property_names[y_coordinates] = "y_coordinates"
    _property_names[z_coordinates] = "z_coordinates"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridCartesian."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridCartesian)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridCartesian, [SpatialAnalysisToolVolumeGridCartesian, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5143879619490205860, 15008466888120033703), SpatialAnalysisToolVolumeGridCartesian)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridCartesian"] = SpatialAnalysisToolVolumeGridCartesian

class SpatialAnalysisToolVolumeGridConstrained(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume grid constrained interface."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_grid_method_offset = 1
    _set_reference_grid_method_offset = 2
    _get_constraint_method_offset = 3
    _set_constraint_method_offset = 4
    _metadata = {
        "iid_data" : (4880089629496303142, 4809807965271431055),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridConstrained)
    
    _get_reference_grid_metadata = { "offset" : _get_reference_grid_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_grid(self) -> "ISpatialAnalysisToolVolumeGrid":
        """Get the reference system in which spherical parameters are computed."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridConstrained._metadata, SpatialAnalysisToolVolumeGridConstrained._get_reference_grid_metadata)

    _set_reference_grid_metadata = { "offset" : _set_reference_grid_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolumeGrid"),) }
    @reference_grid.setter
    def reference_grid(self, referenceGrid:"ISpatialAnalysisToolVolumeGrid") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridConstrained._metadata, SpatialAnalysisToolVolumeGridConstrained._set_reference_grid_metadata, referenceGrid)

    _get_constraint_metadata = { "offset" : _get_constraint_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def constraint(self) -> "ISpatialAnalysisToolVolume":
        """Get the volume constraint on the grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridConstrained._metadata, SpatialAnalysisToolVolumeGridConstrained._get_constraint_metadata)

    _set_constraint_metadata = { "offset" : _set_constraint_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolume"),) }
    @constraint.setter
    def constraint(self, constraint:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridConstrained._metadata, SpatialAnalysisToolVolumeGridConstrained._set_constraint_metadata, constraint)

    _property_names[reference_grid] = "reference_grid"
    _property_names[constraint] = "constraint"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridConstrained."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridConstrained)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridConstrained, [SpatialAnalysisToolVolumeGridConstrained, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5355718201764201772, 18302606991020932526), SpatialAnalysisToolVolumeGridConstrained)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridConstrained"] = SpatialAnalysisToolVolumeGridConstrained

class SpatialAnalysisToolVolumeGridCylindrical(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume grid cylindrical interface."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_system_method_offset = 1
    _set_reference_system_method_offset = 2
    _get_theta_coordinates_method_offset = 3
    _get_radius_coordinates_method_offset = 4
    _get_height_coordinates_method_offset = 5
    _metadata = {
        "iid_data" : (4792617438748898343, 15301605932388729243),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridCylindrical)
    
    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which cylindrical parameters are computed."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCylindrical._metadata, SpatialAnalysisToolVolumeGridCylindrical._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridCylindrical._metadata, SpatialAnalysisToolVolumeGridCylindrical._set_reference_system_metadata, referenceSystem)

    _get_theta_coordinates_metadata = { "offset" : _get_theta_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def theta_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return theta Coordinates parameters for the Theta system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCylindrical._metadata, SpatialAnalysisToolVolumeGridCylindrical._get_theta_coordinates_metadata)

    _get_radius_coordinates_metadata = { "offset" : _get_radius_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def radius_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return radius Coordinates parameters for the Radius system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCylindrical._metadata, SpatialAnalysisToolVolumeGridCylindrical._get_radius_coordinates_metadata)

    _get_height_coordinates_metadata = { "offset" : _get_height_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def height_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return height Coordinates parameters for the Height system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridCylindrical._metadata, SpatialAnalysisToolVolumeGridCylindrical._get_height_coordinates_metadata)

    _property_names[reference_system] = "reference_system"
    _property_names[theta_coordinates] = "theta_coordinates"
    _property_names[radius_coordinates] = "radius_coordinates"
    _property_names[height_coordinates] = "height_coordinates"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridCylindrical."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridCylindrical)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridCylindrical, [SpatialAnalysisToolVolumeGridCylindrical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5616361831989159850, 14417449230462750362), SpatialAnalysisToolVolumeGridCylindrical)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridCylindrical"] = SpatialAnalysisToolVolumeGridCylindrical

class SpatialAnalysisToolVolumeGridLatLonAlt(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume grid lat lon alt (Cartogrographic) interface."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_central_body_method_offset = 1
    _set_reference_central_body_method_offset = 2
    _get_latitude_coordinates_method_offset = 3
    _get_longitude_coordinates_method_offset = 4
    _get_altitude_coordinates_method_offset = 5
    _get_auto_fit_bounds_method_offset = 6
    _set_auto_fit_bounds_method_offset = 7
    _metadata = {
        "iid_data" : (5337570201496317993, 16204349902611395774),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridLatLonAlt)
    
    _get_reference_central_body_metadata = { "offset" : _get_reference_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def reference_central_body(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridLatLonAlt._metadata, SpatialAnalysisToolVolumeGridLatLonAlt._get_reference_central_body_metadata)

    _set_reference_central_body_metadata = { "offset" : _set_reference_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @reference_central_body.setter
    def reference_central_body(self, referenceCentralBody:str) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridLatLonAlt._metadata, SpatialAnalysisToolVolumeGridLatLonAlt._set_reference_central_body_metadata, referenceCentralBody)

    _get_latitude_coordinates_metadata = { "offset" : _get_latitude_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def latitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return latitude Coordinates parameters for the Theta system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridLatLonAlt._metadata, SpatialAnalysisToolVolumeGridLatLonAlt._get_latitude_coordinates_metadata)

    _get_longitude_coordinates_metadata = { "offset" : _get_longitude_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def longitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return longtitude Coordinates parameters for the Radius system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridLatLonAlt._metadata, SpatialAnalysisToolVolumeGridLatLonAlt._get_longitude_coordinates_metadata)

    _get_altitude_coordinates_metadata = { "offset" : _get_altitude_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def altitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return altitude parameters for the Height system."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridLatLonAlt._metadata, SpatialAnalysisToolVolumeGridLatLonAlt._get_altitude_coordinates_metadata)

    _get_auto_fit_bounds_metadata = { "offset" : _get_auto_fit_bounds_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def auto_fit_bounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridLatLonAlt._metadata, SpatialAnalysisToolVolumeGridLatLonAlt._get_auto_fit_bounds_metadata)

    _set_auto_fit_bounds_metadata = { "offset" : _set_auto_fit_bounds_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @auto_fit_bounds.setter
    def auto_fit_bounds(self, autoFitBounds:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridLatLonAlt._metadata, SpatialAnalysisToolVolumeGridLatLonAlt._set_auto_fit_bounds_metadata, autoFitBounds)

    _property_names[reference_central_body] = "reference_central_body"
    _property_names[latitude_coordinates] = "latitude_coordinates"
    _property_names[longitude_coordinates] = "longitude_coordinates"
    _property_names[altitude_coordinates] = "altitude_coordinates"
    _property_names[auto_fit_bounds] = "auto_fit_bounds"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridLatLonAlt."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridLatLonAlt)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridLatLonAlt, [SpatialAnalysisToolVolumeGridLatLonAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5432256157047656388, 11350183618881279388), SpatialAnalysisToolVolumeGridLatLonAlt)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridLatLonAlt"] = SpatialAnalysisToolVolumeGridLatLonAlt

class SpatialAnalysisToolVolumeGridResult(SupportsDeleteCallback):
    """An interface that generates Volume Grid results."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_epoch_method_offset = 1
    _get_size_i_method_offset = 2
    _get_size_j_method_offset = 3
    _get_size_k_method_offset = 4
    _get_volume_metric_data_vector_method_offset = 5
    _get_volume_metric_position_vector_method_offset = 6
    _get_volume_metric_native_position_vector_method_offset = 7
    _get_volume_metric_gradient_vector_method_offset = 8
    _metadata = {
        "iid_data" : (5499177848830365804, 8552211019007533491),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridResult)
    
    _get_epoch_metadata = { "offset" : _get_epoch_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def epoch(self) -> typing.Any:
        """Epoch of returned volumetric data."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_epoch_metadata)

    _get_size_i_metadata = { "offset" : _get_size_i_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def size_i(self) -> int:
        """Number of grid point coordinates representing first dimension of volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_size_i_metadata)

    _get_size_j_metadata = { "offset" : _get_size_j_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def size_j(self) -> int:
        """Number of grid point coordinates representing second dimension of volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_size_j_metadata)

    _get_size_k_metadata = { "offset" : _get_size_k_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def size_k(self) -> int:
        """Number of grid point coordinates representing third dimension of volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_size_k_metadata)

    _get_volume_metric_data_vector_metadata = { "offset" : _get_volume_metric_data_vector_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def volume_metric_data_vector(self) -> list:
        """Vector of scalar values representing volumetric data."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_volume_metric_data_vector_metadata)

    _get_volume_metric_position_vector_metadata = { "offset" : _get_volume_metric_position_vector_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def volume_metric_position_vector(self) -> list:
        """Vector of Cartesian coordinates of all volume grid points."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_volume_metric_position_vector_metadata)

    _get_volume_metric_native_position_vector_metadata = { "offset" : _get_volume_metric_native_position_vector_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def volume_metric_native_position_vector(self) -> list:
        """Vector of native coordinates of all volume grid points."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_volume_metric_native_position_vector_metadata)

    _get_volume_metric_gradient_vector_metadata = { "offset" : _get_volume_metric_gradient_vector_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def volume_metric_gradient_vector(self) -> list:
        """Vector of Cartesian coordinates representing gradient vectors at all volume grid points."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridResult._metadata, SpatialAnalysisToolVolumeGridResult._get_volume_metric_gradient_vector_metadata)

    _property_names[epoch] = "epoch"
    _property_names[size_i] = "size_i"
    _property_names[size_j] = "size_j"
    _property_names[size_k] = "size_k"
    _property_names[volume_metric_data_vector] = "volume_metric_data_vector"
    _property_names[volume_metric_position_vector] = "volume_metric_position_vector"
    _property_names[volume_metric_native_position_vector] = "volume_metric_native_position_vector"
    _property_names[volume_metric_gradient_vector] = "volume_metric_gradient_vector"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridResult, [SpatialAnalysisToolVolumeGridResult, ])

agcls.AgClassCatalog.add_catalog_entry((4933513940597038247, 13537496590627059615), SpatialAnalysisToolVolumeGridResult)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridResult"] = SpatialAnalysisToolVolumeGridResult

class SpatialAnalysisToolVolumeGridSpherical(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A volume grid spherical interface."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_system_method_offset = 1
    _set_reference_system_method_offset = 2
    _get_azimuth_coordinates_method_offset = 3
    _get_elevation_coordinates_method_offset = 4
    _get_range_coordinates_method_offset = 5
    _metadata = {
        "iid_data" : (5645490772616604478, 17133888365359264426),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeGridSpherical)
    
    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which spherical parameters are computed."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridSpherical._metadata, SpatialAnalysisToolVolumeGridSpherical._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeGridSpherical._metadata, SpatialAnalysisToolVolumeGridSpherical._set_reference_system_metadata, referenceSystem)

    _get_azimuth_coordinates_metadata = { "offset" : _get_azimuth_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def azimuth_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return azimuth coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridSpherical._metadata, SpatialAnalysisToolVolumeGridSpherical._get_azimuth_coordinates_metadata)

    _get_elevation_coordinates_metadata = { "offset" : _get_elevation_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def elevation_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return elevation coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridSpherical._metadata, SpatialAnalysisToolVolumeGridSpherical._get_elevation_coordinates_metadata)

    _get_range_coordinates_metadata = { "offset" : _get_range_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def range_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return range coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(SpatialAnalysisToolVolumeGridSpherical._metadata, SpatialAnalysisToolVolumeGridSpherical._get_range_coordinates_metadata)

    _property_names[reference_system] = "reference_system"
    _property_names[azimuth_coordinates] = "azimuth_coordinates"
    _property_names[elevation_coordinates] = "elevation_coordinates"
    _property_names[range_coordinates] = "range_coordinates"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeGridSpherical."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeGridSpherical)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridSpherical, [SpatialAnalysisToolVolumeGridSpherical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5230140972615936311, 7226435708672804267), SpatialAnalysisToolVolumeGridSpherical)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridSpherical"] = SpatialAnalysisToolVolumeGridSpherical

class SpatialAnalysisToolVolumeInview(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An Inview volume interface."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_constraint_object_method_offset = 1
    _set_constraint_object_method_offset = 2
    _get_light_time_delay_method_offset = 3
    _metadata = {
        "iid_data" : (5195129455268480560, 3592106623834241957),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeInview)
    
    _get_constraint_object_metadata = { "offset" : _get_constraint_object_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def constraint_object(self) -> typing.Any:
        """A constraint object of the access."""
        return self._intf.get_property(SpatialAnalysisToolVolumeInview._metadata, SpatialAnalysisToolVolumeInview._get_constraint_object_metadata)

    _set_constraint_object_metadata = { "offset" : _set_constraint_object_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @constraint_object.setter
    def constraint_object(self, constraintObject:typing.Any) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeInview._metadata, SpatialAnalysisToolVolumeInview._set_constraint_object_metadata, constraintObject)

    _get_light_time_delay_metadata = { "offset" : _get_light_time_delay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def light_time_delay(self) -> "TimeToolLightTimeDelay":
        """Return Light Time Delay options parameters."""
        return self._intf.get_property(SpatialAnalysisToolVolumeInview._metadata, SpatialAnalysisToolVolumeInview._get_light_time_delay_metadata)

    _property_names[constraint_object] = "constraint_object"
    _property_names[light_time_delay] = "light_time_delay"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeInview."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeInview)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeInview, [SpatialAnalysisToolVolumeInview, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5724962521871071047, 12322705441895077515), SpatialAnalysisToolVolumeInview)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeInview"] = SpatialAnalysisToolVolumeInview

class SpatialAnalysisToolVolumeLighting(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A lighting volume interface."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_eclipsing_bodies_method_offset = 1
    _set_eclipsing_bodies_method_offset = 2
    _get_use_object_eclipsing_bodies_method_offset = 3
    _set_use_object_eclipsing_bodies_method_offset = 4
    _get_lighting_conditions_method_offset = 5
    _set_lighting_conditions_method_offset = 6
    _metadata = {
        "iid_data" : (5632076028421819400, 17989693341813651347),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeLighting)
    
    _get_eclipsing_bodies_metadata = { "offset" : _get_eclipsing_bodies_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def eclipsing_bodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(SpatialAnalysisToolVolumeLighting._metadata, SpatialAnalysisToolVolumeLighting._get_eclipsing_bodies_metadata)

    _set_eclipsing_bodies_metadata = { "offset" : _set_eclipsing_bodies_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @eclipsing_bodies.setter
    def eclipsing_bodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeLighting._metadata, SpatialAnalysisToolVolumeLighting._set_eclipsing_bodies_metadata, eclipsingBodies)

    _get_use_object_eclipsing_bodies_metadata = { "offset" : _get_use_object_eclipsing_bodies_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_object_eclipsing_bodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(SpatialAnalysisToolVolumeLighting._metadata, SpatialAnalysisToolVolumeLighting._get_use_object_eclipsing_bodies_metadata)

    _set_use_object_eclipsing_bodies_metadata = { "offset" : _set_use_object_eclipsing_bodies_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_object_eclipsing_bodies.setter
    def use_object_eclipsing_bodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeLighting._metadata, SpatialAnalysisToolVolumeLighting._set_use_object_eclipsing_bodies_metadata, useObjectEclipsingBodies)

    _get_lighting_conditions_metadata = { "offset" : _get_lighting_conditions_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE),) }
    @property
    def lighting_conditions(self) -> "CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE":
        """Get or set the lighting conditions."""
        return self._intf.get_property(SpatialAnalysisToolVolumeLighting._metadata, SpatialAnalysisToolVolumeLighting._get_lighting_conditions_metadata)

    _set_lighting_conditions_metadata = { "offset" : _set_lighting_conditions_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE),) }
    @lighting_conditions.setter
    def lighting_conditions(self, lightingConditions:"CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeLighting._metadata, SpatialAnalysisToolVolumeLighting._set_lighting_conditions_metadata, lightingConditions)

    _property_names[eclipsing_bodies] = "eclipsing_bodies"
    _property_names[use_object_eclipsing_bodies] = "use_object_eclipsing_bodies"
    _property_names[lighting_conditions] = "lighting_conditions"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeLighting."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeLighting)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeLighting, [SpatialAnalysisToolVolumeLighting, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4846621819260420121, 12614405677517105581), SpatialAnalysisToolVolumeLighting)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeLighting"] = SpatialAnalysisToolVolumeLighting

class SpatialAnalysisToolVolumeOverTime(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An over time volume interface."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_duration_type_method_offset = 1
    _set_duration_type_method_offset = 2
    _get_reference_volume_method_offset = 3
    _set_reference_volume_method_offset = 4
    _get_reference_intervals_method_offset = 5
    _set_reference_intervals_method_offset = 6
    _get_start_offset_method_offset = 7
    _set_start_offset_method_offset = 8
    _get_stop_offset_method_offset = 9
    _set_stop_offset_method_offset = 10
    _metadata = {
        "iid_data" : (4876582964905500215, 15592635579053740465),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, SpatialAnalysisToolVolumeOverTime)
    
    _get_duration_type_metadata = { "offset" : _get_duration_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_OVER_TIME_DURATION_TYPE),) }
    @property
    def duration_type(self) -> "CRDN_VOLUME_OVER_TIME_DURATION_TYPE":
        """Get or set the lighting conditions."""
        return self._intf.get_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._get_duration_type_metadata)

    _set_duration_type_metadata = { "offset" : _set_duration_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_VOLUME_OVER_TIME_DURATION_TYPE),) }
    @duration_type.setter
    def duration_type(self, durationType:"CRDN_VOLUME_OVER_TIME_DURATION_TYPE") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._set_duration_type_metadata, durationType)

    _get_reference_volume_metadata = { "offset" : _get_reference_volume_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_volume(self) -> "ISpatialAnalysisToolVolume":
        """Get or set the reference volume."""
        return self._intf.get_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._get_reference_volume_metadata)

    _set_reference_volume_metadata = { "offset" : _set_reference_volume_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISpatialAnalysisToolVolume"),) }
    @reference_volume.setter
    def reference_volume(self, referenceVolume:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._set_reference_volume_metadata, referenceVolume)

    _get_reference_intervals_metadata = { "offset" : _get_reference_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list for the over time volume."""
        return self._intf.get_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "offset" : _set_reference_intervals_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._set_reference_intervals_metadata, referenceIntervals)

    _get_start_offset_metadata = { "offset" : _get_start_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def start_offset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when over time volume is set to Sliding Window."""
        return self._intf.get_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._get_start_offset_metadata)

    _set_start_offset_metadata = { "offset" : _set_start_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "offset" : _get_stop_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def stop_offset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when over time volume is set to Sliding Window."""
        return self._intf.get_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "offset" : _set_stop_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(SpatialAnalysisToolVolumeOverTime._metadata, SpatialAnalysisToolVolumeOverTime._set_stop_offset_metadata, stopOffset)

    _property_names[duration_type] = "duration_type"
    _property_names[reference_volume] = "reference_volume"
    _property_names[reference_intervals] = "reference_intervals"
    _property_names[start_offset] = "start_offset"
    _property_names[stop_offset] = "stop_offset"

    def __init__(self, sourceObject=None):
        """Construct an object of type SpatialAnalysisToolVolumeOverTime."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, SpatialAnalysisToolVolumeOverTime)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeOverTime, [SpatialAnalysisToolVolumeOverTime, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4854841648937134318, 3250948660834583456), SpatialAnalysisToolVolumeOverTime)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeOverTime"] = SpatialAnalysisToolVolumeOverTime

class AnalysisWorkbenchGeneric(IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Generic VGT component."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchGeneric."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchGeneric, [IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5463600693607263739, 3992744111484991654), AnalysisWorkbenchGeneric)
agcls.AgTypeNameMap["AnalysisWorkbenchGeneric"] = AnalysisWorkbenchGeneric

class AnalysisWorkbenchTypeInfo(SupportsDeleteCallback):
    """Provide information about the type of VGT components."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_type_description_method_offset = 1
    _get_type_name_method_offset = 2
    _get_short_type_description_method_offset = 3
    _metadata = {
        "iid_data" : (5361699528957364806, 4224976545408186002),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchTypeInfo)
    
    _get_type_description_metadata = { "offset" : _get_type_description_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def type_description(self) -> str:
        """Return the type description."""
        return self._intf.get_property(AnalysisWorkbenchTypeInfo._metadata, AnalysisWorkbenchTypeInfo._get_type_description_metadata)

    _get_type_name_metadata = { "offset" : _get_type_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def type_name(self) -> str:
        """Return the type name."""
        return self._intf.get_property(AnalysisWorkbenchTypeInfo._metadata, AnalysisWorkbenchTypeInfo._get_type_name_metadata)

    _get_short_type_description_metadata = { "offset" : _get_short_type_description_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def short_type_description(self) -> str:
        """Return the short type description."""
        return self._intf.get_property(AnalysisWorkbenchTypeInfo._metadata, AnalysisWorkbenchTypeInfo._get_short_type_description_metadata)

    _property_names[type_description] = "type_description"
    _property_names[type_name] = "type_name"
    _property_names[short_type_description] = "short_type_description"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchTypeInfo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchTypeInfo)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchTypeInfo, [AnalysisWorkbenchTypeInfo, ])

agcls.AgClassCatalog.add_catalog_entry((5699426269249570940, 15161479374799558806), AnalysisWorkbenchTypeInfo)
agcls.AgTypeNameMap["AnalysisWorkbenchTypeInfo"] = AnalysisWorkbenchTypeInfo

class AnalysisWorkbenchInstance(IAnalysisWorkbenchContext, SupportsDeleteCallback):
    """The AnalysisWorkbenchInstance interface enables to obtain information about the parent object that owns the VGT component."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_instance_path_method_offset = 1
    _get_template_method_offset = 2
    _metadata = {
        "iid_data" : (5764490979489035877, 498398658112071554),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchInstance)
    
    _get_instance_path_metadata = { "offset" : _get_instance_path_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def instance_path(self) -> str:
        """Return a path to the parent object that owns the VGT component."""
        return self._intf.get_property(AnalysisWorkbenchInstance._metadata, AnalysisWorkbenchInstance._get_instance_path_metadata)

    _get_template_metadata = { "offset" : _get_template_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def template(self) -> "IAnalysisWorkbenchComponent":
        """Return a template object the VGT component was created from or null if the VGT component was not created from a template."""
        return self._intf.get_property(AnalysisWorkbenchInstance._metadata, AnalysisWorkbenchInstance._get_template_metadata)

    _property_names[instance_path] = "instance_path"
    _property_names[template] = "template"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchInstance."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchInstance)
        IAnalysisWorkbenchContext.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchContext._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchInstance, [AnalysisWorkbenchInstance, IAnalysisWorkbenchContext])

agcls.AgClassCatalog.add_catalog_entry((5391125706042513269, 1545934538743815612), AnalysisWorkbenchInstance)
agcls.AgTypeNameMap["AnalysisWorkbenchInstance"] = AnalysisWorkbenchInstance

class AnalysisWorkbenchTemplate(IAnalysisWorkbenchContext, SupportsDeleteCallback):
    """The AnalysisWorkbenchTemplate interface enables to obtain information about the STK class that owns the VGT component."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_class_name_method_offset = 1
    _metadata = {
        "iid_data" : (5523493391658530282, 9506007543621797),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchTemplate)
    
    _get_class_name_metadata = { "offset" : _get_class_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def class_name(self) -> str:
        """Return a class name (i.e. 'Satellite', 'Facility', etc.)."""
        return self._intf.get_property(AnalysisWorkbenchTemplate._metadata, AnalysisWorkbenchTemplate._get_class_name_metadata)

    _property_names[class_name] = "class_name"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchTemplate."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchTemplate)
        IAnalysisWorkbenchContext.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchContext._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchTemplate, [AnalysisWorkbenchTemplate, IAnalysisWorkbenchContext])

agcls.AgClassCatalog.add_catalog_entry((4884527547614411789, 16415357707545642411), AnalysisWorkbenchTemplate)
agcls.AgTypeNameMap["AnalysisWorkbenchTemplate"] = AnalysisWorkbenchTemplate

class VectorGeometryToolPointRefTo(IAnalysisWorkbenchRefTo, SupportsDeleteCallback):
    """Represents a reference to a VGT point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_path_method_offset = 1
    _set_point_method_offset = 2
    _get_point_method_offset = 3
    _has_cyclic_dependency_method_offset = 4
    _metadata = {
        "iid_data" : (5279351027073801778, 13735137936088795793),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointRefTo)
    
    _set_path_metadata = { "offset" : _set_path_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def set_path(self, path:str) -> None:
        """Set a new point."""
        return self._intf.invoke(VectorGeometryToolPointRefTo._metadata, VectorGeometryToolPointRefTo._set_path_metadata, path)

    _set_point_metadata = { "offset" : _set_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    def set_point(self, point:"IVectorGeometryToolPoint") -> None:
        """Set a new point."""
        return self._intf.invoke(VectorGeometryToolPointRefTo._metadata, VectorGeometryToolPointRefTo._set_point_metadata, point)

    _get_point_metadata = { "offset" : _get_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_point(self) -> "IVectorGeometryToolPoint":
        """Return the actual point object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(VectorGeometryToolPointRefTo._metadata, VectorGeometryToolPointRefTo._get_point_metadata, OutArg())

    _has_cyclic_dependency_metadata = { "offset" : _has_cyclic_dependency_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.VariantBoolArg,) }
    def has_cyclic_dependency(self, point:"IVectorGeometryToolPoint") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(VectorGeometryToolPointRefTo._metadata, VectorGeometryToolPointRefTo._has_cyclic_dependency_metadata, point, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointRefTo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointRefTo)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointRefTo, [VectorGeometryToolPointRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry((4704692840303707085, 8020029865205775543), VectorGeometryToolPointRefTo)
agcls.AgTypeNameMap["VectorGeometryToolPointRefTo"] = VectorGeometryToolPointRefTo

class VectorGeometryToolVectorRefTo(IAnalysisWorkbenchRefTo, SupportsDeleteCallback):
    """Represents a reference to a VGT vector."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_path_method_offset = 1
    _set_vector_method_offset = 2
    _get_vector_method_offset = 3
    _has_cyclic_dependency_method_offset = 4
    _metadata = {
        "iid_data" : (5002430524828082288, 2947395518214351037),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorRefTo)
    
    _set_path_metadata = { "offset" : _set_path_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def set_path(self, path:str) -> None:
        """Set a new vector."""
        return self._intf.invoke(VectorGeometryToolVectorRefTo._metadata, VectorGeometryToolVectorRefTo._set_path_metadata, path)

    _set_vector_metadata = { "offset" : _set_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    def set_vector(self, vector:"IVectorGeometryToolVector") -> None:
        """Set a new vector."""
        return self._intf.invoke(VectorGeometryToolVectorRefTo._metadata, VectorGeometryToolVectorRefTo._set_vector_metadata, vector)

    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_vector(self) -> "IVectorGeometryToolVector":
        """Return the actual vector object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(VectorGeometryToolVectorRefTo._metadata, VectorGeometryToolVectorRefTo._get_vector_metadata, OutArg())

    _has_cyclic_dependency_metadata = { "offset" : _has_cyclic_dependency_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"), agmarshall.VariantBoolArg,) }
    def has_cyclic_dependency(self, vector:"IVectorGeometryToolVector") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(VectorGeometryToolVectorRefTo._metadata, VectorGeometryToolVectorRefTo._has_cyclic_dependency_metadata, vector, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorRefTo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorRefTo)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorRefTo, [VectorGeometryToolVectorRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry((5440566115286381237, 11986298819353492100), VectorGeometryToolVectorRefTo)
agcls.AgTypeNameMap["VectorGeometryToolVectorRefTo"] = VectorGeometryToolVectorRefTo

class VectorGeometryToolAxesRefTo(IAnalysisWorkbenchRefTo, SupportsDeleteCallback):
    """Represents a reference to a VGT axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_path_method_offset = 1
    _set_axes_method_offset = 2
    _get_axes_method_offset = 3
    _has_cyclic_dependency_method_offset = 4
    _metadata = {
        "iid_data" : (5682882817452678510, 4017082628123244947),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesRefTo)
    
    _set_path_metadata = { "offset" : _set_path_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def set_path(self, path:str) -> None:
        """Set a new axes."""
        return self._intf.invoke(VectorGeometryToolAxesRefTo._metadata, VectorGeometryToolAxesRefTo._set_path_metadata, path)

    _set_axes_metadata = { "offset" : _set_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    def set_axes(self, axes:"IVectorGeometryToolAxes") -> None:
        """Set a new axes."""
        return self._intf.invoke(VectorGeometryToolAxesRefTo._metadata, VectorGeometryToolAxesRefTo._set_axes_metadata, axes)

    _get_axes_metadata = { "offset" : _get_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_axes(self) -> "IVectorGeometryToolAxes":
        """Return the actual axes object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(VectorGeometryToolAxesRefTo._metadata, VectorGeometryToolAxesRefTo._get_axes_metadata, OutArg())

    _has_cyclic_dependency_metadata = { "offset" : _has_cyclic_dependency_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.VariantBoolArg,) }
    def has_cyclic_dependency(self, axes:"IVectorGeometryToolAxes") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(VectorGeometryToolAxesRefTo._metadata, VectorGeometryToolAxesRefTo._has_cyclic_dependency_metadata, axes, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesRefTo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesRefTo)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesRefTo, [VectorGeometryToolAxesRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry((5051443874454375573, 2367503670708117661), VectorGeometryToolAxesRefTo)
agcls.AgTypeNameMap["VectorGeometryToolAxesRefTo"] = VectorGeometryToolAxesRefTo

class VectorGeometryToolAngleRefTo(IAnalysisWorkbenchRefTo, SupportsDeleteCallback):
    """Represents a reference to a VGT angle."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_path_method_offset = 1
    _set_angle_method_offset = 2
    _get_angle_method_offset = 3
    _has_cyclic_dependency_method_offset = 4
    _metadata = {
        "iid_data" : (4924923796472561823, 6300112913133557144),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleRefTo)
    
    _set_path_metadata = { "offset" : _set_path_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def set_path(self, path:str) -> None:
        """Set a new angle."""
        return self._intf.invoke(VectorGeometryToolAngleRefTo._metadata, VectorGeometryToolAngleRefTo._set_path_metadata, path)

    _set_angle_metadata = { "offset" : _set_angle_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAngle"),) }
    def set_angle(self, angle:"IVectorGeometryToolAngle") -> None:
        """Set a new angle."""
        return self._intf.invoke(VectorGeometryToolAngleRefTo._metadata, VectorGeometryToolAngleRefTo._set_angle_metadata, angle)

    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_angle(self) -> "IVectorGeometryToolAngle":
        """Return the actual angle object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(VectorGeometryToolAngleRefTo._metadata, VectorGeometryToolAngleRefTo._get_angle_metadata, OutArg())

    _has_cyclic_dependency_metadata = { "offset" : _has_cyclic_dependency_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAngle"), agmarshall.VariantBoolArg,) }
    def has_cyclic_dependency(self, angle:"IVectorGeometryToolAngle") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(VectorGeometryToolAngleRefTo._metadata, VectorGeometryToolAngleRefTo._has_cyclic_dependency_metadata, angle, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleRefTo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleRefTo)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleRefTo, [VectorGeometryToolAngleRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry((5362491565921591286, 3697870622063550641), VectorGeometryToolAngleRefTo)
agcls.AgTypeNameMap["VectorGeometryToolAngleRefTo"] = VectorGeometryToolAngleRefTo

class VectorGeometryToolSystemRefTo(IAnalysisWorkbenchRefTo, SupportsDeleteCallback):
    """Represents a reference to a VGT system."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_path_method_offset = 1
    _set_system_method_offset = 2
    _get_system_method_offset = 3
    _has_cyclic_dependency_method_offset = 4
    _metadata = {
        "iid_data" : (4683122848438464453, 6113846374536717983),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolSystemRefTo)
    
    _set_path_metadata = { "offset" : _set_path_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def set_path(self, path:str) -> None:
        """Set a new system."""
        return self._intf.invoke(VectorGeometryToolSystemRefTo._metadata, VectorGeometryToolSystemRefTo._set_path_metadata, path)

    _set_system_metadata = { "offset" : _set_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    def set_system(self, system:"IVectorGeometryToolSystem") -> None:
        """Set a new system."""
        return self._intf.invoke(VectorGeometryToolSystemRefTo._metadata, VectorGeometryToolSystemRefTo._set_system_metadata, system)

    _get_system_metadata = { "offset" : _get_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_system(self) -> "IVectorGeometryToolSystem":
        """Return the actual system object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(VectorGeometryToolSystemRefTo._metadata, VectorGeometryToolSystemRefTo._get_system_metadata, OutArg())

    _has_cyclic_dependency_metadata = { "offset" : _has_cyclic_dependency_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.VariantBoolArg,) }
    def has_cyclic_dependency(self, system:"IVectorGeometryToolSystem") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(VectorGeometryToolSystemRefTo._metadata, VectorGeometryToolSystemRefTo._has_cyclic_dependency_metadata, system, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolSystemRefTo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolSystemRefTo)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemRefTo, [VectorGeometryToolSystemRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry((4872681286682929827, 12142992341420117925), VectorGeometryToolSystemRefTo)
agcls.AgTypeNameMap["VectorGeometryToolSystemRefTo"] = VectorGeometryToolSystemRefTo

class VectorGeometryToolPlaneRefTo(IAnalysisWorkbenchRefTo, SupportsDeleteCallback):
    """Represents a reference to a VGT plane."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_path_method_offset = 1
    _set_plane_method_offset = 2
    _get_plane_method_offset = 3
    _has_cyclic_dependency_method_offset = 4
    _metadata = {
        "iid_data" : (5342221201152241906, 7909267626057482112),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneRefTo)
    
    _set_path_metadata = { "offset" : _set_path_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def set_path(self, path:str) -> None:
        """Set a new plane using a specified path."""
        return self._intf.invoke(VectorGeometryToolPlaneRefTo._metadata, VectorGeometryToolPlaneRefTo._set_path_metadata, path)

    _set_plane_metadata = { "offset" : _set_plane_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPlane"),) }
    def set_plane(self, plane:"IVectorGeometryToolPlane") -> None:
        """Set a new plane."""
        return self._intf.invoke(VectorGeometryToolPlaneRefTo._metadata, VectorGeometryToolPlaneRefTo._set_plane_metadata, plane)

    _get_plane_metadata = { "offset" : _get_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_plane(self) -> "IVectorGeometryToolPlane":
        """Return the actual plane object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(VectorGeometryToolPlaneRefTo._metadata, VectorGeometryToolPlaneRefTo._get_plane_metadata, OutArg())

    _has_cyclic_dependency_metadata = { "offset" : _has_cyclic_dependency_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPlane"), agmarshall.VariantBoolArg,) }
    def has_cyclic_dependency(self, plane:"IVectorGeometryToolPlane") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(VectorGeometryToolPlaneRefTo._metadata, VectorGeometryToolPlaneRefTo._has_cyclic_dependency_metadata, plane, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneRefTo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneRefTo)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneRefTo, [VectorGeometryToolPlaneRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry((4889764551144905757, 6174863000760270723), VectorGeometryToolPlaneRefTo)
agcls.AgTypeNameMap["VectorGeometryToolPlaneRefTo"] = VectorGeometryToolPlaneRefTo

class VectorGeometryToolVector(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A generic vector class."""
    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVector."""
        SupportsDeleteCallback.__init__(self)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVector, [IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4788543380264657974, 4021920445499540372), VectorGeometryToolVector)
agcls.AgTypeNameMap["VectorGeometryToolVector"] = VectorGeometryToolVector

class VectorGeometryToolAxesLabels(SupportsDeleteCallback):
    """Allow configuring the VGT axes labels."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_label_x_method_offset = 1
    _set_label_x_method_offset = 2
    _get_label_y_method_offset = 3
    _set_label_y_method_offset = 4
    _get_label_z_method_offset = 5
    _set_label_z_method_offset = 6
    _metadata = {
        "iid_data" : (4932524825887872296, 14818591864936711324),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesLabels)
    
    _get_label_x_metadata = { "offset" : _get_label_x_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label_x(self) -> str:
        """Specify an X axis label."""
        return self._intf.get_property(VectorGeometryToolAxesLabels._metadata, VectorGeometryToolAxesLabels._get_label_x_metadata)

    _set_label_x_metadata = { "offset" : _set_label_x_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @label_x.setter
    def label_x(self, labelX:str) -> None:
        return self._intf.set_property(VectorGeometryToolAxesLabels._metadata, VectorGeometryToolAxesLabels._set_label_x_metadata, labelX)

    _get_label_y_metadata = { "offset" : _get_label_y_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label_y(self) -> str:
        """Specify a Y axis label."""
        return self._intf.get_property(VectorGeometryToolAxesLabels._metadata, VectorGeometryToolAxesLabels._get_label_y_metadata)

    _set_label_y_metadata = { "offset" : _set_label_y_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @label_y.setter
    def label_y(self, labelY:str) -> None:
        return self._intf.set_property(VectorGeometryToolAxesLabels._metadata, VectorGeometryToolAxesLabels._set_label_y_metadata, labelY)

    _get_label_z_metadata = { "offset" : _get_label_z_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label_z(self) -> str:
        """Specify a Z axis label."""
        return self._intf.get_property(VectorGeometryToolAxesLabels._metadata, VectorGeometryToolAxesLabels._get_label_z_metadata)

    _set_label_z_metadata = { "offset" : _set_label_z_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @label_z.setter
    def label_z(self, labelZ:str) -> None:
        return self._intf.set_property(VectorGeometryToolAxesLabels._metadata, VectorGeometryToolAxesLabels._set_label_z_metadata, labelZ)

    _property_names[label_x] = "label_x"
    _property_names[label_y] = "label_y"
    _property_names[label_z] = "label_z"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesLabels."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesLabels)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesLabels, [VectorGeometryToolAxesLabels, ])

agcls.AgClassCatalog.add_catalog_entry((5086004625897624493, 5710003380506752172), VectorGeometryToolAxesLabels)
agcls.AgTypeNameMap["VectorGeometryToolAxesLabels"] = VectorGeometryToolAxesLabels

class VectorGeometryToolAxes(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A generic axes class."""
    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxes."""
        SupportsDeleteCallback.__init__(self)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxes, [IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5044961233979432208, 9395285165778922900), VectorGeometryToolAxes)
agcls.AgTypeNameMap["VectorGeometryToolAxes"] = VectorGeometryToolAxes

class VectorGeometryToolPoint(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A generic VGT point class."""
    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPoint."""
        SupportsDeleteCallback.__init__(self)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPoint, [IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5419596708576411945, 12185975766433231289), VectorGeometryToolPoint)
agcls.AgTypeNameMap["VectorGeometryToolPoint"] = VectorGeometryToolPoint

class VectorGeometryToolSystem(IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolSystem."""
        SupportsDeleteCallback.__init__(self)
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystem._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolSystem, [IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5448501409524915739, 12010762595595467697), VectorGeometryToolSystem)
agcls.AgTypeNameMap["VectorGeometryToolSystem"] = VectorGeometryToolSystem

class VectorGeometryToolAngle(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngle."""
        SupportsDeleteCallback.__init__(self)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngle, [IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5629500551113305507, 7730710653323930790), VectorGeometryToolAngle)
agcls.AgTypeNameMap["VectorGeometryToolAngle"] = VectorGeometryToolAngle

class VectorGeometryToolPlaneLabels(SupportsDeleteCallback):
    """Allow configuring the X and Y axes labels."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_x_axis_label_method_offset = 1
    _set_x_axis_label_method_offset = 2
    _get_y_axis_label_method_offset = 3
    _set_y_axis_label_method_offset = 4
    _metadata = {
        "iid_data" : (5440014174761149743, 15219345938915071877),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneLabels)
    
    _get_x_axis_label_metadata = { "offset" : _get_x_axis_label_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def x_axis_label(self) -> str:
        """Specify an X axis label."""
        return self._intf.get_property(VectorGeometryToolPlaneLabels._metadata, VectorGeometryToolPlaneLabels._get_x_axis_label_metadata)

    _set_x_axis_label_metadata = { "offset" : _set_x_axis_label_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @x_axis_label.setter
    def x_axis_label(self, xAxisLabel:str) -> None:
        return self._intf.set_property(VectorGeometryToolPlaneLabels._metadata, VectorGeometryToolPlaneLabels._set_x_axis_label_metadata, xAxisLabel)

    _get_y_axis_label_metadata = { "offset" : _get_y_axis_label_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def y_axis_label(self) -> str:
        """Specify a Y axis label."""
        return self._intf.get_property(VectorGeometryToolPlaneLabels._metadata, VectorGeometryToolPlaneLabels._get_y_axis_label_metadata)

    _set_y_axis_label_metadata = { "offset" : _set_y_axis_label_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @y_axis_label.setter
    def y_axis_label(self, yAxisLabel:str) -> None:
        return self._intf.set_property(VectorGeometryToolPlaneLabels._metadata, VectorGeometryToolPlaneLabels._set_y_axis_label_metadata, yAxisLabel)

    _property_names[x_axis_label] = "x_axis_label"
    _property_names[y_axis_label] = "y_axis_label"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneLabels."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneLabels)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneLabels, [VectorGeometryToolPlaneLabels, ])

agcls.AgClassCatalog.add_catalog_entry((5708362026720629481, 8749304800057505166), VectorGeometryToolPlaneLabels)
agcls.AgTypeNameMap["VectorGeometryToolPlaneLabels"] = VectorGeometryToolPlaneLabels

class VectorGeometryToolPlane(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlane."""
        SupportsDeleteCallback.__init__(self)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlane, [IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5498477606257732229, 9946486879664144023), VectorGeometryToolPlane)
agcls.AgTypeNameMap["VectorGeometryToolPlane"] = VectorGeometryToolPlane

class VectorGeometryToolAxesAlignedAndConstrained(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_alignment_reference_vector_method_offset = 1
    _get_constraint_reference_vector_method_offset = 2
    _get_alignment_direction_method_offset = 3
    _get_constraint_direction_method_offset = 4
    _metadata = {
        "iid_data" : (4741713611122613839, 4582109232137381806),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesAlignedAndConstrained)
    
    _get_alignment_reference_vector_metadata = { "offset" : _get_alignment_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def alignment_reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify an alignment reference vector."""
        return self._intf.get_property(VectorGeometryToolAxesAlignedAndConstrained._metadata, VectorGeometryToolAxesAlignedAndConstrained._get_alignment_reference_vector_metadata)

    _get_constraint_reference_vector_metadata = { "offset" : _get_constraint_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def constraint_reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a constraint reference vector."""
        return self._intf.get_property(VectorGeometryToolAxesAlignedAndConstrained._metadata, VectorGeometryToolAxesAlignedAndConstrained._get_constraint_reference_vector_metadata)

    _get_alignment_direction_metadata = { "offset" : _get_alignment_direction_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def alignment_direction(self) -> "IDirection":
        """Specify a desired alignment direction and the applicable parameters."""
        return self._intf.get_property(VectorGeometryToolAxesAlignedAndConstrained._metadata, VectorGeometryToolAxesAlignedAndConstrained._get_alignment_direction_metadata)

    _get_constraint_direction_metadata = { "offset" : _get_constraint_direction_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def constraint_direction(self) -> "IDirection":
        """Specify a desired constraint direction and the applicable parameters."""
        return self._intf.get_property(VectorGeometryToolAxesAlignedAndConstrained._metadata, VectorGeometryToolAxesAlignedAndConstrained._get_constraint_direction_metadata)

    _property_names[alignment_reference_vector] = "alignment_reference_vector"
    _property_names[constraint_reference_vector] = "constraint_reference_vector"
    _property_names[alignment_direction] = "alignment_direction"
    _property_names[constraint_direction] = "constraint_direction"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesAlignedAndConstrained."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesAlignedAndConstrained)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAlignedAndConstrained, [VectorGeometryToolAxesAlignedAndConstrained, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4850207006922603867, 3173509712834431154), VectorGeometryToolAxesAlignedAndConstrained)
agcls.AgTypeNameMap["VectorGeometryToolAxesAlignedAndConstrained"] = VectorGeometryToolAxesAlignedAndConstrained

class VectorGeometryToolAxesAngularOffset(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_spin_vector_method_offset = 1
    _get_rotation_angle_method_offset = 2
    _get_reference_axes_method_offset = 3
    _get_fixed_offset_angle_method_offset = 4
    _set_fixed_offset_angle_method_offset = 5
    _metadata = {
        "iid_data" : (5677112897421375797, 6984851836854641810),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesAngularOffset)
    
    _get_spin_vector_metadata = { "offset" : _get_spin_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def spin_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a spin vector."""
        return self._intf.get_property(VectorGeometryToolAxesAngularOffset._metadata, VectorGeometryToolAxesAngularOffset._get_spin_vector_metadata)

    _get_rotation_angle_metadata = { "offset" : _get_rotation_angle_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def rotation_angle(self) -> "VectorGeometryToolAngleRefTo":
        """Specify a rotational angle."""
        return self._intf.get_property(VectorGeometryToolAxesAngularOffset._metadata, VectorGeometryToolAxesAngularOffset._get_rotation_angle_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolAxesAngularOffset._metadata, VectorGeometryToolAxesAngularOffset._get_reference_axes_metadata)

    _get_fixed_offset_angle_metadata = { "offset" : _get_fixed_offset_angle_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def fixed_offset_angle(self) -> float:
        """Specify an additional rotational offset."""
        return self._intf.get_property(VectorGeometryToolAxesAngularOffset._metadata, VectorGeometryToolAxesAngularOffset._get_fixed_offset_angle_metadata)

    _set_fixed_offset_angle_metadata = { "offset" : _set_fixed_offset_angle_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @fixed_offset_angle.setter
    def fixed_offset_angle(self, fixedOffsetAngle:float) -> None:
        return self._intf.set_property(VectorGeometryToolAxesAngularOffset._metadata, VectorGeometryToolAxesAngularOffset._set_fixed_offset_angle_metadata, fixedOffsetAngle)

    _property_names[spin_vector] = "spin_vector"
    _property_names[rotation_angle] = "rotation_angle"
    _property_names[reference_axes] = "reference_axes"
    _property_names[fixed_offset_angle] = "fixed_offset_angle"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesAngularOffset."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesAngularOffset)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAngularOffset, [VectorGeometryToolAxesAngularOffset, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4997754132062289803, 5413856362237364661), VectorGeometryToolAxesAngularOffset)
agcls.AgTypeNameMap["VectorGeometryToolAxesAngularOffset"] = VectorGeometryToolAxesAngularOffset

class VectorGeometryToolAxesFixedAtEpoch(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes based on another set fixed at a specified epoch."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_source_axes_method_offset = 1
    _get_reference_axes_method_offset = 2
    _get_epoch_method_offset = 3
    _set_epoch_method_offset = 4
    _metadata = {
        "iid_data" : (5437157536228302950, 4834721672965880495),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesFixedAtEpoch)
    
    _get_source_axes_metadata = { "offset" : _get_source_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a source axes."""
        return self._intf.get_property(VectorGeometryToolAxesFixedAtEpoch._metadata, VectorGeometryToolAxesFixedAtEpoch._get_source_axes_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolAxesFixedAtEpoch._metadata, VectorGeometryToolAxesFixedAtEpoch._get_reference_axes_metadata)

    _get_epoch_metadata = { "offset" : _get_epoch_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def epoch(self) -> typing.Any:
        """Specify an epoch."""
        return self._intf.get_property(VectorGeometryToolAxesFixedAtEpoch._metadata, VectorGeometryToolAxesFixedAtEpoch._get_epoch_metadata)

    _set_epoch_metadata = { "offset" : _set_epoch_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(VectorGeometryToolAxesFixedAtEpoch._metadata, VectorGeometryToolAxesFixedAtEpoch._set_epoch_metadata, epoch)

    _property_names[source_axes] = "source_axes"
    _property_names[reference_axes] = "reference_axes"
    _property_names[epoch] = "epoch"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesFixedAtEpoch."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesFixedAtEpoch)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesFixedAtEpoch, [VectorGeometryToolAxesFixedAtEpoch, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5521125035658318449, 12431711413893056934), VectorGeometryToolAxesFixedAtEpoch)
agcls.AgTypeNameMap["VectorGeometryToolAxesFixedAtEpoch"] = VectorGeometryToolAxesFixedAtEpoch

class VectorGeometryToolAxesBPlane(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """B-Plane axes using the selected target body and reference vector."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_trajectory_method_offset = 1
    _get_reference_vector_method_offset = 2
    _get_target_body_method_offset = 3
    _get_direction_method_offset = 4
    _set_direction_method_offset = 5
    _metadata = {
        "iid_data" : (5031275480175450065, 12426755810793897623),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesBPlane)
    
    _get_trajectory_metadata = { "offset" : _get_trajectory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def trajectory(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(VectorGeometryToolAxesBPlane._metadata, VectorGeometryToolAxesBPlane._get_trajectory_metadata)

    _get_reference_vector_metadata = { "offset" : _get_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(VectorGeometryToolAxesBPlane._metadata, VectorGeometryToolAxesBPlane._get_reference_vector_metadata)

    _get_target_body_metadata = { "offset" : _get_target_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def target_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a target central body."""
        return self._intf.get_property(VectorGeometryToolAxesBPlane._metadata, VectorGeometryToolAxesBPlane._get_target_body_metadata)

    _get_direction_metadata = { "offset" : _get_direction_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIRECTION_TYPE),) }
    @property
    def direction(self) -> "CRDN_DIRECTION_TYPE":
        """Specify a direction (incoming or outgoing)."""
        return self._intf.get_property(VectorGeometryToolAxesBPlane._metadata, VectorGeometryToolAxesBPlane._get_direction_metadata)

    _set_direction_metadata = { "offset" : _set_direction_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIRECTION_TYPE),) }
    @direction.setter
    def direction(self, direction:"CRDN_DIRECTION_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolAxesBPlane._metadata, VectorGeometryToolAxesBPlane._set_direction_metadata, direction)

    _property_names[trajectory] = "trajectory"
    _property_names[reference_vector] = "reference_vector"
    _property_names[target_body] = "target_body"
    _property_names[direction] = "direction"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesBPlane."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesBPlane)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesBPlane, [VectorGeometryToolAxesBPlane, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5733700134692656362, 13054031072239382407), VectorGeometryToolAxesBPlane)
agcls.AgTypeNameMap["VectorGeometryToolAxesBPlane"] = VectorGeometryToolAxesBPlane

class VectorGeometryToolAxesCustomScript(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Customized axes offset with respect to a set of reference Axes."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_axes_method_offset = 1
    _get_filename_method_offset = 2
    _set_filename_method_offset = 3
    _metadata = {
        "iid_data" : (5323258079388012774, 73336895666566586),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesCustomScript)
    
    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolAxesCustomScript._metadata, VectorGeometryToolAxesCustomScript._get_reference_axes_metadata)

    _get_filename_metadata = { "offset" : _get_filename_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def filename(self) -> str:
        """Can be MATLAB (.m or .dll) or VB Script (.vbs) script file."""
        return self._intf.get_property(VectorGeometryToolAxesCustomScript._metadata, VectorGeometryToolAxesCustomScript._get_filename_metadata)

    _set_filename_metadata = { "offset" : _set_filename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(VectorGeometryToolAxesCustomScript._metadata, VectorGeometryToolAxesCustomScript._set_filename_metadata, filename)

    _property_names[reference_axes] = "reference_axes"
    _property_names[filename] = "filename"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesCustomScript."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesCustomScript)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesCustomScript, [VectorGeometryToolAxesCustomScript, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5110760456880555996, 122080162762217350), VectorGeometryToolAxesCustomScript)
agcls.AgTypeNameMap["VectorGeometryToolAxesCustomScript"] = VectorGeometryToolAxesCustomScript

class VectorGeometryToolAxesAttitudeFile(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes specified by data from a file."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filename_method_offset = 1
    _set_filename_method_offset = 2
    _metadata = {
        "iid_data" : (5300531074972095677, 16740618416462344876),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesAttitudeFile)
    
    _get_filename_metadata = { "offset" : _get_filename_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        return self._intf.get_property(VectorGeometryToolAxesAttitudeFile._metadata, VectorGeometryToolAxesAttitudeFile._get_filename_metadata)

    _set_filename_metadata = { "offset" : _set_filename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(VectorGeometryToolAxesAttitudeFile._metadata, VectorGeometryToolAxesAttitudeFile._set_filename_metadata, filename)

    _property_names[filename] = "filename"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesAttitudeFile."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesAttitudeFile)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAttitudeFile, [VectorGeometryToolAxesAttitudeFile, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5288525702130684003, 14972327049341920664), VectorGeometryToolAxesAttitudeFile)
agcls.AgTypeNameMap["VectorGeometryToolAxesAttitudeFile"] = VectorGeometryToolAxesAttitudeFile

class VectorGeometryToolAxesFixed(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes fixed in reference axes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_axes_method_offset = 1
    _get_fixed_orientation_method_offset = 2
    _metadata = {
        "iid_data" : (5423714790564105553, 2470081558751579307),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesFixed)
    
    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolAxesFixed._metadata, VectorGeometryToolAxesFixed._get_reference_axes_metadata)

    _get_fixed_orientation_metadata = { "offset" : _get_fixed_orientation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def fixed_orientation(self) -> "IOrientation":
        """Specify a desired orientation and the applicable parameters."""
        return self._intf.get_property(VectorGeometryToolAxesFixed._metadata, VectorGeometryToolAxesFixed._get_fixed_orientation_metadata)

    _property_names[reference_axes] = "reference_axes"
    _property_names[fixed_orientation] = "fixed_orientation"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesFixed."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesFixed)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesFixed, [VectorGeometryToolAxesFixed, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4637366771607936115, 17213460083789714103), VectorGeometryToolAxesFixed)
agcls.AgTypeNameMap["VectorGeometryToolAxesFixed"] = VectorGeometryToolAxesFixed

class VectorGeometryToolAxesModelAttach(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_pointable_element_name_method_offset = 1
    _set_pointable_element_name_method_offset = 2
    _metadata = {
        "iid_data" : (4714192977359068868, 12710169172715718539),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesModelAttach)
    
    _get_pointable_element_name_metadata = { "offset" : _get_pointable_element_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def pointable_element_name(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        return self._intf.get_property(VectorGeometryToolAxesModelAttach._metadata, VectorGeometryToolAxesModelAttach._get_pointable_element_name_metadata)

    _set_pointable_element_name_metadata = { "offset" : _set_pointable_element_name_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @pointable_element_name.setter
    def pointable_element_name(self, pointableElementName:str) -> None:
        return self._intf.set_property(VectorGeometryToolAxesModelAttach._metadata, VectorGeometryToolAxesModelAttach._set_pointable_element_name_metadata, pointableElementName)

    _property_names[pointable_element_name] = "pointable_element_name"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesModelAttach."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesModelAttach)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesModelAttach, [VectorGeometryToolAxesModelAttach, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5193235162391666986, 18246769432303230655), VectorGeometryToolAxesModelAttach)
agcls.AgTypeNameMap["VectorGeometryToolAxesModelAttach"] = VectorGeometryToolAxesModelAttach

class VectorGeometryToolAxesSpinning(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_spin_vector_method_offset = 1
    _get_reference_axes_method_offset = 2
    _get_epoch_method_offset = 3
    _set_epoch_method_offset = 4
    _get_initial_offset_method_offset = 5
    _set_initial_offset_method_offset = 6
    _get_spin_rate_method_offset = 7
    _set_spin_rate_method_offset = 8
    _metadata = {
        "iid_data" : (4667617302730203157, 4061177140042338229),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesSpinning)
    
    _get_spin_vector_metadata = { "offset" : _get_spin_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def spin_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a spin vector."""
        return self._intf.get_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._get_spin_vector_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._get_reference_axes_metadata)

    _get_epoch_metadata = { "offset" : _get_epoch_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def epoch(self) -> typing.Any:
        """Specify an epoch at which the axes are aligned with the reference axes."""
        return self._intf.get_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._get_epoch_metadata)

    _set_epoch_metadata = { "offset" : _set_epoch_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._set_epoch_metadata, epoch)

    _get_initial_offset_metadata = { "offset" : _get_initial_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def initial_offset(self) -> float:
        """Specify an additional rotational offset."""
        return self._intf.get_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._get_initial_offset_metadata)

    _set_initial_offset_metadata = { "offset" : _set_initial_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @initial_offset.setter
    def initial_offset(self, initialOffset:float) -> None:
        return self._intf.set_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._set_initial_offset_metadata, initialOffset)

    _get_spin_rate_metadata = { "offset" : _get_spin_rate_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def spin_rate(self) -> float:
        """Specify a spin rate the axes spins about the spin vector."""
        return self._intf.get_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._get_spin_rate_metadata)

    _set_spin_rate_metadata = { "offset" : _set_spin_rate_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @spin_rate.setter
    def spin_rate(self, spinRate:float) -> None:
        return self._intf.set_property(VectorGeometryToolAxesSpinning._metadata, VectorGeometryToolAxesSpinning._set_spin_rate_metadata, spinRate)

    _property_names[spin_vector] = "spin_vector"
    _property_names[reference_axes] = "reference_axes"
    _property_names[epoch] = "epoch"
    _property_names[initial_offset] = "initial_offset"
    _property_names[spin_rate] = "spin_rate"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesSpinning."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesSpinning)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesSpinning, [VectorGeometryToolAxesSpinning, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4995482426629917549, 13130993006376102317), VectorGeometryToolAxesSpinning)
agcls.AgTypeNameMap["VectorGeometryToolAxesSpinning"] = VectorGeometryToolAxesSpinning

class VectorGeometryToolAxesOnSurface(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Topocentric axes located at the reference point's projection on the central body."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _get_use_msl_method_offset = 3
    _set_use_msl_method_offset = 4
    _metadata = {
        "iid_data" : (5185933021301684471, 12275505551023435660),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesOnSurface)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolAxesOnSurface._metadata, VectorGeometryToolAxesOnSurface._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(VectorGeometryToolAxesOnSurface._metadata, VectorGeometryToolAxesOnSurface._get_reference_point_metadata)

    _get_use_msl_metadata = { "offset" : _get_use_msl_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_msl(self) -> bool:
        """Specify whether the reference shape is at the Mean Sea Level."""
        return self._intf.get_property(VectorGeometryToolAxesOnSurface._metadata, VectorGeometryToolAxesOnSurface._get_use_msl_metadata)

    _set_use_msl_metadata = { "offset" : _set_use_msl_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_msl.setter
    def use_msl(self, useMSL:bool) -> None:
        return self._intf.set_property(VectorGeometryToolAxesOnSurface._metadata, VectorGeometryToolAxesOnSurface._set_use_msl_metadata, useMSL)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[use_msl] = "use_msl"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesOnSurface."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesOnSurface)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesOnSurface, [VectorGeometryToolAxesOnSurface, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4971314585753366554, 1292441604687819144), VectorGeometryToolAxesOnSurface)
agcls.AgTypeNameMap["VectorGeometryToolAxesOnSurface"] = VectorGeometryToolAxesOnSurface

class VectorGeometryToolAxesTrajectory(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Axes based on trajectory of the point relative to the reference coordinate system."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_trajectory_point_method_offset = 1
    _get_reference_system_method_offset = 2
    _get_trajectory_axes_type_method_offset = 3
    _set_trajectory_axes_type_method_offset = 4
    _metadata = {
        "iid_data" : (5651358147515433935, 4289649635532755076),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesTrajectory)
    
    _get_trajectory_point_metadata = { "offset" : _get_trajectory_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def trajectory_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(VectorGeometryToolAxesTrajectory._metadata, VectorGeometryToolAxesTrajectory._get_trajectory_point_metadata)

    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(VectorGeometryToolAxesTrajectory._metadata, VectorGeometryToolAxesTrajectory._get_reference_system_metadata)

    _get_trajectory_axes_type_metadata = { "offset" : _get_trajectory_axes_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_TRAJECTORY_AXES_TYPE),) }
    @property
    def trajectory_axes_type(self) -> "CRDN_TRAJECTORY_AXES_TYPE":
        """Specify a type of the trajectory's coordinate frame."""
        return self._intf.get_property(VectorGeometryToolAxesTrajectory._metadata, VectorGeometryToolAxesTrajectory._get_trajectory_axes_type_metadata)

    _set_trajectory_axes_type_metadata = { "offset" : _set_trajectory_axes_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_TRAJECTORY_AXES_TYPE),) }
    @trajectory_axes_type.setter
    def trajectory_axes_type(self, trajectoryAxesType:"CRDN_TRAJECTORY_AXES_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolAxesTrajectory._metadata, VectorGeometryToolAxesTrajectory._set_trajectory_axes_type_metadata, trajectoryAxesType)

    _property_names[trajectory_point] = "trajectory_point"
    _property_names[reference_system] = "reference_system"
    _property_names[trajectory_axes_type] = "trajectory_axes_type"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesTrajectory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesTrajectory)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesTrajectory, [VectorGeometryToolAxesTrajectory, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5298893710421423902, 14770159094158175145), VectorGeometryToolAxesTrajectory)
agcls.AgTypeNameMap["VectorGeometryToolAxesTrajectory"] = VectorGeometryToolAxesTrajectory

class VectorGeometryToolAxesLagrangeLibration(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_primary_central_body_method_offset = 1
    _get_point_type_method_offset = 2
    _set_point_type_method_offset = 3
    _get_secondary_central_bodies_method_offset = 4
    _metadata = {
        "iid_data" : (5009774174844947093, 15791835418586956929),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesLagrangeLibration)
    
    _get_primary_central_body_metadata = { "offset" : _get_primary_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def primary_central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a primary central body."""
        return self._intf.get_property(VectorGeometryToolAxesLagrangeLibration._metadata, VectorGeometryToolAxesLagrangeLibration._get_primary_central_body_metadata)

    _get_point_type_metadata = { "offset" : _get_point_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @property
    def point_type(self) -> "CRDN_LAGRANGE_LIBRATION_POINT_TYPE":
        """Specify a lagrange point (L1, L2, etc.)."""
        return self._intf.get_property(VectorGeometryToolAxesLagrangeLibration._metadata, VectorGeometryToolAxesLagrangeLibration._get_point_type_metadata)

    _set_point_type_metadata = { "offset" : _set_point_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @point_type.setter
    def point_type(self, pointType:"CRDN_LAGRANGE_LIBRATION_POINT_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolAxesLagrangeLibration._metadata, VectorGeometryToolAxesLagrangeLibration._set_point_type_metadata, pointType)

    _get_secondary_central_bodies_metadata = { "offset" : _get_secondary_central_bodies_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def secondary_central_bodies(self) -> "AnalysisWorkbenchCentralBodyCollection":
        """Specify secondary central bodies."""
        return self._intf.get_property(VectorGeometryToolAxesLagrangeLibration._metadata, VectorGeometryToolAxesLagrangeLibration._get_secondary_central_bodies_metadata)

    _property_names[primary_central_body] = "primary_central_body"
    _property_names[point_type] = "point_type"
    _property_names[secondary_central_bodies] = "secondary_central_bodies"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesLagrangeLibration."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesLagrangeLibration)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesLagrangeLibration, [VectorGeometryToolAxesLagrangeLibration, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5341406077696168069, 3448170282291780742), VectorGeometryToolAxesLagrangeLibration)
agcls.AgTypeNameMap["VectorGeometryToolAxesLagrangeLibration"] = VectorGeometryToolAxesLagrangeLibration

class VectorGeometryToolAxesCommonTasks(SupportsDeleteCallback):
    """Provide methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_topocentric_axes_quaternion_method_offset = 1
    _create_topocentric_axes_euler_angles_method_offset = 2
    _create_fixed_method_offset = 3
    _sample_method_offset = 4
    _metadata = {
        "iid_data" : (5573973030027962339, 11350862514454620079),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesCommonTasks)
    
    _create_topocentric_axes_quaternion_metadata = { "offset" : _create_topocentric_axes_quaternion_method_offset,
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_topocentric_axes_quaternion(self, originPoint:"IVectorGeometryToolPoint", qx:float, qy:float, qz:float, qs:float) -> "VectorGeometryToolAxesFixed":
        """Create non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The quaternion defines the axes's orientation."""
        return self._intf.invoke(VectorGeometryToolAxesCommonTasks._metadata, VectorGeometryToolAxesCommonTasks._create_topocentric_axes_quaternion_metadata, originPoint, qx, qy, qz, qs, OutArg())

    _create_topocentric_axes_euler_angles_metadata = { "offset" : _create_topocentric_axes_euler_angles_method_offset,
            "arg_types" : (agcom.PVOID, agcom.LONG, agcom.Variant, agcom.Variant, agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.EnumArg(EULER_ORIENTATION_SEQUENCE), agmarshall.VariantArg, agmarshall.VariantArg, agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def create_topocentric_axes_euler_angles(self, originPoint:"IVectorGeometryToolPoint", sequence:"EULER_ORIENTATION_SEQUENCE", a:typing.Any, b:typing.Any, c:typing.Any) -> "VectorGeometryToolAxesFixed":
        """Create non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The euler angles define the axes's orientation."""
        return self._intf.invoke(VectorGeometryToolAxesCommonTasks._metadata, VectorGeometryToolAxesCommonTasks._create_topocentric_axes_euler_angles_metadata, originPoint, sequence, a, b, c, OutArg())

    _create_fixed_metadata = { "offset" : _create_fixed_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def create_fixed(self, referenceAxes:"IVectorGeometryToolAxes") -> "VectorGeometryToolAxesFixed":
        """Create non-persistent fixed axes based on specified axes."""
        return self._intf.invoke(VectorGeometryToolAxesCommonTasks._metadata, VectorGeometryToolAxesCommonTasks._create_fixed_metadata, referenceAxes, OutArg())

    _sample_metadata = { "offset" : _sample_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def sample(self, axes:"IVectorGeometryToolAxes", referenceAxes:"IVectorGeometryToolAxes", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "TimeToolAxesSamplingResult":
        """Compute and returns tabulated orientations and angular velocities of axes with respect to reference axes using specified sampling parameters."""
        return self._intf.invoke(VectorGeometryToolAxesCommonTasks._metadata, VectorGeometryToolAxesCommonTasks._sample_metadata, axes, referenceAxes, intervals, minStep, maxStep, targetRate, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesCommonTasks."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesCommonTasks)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesCommonTasks, [VectorGeometryToolAxesCommonTasks, ])

agcls.AgClassCatalog.add_catalog_entry((5420778078107633244, 5349538928625407639), VectorGeometryToolAxesCommonTasks)
agcls.AgTypeNameMap["VectorGeometryToolAxesCommonTasks"] = VectorGeometryToolAxesCommonTasks

class VectorGeometryToolAxesAtTimeInstant(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes, SupportsDeleteCallback):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_time_instant_method_offset = 1
    _set_reference_time_instant_method_offset = 2
    _get_source_axes_method_offset = 3
    _set_source_axes_method_offset = 4
    _get_reference_axes_method_offset = 5
    _set_reference_axes_method_offset = 6
    _metadata = {
        "iid_data" : (4873280145999219285, 11891884691591801994),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesAtTimeInstant)
    
    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(VectorGeometryToolAxesAtTimeInstant._metadata, VectorGeometryToolAxesAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(VectorGeometryToolAxesAtTimeInstant._metadata, VectorGeometryToolAxesAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_source_axes_metadata = { "offset" : _get_source_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_axes(self) -> "IVectorGeometryToolAxes":
        """A base axes defining the orientation. Can be any VGT axes."""
        return self._intf.get_property(VectorGeometryToolAxesAtTimeInstant._metadata, VectorGeometryToolAxesAtTimeInstant._get_source_axes_metadata)

    _set_source_axes_metadata = { "offset" : _set_source_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @source_axes.setter
    def source_axes(self, sourceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(VectorGeometryToolAxesAtTimeInstant._metadata, VectorGeometryToolAxesAtTimeInstant._set_source_axes_metadata, sourceAxes)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """A reference axes. Can be any VGT axes."""
        return self._intf.get_property(VectorGeometryToolAxesAtTimeInstant._metadata, VectorGeometryToolAxesAtTimeInstant._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "offset" : _set_reference_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(VectorGeometryToolAxesAtTimeInstant._metadata, VectorGeometryToolAxesAtTimeInstant._set_reference_axes_metadata, referenceAxes)

    _property_names[reference_time_instant] = "reference_time_instant"
    _property_names[source_axes] = "source_axes"
    _property_names[reference_axes] = "reference_axes"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesAtTimeInstant."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesAtTimeInstant)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAtTimeInstant, [VectorGeometryToolAxesAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes])

agcls.AgClassCatalog.add_catalog_entry((5017193475427648010, 10215401686756772007), VectorGeometryToolAxesAtTimeInstant)
agcls.AgTypeNameMap["VectorGeometryToolAxesAtTimeInstant"] = VectorGeometryToolAxesAtTimeInstant

class VectorGeometryToolAxesPlugin(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes, SupportsDeleteCallback):
    """A VGT axes plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_prog_id_method_offset = 1
    _get_display_name_method_offset = 2
    _get_available_properties_method_offset = 3
    _reset_method_offset = 4
    _set_property_method_offset = 5
    _get_property_method_offset = 6
    _metadata = {
        "iid_data" : (5229726198367507937, 5541409003390586014),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesPlugin)
    
    _get_prog_id_metadata = { "offset" : _get_prog_id_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(VectorGeometryToolAxesPlugin._metadata, VectorGeometryToolAxesPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "offset" : _get_display_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def display_name(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(VectorGeometryToolAxesPlugin._metadata, VectorGeometryToolAxesPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "offset" : _get_available_properties_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(VectorGeometryToolAxesPlugin._metadata, VectorGeometryToolAxesPlugin._get_available_properties_metadata)

    _reset_metadata = { "offset" : _reset_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(VectorGeometryToolAxesPlugin._metadata, VectorGeometryToolAxesPlugin._reset_metadata, )

    _set_property_metadata = { "offset" : _set_property_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def set_property(self, name:str, value:str) -> None:
        """Set the plugin properties. This method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(VectorGeometryToolAxesPlugin._metadata, VectorGeometryToolAxesPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "offset" : _get_property_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def get_property(self, name:str) -> str:
        """Read a value of the specified plugin property. This method throws an exception if the property does not exist."""
        return self._intf.invoke(VectorGeometryToolAxesPlugin._metadata, VectorGeometryToolAxesPlugin._get_property_metadata, name, OutArg())

    _property_names[prog_id] = "prog_id"
    _property_names[display_name] = "display_name"
    _property_names[available_properties] = "available_properties"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesPlugin."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesPlugin)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesPlugin, [VectorGeometryToolAxesPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes])

agcls.AgClassCatalog.add_catalog_entry((5024306098242634861, 9027031691428489138), VectorGeometryToolAxesPlugin)
agcls.AgTypeNameMap["VectorGeometryToolAxesPlugin"] = VectorGeometryToolAxesPlugin

class VectorGeometryToolAngleBetweenVectors(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An angle between two vectors."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_from_vector_method_offset = 1
    _get_to_vector_method_offset = 2
    _metadata = {
        "iid_data" : (4706165728470396558, 4613885311283434626),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleBetweenVectors)
    
    _get_from_vector_metadata = { "offset" : _get_from_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def from_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify the first of the two vectors the angle is measured."""
        return self._intf.get_property(VectorGeometryToolAngleBetweenVectors._metadata, VectorGeometryToolAngleBetweenVectors._get_from_vector_metadata)

    _get_to_vector_metadata = { "offset" : _get_to_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def to_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify the second of the two vectors the angle is measured."""
        return self._intf.get_property(VectorGeometryToolAngleBetweenVectors._metadata, VectorGeometryToolAngleBetweenVectors._get_to_vector_metadata)

    _property_names[from_vector] = "from_vector"
    _property_names[to_vector] = "to_vector"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleBetweenVectors."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleBetweenVectors)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleBetweenVectors, [VectorGeometryToolAngleBetweenVectors, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4934121995950007344, 3509908635259060373), VectorGeometryToolAngleBetweenVectors)
agcls.AgTypeNameMap["VectorGeometryToolAngleBetweenVectors"] = VectorGeometryToolAngleBetweenVectors

class VectorGeometryToolAngleBetweenPlanes(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An angle between two planes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_from_plane_method_offset = 1
    _get_to_plane_method_offset = 2
    _metadata = {
        "iid_data" : (4818502341743229941, 4954302282592202382),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleBetweenPlanes)
    
    _get_from_plane_metadata = { "offset" : _get_from_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def from_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the first of the two planes the angle is measured."""
        return self._intf.get_property(VectorGeometryToolAngleBetweenPlanes._metadata, VectorGeometryToolAngleBetweenPlanes._get_from_plane_metadata)

    _get_to_plane_metadata = { "offset" : _get_to_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def to_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the second of the two planes the angle is measured."""
        return self._intf.get_property(VectorGeometryToolAngleBetweenPlanes._metadata, VectorGeometryToolAngleBetweenPlanes._get_to_plane_metadata)

    _property_names[from_plane] = "from_plane"
    _property_names[to_plane] = "to_plane"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleBetweenPlanes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleBetweenPlanes)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleBetweenPlanes, [VectorGeometryToolAngleBetweenPlanes, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5142415411480004719, 5672759854970127006), VectorGeometryToolAngleBetweenPlanes)
agcls.AgTypeNameMap["VectorGeometryToolAngleBetweenPlanes"] = VectorGeometryToolAngleBetweenPlanes

class VectorGeometryToolAngleDihedral(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An angle between two vectors about an axis."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_from_vector_method_offset = 1
    _get_to_vector_method_offset = 2
    _get_pole_about_method_offset = 3
    _get_counter_clockwise_rotation_method_offset = 4
    _set_counter_clockwise_rotation_method_offset = 5
    _get_signed_angle_method_offset = 6
    _set_signed_angle_method_offset = 7
    _metadata = {
        "iid_data" : (5679713389409677088, 15515088218937651083),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleDihedral)
    
    _get_from_vector_metadata = { "offset" : _get_from_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def from_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a first vector to measure the angle."""
        return self._intf.get_property(VectorGeometryToolAngleDihedral._metadata, VectorGeometryToolAngleDihedral._get_from_vector_metadata)

    _get_to_vector_metadata = { "offset" : _get_to_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def to_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a second vector to measure the angle."""
        return self._intf.get_property(VectorGeometryToolAngleDihedral._metadata, VectorGeometryToolAngleDihedral._get_to_vector_metadata)

    _get_pole_about_metadata = { "offset" : _get_pole_about_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def pole_about(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a vector about."""
        return self._intf.get_property(VectorGeometryToolAngleDihedral._metadata, VectorGeometryToolAngleDihedral._get_pole_about_metadata)

    _get_counter_clockwise_rotation_metadata = { "offset" : _get_counter_clockwise_rotation_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def counter_clockwise_rotation(self) -> bool:
        """Specify whether the rotation is counter-clockwise."""
        return self._intf.get_property(VectorGeometryToolAngleDihedral._metadata, VectorGeometryToolAngleDihedral._get_counter_clockwise_rotation_metadata)

    _set_counter_clockwise_rotation_metadata = { "offset" : _set_counter_clockwise_rotation_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @counter_clockwise_rotation.setter
    def counter_clockwise_rotation(self, counterClockwiseRotation:bool) -> None:
        return self._intf.set_property(VectorGeometryToolAngleDihedral._metadata, VectorGeometryToolAngleDihedral._set_counter_clockwise_rotation_metadata, counterClockwiseRotation)

    _get_signed_angle_metadata = { "offset" : _get_signed_angle_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def signed_angle(self) -> bool:
        """Specify whether the axis of rotation for the angle is aligned with Positive or Negative direction of the about vector."""
        return self._intf.get_property(VectorGeometryToolAngleDihedral._metadata, VectorGeometryToolAngleDihedral._get_signed_angle_metadata)

    _set_signed_angle_metadata = { "offset" : _set_signed_angle_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @signed_angle.setter
    def signed_angle(self, signedAngle:bool) -> None:
        return self._intf.set_property(VectorGeometryToolAngleDihedral._metadata, VectorGeometryToolAngleDihedral._set_signed_angle_metadata, signedAngle)

    _property_names[from_vector] = "from_vector"
    _property_names[to_vector] = "to_vector"
    _property_names[pole_about] = "pole_about"
    _property_names[counter_clockwise_rotation] = "counter_clockwise_rotation"
    _property_names[signed_angle] = "signed_angle"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleDihedral."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleDihedral)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleDihedral, [VectorGeometryToolAngleDihedral, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4903268742534288827, 1669198075433999546), VectorGeometryToolAngleDihedral)
agcls.AgTypeNameMap["VectorGeometryToolAngleDihedral"] = VectorGeometryToolAngleDihedral

class VectorGeometryToolAngleRotation(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_from_axes_method_offset = 1
    _get_to_axes_method_offset = 2
    _get_reference_direction_method_offset = 3
    _set_reference_direction_method_offset = 4
    _metadata = {
        "iid_data" : (5142182411345604471, 400361542239300246),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleRotation)
    
    _get_from_axes_metadata = { "offset" : _get_from_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def from_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify an axes to rotate from."""
        return self._intf.get_property(VectorGeometryToolAngleRotation._metadata, VectorGeometryToolAngleRotation._get_from_axes_metadata)

    _get_to_axes_metadata = { "offset" : _get_to_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def to_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify an axes to rotate to."""
        return self._intf.get_property(VectorGeometryToolAngleRotation._metadata, VectorGeometryToolAngleRotation._get_to_axes_metadata)

    _get_reference_direction_metadata = { "offset" : _get_reference_direction_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_DISPLAY_AXIS_SELECTOR),) }
    @property
    def reference_direction(self) -> "CRDN_DISPLAY_AXIS_SELECTOR":
        """Specify a rotation direction."""
        return self._intf.get_property(VectorGeometryToolAngleRotation._metadata, VectorGeometryToolAngleRotation._get_reference_direction_metadata)

    _set_reference_direction_metadata = { "offset" : _set_reference_direction_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_DISPLAY_AXIS_SELECTOR),) }
    @reference_direction.setter
    def reference_direction(self, referenceDirection:"CRDN_DISPLAY_AXIS_SELECTOR") -> None:
        return self._intf.set_property(VectorGeometryToolAngleRotation._metadata, VectorGeometryToolAngleRotation._set_reference_direction_metadata, referenceDirection)

    _property_names[from_axes] = "from_axes"
    _property_names[to_axes] = "to_axes"
    _property_names[reference_direction] = "reference_direction"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleRotation."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleRotation)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleRotation, [VectorGeometryToolAngleRotation, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4804078596032006051, 13921202890855074486), VectorGeometryToolAngleRotation)
agcls.AgTypeNameMap["VectorGeometryToolAngleRotation"] = VectorGeometryToolAngleRotation

class VectorGeometryToolAngleToPlane(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """An angle between a vector and a plane."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_vector_method_offset = 1
    _get_reference_plane_method_offset = 2
    _get_signed_method_offset = 3
    _set_signed_method_offset = 4
    _metadata = {
        "iid_data" : (4646333063766877613, 14553174656509283513),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleToPlane)
    
    _get_reference_vector_metadata = { "offset" : _get_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(VectorGeometryToolAngleToPlane._metadata, VectorGeometryToolAngleToPlane._get_reference_vector_metadata)

    _get_reference_plane_metadata = { "offset" : _get_reference_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(VectorGeometryToolAngleToPlane._metadata, VectorGeometryToolAngleToPlane._get_reference_plane_metadata)

    _get_signed_metadata = { "offset" : _get_signed_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNED_ANGLE_TYPE),) }
    @property
    def signed(self) -> "CRDN_SIGNED_ANGLE_TYPE":
        """Control whether the angle is measured as either Positive or Negative when the reference Vector is directed toward the plane's normal, or always positive."""
        return self._intf.get_property(VectorGeometryToolAngleToPlane._metadata, VectorGeometryToolAngleToPlane._get_signed_metadata)

    _set_signed_metadata = { "offset" : _set_signed_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNED_ANGLE_TYPE),) }
    @signed.setter
    def signed(self, signed:"CRDN_SIGNED_ANGLE_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolAngleToPlane._metadata, VectorGeometryToolAngleToPlane._set_signed_metadata, signed)

    _property_names[reference_vector] = "reference_vector"
    _property_names[reference_plane] = "reference_plane"
    _property_names[signed] = "signed"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleToPlane."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleToPlane)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleToPlane, [VectorGeometryToolAngleToPlane, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4741464092637169531, 108701953784669870), VectorGeometryToolAngleToPlane)
agcls.AgTypeNameMap["VectorGeometryToolAngleToPlane"] = VectorGeometryToolAngleToPlane

class VectorGeometryToolPlaneNormal(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A plane normal to a vector at a given point."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_normal_vector_method_offset = 1
    _get_reference_vector_method_offset = 2
    _get_reference_point_method_offset = 3
    _metadata = {
        "iid_data" : (4866054806566235740, 13557789966285975229),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneNormal)
    
    _get_normal_vector_metadata = { "offset" : _get_normal_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def normal_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a Normal vector."""
        return self._intf.get_property(VectorGeometryToolPlaneNormal._metadata, VectorGeometryToolPlaneNormal._get_normal_vector_metadata)

    _get_reference_vector_metadata = { "offset" : _get_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(VectorGeometryToolPlaneNormal._metadata, VectorGeometryToolPlaneNormal._get_reference_vector_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(VectorGeometryToolPlaneNormal._metadata, VectorGeometryToolPlaneNormal._get_reference_point_metadata)

    _property_names[normal_vector] = "normal_vector"
    _property_names[reference_vector] = "reference_vector"
    _property_names[reference_point] = "reference_point"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneNormal."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneNormal)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneNormal, [VectorGeometryToolPlaneNormal, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5056270710623515037, 7829687135599012744), VectorGeometryToolPlaneNormal)
agcls.AgTypeNameMap["VectorGeometryToolPlaneNormal"] = VectorGeometryToolPlaneNormal

class VectorGeometryToolPlaneQuadrant(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A plane based on a selected Quadrant of a reference system."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_system_method_offset = 1
    _get_quadrant_method_offset = 2
    _set_quadrant_method_offset = 3
    _metadata = {
        "iid_data" : (4933086119360190640, 8795220663760332954),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneQuadrant)
    
    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(VectorGeometryToolPlaneQuadrant._metadata, VectorGeometryToolPlaneQuadrant._get_reference_system_metadata)

    _get_quadrant_metadata = { "offset" : _get_quadrant_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_QUADRANT_TYPE),) }
    @property
    def quadrant(self) -> "CRDN_QUADRANT_TYPE":
        """Specify a quadrant."""
        return self._intf.get_property(VectorGeometryToolPlaneQuadrant._metadata, VectorGeometryToolPlaneQuadrant._get_quadrant_metadata)

    _set_quadrant_metadata = { "offset" : _set_quadrant_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_QUADRANT_TYPE),) }
    @quadrant.setter
    def quadrant(self, quadrant:"CRDN_QUADRANT_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolPlaneQuadrant._metadata, VectorGeometryToolPlaneQuadrant._set_quadrant_metadata, quadrant)

    _property_names[reference_system] = "reference_system"
    _property_names[quadrant] = "quadrant"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneQuadrant."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneQuadrant)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneQuadrant, [VectorGeometryToolPlaneQuadrant, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5733687016289259105, 17528777649977896622), VectorGeometryToolPlaneQuadrant)
agcls.AgTypeNameMap["VectorGeometryToolPlaneQuadrant"] = VectorGeometryToolPlaneQuadrant

class VectorGeometryToolPlaneTrajectory(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_point_method_offset = 1
    _get_reference_system_method_offset = 2
    _get_rotation_offset_method_offset = 3
    _set_rotation_offset_method_offset = 4
    _metadata = {
        "iid_data" : (5529355900142766113, 13753958645856205187),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneTrajectory)
    
    _get_point_metadata = { "offset" : _get_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(VectorGeometryToolPlaneTrajectory._metadata, VectorGeometryToolPlaneTrajectory._get_point_metadata)

    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(VectorGeometryToolPlaneTrajectory._metadata, VectorGeometryToolPlaneTrajectory._get_reference_system_metadata)

    _get_rotation_offset_metadata = { "offset" : _get_rotation_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def rotation_offset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        return self._intf.get_property(VectorGeometryToolPlaneTrajectory._metadata, VectorGeometryToolPlaneTrajectory._get_rotation_offset_metadata)

    _set_rotation_offset_metadata = { "offset" : _set_rotation_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @rotation_offset.setter
    def rotation_offset(self, rotationOffset:float) -> None:
        return self._intf.set_property(VectorGeometryToolPlaneTrajectory._metadata, VectorGeometryToolPlaneTrajectory._set_rotation_offset_metadata, rotationOffset)

    _property_names[point] = "point"
    _property_names[reference_system] = "reference_system"
    _property_names[rotation_offset] = "rotation_offset"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneTrajectory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneTrajectory)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneTrajectory, [VectorGeometryToolPlaneTrajectory, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5238081677499142009, 8579850293282649519), VectorGeometryToolPlaneTrajectory)
agcls.AgTypeNameMap["VectorGeometryToolPlaneTrajectory"] = VectorGeometryToolPlaneTrajectory

class VectorGeometryToolPlaneTriad(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A Plane containing points A, B and ReferencePont with the first axis aligned with the direction from the ReferencePoint to point A and the second axis toward the direction from the ReferencePoint to point B."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_point_a_method_offset = 1
    _get_point_b_method_offset = 2
    _get_reference_point_method_offset = 3
    _get_rotation_offset_method_offset = 4
    _set_rotation_offset_method_offset = 5
    _metadata = {
        "iid_data" : (5649803850081976515, 15920961542924307585),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneTriad)
    
    _get_point_a_metadata = { "offset" : _get_point_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point_a(self) -> "VectorGeometryToolPointRefTo":
        """Specify a point A."""
        return self._intf.get_property(VectorGeometryToolPlaneTriad._metadata, VectorGeometryToolPlaneTriad._get_point_a_metadata)

    _get_point_b_metadata = { "offset" : _get_point_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point_b(self) -> "VectorGeometryToolPointRefTo":
        """Specify a point B."""
        return self._intf.get_property(VectorGeometryToolPlaneTriad._metadata, VectorGeometryToolPlaneTriad._get_point_b_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(VectorGeometryToolPlaneTriad._metadata, VectorGeometryToolPlaneTriad._get_reference_point_metadata)

    _get_rotation_offset_metadata = { "offset" : _get_rotation_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def rotation_offset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        return self._intf.get_property(VectorGeometryToolPlaneTriad._metadata, VectorGeometryToolPlaneTriad._get_rotation_offset_metadata)

    _set_rotation_offset_metadata = { "offset" : _set_rotation_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @rotation_offset.setter
    def rotation_offset(self, rotationOffset:float) -> None:
        return self._intf.set_property(VectorGeometryToolPlaneTriad._metadata, VectorGeometryToolPlaneTriad._set_rotation_offset_metadata, rotationOffset)

    _property_names[point_a] = "point_a"
    _property_names[point_b] = "point_b"
    _property_names[reference_point] = "reference_point"
    _property_names[rotation_offset] = "rotation_offset"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneTriad."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneTriad)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneTriad, [VectorGeometryToolPlaneTriad, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5574538283155536192, 17633244628996092321), VectorGeometryToolPlaneTriad)
agcls.AgTypeNameMap["VectorGeometryToolPlaneTriad"] = VectorGeometryToolPlaneTriad

class VectorGeometryToolPlaneTwoVector(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A plane passing through point and containing two given vectors."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_vector_method_offset = 1
    _get_vector2_method_offset = 2
    _get_reference_point_method_offset = 3
    _metadata = {
        "iid_data" : (5281608343756431856, 15763435674294787213),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneTwoVector)
    
    _get_reference_vector_metadata = { "offset" : _get_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(VectorGeometryToolPlaneTwoVector._metadata, VectorGeometryToolPlaneTwoVector._get_reference_vector_metadata)

    _get_vector2_metadata = { "offset" : _get_vector2_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector2(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a Normal vector."""
        return self._intf.get_property(VectorGeometryToolPlaneTwoVector._metadata, VectorGeometryToolPlaneTwoVector._get_vector2_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(VectorGeometryToolPlaneTwoVector._metadata, VectorGeometryToolPlaneTwoVector._get_reference_point_metadata)

    _property_names[reference_vector] = "reference_vector"
    _property_names[vector2] = "vector2"
    _property_names[reference_point] = "reference_point"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneTwoVector."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneTwoVector)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneTwoVector, [VectorGeometryToolPlaneTwoVector, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5259565249100914298, 10449004369849458077), VectorGeometryToolPlaneTwoVector)
agcls.AgTypeNameMap["VectorGeometryToolPlaneTwoVector"] = VectorGeometryToolPlaneTwoVector

class VectorGeometryToolPointBPlane(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """B-Plane point using the selected target body."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_target_body_method_offset = 1
    _get_trajectory_method_offset = 2
    _get_point_type_method_offset = 3
    _set_point_type_method_offset = 4
    _get_direction_method_offset = 5
    _set_direction_method_offset = 6
    _metadata = {
        "iid_data" : (5549652071222573439, 12634532755935206801),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointBPlane)
    
    _get_target_body_metadata = { "offset" : _get_target_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def target_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a target central body."""
        return self._intf.get_property(VectorGeometryToolPointBPlane._metadata, VectorGeometryToolPointBPlane._get_target_body_metadata)

    _get_trajectory_metadata = { "offset" : _get_trajectory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def trajectory(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(VectorGeometryToolPointBPlane._metadata, VectorGeometryToolPointBPlane._get_trajectory_metadata)

    _get_point_type_metadata = { "offset" : _get_point_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE),) }
    @property
    def point_type(self) -> "VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE":
        """Specify a point type."""
        return self._intf.get_property(VectorGeometryToolPointBPlane._metadata, VectorGeometryToolPointBPlane._get_point_type_metadata)

    _set_point_type_metadata = { "offset" : _set_point_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE),) }
    @point_type.setter
    def point_type(self, pointType:"VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolPointBPlane._metadata, VectorGeometryToolPointBPlane._set_point_type_metadata, pointType)

    _get_direction_metadata = { "offset" : _get_direction_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIRECTION_TYPE),) }
    @property
    def direction(self) -> "CRDN_DIRECTION_TYPE":
        """Specify a direction (incoming or outgoing)."""
        return self._intf.get_property(VectorGeometryToolPointBPlane._metadata, VectorGeometryToolPointBPlane._get_direction_metadata)

    _set_direction_metadata = { "offset" : _set_direction_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIRECTION_TYPE),) }
    @direction.setter
    def direction(self, direction:"CRDN_DIRECTION_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolPointBPlane._metadata, VectorGeometryToolPointBPlane._set_direction_metadata, direction)

    _property_names[target_body] = "target_body"
    _property_names[trajectory] = "trajectory"
    _property_names[point_type] = "point_type"
    _property_names[direction] = "direction"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointBPlane."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointBPlane)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointBPlane, [VectorGeometryToolPointBPlane, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5174217959427746283, 8080120297144408971), VectorGeometryToolPointBPlane)
agcls.AgTypeNameMap["VectorGeometryToolPointBPlane"] = VectorGeometryToolPointBPlane

class VectorGeometryToolPointFile(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Point specified by data from a file."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filename_method_offset = 1
    _set_filename_method_offset = 2
    _metadata = {
        "iid_data" : (4809037603532842876, 17498737964067706761),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointFile)
    
    _get_filename_metadata = { "offset" : _get_filename_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        return self._intf.get_property(VectorGeometryToolPointFile._metadata, VectorGeometryToolPointFile._get_filename_metadata)

    _set_filename_metadata = { "offset" : _set_filename_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(VectorGeometryToolPointFile._metadata, VectorGeometryToolPointFile._set_filename_metadata, filename)

    _property_names[filename] = "filename"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointFile."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointFile)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointFile, [VectorGeometryToolPointFile, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5372805118883383591, 8272625305257767061), VectorGeometryToolPointFile)
agcls.AgTypeNameMap["VectorGeometryToolPointFile"] = VectorGeometryToolPointFile

class VectorGeometryToolPointFixedInSystem(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Point fixed in a reference coordinate system using the selected coordinate type."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_method_offset = 1
    _get_fixed_point_method_offset = 2
    _metadata = {
        "iid_data" : (5663910966529630382, 8421606499748928414),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointFixedInSystem)
    
    _get_reference_metadata = { "offset" : _get_reference_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(VectorGeometryToolPointFixedInSystem._metadata, VectorGeometryToolPointFixedInSystem._get_reference_metadata)

    _get_fixed_point_metadata = { "offset" : _get_fixed_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def fixed_point(self) -> "IPosition":
        """Specify the point's position. The position is relative with respect to the specified reference system."""
        return self._intf.get_property(VectorGeometryToolPointFixedInSystem._metadata, VectorGeometryToolPointFixedInSystem._get_fixed_point_metadata)

    _property_names[reference] = "reference"
    _property_names[fixed_point] = "fixed_point"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointFixedInSystem."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointFixedInSystem)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointFixedInSystem, [VectorGeometryToolPointFixedInSystem, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4930325908174212614, 8676034700317006526), VectorGeometryToolPointFixedInSystem)
agcls.AgTypeNameMap["VectorGeometryToolPointFixedInSystem"] = VectorGeometryToolPointFixedInSystem

class VectorGeometryToolPointGrazing(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _get_direction_vector_method_offset = 3
    _get_altitude_method_offset = 4
    _set_altitude_method_offset = 5
    _metadata = {
        "iid_data" : (5012527720511243134, 16225700843195084963),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointGrazing)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolPointGrazing._metadata, VectorGeometryToolPointGrazing._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        return self._intf.get_property(VectorGeometryToolPointGrazing._metadata, VectorGeometryToolPointGrazing._get_reference_point_metadata)

    _get_direction_vector_metadata = { "offset" : _get_direction_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def direction_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a direction vector to be used in conjunction with the position vector from the selected central body to the reference point to define a plane in which the line will lie."""
        return self._intf.get_property(VectorGeometryToolPointGrazing._metadata, VectorGeometryToolPointGrazing._get_direction_vector_metadata)

    _get_altitude_metadata = { "offset" : _get_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude(self) -> float:
        """The point of closest approach to the central body surface occurs at the specified altitude."""
        return self._intf.get_property(VectorGeometryToolPointGrazing._metadata, VectorGeometryToolPointGrazing._get_altitude_metadata)

    _set_altitude_metadata = { "offset" : _set_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude.setter
    def altitude(self, altitude:float) -> None:
        return self._intf.set_property(VectorGeometryToolPointGrazing._metadata, VectorGeometryToolPointGrazing._set_altitude_metadata, altitude)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[direction_vector] = "direction_vector"
    _property_names[altitude] = "altitude"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointGrazing."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointGrazing)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointGrazing, [VectorGeometryToolPointGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4873095929191246164, 17861236567847545995), VectorGeometryToolPointGrazing)
agcls.AgTypeNameMap["VectorGeometryToolPointGrazing"] = VectorGeometryToolPointGrazing

class VectorGeometryToolPointGlint(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Point on central body surface that reflects from source to observer."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_source_point_method_offset = 2
    _get_observer_point_method_offset = 3
    _metadata = {
        "iid_data" : (4807494688843401545, 7891160833855003008),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointGlint)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolPointGlint._metadata, VectorGeometryToolPointGlint._get_central_body_metadata)

    _get_source_point_metadata = { "offset" : _get_source_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a source point."""
        return self._intf.get_property(VectorGeometryToolPointGlint._metadata, VectorGeometryToolPointGlint._get_source_point_metadata)

    _get_observer_point_metadata = { "offset" : _get_observer_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def observer_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify an observer point."""
        return self._intf.get_property(VectorGeometryToolPointGlint._metadata, VectorGeometryToolPointGlint._get_observer_point_metadata)

    _property_names[central_body] = "central_body"
    _property_names[source_point] = "source_point"
    _property_names[observer_point] = "observer_point"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointGlint."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointGlint)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointGlint, [VectorGeometryToolPointGlint, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5016182750180824403, 8007295032329350291), VectorGeometryToolPointGlint)
agcls.AgTypeNameMap["VectorGeometryToolPointGlint"] = VectorGeometryToolPointGlint

class VectorGeometryToolPointCovarianceGrazing(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_point_method_offset = 1
    _get_direction_vector_method_offset = 2
    _get_target_name_method_offset = 3
    _set_target_name_method_offset = 4
    _get_distance_method_offset = 5
    _set_distance_method_offset = 6
    _get_probability_method_offset = 7
    _set_probability_method_offset = 8
    _get_scale_method_offset = 9
    _set_scale_method_offset = 10
    _get_use_probability_method_offset = 11
    _set_use_probability_method_offset = 12
    _metadata = {
        "iid_data" : (5091732626748640146, 4436454314855977661),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointCovarianceGrazing)
    
    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        return self._intf.get_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._get_reference_point_metadata)

    _get_direction_vector_metadata = { "offset" : _get_direction_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def direction_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a direction vector to be used in conjunction with the displacement vector from the selected target object to the reference point to define a plane in which the line will lie."""
        return self._intf.get_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._get_direction_vector_metadata)

    _get_target_name_metadata = { "offset" : _get_target_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def target_name(self) -> str:
        """Specify a target object about which the covariance ellipsoid is centered."""
        return self._intf.get_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._get_target_name_metadata)

    _set_target_name_metadata = { "offset" : _set_target_name_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @target_name.setter
    def target_name(self, targetName:str) -> None:
        return self._intf.set_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._set_target_name_metadata, targetName)

    _get_distance_metadata = { "offset" : _get_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def distance(self) -> float:
        """The point of closest approach to the covariance ellipsoid surface occurs at the specified distance."""
        return self._intf.get_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._get_distance_metadata)

    _set_distance_metadata = { "offset" : _set_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @distance.setter
    def distance(self, distance:float) -> None:
        return self._intf.set_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._set_distance_metadata, distance)

    _get_probability_metadata = { "offset" : _get_probability_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def probability(self) -> float:
        """Specify a probability that the true position is inside the ellipsoid boundary."""
        return self._intf.get_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._get_probability_metadata)

    _set_probability_metadata = { "offset" : _set_probability_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @probability.setter
    def probability(self, probability:float) -> None:
        return self._intf.set_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._set_probability_metadata, probability)

    _get_scale_metadata = { "offset" : _get_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale(self) -> float:
        """Specify a scale factor which is applied to the one sigma ellipsoid."""
        return self._intf.get_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._get_scale_metadata)

    _set_scale_metadata = { "offset" : _set_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale.setter
    def scale(self, scale:float) -> None:
        return self._intf.set_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._set_scale_metadata, scale)

    _get_use_probability_metadata = { "offset" : _get_use_probability_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_probability(self) -> bool:
        """A flag controlling whether to use probability or scale factor."""
        return self._intf.get_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._get_use_probability_metadata)

    _set_use_probability_metadata = { "offset" : _set_use_probability_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_probability.setter
    def use_probability(self, useProbability:bool) -> None:
        return self._intf.set_property(VectorGeometryToolPointCovarianceGrazing._metadata, VectorGeometryToolPointCovarianceGrazing._set_use_probability_metadata, useProbability)

    _property_names[reference_point] = "reference_point"
    _property_names[direction_vector] = "direction_vector"
    _property_names[target_name] = "target_name"
    _property_names[distance] = "distance"
    _property_names[probability] = "probability"
    _property_names[scale] = "scale"
    _property_names[use_probability] = "use_probability"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointCovarianceGrazing."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointCovarianceGrazing)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCovarianceGrazing, [VectorGeometryToolPointCovarianceGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5112836196461516807, 2313902703372365995), VectorGeometryToolPointCovarianceGrazing)
agcls.AgTypeNameMap["VectorGeometryToolPointCovarianceGrazing"] = VectorGeometryToolPointCovarianceGrazing

class VectorGeometryToolPointPlaneIntersection(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Point on a plane located along a given direction looking from a given origin."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_direction_vector_method_offset = 1
    _get_reference_plane_method_offset = 2
    _get_origin_point_method_offset = 3
    _metadata = {
        "iid_data" : (4894427207736479321, 12949805093403104665),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointPlaneIntersection)
    
    _get_direction_vector_metadata = { "offset" : _get_direction_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def direction_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a direction vector."""
        return self._intf.get_property(VectorGeometryToolPointPlaneIntersection._metadata, VectorGeometryToolPointPlaneIntersection._get_direction_vector_metadata)

    _get_reference_plane_metadata = { "offset" : _get_reference_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(VectorGeometryToolPointPlaneIntersection._metadata, VectorGeometryToolPointPlaneIntersection._get_reference_plane_metadata)

    _get_origin_point_metadata = { "offset" : _get_origin_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def origin_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify the origin point."""
        return self._intf.get_property(VectorGeometryToolPointPlaneIntersection._metadata, VectorGeometryToolPointPlaneIntersection._get_origin_point_metadata)

    _property_names[direction_vector] = "direction_vector"
    _property_names[reference_plane] = "reference_plane"
    _property_names[origin_point] = "origin_point"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointPlaneIntersection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointPlaneIntersection)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointPlaneIntersection, [VectorGeometryToolPointPlaneIntersection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5461437594446824900, 7840863517079307695), VectorGeometryToolPointPlaneIntersection)
agcls.AgTypeNameMap["VectorGeometryToolPointPlaneIntersection"] = VectorGeometryToolPointPlaneIntersection

class VectorGeometryToolPointOnSurface(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """The detic subpoint of the reference point as projected onto the central body."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _get_reference_shape_method_offset = 3
    _set_reference_shape_method_offset = 4
    _get_surface_type_method_offset = 5
    _set_surface_type_method_offset = 6
    _metadata = {
        "iid_data" : (5076325792578851871, 4433532405534888869),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointOnSurface)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolPointOnSurface._metadata, VectorGeometryToolPointOnSurface._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(VectorGeometryToolPointOnSurface._metadata, VectorGeometryToolPointOnSurface._get_reference_point_metadata)

    _get_reference_shape_metadata = { "offset" : _get_reference_shape_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @property
    def reference_shape(self) -> "CRDN_REFERENCE_SHAPE_TYPE":
        """Specify a reference shape."""
        return self._intf.get_property(VectorGeometryToolPointOnSurface._metadata, VectorGeometryToolPointOnSurface._get_reference_shape_metadata)

    _set_reference_shape_metadata = { "offset" : _set_reference_shape_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @reference_shape.setter
    def reference_shape(self, referenceShape:"CRDN_REFERENCE_SHAPE_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolPointOnSurface._metadata, VectorGeometryToolPointOnSurface._set_reference_shape_metadata, referenceShape)

    _get_surface_type_metadata = { "offset" : _get_surface_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SURFACE_TYPE),) }
    @property
    def surface_type(self) -> "CRDN_SURFACE_TYPE":
        """Specify a surface type."""
        return self._intf.get_property(VectorGeometryToolPointOnSurface._metadata, VectorGeometryToolPointOnSurface._get_surface_type_metadata)

    _set_surface_type_metadata = { "offset" : _set_surface_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SURFACE_TYPE),) }
    @surface_type.setter
    def surface_type(self, surfaceType:"CRDN_SURFACE_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolPointOnSurface._metadata, VectorGeometryToolPointOnSurface._set_surface_type_metadata, surfaceType)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[reference_shape] = "reference_shape"
    _property_names[surface_type] = "surface_type"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointOnSurface."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointOnSurface)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointOnSurface, [VectorGeometryToolPointOnSurface, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5194814587264618449, 6271131256489865090), VectorGeometryToolPointOnSurface)
agcls.AgTypeNameMap["VectorGeometryToolPointOnSurface"] = VectorGeometryToolPointOnSurface

class VectorGeometryToolPointModelAttach(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_pointable_element_name_method_offset = 1
    _set_pointable_element_name_method_offset = 2
    _get_use_scale_method_offset = 3
    _set_use_scale_method_offset = 4
    _metadata = {
        "iid_data" : (4969317928494912584, 2239240105920673212),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointModelAttach)
    
    _get_pointable_element_name_metadata = { "offset" : _get_pointable_element_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def pointable_element_name(self) -> str:
        """Specify a model attachment point."""
        return self._intf.get_property(VectorGeometryToolPointModelAttach._metadata, VectorGeometryToolPointModelAttach._get_pointable_element_name_metadata)

    _set_pointable_element_name_metadata = { "offset" : _set_pointable_element_name_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @pointable_element_name.setter
    def pointable_element_name(self, pointableElementName:str) -> None:
        return self._intf.set_property(VectorGeometryToolPointModelAttach._metadata, VectorGeometryToolPointModelAttach._set_pointable_element_name_metadata, pointableElementName)

    _get_use_scale_metadata = { "offset" : _get_use_scale_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_scale(self) -> bool:
        """Specify whether to use the model scale."""
        return self._intf.get_property(VectorGeometryToolPointModelAttach._metadata, VectorGeometryToolPointModelAttach._get_use_scale_metadata)

    _set_use_scale_metadata = { "offset" : _set_use_scale_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_scale.setter
    def use_scale(self, useScale:bool) -> None:
        return self._intf.set_property(VectorGeometryToolPointModelAttach._metadata, VectorGeometryToolPointModelAttach._set_use_scale_metadata, useScale)

    _property_names[pointable_element_name] = "pointable_element_name"
    _property_names[use_scale] = "use_scale"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointModelAttach."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointModelAttach)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointModelAttach, [VectorGeometryToolPointModelAttach, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5148449423463122454, 9925486399943562398), VectorGeometryToolPointModelAttach)
agcls.AgTypeNameMap["VectorGeometryToolPointModelAttach"] = VectorGeometryToolPointModelAttach

class VectorGeometryToolPointSatelliteCollectionEntry(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_entry_name_method_offset = 1
    _set_entry_name_method_offset = 2
    _metadata = {
        "iid_data" : (5654158336124113307, 752486724811347121),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointSatelliteCollectionEntry)
    
    _get_entry_name_metadata = { "offset" : _get_entry_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def entry_name(self) -> str:
        """Specify a satellite collection entry name."""
        return self._intf.get_property(VectorGeometryToolPointSatelliteCollectionEntry._metadata, VectorGeometryToolPointSatelliteCollectionEntry._get_entry_name_metadata)

    _set_entry_name_metadata = { "offset" : _set_entry_name_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @entry_name.setter
    def entry_name(self, entryName:str) -> None:
        return self._intf.set_property(VectorGeometryToolPointSatelliteCollectionEntry._metadata, VectorGeometryToolPointSatelliteCollectionEntry._set_entry_name_metadata, entryName)

    _property_names[entry_name] = "entry_name"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointSatelliteCollectionEntry."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointSatelliteCollectionEntry)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointSatelliteCollectionEntry, [VectorGeometryToolPointSatelliteCollectionEntry, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5612905802720005101, 1472722314735659699), VectorGeometryToolPointSatelliteCollectionEntry)
agcls.AgTypeNameMap["VectorGeometryToolPointSatelliteCollectionEntry"] = VectorGeometryToolPointSatelliteCollectionEntry

class VectorGeometryToolPointPlaneProjection(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_source_point_method_offset = 1
    _get_reference_plane_method_offset = 2
    _metadata = {
        "iid_data" : (4927441133230225106, 13722760528613846674),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointPlaneProjection)
    
    _get_source_point_metadata = { "offset" : _get_source_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a source point."""
        return self._intf.get_property(VectorGeometryToolPointPlaneProjection._metadata, VectorGeometryToolPointPlaneProjection._get_source_point_metadata)

    _get_reference_plane_metadata = { "offset" : _get_reference_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(VectorGeometryToolPointPlaneProjection._metadata, VectorGeometryToolPointPlaneProjection._get_reference_plane_metadata)

    _property_names[source_point] = "source_point"
    _property_names[reference_plane] = "reference_plane"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointPlaneProjection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointPlaneProjection)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointPlaneProjection, [VectorGeometryToolPointPlaneProjection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4825084289371647385, 4219695295586287035), VectorGeometryToolPointPlaneProjection)
agcls.AgTypeNameMap["VectorGeometryToolPointPlaneProjection"] = VectorGeometryToolPointPlaneProjection

class VectorGeometryToolPointLagrangeLibration(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_point_type_method_offset = 2
    _set_point_type_method_offset = 3
    _get_secondary_central_bodies_method_offset = 4
    _metadata = {
        "iid_data" : (5711160304298990704, 2510698324538832526),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointLagrangeLibration)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolPointLagrangeLibration._metadata, VectorGeometryToolPointLagrangeLibration._get_central_body_metadata)

    _get_point_type_metadata = { "offset" : _get_point_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @property
    def point_type(self) -> "CRDN_LAGRANGE_LIBRATION_POINT_TYPE":
        """Specify a lagrange point (L1, L2, etc.)."""
        return self._intf.get_property(VectorGeometryToolPointLagrangeLibration._metadata, VectorGeometryToolPointLagrangeLibration._get_point_type_metadata)

    _set_point_type_metadata = { "offset" : _set_point_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @point_type.setter
    def point_type(self, pointType:"CRDN_LAGRANGE_LIBRATION_POINT_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolPointLagrangeLibration._metadata, VectorGeometryToolPointLagrangeLibration._set_point_type_metadata, pointType)

    _get_secondary_central_bodies_metadata = { "offset" : _get_secondary_central_bodies_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def secondary_central_bodies(self) -> "AnalysisWorkbenchCentralBodyCollection":
        """Specify multiple secondary central bodies."""
        return self._intf.get_property(VectorGeometryToolPointLagrangeLibration._metadata, VectorGeometryToolPointLagrangeLibration._get_secondary_central_bodies_metadata)

    _property_names[central_body] = "central_body"
    _property_names[point_type] = "point_type"
    _property_names[secondary_central_bodies] = "secondary_central_bodies"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointLagrangeLibration."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointLagrangeLibration)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointLagrangeLibration, [VectorGeometryToolPointLagrangeLibration, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4926224797655292278, 9084591209309612973), VectorGeometryToolPointLagrangeLibration)
agcls.AgTypeNameMap["VectorGeometryToolPointLagrangeLibration"] = VectorGeometryToolPointLagrangeLibration

class VectorGeometryToolPointCommonTasks(SupportsDeleteCallback):
    """Provide methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_fixed_in_system_cartographic_method_offset = 1
    _create_fixed_in_system_cartesian_method_offset = 2
    _sample_method_offset = 3
    _metadata = {
        "iid_data" : (5304183914034086053, 11427369840103977859),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointCommonTasks)
    
    _create_fixed_in_system_cartographic_metadata = { "offset" : _create_fixed_in_system_cartographic_method_offset,
            "arg_types" : (agcom.PVOID, agcom.Variant, agcom.Variant, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.VariantArg, agmarshall.VariantArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_fixed_in_system_cartographic(self, referenceSystem:"IVectorGeometryToolSystem", latitude:typing.Any, longitude:typing.Any, altitude:float) -> "VectorGeometryToolPointFixedInSystem":
        """Create a non-persistent point fixed in a specified reference system."""
        return self._intf.invoke(VectorGeometryToolPointCommonTasks._metadata, VectorGeometryToolPointCommonTasks._create_fixed_in_system_cartographic_metadata, referenceSystem, latitude, longitude, altitude, OutArg())

    _create_fixed_in_system_cartesian_metadata = { "offset" : _create_fixed_in_system_cartesian_method_offset,
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_fixed_in_system_cartesian(self, referenceSystem:"IVectorGeometryToolSystem", x:float, y:float, z:float) -> "VectorGeometryToolPointFixedInSystem":
        """Create a non-persistent point fixed in a specified reference system."""
        return self._intf.invoke(VectorGeometryToolPointCommonTasks._metadata, VectorGeometryToolPointCommonTasks._create_fixed_in_system_cartesian_metadata, referenceSystem, x, y, z, OutArg())

    _sample_metadata = { "offset" : _sample_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def sample(self, point:"IVectorGeometryToolPoint", referenceSystem:"IVectorGeometryToolSystem", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "TimeToolPointSamplingResult":
        """Compute and returns tabulated positions and velocities of a point with respect to reference system using specified sampling parameters."""
        return self._intf.invoke(VectorGeometryToolPointCommonTasks._metadata, VectorGeometryToolPointCommonTasks._sample_metadata, point, referenceSystem, intervals, minStep, maxStep, targetRate, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointCommonTasks."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointCommonTasks)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCommonTasks, [VectorGeometryToolPointCommonTasks, ])

agcls.AgClassCatalog.add_catalog_entry((5070744430662018124, 11417400654641998503), VectorGeometryToolPointCommonTasks)
agcls.AgTypeNameMap["VectorGeometryToolPointCommonTasks"] = VectorGeometryToolPointCommonTasks

class VectorGeometryToolPointCentBodyIntersect(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint, SupportsDeleteCallback):
    """Point on central body surface along direction vector originating at source point."""

    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _set_central_body_method_offset = 2
    _get_reference_point_method_offset = 3
    _set_reference_point_method_offset = 4
    _get_direction_vector_method_offset = 5
    _set_direction_vector_method_offset = 6
    _get_intersection_surface_method_offset = 7
    _set_intersection_surface_method_offset = 8
    _get_altitude_method_offset = 9
    _set_altitude_method_offset = 10
    _get_use_range_constraint_method_offset = 11
    _set_use_range_constraint_method_offset = 12
    _get_minimum_range_method_offset = 13
    _set_minimum_range_method_offset = 14
    _get_maximum_range_method_offset = 15
    _set_maximum_range_method_offset = 16
    _get_use_minimum_range_method_offset = 17
    _set_use_minimum_range_method_offset = 18
    _get_use_maximum_range_method_offset = 19
    _set_use_maximum_range_method_offset = 20
    _set_range_method_offset = 21
    _get_allow_intersection_from_below_method_offset = 22
    _set_allow_intersection_from_below_method_offset = 23
    _metadata = {
        "iid_data" : (4948493263913194603, 4729147732375268017),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointCentBodyIntersect)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Central body."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_central_body_metadata, centralBody)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """A reference point. Can be any point from VGT."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_reference_point_metadata)

    _set_reference_point_metadata = { "offset" : _set_reference_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_reference_point_metadata, referencePoint)

    _get_direction_vector_metadata = { "offset" : _get_direction_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def direction_vector(self) -> "IVectorGeometryToolVector":
        """A direction vector. Can be any vector from VGT."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_direction_vector_metadata)

    _set_direction_vector_metadata = { "offset" : _set_direction_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @direction_vector.setter
    def direction_vector(self, directionVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_direction_vector_metadata, directionVector)

    _get_intersection_surface_metadata = { "offset" : _get_intersection_surface_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERSECTION_SURFACE),) }
    @property
    def intersection_surface(self) -> "CRDN_INTERSECTION_SURFACE":
        """An intersection surface."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_intersection_surface_metadata)

    _set_intersection_surface_metadata = { "offset" : _set_intersection_surface_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_INTERSECTION_SURFACE),) }
    @intersection_surface.setter
    def intersection_surface(self, intersectionSurface:"CRDN_INTERSECTION_SURFACE") -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_intersection_surface_metadata, intersectionSurface)

    _get_altitude_metadata = { "offset" : _get_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude(self) -> float:
        """An altitude."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_altitude_metadata)

    _set_altitude_metadata = { "offset" : _set_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude.setter
    def altitude(self, altitude:float) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_altitude_metadata, altitude)

    _get_use_range_constraint_metadata = { "offset" : _get_use_range_constraint_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_range_constraint(self) -> bool:
        """Whether to use range constraint."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_use_range_constraint_metadata)

    _set_use_range_constraint_metadata = { "offset" : _set_use_range_constraint_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_range_constraint.setter
    def use_range_constraint(self, useRangeConstraint:bool) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_use_range_constraint_metadata, useRangeConstraint)

    _get_minimum_range_metadata = { "offset" : _get_minimum_range_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_range(self) -> float:
        """A minimum range. An exception is thrown if the value exceeds the MaximumRange. Applicable only if the range constraint is not used."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_minimum_range_metadata)

    _set_minimum_range_metadata = { "offset" : _set_minimum_range_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_range.setter
    def minimum_range(self, minimumRange:float) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_minimum_range_metadata, minimumRange)

    _get_maximum_range_metadata = { "offset" : _get_maximum_range_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_range(self) -> float:
        """A maximum range. An exception is thrown if the value is less than the MinimumRange. Applicable only if the range constraint is not used."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_maximum_range_metadata)

    _set_maximum_range_metadata = { "offset" : _set_maximum_range_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_range.setter
    def maximum_range(self, maximumRange:float) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_maximum_range_metadata, maximumRange)

    _get_use_minimum_range_metadata = { "offset" : _get_use_minimum_range_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_minimum_range(self) -> bool:
        """Whether the minimum range is used. Applicable only if the range constraint is not used."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_use_minimum_range_metadata)

    _set_use_minimum_range_metadata = { "offset" : _set_use_minimum_range_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_minimum_range.setter
    def use_minimum_range(self, useMinimumRange:bool) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_use_minimum_range_metadata, useMinimumRange)

    _get_use_maximum_range_metadata = { "offset" : _get_use_maximum_range_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_maximum_range(self) -> bool:
        """Whether the maximum range is used. Applicable only if the range constraint is not used."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_use_maximum_range_metadata)

    _set_use_maximum_range_metadata = { "offset" : _set_use_maximum_range_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_maximum_range.setter
    def use_maximum_range(self, useMaximumRange:bool) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_use_maximum_range_metadata, useMaximumRange)

    _set_range_metadata = { "offset" : _set_range_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg,) }
    def set_range(self, minimum:float, maximum:float) -> None:
        """Set minimum and maximum range. An exception is thrown if Minimum exceeds Maximum. An exception is thrown if UseRangeConstraint is set to true. Applicable only if the range constraint is not used."""
        return self._intf.invoke(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_range_metadata, minimum, maximum)

    _get_allow_intersection_from_below_metadata = { "offset" : _get_allow_intersection_from_below_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def allow_intersection_from_below(self) -> bool:
        """Whether intersection is computed when reference point is inside the surface. Applicable when the surface is not defined by terrain."""
        return self._intf.get_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._get_allow_intersection_from_below_metadata)

    _set_allow_intersection_from_below_metadata = { "offset" : _set_allow_intersection_from_below_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @allow_intersection_from_below.setter
    def allow_intersection_from_below(self, allowIntersectionFromBelow:bool) -> None:
        return self._intf.set_property(VectorGeometryToolPointCentBodyIntersect._metadata, VectorGeometryToolPointCentBodyIntersect._set_allow_intersection_from_below_metadata, allowIntersectionFromBelow)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[direction_vector] = "direction_vector"
    _property_names[intersection_surface] = "intersection_surface"
    _property_names[altitude] = "altitude"
    _property_names[use_range_constraint] = "use_range_constraint"
    _property_names[minimum_range] = "minimum_range"
    _property_names[maximum_range] = "maximum_range"
    _property_names[use_minimum_range] = "use_minimum_range"
    _property_names[use_maximum_range] = "use_maximum_range"
    _property_names[allow_intersection_from_below] = "allow_intersection_from_below"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointCentBodyIntersect."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointCentBodyIntersect)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCentBodyIntersect, [VectorGeometryToolPointCentBodyIntersect, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry((5231912502645770216, 9486194056870701488), VectorGeometryToolPointCentBodyIntersect)
agcls.AgTypeNameMap["VectorGeometryToolPointCentBodyIntersect"] = VectorGeometryToolPointCentBodyIntersect

class VectorGeometryToolPointAtTimeInstant(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint, SupportsDeleteCallback):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_time_instant_method_offset = 1
    _set_reference_time_instant_method_offset = 2
    _get_source_point_method_offset = 3
    _set_source_point_method_offset = 4
    _get_reference_system_method_offset = 5
    _set_reference_system_method_offset = 6
    _metadata = {
        "iid_data" : (4692963829731128305, 15665731167175750805),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointAtTimeInstant)
    
    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(VectorGeometryToolPointAtTimeInstant._metadata, VectorGeometryToolPointAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(VectorGeometryToolPointAtTimeInstant._metadata, VectorGeometryToolPointAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_source_point_metadata = { "offset" : _get_source_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_point(self) -> "IVectorGeometryToolPoint":
        """A source point. Can be any VGT point."""
        return self._intf.get_property(VectorGeometryToolPointAtTimeInstant._metadata, VectorGeometryToolPointAtTimeInstant._get_source_point_metadata)

    _set_source_point_metadata = { "offset" : _set_source_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @source_point.setter
    def source_point(self, sourcePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(VectorGeometryToolPointAtTimeInstant._metadata, VectorGeometryToolPointAtTimeInstant._set_source_point_metadata, sourcePoint)

    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """A reference system. Can be any VGT system."""
        return self._intf.get_property(VectorGeometryToolPointAtTimeInstant._metadata, VectorGeometryToolPointAtTimeInstant._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(VectorGeometryToolPointAtTimeInstant._metadata, VectorGeometryToolPointAtTimeInstant._set_reference_system_metadata, referenceSystem)

    _property_names[reference_time_instant] = "reference_time_instant"
    _property_names[source_point] = "source_point"
    _property_names[reference_system] = "reference_system"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointAtTimeInstant."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointAtTimeInstant)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointAtTimeInstant, [VectorGeometryToolPointAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry((5033554046644602591, 15766838857592252346), VectorGeometryToolPointAtTimeInstant)
agcls.AgTypeNameMap["VectorGeometryToolPointAtTimeInstant"] = VectorGeometryToolPointAtTimeInstant

class VectorGeometryToolPointPlugin(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint, SupportsDeleteCallback):
    """A VGT point plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_prog_id_method_offset = 1
    _get_display_name_method_offset = 2
    _get_available_properties_method_offset = 3
    _reset_method_offset = 4
    _set_property_method_offset = 5
    _get_property_method_offset = 6
    _metadata = {
        "iid_data" : (4736322476288056248, 3154611226967789489),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointPlugin)
    
    _get_prog_id_metadata = { "offset" : _get_prog_id_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(VectorGeometryToolPointPlugin._metadata, VectorGeometryToolPointPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "offset" : _get_display_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def display_name(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(VectorGeometryToolPointPlugin._metadata, VectorGeometryToolPointPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "offset" : _get_available_properties_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(VectorGeometryToolPointPlugin._metadata, VectorGeometryToolPointPlugin._get_available_properties_metadata)

    _reset_metadata = { "offset" : _reset_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(VectorGeometryToolPointPlugin._metadata, VectorGeometryToolPointPlugin._reset_metadata, )

    _set_property_metadata = { "offset" : _set_property_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def set_property(self, name:str, value:str) -> None:
        """Set the plugin properties. This method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(VectorGeometryToolPointPlugin._metadata, VectorGeometryToolPointPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "offset" : _get_property_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def get_property(self, name:str) -> str:
        """Read a value of the specified plugin property. This method throws an exception if the property does not exist."""
        return self._intf.invoke(VectorGeometryToolPointPlugin._metadata, VectorGeometryToolPointPlugin._get_property_metadata, name, OutArg())

    _property_names[prog_id] = "prog_id"
    _property_names[display_name] = "display_name"
    _property_names[available_properties] = "available_properties"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointPlugin."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointPlugin)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointPlugin, [VectorGeometryToolPointPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry((5757596304647117876, 17401426131146318778), VectorGeometryToolPointPlugin)
agcls.AgTypeNameMap["VectorGeometryToolPointPlugin"] = VectorGeometryToolPointPlugin

class VectorGeometryToolPointCBFixedOffset(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint, SupportsDeleteCallback):
    """Point specified by fixed components with respect to central body."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _set_central_body_method_offset = 2
    _get_reference_shape_method_offset = 3
    _set_reference_shape_method_offset = 4
    _get_position_method_offset = 5
    _metadata = {
        "iid_data" : (4611805182153342992, 11947442291432870303),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointCBFixedOffset)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get the central body."""
        return self._intf.get_property(VectorGeometryToolPointCBFixedOffset._metadata, VectorGeometryToolPointCBFixedOffset._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(VectorGeometryToolPointCBFixedOffset._metadata, VectorGeometryToolPointCBFixedOffset._set_central_body_metadata, centralBody)

    _get_reference_shape_metadata = { "offset" : _get_reference_shape_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @property
    def reference_shape(self) -> "CRDN_REFERENCE_SHAPE_TYPE":
        """Choose the point height's reference. Available options are central body ellipsoid (WSG84), terrain or Mean Sea Level."""
        return self._intf.get_property(VectorGeometryToolPointCBFixedOffset._metadata, VectorGeometryToolPointCBFixedOffset._get_reference_shape_metadata)

    _set_reference_shape_metadata = { "offset" : _set_reference_shape_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @reference_shape.setter
    def reference_shape(self, referenceShape:"CRDN_REFERENCE_SHAPE_TYPE") -> None:
        return self._intf.set_property(VectorGeometryToolPointCBFixedOffset._metadata, VectorGeometryToolPointCBFixedOffset._set_reference_shape_metadata, referenceShape)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def position(self) -> "IPosition":
        """A position of the point fixed on the central body."""
        return self._intf.get_property(VectorGeometryToolPointCBFixedOffset._metadata, VectorGeometryToolPointCBFixedOffset._get_position_metadata)

    _property_names[central_body] = "central_body"
    _property_names[reference_shape] = "reference_shape"
    _property_names[position] = "position"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointCBFixedOffset."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointCBFixedOffset)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCBFixedOffset, [VectorGeometryToolPointCBFixedOffset, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry((5575906236718038446, 6573727919483783565), VectorGeometryToolPointCBFixedOffset)
agcls.AgTypeNameMap["VectorGeometryToolPointCBFixedOffset"] = VectorGeometryToolPointCBFixedOffset

class VectorGeometryToolSystemAssembled(IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A system assembled from an origin point and a set of reference axes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_origin_point_method_offset = 1
    _get_reference_axes_method_offset = 2
    _metadata = {
        "iid_data" : (5029707979930027416, 8598486438770545800),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolSystemAssembled)
    
    _get_origin_point_metadata = { "offset" : _get_origin_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def origin_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a point of origin."""
        return self._intf.get_property(VectorGeometryToolSystemAssembled._metadata, VectorGeometryToolSystemAssembled._get_origin_point_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolSystemAssembled._metadata, VectorGeometryToolSystemAssembled._get_reference_axes_metadata)

    _property_names[origin_point] = "origin_point"
    _property_names[reference_axes] = "reference_axes"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolSystemAssembled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolSystemAssembled)
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystem._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemAssembled, [VectorGeometryToolSystemAssembled, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5078526353961026737, 9169402548554558883), VectorGeometryToolSystemAssembled)
agcls.AgTypeNameMap["VectorGeometryToolSystemAssembled"] = VectorGeometryToolSystemAssembled

class VectorGeometryToolSystemOnSurface(IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_azimuth_angle_method_offset = 2
    _set_azimuth_angle_method_offset = 3
    _get_use_msl_method_offset = 4
    _set_use_msl_method_offset = 5
    _get_position_method_offset = 6
    _metadata = {
        "iid_data" : (5364665391471234614, 9385572869045227689),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolSystemOnSurface)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolSystemOnSurface._metadata, VectorGeometryToolSystemOnSurface._get_central_body_metadata)

    _get_azimuth_angle_metadata = { "offset" : _get_azimuth_angle_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def azimuth_angle(self) -> float:
        """An angle by which the topocentric axes is rotated."""
        return self._intf.get_property(VectorGeometryToolSystemOnSurface._metadata, VectorGeometryToolSystemOnSurface._get_azimuth_angle_metadata)

    _set_azimuth_angle_metadata = { "offset" : _set_azimuth_angle_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @azimuth_angle.setter
    def azimuth_angle(self, azimuthAngle:float) -> None:
        return self._intf.set_property(VectorGeometryToolSystemOnSurface._metadata, VectorGeometryToolSystemOnSurface._set_azimuth_angle_metadata, azimuthAngle)

    _get_use_msl_metadata = { "offset" : _get_use_msl_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_msl(self) -> bool:
        """Specify whether to use the Mean Sea Level as the reference shape."""
        return self._intf.get_property(VectorGeometryToolSystemOnSurface._metadata, VectorGeometryToolSystemOnSurface._get_use_msl_metadata)

    _set_use_msl_metadata = { "offset" : _set_use_msl_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_msl.setter
    def use_msl(self, useMSL:bool) -> None:
        return self._intf.set_property(VectorGeometryToolSystemOnSurface._metadata, VectorGeometryToolSystemOnSurface._set_use_msl_metadata, useMSL)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def position(self) -> "AnalysisWorkbenchLLAPosition":
        """Specify the position of the system's origin."""
        return self._intf.get_property(VectorGeometryToolSystemOnSurface._metadata, VectorGeometryToolSystemOnSurface._get_position_metadata)

    _property_names[central_body] = "central_body"
    _property_names[azimuth_angle] = "azimuth_angle"
    _property_names[use_msl] = "use_msl"
    _property_names[position] = "position"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolSystemOnSurface."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolSystemOnSurface)
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystem._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemOnSurface, [VectorGeometryToolSystemOnSurface, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4833388918947980281, 1384230461932870068), VectorGeometryToolSystemOnSurface)
agcls.AgTypeNameMap["VectorGeometryToolSystemOnSurface"] = VectorGeometryToolSystemOnSurface

class AnalysisWorkbenchLLAPosition(SupportsDeleteCallback):
    """A position represented by the Latitude, longtitude and Latitude."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_latitude_method_offset = 1
    _set_latitude_method_offset = 2
    _get_longitude_method_offset = 3
    _set_longitude_method_offset = 4
    _get_altitude_method_offset = 5
    _set_altitude_method_offset = 6
    _metadata = {
        "iid_data" : (5728291300314624810, 14010987516788309178),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchLLAPosition)
    
    _get_latitude_metadata = { "offset" : _get_latitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def latitude(self) -> float:
        """Specify a latitude angle."""
        return self._intf.get_property(AnalysisWorkbenchLLAPosition._metadata, AnalysisWorkbenchLLAPosition._get_latitude_metadata)

    _set_latitude_metadata = { "offset" : _set_latitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @latitude.setter
    def latitude(self, latitude:float) -> None:
        return self._intf.set_property(AnalysisWorkbenchLLAPosition._metadata, AnalysisWorkbenchLLAPosition._set_latitude_metadata, latitude)

    _get_longitude_metadata = { "offset" : _get_longitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def longitude(self) -> float:
        """Specify a longitude angle."""
        return self._intf.get_property(AnalysisWorkbenchLLAPosition._metadata, AnalysisWorkbenchLLAPosition._get_longitude_metadata)

    _set_longitude_metadata = { "offset" : _set_longitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @longitude.setter
    def longitude(self, longitude:float) -> None:
        return self._intf.set_property(AnalysisWorkbenchLLAPosition._metadata, AnalysisWorkbenchLLAPosition._set_longitude_metadata, longitude)

    _get_altitude_metadata = { "offset" : _get_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude(self) -> float:
        """Specify an altitude value."""
        return self._intf.get_property(AnalysisWorkbenchLLAPosition._metadata, AnalysisWorkbenchLLAPosition._get_altitude_metadata)

    _set_altitude_metadata = { "offset" : _set_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude.setter
    def altitude(self, altitude:float) -> None:
        return self._intf.set_property(AnalysisWorkbenchLLAPosition._metadata, AnalysisWorkbenchLLAPosition._set_altitude_metadata, altitude)

    _property_names[latitude] = "latitude"
    _property_names[longitude] = "longitude"
    _property_names[altitude] = "altitude"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchLLAPosition."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchLLAPosition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchLLAPosition, [AnalysisWorkbenchLLAPosition, ])

agcls.AgClassCatalog.add_catalog_entry((4898112692119023441, 4393568345042619304), AnalysisWorkbenchLLAPosition)
agcls.AgTypeNameMap["AnalysisWorkbenchLLAPosition"] = AnalysisWorkbenchLLAPosition

class VectorGeometryToolSystemCommonTasks(SupportsDeleteCallback):
    """Provide methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_east_north_up_cartographic_method_offset = 1
    _create_assembled_method_offset = 2
    _metadata = {
        "iid_data" : (5508899997142077058, 9407051909521800110),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolSystemCommonTasks)
    
    _create_east_north_up_cartographic_metadata = { "offset" : _create_east_north_up_cartographic_method_offset,
            "arg_types" : (agcom.Variant, agcom.Variant, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.VariantArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_east_north_up_cartographic(self, latitude:typing.Any, longitude:typing.Any, altitude:float) -> "VectorGeometryToolSystemAssembled":
        """Create a non-persistent East-North-Up (ENU) reference frame with the origin at the specified geodetic location."""
        return self._intf.invoke(VectorGeometryToolSystemCommonTasks._metadata, VectorGeometryToolSystemCommonTasks._create_east_north_up_cartographic_metadata, latitude, longitude, altitude, OutArg())

    _create_assembled_metadata = { "offset" : _create_assembled_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceOutArg,) }
    def create_assembled(self, originPoint:"IVectorGeometryToolPoint", referenceAxes:"IVectorGeometryToolAxes") -> "VectorGeometryToolSystemAssembled":
        """Create a non-persistent system component assembled from an origin point and a set of reference axes."""
        return self._intf.invoke(VectorGeometryToolSystemCommonTasks._metadata, VectorGeometryToolSystemCommonTasks._create_assembled_metadata, originPoint, referenceAxes, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolSystemCommonTasks."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolSystemCommonTasks)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemCommonTasks, [VectorGeometryToolSystemCommonTasks, ])

agcls.AgClassCatalog.add_catalog_entry((5585304109946744641, 4691437628496683701), VectorGeometryToolSystemCommonTasks)
agcls.AgTypeNameMap["VectorGeometryToolSystemCommonTasks"] = VectorGeometryToolSystemCommonTasks

class VectorGeometryToolVectorAngleRate(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_angle_method_offset = 1
    _get_differencing_time_step_method_offset = 2
    _set_differencing_time_step_method_offset = 3
    _metadata = {
        "iid_data" : (5597316415742021355, 2905315476766484131),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorAngleRate)
    
    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def angle(self) -> "VectorGeometryToolAngleRefTo":
        """Specify an angle. The angle vector will be perpendicular to the plane in which the angle is defined."""
        return self._intf.get_property(VectorGeometryToolVectorAngleRate._metadata, VectorGeometryToolVectorAngleRate._get_angle_metadata)

    _get_differencing_time_step_metadata = { "offset" : _get_differencing_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(VectorGeometryToolVectorAngleRate._metadata, VectorGeometryToolVectorAngleRate._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "offset" : _set_differencing_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorAngleRate._metadata, VectorGeometryToolVectorAngleRate._set_differencing_time_step_metadata, differencingTimeStep)

    _property_names[angle] = "angle"
    _property_names[differencing_time_step] = "differencing_time_step"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorAngleRate."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorAngleRate)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorAngleRate, [VectorGeometryToolVectorAngleRate, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4661945362119516281, 7374273867052019634), VectorGeometryToolVectorAngleRate)
agcls.AgTypeNameMap["VectorGeometryToolVectorAngleRate"] = VectorGeometryToolVectorAngleRate

class VectorGeometryToolVectorApoapsis(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_point_method_offset = 1
    _get_central_body_method_offset = 2
    _get_mean_element_type_method_offset = 3
    _set_mean_element_type_method_offset = 4
    _metadata = {
        "iid_data" : (5576331771676654674, 4033187042520018608),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorApoapsis)
    
    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(VectorGeometryToolVectorApoapsis._metadata, VectorGeometryToolVectorApoapsis._get_reference_point_metadata)

    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolVectorApoapsis._metadata, VectorGeometryToolVectorApoapsis._get_central_body_metadata)

    _get_mean_element_type_metadata = { "offset" : _get_mean_element_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(VectorGeometryToolVectorApoapsis._metadata, VectorGeometryToolVectorApoapsis._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "offset" : _set_mean_element_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(VectorGeometryToolVectorApoapsis._metadata, VectorGeometryToolVectorApoapsis._set_mean_element_type_metadata, meanElementType)

    _property_names[reference_point] = "reference_point"
    _property_names[central_body] = "central_body"
    _property_names[mean_element_type] = "mean_element_type"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorApoapsis."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorApoapsis)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorApoapsis, [VectorGeometryToolVectorApoapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4900243800521446284, 154039380244160657), VectorGeometryToolVectorApoapsis)
agcls.AgTypeNameMap["VectorGeometryToolVectorApoapsis"] = VectorGeometryToolVectorApoapsis

class VectorGeometryToolVectorFixedAtEpoch(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A vector based on another vector fixed at a specified epoch."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_epoch_method_offset = 1
    _set_epoch_method_offset = 2
    _get_source_vector_method_offset = 3
    _get_reference_axes_method_offset = 4
    _metadata = {
        "iid_data" : (4848916224173762568, 6757523323665043074),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorFixedAtEpoch)
    
    _get_epoch_metadata = { "offset" : _get_epoch_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def epoch(self) -> typing.Any:
        """Specify an epoch."""
        return self._intf.get_property(VectorGeometryToolVectorFixedAtEpoch._metadata, VectorGeometryToolVectorFixedAtEpoch._get_epoch_metadata)

    _set_epoch_metadata = { "offset" : _set_epoch_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(VectorGeometryToolVectorFixedAtEpoch._metadata, VectorGeometryToolVectorFixedAtEpoch._set_epoch_metadata, epoch)

    _get_source_vector_metadata = { "offset" : _get_source_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a source vector."""
        return self._intf.get_property(VectorGeometryToolVectorFixedAtEpoch._metadata, VectorGeometryToolVectorFixedAtEpoch._get_source_vector_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolVectorFixedAtEpoch._metadata, VectorGeometryToolVectorFixedAtEpoch._get_reference_axes_metadata)

    _property_names[epoch] = "epoch"
    _property_names[source_vector] = "source_vector"
    _property_names[reference_axes] = "reference_axes"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorFixedAtEpoch."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorFixedAtEpoch)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFixedAtEpoch, [VectorGeometryToolVectorFixedAtEpoch, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4676459523933582837, 2528162089752102555), VectorGeometryToolVectorFixedAtEpoch)
agcls.AgTypeNameMap["VectorGeometryToolVectorFixedAtEpoch"] = VectorGeometryToolVectorFixedAtEpoch

class VectorGeometryToolVectorAngularVelocity(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_axes_method_offset = 1
    _get_reference_axes_method_offset = 2
    _get_differencing_time_step_method_offset = 3
    _set_differencing_time_step_method_offset = 4
    _metadata = {
        "iid_data" : (5760985025826459721, 14553782751100665529),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorAngularVelocity)
    
    _get_axes_metadata = { "offset" : _get_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify the axes."""
        return self._intf.get_property(VectorGeometryToolVectorAngularVelocity._metadata, VectorGeometryToolVectorAngularVelocity._get_axes_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolVectorAngularVelocity._metadata, VectorGeometryToolVectorAngularVelocity._get_reference_axes_metadata)

    _get_differencing_time_step_metadata = { "offset" : _get_differencing_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(VectorGeometryToolVectorAngularVelocity._metadata, VectorGeometryToolVectorAngularVelocity._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "offset" : _set_differencing_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorAngularVelocity._metadata, VectorGeometryToolVectorAngularVelocity._set_differencing_time_step_metadata, differencingTimeStep)

    _property_names[axes] = "axes"
    _property_names[reference_axes] = "reference_axes"
    _property_names[differencing_time_step] = "differencing_time_step"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorAngularVelocity."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorAngularVelocity)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorAngularVelocity, [VectorGeometryToolVectorAngularVelocity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5373198340793861083, 1284675054128437125), VectorGeometryToolVectorAngularVelocity)
agcls.AgTypeNameMap["VectorGeometryToolVectorAngularVelocity"] = VectorGeometryToolVectorAngularVelocity

class VectorGeometryToolVectorConing(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_about_vector_method_offset = 1
    _get_reference_vector_method_offset = 2
    _get_start_clock_angle_method_offset = 3
    _set_start_clock_angle_method_offset = 4
    _get_stop_clock_angle_method_offset = 5
    _set_stop_clock_angle_method_offset = 6
    _get_start_epoch_method_offset = 7
    _set_start_epoch_method_offset = 8
    _get_clock_angle_rate_method_offset = 9
    _set_clock_angle_rate_method_offset = 10
    _get_mode_method_offset = 11
    _set_mode_method_offset = 12
    _metadata = {
        "iid_data" : (5709421970301581804, 11872479787623141790),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorConing)
    
    _get_about_vector_metadata = { "offset" : _get_about_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def about_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a vector around which the the reference vector is revolved."""
        return self._intf.get_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._get_about_vector_metadata)

    _get_reference_vector_metadata = { "offset" : _get_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._get_reference_vector_metadata)

    _get_start_clock_angle_metadata = { "offset" : _get_start_clock_angle_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def start_clock_angle(self) -> float:
        """Specify a start angle."""
        return self._intf.get_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._get_start_clock_angle_metadata)

    _set_start_clock_angle_metadata = { "offset" : _set_start_clock_angle_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @start_clock_angle.setter
    def start_clock_angle(self, startClockAngle:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._set_start_clock_angle_metadata, startClockAngle)

    _get_stop_clock_angle_metadata = { "offset" : _get_stop_clock_angle_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def stop_clock_angle(self) -> float:
        """Specify a stop angle."""
        return self._intf.get_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._get_stop_clock_angle_metadata)

    _set_stop_clock_angle_metadata = { "offset" : _set_stop_clock_angle_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @stop_clock_angle.setter
    def stop_clock_angle(self, stopClockAngle:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._set_stop_clock_angle_metadata, stopClockAngle)

    _get_start_epoch_metadata = { "offset" : _get_start_epoch_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def start_epoch(self) -> typing.Any:
        """Specify an epoch at which the coning vector is aligned with the reference vector."""
        return self._intf.get_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._get_start_epoch_metadata)

    _set_start_epoch_metadata = { "offset" : _set_start_epoch_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @start_epoch.setter
    def start_epoch(self, startEpoch:typing.Any) -> None:
        return self._intf.set_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._set_start_epoch_metadata, startEpoch)

    _get_clock_angle_rate_metadata = { "offset" : _get_clock_angle_rate_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def clock_angle_rate(self) -> float:
        """Specify a rotation rate."""
        return self._intf.get_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._get_clock_angle_rate_metadata)

    _set_clock_angle_rate_metadata = { "offset" : _set_clock_angle_rate_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @clock_angle_rate.setter
    def clock_angle_rate(self, clockAngleRate:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._set_clock_angle_rate_metadata, clockAngleRate)

    _get_mode_metadata = { "offset" : _get_mode_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SWEEP_MODE),) }
    @property
    def mode(self) -> "CRDN_SWEEP_MODE":
        """Specify either unidirectional or bidirectional mode."""
        return self._intf.get_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._get_mode_metadata)

    _set_mode_metadata = { "offset" : _set_mode_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SWEEP_MODE),) }
    @mode.setter
    def mode(self, mode:"CRDN_SWEEP_MODE") -> None:
        return self._intf.set_property(VectorGeometryToolVectorConing._metadata, VectorGeometryToolVectorConing._set_mode_metadata, mode)

    _property_names[about_vector] = "about_vector"
    _property_names[reference_vector] = "reference_vector"
    _property_names[start_clock_angle] = "start_clock_angle"
    _property_names[stop_clock_angle] = "stop_clock_angle"
    _property_names[start_epoch] = "start_epoch"
    _property_names[clock_angle_rate] = "clock_angle_rate"
    _property_names[mode] = "mode"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorConing."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorConing)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorConing, [VectorGeometryToolVectorConing, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4689903705630636422, 13286675890476868740), VectorGeometryToolVectorConing)
agcls.AgTypeNameMap["VectorGeometryToolVectorConing"] = VectorGeometryToolVectorConing

class VectorGeometryToolVectorCross(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """The vector cross product of two vectors."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_from_vector_method_offset = 1
    _get_to_vector_method_offset = 2
    _get_is_normalized_method_offset = 3
    _set_is_normalized_method_offset = 4
    _get_dimension_method_offset = 5
    _set_dimension_method_offset = 6
    _metadata = {
        "iid_data" : (5275257649457659428, 11860577519903670147),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorCross)
    
    _get_from_vector_metadata = { "offset" : _get_from_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def from_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify one of the two vectors which define the vector cross product."""
        return self._intf.get_property(VectorGeometryToolVectorCross._metadata, VectorGeometryToolVectorCross._get_from_vector_metadata)

    _get_to_vector_metadata = { "offset" : _get_to_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def to_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify the second of the two vectors which define the vector cross product."""
        return self._intf.get_property(VectorGeometryToolVectorCross._metadata, VectorGeometryToolVectorCross._get_to_vector_metadata)

    _get_is_normalized_metadata = { "offset" : _get_is_normalized_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_normalized(self) -> bool:
        """Whether to convert the cross product of two vectors to a unit vector."""
        return self._intf.get_property(VectorGeometryToolVectorCross._metadata, VectorGeometryToolVectorCross._get_is_normalized_metadata)

    _set_is_normalized_metadata = { "offset" : _set_is_normalized_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @is_normalized.setter
    def is_normalized(self, isNormalized:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorCross._metadata, VectorGeometryToolVectorCross._set_is_normalized_metadata, isNormalized)

    _get_dimension_metadata = { "offset" : _get_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def dimension(self) -> str:
        """Return a unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        return self._intf.get_property(VectorGeometryToolVectorCross._metadata, VectorGeometryToolVectorCross._get_dimension_metadata)

    _set_dimension_metadata = { "offset" : _set_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorCross._metadata, VectorGeometryToolVectorCross._set_dimension_metadata, dimension)

    _property_names[from_vector] = "from_vector"
    _property_names[to_vector] = "to_vector"
    _property_names[is_normalized] = "is_normalized"
    _property_names[dimension] = "dimension"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorCross."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorCross)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorCross, [VectorGeometryToolVectorCross, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5034551376650625975, 1225344703421792407), VectorGeometryToolVectorCross)
agcls.AgTypeNameMap["VectorGeometryToolVectorCross"] = VectorGeometryToolVectorCross

class VectorGeometryToolVectorCustomScript(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Customized vector components defined with respect to reference axes."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_axes_method_offset = 1
    _get_script_file_method_offset = 2
    _set_script_file_method_offset = 3
    _get_initialization_script_file_method_offset = 4
    _set_initialization_script_file_method_offset = 5
    _metadata = {
        "iid_data" : (5630758871882886244, 16194130094764419741),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorCustomScript)
    
    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolVectorCustomScript._metadata, VectorGeometryToolVectorCustomScript._get_reference_axes_metadata)

    _get_script_file_metadata = { "offset" : _get_script_file_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def script_file(self) -> str:
        """Specify a script file."""
        return self._intf.get_property(VectorGeometryToolVectorCustomScript._metadata, VectorGeometryToolVectorCustomScript._get_script_file_metadata)

    _set_script_file_metadata = { "offset" : _set_script_file_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @script_file.setter
    def script_file(self, scriptFile:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorCustomScript._metadata, VectorGeometryToolVectorCustomScript._set_script_file_metadata, scriptFile)

    _get_initialization_script_file_metadata = { "offset" : _get_initialization_script_file_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def initialization_script_file(self) -> str:
        """Specify an initialization script file (optional). The initialization script is run once, at the beginning of the calculation."""
        return self._intf.get_property(VectorGeometryToolVectorCustomScript._metadata, VectorGeometryToolVectorCustomScript._get_initialization_script_file_metadata)

    _set_initialization_script_file_metadata = { "offset" : _set_initialization_script_file_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @initialization_script_file.setter
    def initialization_script_file(self, initializationScriptFile:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorCustomScript._metadata, VectorGeometryToolVectorCustomScript._set_initialization_script_file_metadata, initializationScriptFile)

    _property_names[reference_axes] = "reference_axes"
    _property_names[script_file] = "script_file"
    _property_names[initialization_script_file] = "initialization_script_file"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorCustomScript."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorCustomScript)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorCustomScript, [VectorGeometryToolVectorCustomScript, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4728535357545307590, 16737740404794421951), VectorGeometryToolVectorCustomScript)
agcls.AgTypeNameMap["VectorGeometryToolVectorCustomScript"] = VectorGeometryToolVectorCustomScript

class VectorGeometryToolVectorDerivative(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A vector derivative of a vector computed with respect to specified axes."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_vector_method_offset = 1
    _get_reference_axes_method_offset = 2
    _get_differencing_time_step_method_offset = 3
    _set_differencing_time_step_method_offset = 4
    _get_force_use_of_numerical_differences_method_offset = 5
    _set_force_use_of_numerical_differences_method_offset = 6
    _metadata = {
        "iid_data" : (5530402949093608972, 14398790889031353009),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorDerivative)
    
    _get_vector_metadata = { "offset" : _get_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a base vector."""
        return self._intf.get_property(VectorGeometryToolVectorDerivative._metadata, VectorGeometryToolVectorDerivative._get_vector_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolVectorDerivative._metadata, VectorGeometryToolVectorDerivative._get_reference_axes_metadata)

    _get_differencing_time_step_metadata = { "offset" : _get_differencing_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(VectorGeometryToolVectorDerivative._metadata, VectorGeometryToolVectorDerivative._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "offset" : _set_differencing_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorDerivative._metadata, VectorGeometryToolVectorDerivative._set_differencing_time_step_metadata, differencingTimeStep)

    _get_force_use_of_numerical_differences_metadata = { "offset" : _get_force_use_of_numerical_differences_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def force_use_of_numerical_differences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        return self._intf.get_property(VectorGeometryToolVectorDerivative._metadata, VectorGeometryToolVectorDerivative._get_force_use_of_numerical_differences_metadata)

    _set_force_use_of_numerical_differences_metadata = { "offset" : _set_force_use_of_numerical_differences_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @force_use_of_numerical_differences.setter
    def force_use_of_numerical_differences(self, forceUseOfNumericalDifferences:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorDerivative._metadata, VectorGeometryToolVectorDerivative._set_force_use_of_numerical_differences_metadata, forceUseOfNumericalDifferences)

    _property_names[vector] = "vector"
    _property_names[reference_axes] = "reference_axes"
    _property_names[differencing_time_step] = "differencing_time_step"
    _property_names[force_use_of_numerical_differences] = "force_use_of_numerical_differences"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorDerivative."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorDerivative)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDerivative, [VectorGeometryToolVectorDerivative, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5309408879000341305, 12873274334918222470), VectorGeometryToolVectorDerivative)
agcls.AgTypeNameMap["VectorGeometryToolVectorDerivative"] = VectorGeometryToolVectorDerivative

class VectorGeometryToolVectorDisplacement(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Vector defined by its start and end points."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_origin_method_offset = 1
    _get_destination_method_offset = 2
    _get_apparent_method_offset = 3
    _set_apparent_method_offset = 4
    _get_ignore_aberration_method_offset = 5
    _set_ignore_aberration_method_offset = 6
    _get_signal_sense_method_offset = 7
    _set_signal_sense_method_offset = 8
    _get_reference_system_method_offset = 9
    _metadata = {
        "iid_data" : (5476956723820268905, 5996813961645053609),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorDisplacement)
    
    _get_origin_metadata = { "offset" : _get_origin_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def origin(self) -> "VectorGeometryToolPointRefTo":
        """Specify the vector's origin point."""
        return self._intf.get_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._get_origin_metadata)

    _get_destination_metadata = { "offset" : _get_destination_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def destination(self) -> "VectorGeometryToolPointRefTo":
        """Specify the vector's destination point."""
        return self._intf.get_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._get_destination_metadata)

    _get_apparent_metadata = { "offset" : _get_apparent_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def apparent(self) -> bool:
        """Control whether to take a light speed delay into account."""
        return self._intf.get_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._get_apparent_metadata)

    _set_apparent_metadata = { "offset" : _set_apparent_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @apparent.setter
    def apparent(self, apparent:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._set_apparent_metadata, apparent)

    _get_ignore_aberration_metadata = { "offset" : _get_ignore_aberration_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def ignore_aberration(self) -> bool:
        """Set to true if you do not want to calculate the aberration correction. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._get_ignore_aberration_metadata)

    _set_ignore_aberration_metadata = { "offset" : _set_ignore_aberration_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @ignore_aberration.setter
    def ignore_aberration(self, ignoreAberration:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._set_ignore_aberration_metadata, ignoreAberration)

    _get_signal_sense_metadata = { "offset" : _get_signal_sense_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """Specify a sense of signal transmission. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "offset" : _set_signal_sense_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._set_signal_sense_metadata, signalSense)

    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a frame in which the light time delay is computed. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(VectorGeometryToolVectorDisplacement._metadata, VectorGeometryToolVectorDisplacement._get_reference_system_metadata)

    _property_names[origin] = "origin"
    _property_names[destination] = "destination"
    _property_names[apparent] = "apparent"
    _property_names[ignore_aberration] = "ignore_aberration"
    _property_names[signal_sense] = "signal_sense"
    _property_names[reference_system] = "reference_system"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorDisplacement."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorDisplacement)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDisplacement, [VectorGeometryToolVectorDisplacement, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5117622138243308135, 15050542198214194335), VectorGeometryToolVectorDisplacement)
agcls.AgTypeNameMap["VectorGeometryToolVectorDisplacement"] = VectorGeometryToolVectorDisplacement

class VectorGeometryToolVectorTwoPlanesIntersection(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined along the intersection of two planes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_plane_a_method_offset = 1
    _get_plane_b_method_offset = 2
    _metadata = {
        "iid_data" : (5154489590938645061, 17953582977026772639),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorTwoPlanesIntersection)
    
    _get_plane_a_metadata = { "offset" : _get_plane_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def plane_a(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the first of the two planes which intersection defines the vector."""
        return self._intf.get_property(VectorGeometryToolVectorTwoPlanesIntersection._metadata, VectorGeometryToolVectorTwoPlanesIntersection._get_plane_a_metadata)

    _get_plane_b_metadata = { "offset" : _get_plane_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def plane_b(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the second of the two planes which intersection defines the vector."""
        return self._intf.get_property(VectorGeometryToolVectorTwoPlanesIntersection._metadata, VectorGeometryToolVectorTwoPlanesIntersection._get_plane_b_metadata)

    _property_names[plane_a] = "plane_a"
    _property_names[plane_b] = "plane_b"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorTwoPlanesIntersection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorTwoPlanesIntersection)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorTwoPlanesIntersection, [VectorGeometryToolVectorTwoPlanesIntersection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5484952021995115859, 5066214406894258350), VectorGeometryToolVectorTwoPlanesIntersection)
agcls.AgTypeNameMap["VectorGeometryToolVectorTwoPlanesIntersection"] = VectorGeometryToolVectorTwoPlanesIntersection

class VectorGeometryToolVectorModelAttach(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_pointable_element_name_method_offset = 1
    _set_pointable_element_name_method_offset = 2
    _metadata = {
        "iid_data" : (4701670409828626012, 1500555686229726852),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorModelAttach)
    
    _get_pointable_element_name_metadata = { "offset" : _get_pointable_element_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def pointable_element_name(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        return self._intf.get_property(VectorGeometryToolVectorModelAttach._metadata, VectorGeometryToolVectorModelAttach._get_pointable_element_name_metadata)

    _set_pointable_element_name_metadata = { "offset" : _set_pointable_element_name_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @pointable_element_name.setter
    def pointable_element_name(self, pointableElementName:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorModelAttach._metadata, VectorGeometryToolVectorModelAttach._set_pointable_element_name_metadata, pointableElementName)

    _property_names[pointable_element_name] = "pointable_element_name"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorModelAttach."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorModelAttach)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorModelAttach, [VectorGeometryToolVectorModelAttach, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5211444618584649400, 9648191457011466908), VectorGeometryToolVectorModelAttach)
agcls.AgTypeNameMap["VectorGeometryToolVectorModelAttach"] = VectorGeometryToolVectorModelAttach

class VectorGeometryToolVectorProjection(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A projection of a vector computed with respect to a reference plane."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_source_method_offset = 1
    _get_reference_plane_method_offset = 2
    _metadata = {
        "iid_data" : (4651278934469564705, 16548193310250725505),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorProjection)
    
    _get_source_metadata = { "offset" : _get_source_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a source vector."""
        return self._intf.get_property(VectorGeometryToolVectorProjection._metadata, VectorGeometryToolVectorProjection._get_source_metadata)

    _get_reference_plane_metadata = { "offset" : _get_reference_plane_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(VectorGeometryToolVectorProjection._metadata, VectorGeometryToolVectorProjection._get_reference_plane_metadata)

    _property_names[source] = "source"
    _property_names[reference_plane] = "reference_plane"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorProjection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorProjection)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorProjection, [VectorGeometryToolVectorProjection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5150896074625799242, 60409490020408760), VectorGeometryToolVectorProjection)
agcls.AgTypeNameMap["VectorGeometryToolVectorProjection"] = VectorGeometryToolVectorProjection

class VectorGeometryToolVectorScaled(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_vector_method_offset = 1
    _get_scale_method_offset = 2
    _set_scale_method_offset = 3
    _get_is_normalized_method_offset = 4
    _set_is_normalized_method_offset = 5
    _metadata = {
        "iid_data" : (4886994558078501166, 17758379833803953041),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorScaled)
    
    _get_reference_vector_metadata = { "offset" : _get_reference_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """A vector being scaled."""
        return self._intf.get_property(VectorGeometryToolVectorScaled._metadata, VectorGeometryToolVectorScaled._get_reference_vector_metadata)

    _get_scale_metadata = { "offset" : _get_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale(self) -> float:
        """A scaling multiple."""
        return self._intf.get_property(VectorGeometryToolVectorScaled._metadata, VectorGeometryToolVectorScaled._get_scale_metadata)

    _set_scale_metadata = { "offset" : _set_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale.setter
    def scale(self, scale:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScaled._metadata, VectorGeometryToolVectorScaled._set_scale_metadata, scale)

    _get_is_normalized_metadata = { "offset" : _get_is_normalized_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_normalized(self) -> bool:
        """Control whether to convert the reference vector to a unit vector before scalling."""
        return self._intf.get_property(VectorGeometryToolVectorScaled._metadata, VectorGeometryToolVectorScaled._get_is_normalized_metadata)

    _set_is_normalized_metadata = { "offset" : _set_is_normalized_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @is_normalized.setter
    def is_normalized(self, isNormalized:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScaled._metadata, VectorGeometryToolVectorScaled._set_is_normalized_metadata, isNormalized)

    _property_names[reference_vector] = "reference_vector"
    _property_names[scale] = "scale"
    _property_names[is_normalized] = "is_normalized"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorScaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorScaled)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorScaled, [VectorGeometryToolVectorScaled, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4858017423407189033, 9592990787974832285), VectorGeometryToolVectorScaled)
agcls.AgTypeNameMap["VectorGeometryToolVectorScaled"] = VectorGeometryToolVectorScaled

class VectorGeometryToolVectorEccentricity(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _get_mean_element_type_method_offset = 3
    _set_mean_element_type_method_offset = 4
    _metadata = {
        "iid_data" : (5025708763849433005, 12709075287380647325),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorEccentricity)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolVectorEccentricity._metadata, VectorGeometryToolVectorEccentricity._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(VectorGeometryToolVectorEccentricity._metadata, VectorGeometryToolVectorEccentricity._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "offset" : _get_mean_element_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(VectorGeometryToolVectorEccentricity._metadata, VectorGeometryToolVectorEccentricity._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "offset" : _set_mean_element_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(VectorGeometryToolVectorEccentricity._metadata, VectorGeometryToolVectorEccentricity._set_mean_element_type_metadata, meanElementType)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[mean_element_type] = "mean_element_type"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorEccentricity."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorEccentricity)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorEccentricity, [VectorGeometryToolVectorEccentricity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5150167353244342231, 587328373879496597), VectorGeometryToolVectorEccentricity)
agcls.AgTypeNameMap["VectorGeometryToolVectorEccentricity"] = VectorGeometryToolVectorEccentricity

class VectorGeometryToolVectorFixedInAxes(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Vector fixed in the reference axes using the selected coordinate type."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_axes_method_offset = 1
    _get_direction_method_offset = 2
    _metadata = {
        "iid_data" : (5438855473206840795, 4873753614762144673),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorFixedInAxes)
    
    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolVectorFixedInAxes._metadata, VectorGeometryToolVectorFixedInAxes._get_reference_axes_metadata)

    _get_direction_metadata = { "offset" : _get_direction_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def direction(self) -> "IDirection":
        """Specify the vector direction."""
        return self._intf.get_property(VectorGeometryToolVectorFixedInAxes._metadata, VectorGeometryToolVectorFixedInAxes._get_direction_metadata)

    _property_names[reference_axes] = "reference_axes"
    _property_names[direction] = "direction"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorFixedInAxes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorFixedInAxes)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFixedInAxes, [VectorGeometryToolVectorFixedInAxes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5414607667608549731, 5541039856994583477), VectorGeometryToolVectorFixedInAxes)
agcls.AgTypeNameMap["VectorGeometryToolVectorFixedInAxes"] = VectorGeometryToolVectorFixedInAxes

class VectorGeometryToolVectorLineOfNodes(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _metadata = {
        "iid_data" : (5620801902714546977, 17415199759640402072),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorLineOfNodes)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolVectorLineOfNodes._metadata, VectorGeometryToolVectorLineOfNodes._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(VectorGeometryToolVectorLineOfNodes._metadata, VectorGeometryToolVectorLineOfNodes._get_reference_point_metadata)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorLineOfNodes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorLineOfNodes)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorLineOfNodes, [VectorGeometryToolVectorLineOfNodes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5697497466063765457, 2971359664823275691), VectorGeometryToolVectorLineOfNodes)
agcls.AgTypeNameMap["VectorGeometryToolVectorLineOfNodes"] = VectorGeometryToolVectorLineOfNodes

class VectorGeometryToolVectorOrbitAngularMomentum(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _get_mean_element_type_method_offset = 3
    _set_mean_element_type_method_offset = 4
    _metadata = {
        "iid_data" : (4672338610862171914, 4748446384217441694),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorOrbitAngularMomentum)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolVectorOrbitAngularMomentum._metadata, VectorGeometryToolVectorOrbitAngularMomentum._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(VectorGeometryToolVectorOrbitAngularMomentum._metadata, VectorGeometryToolVectorOrbitAngularMomentum._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "offset" : _get_mean_element_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(VectorGeometryToolVectorOrbitAngularMomentum._metadata, VectorGeometryToolVectorOrbitAngularMomentum._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "offset" : _set_mean_element_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(VectorGeometryToolVectorOrbitAngularMomentum._metadata, VectorGeometryToolVectorOrbitAngularMomentum._set_mean_element_type_metadata, meanElementType)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[mean_element_type] = "mean_element_type"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorOrbitAngularMomentum."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorOrbitAngularMomentum)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorOrbitAngularMomentum, [VectorGeometryToolVectorOrbitAngularMomentum, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((4891611620770882179, 10483757950771463324), VectorGeometryToolVectorOrbitAngularMomentum)
agcls.AgTypeNameMap["VectorGeometryToolVectorOrbitAngularMomentum"] = VectorGeometryToolVectorOrbitAngularMomentum

class VectorGeometryToolVectorOrbitNormal(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _get_mean_element_type_method_offset = 3
    _set_mean_element_type_method_offset = 4
    _metadata = {
        "iid_data" : (4663288290247263893, 6881582421855256250),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorOrbitNormal)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolVectorOrbitNormal._metadata, VectorGeometryToolVectorOrbitNormal._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(VectorGeometryToolVectorOrbitNormal._metadata, VectorGeometryToolVectorOrbitNormal._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "offset" : _get_mean_element_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(VectorGeometryToolVectorOrbitNormal._metadata, VectorGeometryToolVectorOrbitNormal._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "offset" : _set_mean_element_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(VectorGeometryToolVectorOrbitNormal._metadata, VectorGeometryToolVectorOrbitNormal._set_mean_element_type_metadata, meanElementType)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[mean_element_type] = "mean_element_type"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorOrbitNormal."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorOrbitNormal)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorOrbitNormal, [VectorGeometryToolVectorOrbitNormal, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5690167406211296648, 16267055690317479320), VectorGeometryToolVectorOrbitNormal)
agcls.AgTypeNameMap["VectorGeometryToolVectorOrbitNormal"] = VectorGeometryToolVectorOrbitNormal

class VectorGeometryToolVectorPeriapsis(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_reference_point_method_offset = 2
    _get_mean_element_type_method_offset = 3
    _set_mean_element_type_method_offset = 4
    _metadata = {
        "iid_data" : (5437835362413743277, 15452296298104812190),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorPeriapsis)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(VectorGeometryToolVectorPeriapsis._metadata, VectorGeometryToolVectorPeriapsis._get_central_body_metadata)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(VectorGeometryToolVectorPeriapsis._metadata, VectorGeometryToolVectorPeriapsis._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "offset" : _get_mean_element_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(VectorGeometryToolVectorPeriapsis._metadata, VectorGeometryToolVectorPeriapsis._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "offset" : _set_mean_element_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(VectorGeometryToolVectorPeriapsis._metadata, VectorGeometryToolVectorPeriapsis._set_mean_element_type_metadata, meanElementType)

    _property_names[central_body] = "central_body"
    _property_names[reference_point] = "reference_point"
    _property_names[mean_element_type] = "mean_element_type"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorPeriapsis."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorPeriapsis)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorPeriapsis, [VectorGeometryToolVectorPeriapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5256947048057516928, 4939205471749242766), VectorGeometryToolVectorPeriapsis)
agcls.AgTypeNameMap["VectorGeometryToolVectorPeriapsis"] = VectorGeometryToolVectorPeriapsis

class VectorGeometryToolVectorReflection(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """A vector (incident vector) reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_incoming_vector_method_offset = 1
    _get_use_opposite_of_selected_vector_method_offset = 2
    _set_use_opposite_of_selected_vector_method_offset = 3
    _get_normal_vector_method_offset = 4
    _get_allow_reflections_on_backside_method_offset = 5
    _set_allow_reflections_on_backside_method_offset = 6
    _get_scale_factor_method_offset = 7
    _set_scale_factor_method_offset = 8
    _metadata = {
        "iid_data" : (4748526333704094068, 13594143576183274168),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorReflection)
    
    _get_incoming_vector_metadata = { "offset" : _get_incoming_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def incoming_vector(self) -> "VectorGeometryToolVectorRefTo":
        """The reflecting vector."""
        return self._intf.get_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._get_incoming_vector_metadata)

    _get_use_opposite_of_selected_vector_metadata = { "offset" : _get_use_opposite_of_selected_vector_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_opposite_of_selected_vector(self) -> bool:
        """When set to false, resets the direction of the Incident Vector to default."""
        return self._intf.get_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._get_use_opposite_of_selected_vector_metadata)

    _set_use_opposite_of_selected_vector_metadata = { "offset" : _set_use_opposite_of_selected_vector_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_opposite_of_selected_vector.setter
    def use_opposite_of_selected_vector(self, useOppositeOfSelectedVector:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._set_use_opposite_of_selected_vector_metadata, useOppositeOfSelectedVector)

    _get_normal_vector_metadata = { "offset" : _get_normal_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def normal_vector(self) -> "VectorGeometryToolVectorRefTo":
        """The vector defines the reflection surface."""
        return self._intf.get_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._get_normal_vector_metadata)

    _get_allow_reflections_on_backside_metadata = { "offset" : _get_allow_reflections_on_backside_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def allow_reflections_on_backside(self) -> bool:
        """Control whether to reflect the indicent vector on both sides of the plane."""
        return self._intf.get_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._get_allow_reflections_on_backside_metadata)

    _set_allow_reflections_on_backside_metadata = { "offset" : _set_allow_reflections_on_backside_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @allow_reflections_on_backside.setter
    def allow_reflections_on_backside(self, allowReflectionsOnBackside:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._set_allow_reflections_on_backside_metadata, allowReflectionsOnBackside)

    _get_scale_factor_metadata = { "offset" : _get_scale_factor_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale_factor(self) -> float:
        """The vector's scale factor."""
        return self._intf.get_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._get_scale_factor_metadata)

    _set_scale_factor_metadata = { "offset" : _set_scale_factor_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale_factor.setter
    def scale_factor(self, scaleFactor:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorReflection._metadata, VectorGeometryToolVectorReflection._set_scale_factor_metadata, scaleFactor)

    _property_names[incoming_vector] = "incoming_vector"
    _property_names[use_opposite_of_selected_vector] = "use_opposite_of_selected_vector"
    _property_names[normal_vector] = "normal_vector"
    _property_names[allow_reflections_on_backside] = "allow_reflections_on_backside"
    _property_names[scale_factor] = "scale_factor"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorReflection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorReflection)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorReflection, [VectorGeometryToolVectorReflection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5242169156125559792, 12802032634593964167), VectorGeometryToolVectorReflection)
agcls.AgTypeNameMap["VectorGeometryToolVectorReflection"] = VectorGeometryToolVectorReflection

class VectorGeometryToolVectorRotationVector(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_axes_method_offset = 1
    _get_reference_axes_method_offset = 2
    _get_force_minimum_rotation_method_offset = 3
    _set_force_minimum_rotation_method_offset = 4
    _metadata = {
        "iid_data" : (5460315657885274874, 3646263761371809724),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorRotationVector)
    
    _get_axes_metadata = { "offset" : _get_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify the axes."""
        return self._intf.get_property(VectorGeometryToolVectorRotationVector._metadata, VectorGeometryToolVectorRotationVector._get_axes_metadata)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(VectorGeometryToolVectorRotationVector._metadata, VectorGeometryToolVectorRotationVector._get_reference_axes_metadata)

    _get_force_minimum_rotation_metadata = { "offset" : _get_force_minimum_rotation_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def force_minimum_rotation(self) -> bool:
        """Insures that the rotation angle will be between 0 and pi. If the angle is increasing at pi, then the axis direction will be negated to keep phi less than pi."""
        return self._intf.get_property(VectorGeometryToolVectorRotationVector._metadata, VectorGeometryToolVectorRotationVector._get_force_minimum_rotation_metadata)

    _set_force_minimum_rotation_metadata = { "offset" : _set_force_minimum_rotation_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @force_minimum_rotation.setter
    def force_minimum_rotation(self, forceMinimumRotation:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorRotationVector._metadata, VectorGeometryToolVectorRotationVector._set_force_minimum_rotation_metadata, forceMinimumRotation)

    _property_names[axes] = "axes"
    _property_names[reference_axes] = "reference_axes"
    _property_names[force_minimum_rotation] = "force_minimum_rotation"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorRotationVector."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorRotationVector)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorRotationVector, [VectorGeometryToolVectorRotationVector, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5286863955939671726, 10289535475779917705), VectorGeometryToolVectorRotationVector)
agcls.AgTypeNameMap["VectorGeometryToolVectorRotationVector"] = VectorGeometryToolVectorRotationVector

class VectorGeometryToolVectorDirectionToStar(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent, SupportsDeleteCallback):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_selected_star_method_offset = 1
    _set_selected_star_method_offset = 2
    _metadata = {
        "iid_data" : (4820370741406600788, 12462817074117337733),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorDirectionToStar)
    
    _get_selected_star_metadata = { "offset" : _get_selected_star_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def selected_star(self) -> str:
        """A fully qualified path to a Star object."""
        return self._intf.get_property(VectorGeometryToolVectorDirectionToStar._metadata, VectorGeometryToolVectorDirectionToStar._get_selected_star_metadata)

    _set_selected_star_metadata = { "offset" : _set_selected_star_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @selected_star.setter
    def selected_star(self, selectedStar:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorDirectionToStar._metadata, VectorGeometryToolVectorDirectionToStar._set_selected_star_metadata, selectedStar)

    _property_names[selected_star] = "selected_star"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorDirectionToStar."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorDirectionToStar)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDirectionToStar, [VectorGeometryToolVectorDirectionToStar, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry((5047539549077495756, 11298035590861304728), VectorGeometryToolVectorDirectionToStar)
agcls.AgTypeNameMap["VectorGeometryToolVectorDirectionToStar"] = VectorGeometryToolVectorDirectionToStar

class VectorGeometryToolVectorFixedAtTimeInstant(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_time_instant_method_offset = 1
    _set_reference_time_instant_method_offset = 2
    _get_source_vector_method_offset = 3
    _set_source_vector_method_offset = 4
    _get_reference_axes_method_offset = 5
    _set_reference_axes_method_offset = 6
    _metadata = {
        "iid_data" : (4794500466872215055, 9081519325933884048),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorFixedAtTimeInstant)
    
    _get_reference_time_instant_metadata = { "offset" : _get_reference_time_instant_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(VectorGeometryToolVectorFixedAtTimeInstant._metadata, VectorGeometryToolVectorFixedAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "offset" : _set_reference_time_instant_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(VectorGeometryToolVectorFixedAtTimeInstant._metadata, VectorGeometryToolVectorFixedAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_source_vector_metadata = { "offset" : _get_source_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_vector(self) -> "IVectorGeometryToolVector":
        """A source vector. Can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorFixedAtTimeInstant._metadata, VectorGeometryToolVectorFixedAtTimeInstant._get_source_vector_metadata)

    _set_source_vector_metadata = { "offset" : _set_source_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @source_vector.setter
    def source_vector(self, sourceVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorFixedAtTimeInstant._metadata, VectorGeometryToolVectorFixedAtTimeInstant._set_source_vector_metadata, sourceVector)

    _get_reference_axes_metadata = { "offset" : _get_reference_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """A reference axes. Can be any VGT axes."""
        return self._intf.get_property(VectorGeometryToolVectorFixedAtTimeInstant._metadata, VectorGeometryToolVectorFixedAtTimeInstant._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "offset" : _set_reference_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(VectorGeometryToolVectorFixedAtTimeInstant._metadata, VectorGeometryToolVectorFixedAtTimeInstant._set_reference_axes_metadata, referenceAxes)

    _property_names[reference_time_instant] = "reference_time_instant"
    _property_names[source_vector] = "source_vector"
    _property_names[reference_axes] = "reference_axes"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorFixedAtTimeInstant."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorFixedAtTimeInstant)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFixedAtTimeInstant, [VectorGeometryToolVectorFixedAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((5433779106058024883, 18263442844859596677), VectorGeometryToolVectorFixedAtTimeInstant)
agcls.AgTypeNameMap["VectorGeometryToolVectorFixedAtTimeInstant"] = VectorGeometryToolVectorFixedAtTimeInstant

class VectorGeometryToolVectorLinearCombination(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """Linear combination of two input vectors."""

    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_vector_a_method_offset = 1
    _set_vector_a_method_offset = 2
    _get_scale_factor_a_method_offset = 3
    _set_scale_factor_a_method_offset = 4
    _get_normalize_vector_a_method_offset = 5
    _set_normalize_vector_a_method_offset = 6
    _get_vector_b_method_offset = 7
    _set_vector_b_method_offset = 8
    _get_scale_factor_b_method_offset = 9
    _set_scale_factor_b_method_offset = 10
    _get_normalize_vector_b_method_offset = 11
    _set_normalize_vector_b_method_offset = 12
    _get_output_dimension_inheritance_method_offset = 13
    _set_output_dimension_inheritance_method_offset = 14
    _get_output_dimension_method_offset = 15
    _set_output_dimension_method_offset = 16
    _metadata = {
        "iid_data" : (4740055483795291320, 15900085786830737054),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorLinearCombination)
    
    _get_vector_a_metadata = { "offset" : _get_vector_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_a(self) -> "IVectorGeometryToolVector":
        """Vector A can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_vector_a_metadata)

    _set_vector_a_metadata = { "offset" : _set_vector_a_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @vector_a.setter
    def vector_a(self, vectorA:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_vector_a_metadata, vectorA)

    _get_scale_factor_a_metadata = { "offset" : _get_scale_factor_a_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale_factor_a(self) -> float:
        """Scale factor for vector A."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_scale_factor_a_metadata)

    _set_scale_factor_a_metadata = { "offset" : _set_scale_factor_a_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale_factor_a.setter
    def scale_factor_a(self, scaleFactorA:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_scale_factor_a_metadata, scaleFactorA)

    _get_normalize_vector_a_metadata = { "offset" : _get_normalize_vector_a_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def normalize_vector_a(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_normalize_vector_a_metadata)

    _set_normalize_vector_a_metadata = { "offset" : _set_normalize_vector_a_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @normalize_vector_a.setter
    def normalize_vector_a(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_normalize_vector_a_metadata, normalizeVectorA)

    _get_vector_b_metadata = { "offset" : _get_vector_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_b(self) -> "IVectorGeometryToolVector":
        """Vector B can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_vector_b_metadata)

    _set_vector_b_metadata = { "offset" : _set_vector_b_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @vector_b.setter
    def vector_b(self, vectorB:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_vector_b_metadata, vectorB)

    _get_scale_factor_b_metadata = { "offset" : _get_scale_factor_b_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale_factor_b(self) -> float:
        """Scale factor for vector B."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_scale_factor_b_metadata)

    _set_scale_factor_b_metadata = { "offset" : _set_scale_factor_b_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale_factor_b.setter
    def scale_factor_b(self, scaleFactorB:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_scale_factor_b_metadata, scaleFactorB)

    _get_normalize_vector_b_metadata = { "offset" : _get_normalize_vector_b_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def normalize_vector_b(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_normalize_vector_b_metadata)

    _set_normalize_vector_b_metadata = { "offset" : _set_normalize_vector_b_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @normalize_vector_b.setter
    def normalize_vector_b(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_normalize_vector_b_metadata, normalizeVectorB)

    _get_output_dimension_inheritance_metadata = { "offset" : _get_output_dimension_inheritance_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIMENSION_INHERITANCE),) }
    @property
    def output_dimension_inheritance(self) -> "CRDN_DIMENSION_INHERITANCE":
        """Determine whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_output_dimension_inheritance_metadata)

    _set_output_dimension_inheritance_metadata = { "offset" : _set_output_dimension_inheritance_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIMENSION_INHERITANCE),) }
    @output_dimension_inheritance.setter
    def output_dimension_inheritance(self, outputDimensionInheritance:"CRDN_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_output_dimension_inheritance_metadata, outputDimensionInheritance)

    _get_output_dimension_metadata = { "offset" : _get_output_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def output_dimension(self) -> str:
        """A dimension to interpret the output vector."""
        return self._intf.get_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "offset" : _set_output_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorLinearCombination._metadata, VectorGeometryToolVectorLinearCombination._set_output_dimension_metadata, outputDimension)

    _property_names[vector_a] = "vector_a"
    _property_names[scale_factor_a] = "scale_factor_a"
    _property_names[normalize_vector_a] = "normalize_vector_a"
    _property_names[vector_b] = "vector_b"
    _property_names[scale_factor_b] = "scale_factor_b"
    _property_names[normalize_vector_b] = "normalize_vector_b"
    _property_names[output_dimension_inheritance] = "output_dimension_inheritance"
    _property_names[output_dimension] = "output_dimension"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorLinearCombination."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorLinearCombination)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorLinearCombination, [VectorGeometryToolVectorLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((5538434821612795468, 13698347071120474037), VectorGeometryToolVectorLinearCombination)
agcls.AgTypeNameMap["VectorGeometryToolVectorLinearCombination"] = VectorGeometryToolVectorLinearCombination

class VectorGeometryToolVectorProjectAlongVector(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """A projection of a source vector in the direction of another vector."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_source_vector_method_offset = 1
    _set_source_vector_method_offset = 2
    _get_along_vector_method_offset = 3
    _set_along_vector_method_offset = 4
    _metadata = {
        "iid_data" : (5755066096907232965, 3388857209259158146),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorProjectAlongVector)
    
    _get_source_vector_metadata = { "offset" : _get_source_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def source_vector(self) -> "IVectorGeometryToolVector":
        """A source vector. Can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorProjectAlongVector._metadata, VectorGeometryToolVectorProjectAlongVector._get_source_vector_metadata)

    _set_source_vector_metadata = { "offset" : _set_source_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @source_vector.setter
    def source_vector(self, sourceVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorProjectAlongVector._metadata, VectorGeometryToolVectorProjectAlongVector._set_source_vector_metadata, sourceVector)

    _get_along_vector_metadata = { "offset" : _get_along_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def along_vector(self) -> "IVectorGeometryToolVector":
        """A vector along which the source vector is projected. Can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorProjectAlongVector._metadata, VectorGeometryToolVectorProjectAlongVector._get_along_vector_metadata)

    _set_along_vector_metadata = { "offset" : _set_along_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @along_vector.setter
    def along_vector(self, alongVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorProjectAlongVector._metadata, VectorGeometryToolVectorProjectAlongVector._set_along_vector_metadata, alongVector)

    _property_names[source_vector] = "source_vector"
    _property_names[along_vector] = "along_vector"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorProjectAlongVector."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorProjectAlongVector)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorProjectAlongVector, [VectorGeometryToolVectorProjectAlongVector, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((5381541363365362073, 9025593909509941933), VectorGeometryToolVectorProjectAlongVector)
agcls.AgTypeNameMap["VectorGeometryToolVectorProjectAlongVector"] = VectorGeometryToolVectorProjectAlongVector

class VectorGeometryToolVectorScalarLinearCombination(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """Linear combination of two input vectors using scalars."""

    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_vector_a_method_offset = 1
    _set_vector_a_method_offset = 2
    _get_scale_factor_a_method_offset = 3
    _set_scale_factor_a_method_offset = 4
    _get_normalize_vector_a_method_offset = 5
    _set_normalize_vector_a_method_offset = 6
    _get_use_scale_from_scalar_a_method_offset = 7
    _set_use_scale_from_scalar_a_method_offset = 8
    _get_use_scale_from_scalar_b_method_offset = 9
    _set_use_scale_from_scalar_b_method_offset = 10
    _get_scalar_a_method_offset = 11
    _set_scalar_a_method_offset = 12
    _get_scalar_b_method_offset = 13
    _set_scalar_b_method_offset = 14
    _get_vector_b_method_offset = 15
    _set_vector_b_method_offset = 16
    _get_scale_factor_b_method_offset = 17
    _set_scale_factor_b_method_offset = 18
    _get_normalize_vector_b_method_offset = 19
    _set_normalize_vector_b_method_offset = 20
    _get_output_dimension_inheritance_method_offset = 21
    _set_output_dimension_inheritance_method_offset = 22
    _get_output_dimension_method_offset = 23
    _set_output_dimension_method_offset = 24
    _metadata = {
        "iid_data" : (5516212796897271910, 8672269917452776626),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorScalarLinearCombination)
    
    _get_vector_a_metadata = { "offset" : _get_vector_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_a(self) -> "IVectorGeometryToolVector":
        """Vector A can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_vector_a_metadata)

    _set_vector_a_metadata = { "offset" : _set_vector_a_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @vector_a.setter
    def vector_a(self, vectorA:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_vector_a_metadata, vectorA)

    _get_scale_factor_a_metadata = { "offset" : _get_scale_factor_a_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale_factor_a(self) -> float:
        """Scale factor for vector A."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_scale_factor_a_metadata)

    _set_scale_factor_a_metadata = { "offset" : _set_scale_factor_a_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale_factor_a.setter
    def scale_factor_a(self, scaleFactorA:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_scale_factor_a_metadata, scaleFactorA)

    _get_normalize_vector_a_metadata = { "offset" : _get_normalize_vector_a_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def normalize_vector_a(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_normalize_vector_a_metadata)

    _set_normalize_vector_a_metadata = { "offset" : _set_normalize_vector_a_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @normalize_vector_a.setter
    def normalize_vector_a(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_normalize_vector_a_metadata, normalizeVectorA)

    _get_use_scale_from_scalar_a_metadata = { "offset" : _get_use_scale_from_scalar_a_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_scale_from_scalar_a(self) -> bool:
        """Whether to use a scale from scalar A."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_use_scale_from_scalar_a_metadata)

    _set_use_scale_from_scalar_a_metadata = { "offset" : _set_use_scale_from_scalar_a_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_scale_from_scalar_a.setter
    def use_scale_from_scalar_a(self, useScaleFromScalarA:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_use_scale_from_scalar_a_metadata, useScaleFromScalarA)

    _get_use_scale_from_scalar_b_metadata = { "offset" : _get_use_scale_from_scalar_b_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_scale_from_scalar_b(self) -> bool:
        """Whether to use a scale from scalar B."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_use_scale_from_scalar_b_metadata)

    _set_use_scale_from_scalar_b_metadata = { "offset" : _set_use_scale_from_scalar_b_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_scale_from_scalar_b.setter
    def use_scale_from_scalar_b(self, useScaleFromScalarB:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_use_scale_from_scalar_b_metadata, useScaleFromScalarB)

    _get_scalar_a_metadata = { "offset" : _get_scalar_a_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scalar_a(self) -> "ICalculationToolScalar":
        """Scalar scale A. Can be any Scalar calculation."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_scalar_a_metadata)

    _set_scalar_a_metadata = { "offset" : _set_scalar_a_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @scalar_a.setter
    def scalar_a(self, scalarA:"ICalculationToolScalar") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_scalar_a_metadata, scalarA)

    _get_scalar_b_metadata = { "offset" : _get_scalar_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scalar_b(self) -> "ICalculationToolScalar":
        """Scalar scale B. Can be any Scalar calculation."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_scalar_b_metadata)

    _set_scalar_b_metadata = { "offset" : _set_scalar_b_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @scalar_b.setter
    def scalar_b(self, scalarB:"ICalculationToolScalar") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_scalar_b_metadata, scalarB)

    _get_vector_b_metadata = { "offset" : _get_vector_b_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_b(self) -> "IVectorGeometryToolVector":
        """Vector B can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_vector_b_metadata)

    _set_vector_b_metadata = { "offset" : _set_vector_b_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @vector_b.setter
    def vector_b(self, vectorB:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_vector_b_metadata, vectorB)

    _get_scale_factor_b_metadata = { "offset" : _get_scale_factor_b_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale_factor_b(self) -> float:
        """Scale factor for vector B."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_scale_factor_b_metadata)

    _set_scale_factor_b_metadata = { "offset" : _set_scale_factor_b_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale_factor_b.setter
    def scale_factor_b(self, scaleFactorB:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_scale_factor_b_metadata, scaleFactorB)

    _get_normalize_vector_b_metadata = { "offset" : _get_normalize_vector_b_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def normalize_vector_b(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_normalize_vector_b_metadata)

    _set_normalize_vector_b_metadata = { "offset" : _set_normalize_vector_b_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @normalize_vector_b.setter
    def normalize_vector_b(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_normalize_vector_b_metadata, normalizeVectorB)

    _get_output_dimension_inheritance_metadata = { "offset" : _get_output_dimension_inheritance_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIMENSION_INHERITANCE),) }
    @property
    def output_dimension_inheritance(self) -> "CRDN_DIMENSION_INHERITANCE":
        """Determine whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_output_dimension_inheritance_metadata)

    _set_output_dimension_inheritance_metadata = { "offset" : _set_output_dimension_inheritance_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CRDN_DIMENSION_INHERITANCE),) }
    @output_dimension_inheritance.setter
    def output_dimension_inheritance(self, outputDimensionInheritance:"CRDN_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_output_dimension_inheritance_metadata, outputDimensionInheritance)

    _get_output_dimension_metadata = { "offset" : _get_output_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def output_dimension(self) -> str:
        """A dimension to interpret the output vector."""
        return self._intf.get_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "offset" : _set_output_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarLinearCombination._metadata, VectorGeometryToolVectorScalarLinearCombination._set_output_dimension_metadata, outputDimension)

    _property_names[vector_a] = "vector_a"
    _property_names[scale_factor_a] = "scale_factor_a"
    _property_names[normalize_vector_a] = "normalize_vector_a"
    _property_names[use_scale_from_scalar_a] = "use_scale_from_scalar_a"
    _property_names[use_scale_from_scalar_b] = "use_scale_from_scalar_b"
    _property_names[scalar_a] = "scalar_a"
    _property_names[scalar_b] = "scalar_b"
    _property_names[vector_b] = "vector_b"
    _property_names[scale_factor_b] = "scale_factor_b"
    _property_names[normalize_vector_b] = "normalize_vector_b"
    _property_names[output_dimension_inheritance] = "output_dimension_inheritance"
    _property_names[output_dimension] = "output_dimension"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorScalarLinearCombination."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorScalarLinearCombination)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorScalarLinearCombination, [VectorGeometryToolVectorScalarLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((5336658214580096933, 17880387423263486893), VectorGeometryToolVectorScalarLinearCombination)
agcls.AgTypeNameMap["VectorGeometryToolVectorScalarLinearCombination"] = VectorGeometryToolVectorScalarLinearCombination

class VectorGeometryToolVectorScalarScaled(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """Scaled version of the input vector using scalar."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_input_vector_method_offset = 1
    _set_input_vector_method_offset = 2
    _get_input_scalar_method_offset = 3
    _set_input_scalar_method_offset = 4
    _get_scale_factor_method_offset = 5
    _set_scale_factor_method_offset = 6
    _get_normalize_method_offset = 7
    _set_normalize_method_offset = 8
    _get_dimension_inheritance_method_offset = 9
    _set_dimension_inheritance_method_offset = 10
    _get_dimension_method_offset = 11
    _set_dimension_method_offset = 12
    _metadata = {
        "iid_data" : (4894220826375370834, 10889903187965997459),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorScalarScaled)
    
    _get_input_vector_metadata = { "offset" : _get_input_vector_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_vector(self) -> "IVectorGeometryToolVector":
        """An input vector scaled by the scalar. Can be any VGT vector."""
        return self._intf.get_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._get_input_vector_metadata)

    _set_input_vector_metadata = { "offset" : _set_input_vector_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    @input_vector.setter
    def input_vector(self, inputVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._set_input_vector_metadata, inputVector)

    _get_input_scalar_metadata = { "offset" : _get_input_scalar_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """A variable scale applied to the input vector. Can be based on any Scalar calculation."""
        return self._intf.get_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "offset" : _set_input_scalar_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._set_input_scalar_metadata, inputScalar)

    _get_scale_factor_metadata = { "offset" : _get_scale_factor_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale_factor(self) -> float:
        """A constant scale applied to the input vector."""
        return self._intf.get_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._get_scale_factor_metadata)

    _set_scale_factor_metadata = { "offset" : _set_scale_factor_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale_factor.setter
    def scale_factor(self, scaleFactor:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._set_scale_factor_metadata, scaleFactor)

    _get_normalize_metadata = { "offset" : _get_normalize_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def normalize(self) -> bool:
        """Whether to normalize the input vector before applying constant and variable scales."""
        return self._intf.get_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._get_normalize_metadata)

    _set_normalize_metadata = { "offset" : _set_normalize_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @normalize.setter
    def normalize(self, normalize:bool) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._set_normalize_metadata, normalize)

    _get_dimension_inheritance_metadata = { "offset" : _get_dimension_inheritance_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE),) }
    @property
    def dimension_inheritance(self) -> "VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE":
        """Whether or not to inherit dimension from the input vector or the scalar."""
        return self._intf.get_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._get_dimension_inheritance_metadata)

    _set_dimension_inheritance_metadata = { "offset" : _set_dimension_inheritance_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE),) }
    @dimension_inheritance.setter
    def dimension_inheritance(self, dimensionInheritance:"VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._set_dimension_inheritance_metadata, dimensionInheritance)

    _get_dimension_metadata = { "offset" : _get_dimension_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def dimension(self) -> str:
        """A dimension assigned to the output vector."""
        return self._intf.get_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._get_dimension_metadata)

    _set_dimension_metadata = { "offset" : _set_dimension_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorScalarScaled._metadata, VectorGeometryToolVectorScalarScaled._set_dimension_metadata, dimension)

    _property_names[input_vector] = "input_vector"
    _property_names[input_scalar] = "input_scalar"
    _property_names[scale_factor] = "scale_factor"
    _property_names[normalize] = "normalize"
    _property_names[dimension_inheritance] = "dimension_inheritance"
    _property_names[dimension] = "dimension"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorScalarScaled."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorScalarScaled)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorScalarScaled, [VectorGeometryToolVectorScalarScaled, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((4832758772442315154, 12540700473237060019), VectorGeometryToolVectorScalarScaled)
agcls.AgTypeNameMap["VectorGeometryToolVectorScalarScaled"] = VectorGeometryToolVectorScalarScaled

class VectorGeometryToolVectorVelocityAcceleration(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """Velocity vector of a point in a coordinate system."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_system_method_offset = 1
    _set_reference_system_method_offset = 2
    _get_point_method_offset = 3
    _set_point_method_offset = 4
    _get_differencing_time_step_method_offset = 5
    _set_differencing_time_step_method_offset = 6
    _metadata = {
        "iid_data" : (5375860155292160993, 17499030931590071207),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorVelocityAcceleration)
    
    _get_reference_system_metadata = { "offset" : _get_reference_system_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """A reference (coordinate) system. Can be any VGT system."""
        return self._intf.get_property(VectorGeometryToolVectorVelocityAcceleration._metadata, VectorGeometryToolVectorVelocityAcceleration._get_reference_system_metadata)

    _set_reference_system_metadata = { "offset" : _set_reference_system_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(VectorGeometryToolVectorVelocityAcceleration._metadata, VectorGeometryToolVectorVelocityAcceleration._set_reference_system_metadata, referenceSystem)

    _get_point_metadata = { "offset" : _get_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point(self) -> "IVectorGeometryToolPoint":
        """A point which velocity this vector represents. Can be any VGT point."""
        return self._intf.get_property(VectorGeometryToolVectorVelocityAcceleration._metadata, VectorGeometryToolVectorVelocityAcceleration._get_point_metadata)

    _set_point_metadata = { "offset" : _set_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @point.setter
    def point(self, point:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(VectorGeometryToolVectorVelocityAcceleration._metadata, VectorGeometryToolVectorVelocityAcceleration._set_point_metadata, point)

    _get_differencing_time_step_metadata = { "offset" : _get_differencing_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(VectorGeometryToolVectorVelocityAcceleration._metadata, VectorGeometryToolVectorVelocityAcceleration._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "offset" : _set_differencing_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorVelocityAcceleration._metadata, VectorGeometryToolVectorVelocityAcceleration._set_differencing_time_step_metadata, differencingTimeStep)

    _property_names[reference_system] = "reference_system"
    _property_names[point] = "point"
    _property_names[differencing_time_step] = "differencing_time_step"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorVelocityAcceleration."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorVelocityAcceleration)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorVelocityAcceleration, [VectorGeometryToolVectorVelocityAcceleration, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((5695013519916147237, 17504416085998501559), VectorGeometryToolVectorVelocityAcceleration)
agcls.AgTypeNameMap["VectorGeometryToolVectorVelocityAcceleration"] = VectorGeometryToolVectorVelocityAcceleration

class VectorGeometryToolVectorPlugin(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """A VGT vector plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_prog_id_method_offset = 1
    _get_display_name_method_offset = 2
    _get_available_properties_method_offset = 3
    _reset_method_offset = 4
    _set_property_method_offset = 5
    _get_property_method_offset = 6
    _metadata = {
        "iid_data" : (5460902203496199703, 16978439278174404752),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorPlugin)
    
    _get_prog_id_metadata = { "offset" : _get_prog_id_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(VectorGeometryToolVectorPlugin._metadata, VectorGeometryToolVectorPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "offset" : _get_display_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def display_name(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(VectorGeometryToolVectorPlugin._metadata, VectorGeometryToolVectorPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "offset" : _get_available_properties_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(VectorGeometryToolVectorPlugin._metadata, VectorGeometryToolVectorPlugin._get_available_properties_metadata)

    _reset_metadata = { "offset" : _reset_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(VectorGeometryToolVectorPlugin._metadata, VectorGeometryToolVectorPlugin._reset_metadata, )

    _set_property_metadata = { "offset" : _set_property_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def set_property(self, name:str, value:str) -> None:
        """Set the plugin properties. This method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(VectorGeometryToolVectorPlugin._metadata, VectorGeometryToolVectorPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "offset" : _get_property_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg,) }
    def get_property(self, name:str) -> str:
        """Read a value of the specified plugin property. This method throws an exception if the property does not exist."""
        return self._intf.invoke(VectorGeometryToolVectorPlugin._metadata, VectorGeometryToolVectorPlugin._get_property_metadata, name, OutArg())

    _property_names[prog_id] = "prog_id"
    _property_names[display_name] = "display_name"
    _property_names[available_properties] = "available_properties"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorPlugin."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorPlugin)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorPlugin, [VectorGeometryToolVectorPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((5185411868180955802, 1723185518236018616), VectorGeometryToolVectorPlugin)
agcls.AgTypeNameMap["VectorGeometryToolVectorPlugin"] = VectorGeometryToolVectorPlugin

class VectorGeometryToolVectorDispSurface(IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector, SupportsDeleteCallback):
    """Displacement between origin and destination points using surface distance and altitude difference."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_origin_point_method_offset = 1
    _set_origin_point_method_offset = 2
    _get_destination_point_method_offset = 3
    _set_destination_point_method_offset = 4
    _get_surface_central_body_method_offset = 5
    _set_surface_central_body_method_offset = 6
    _get_differencing_time_step_method_offset = 7
    _set_differencing_time_step_method_offset = 8
    _metadata = {
        "iid_data" : (4749322752609177542, 3138784402351446404),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorDispSurface)
    
    _get_origin_point_metadata = { "offset" : _get_origin_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def origin_point(self) -> "IVectorGeometryToolPoint":
        """An origin point."""
        return self._intf.get_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._get_origin_point_metadata)

    _set_origin_point_metadata = { "offset" : _set_origin_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @origin_point.setter
    def origin_point(self, originPoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._set_origin_point_metadata, originPoint)

    _get_destination_point_metadata = { "offset" : _get_destination_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def destination_point(self) -> "IVectorGeometryToolPoint":
        """Destination point."""
        return self._intf.get_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._get_destination_point_metadata)

    _set_destination_point_metadata = { "offset" : _set_destination_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    @destination_point.setter
    def destination_point(self, destinationPoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._set_destination_point_metadata, destinationPoint)

    _get_surface_central_body_metadata = { "offset" : _get_surface_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def surface_central_body(self) -> str:
        """Get or set the surface central body property."""
        return self._intf.get_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._get_surface_central_body_metadata)

    _set_surface_central_body_metadata = { "offset" : _set_surface_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @surface_central_body.setter
    def surface_central_body(self, surfaceCentralBody:str) -> None:
        return self._intf.set_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._set_surface_central_body_metadata, surfaceCentralBody)

    _get_differencing_time_step_metadata = { "offset" : _get_differencing_time_step_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in displacement on surface vector. (derivatives using central differencing)."""
        return self._intf.get_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "offset" : _set_differencing_time_step_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(VectorGeometryToolVectorDispSurface._metadata, VectorGeometryToolVectorDispSurface._set_differencing_time_step_metadata, differencingTimeStep)

    _property_names[origin_point] = "origin_point"
    _property_names[destination_point] = "destination_point"
    _property_names[surface_central_body] = "surface_central_body"
    _property_names[differencing_time_step] = "differencing_time_step"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorDispSurface."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorDispSurface)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDispSurface, [VectorGeometryToolVectorDispSurface, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry((5165198519091638019, 11878832301117811344), VectorGeometryToolVectorDispSurface)
agcls.AgTypeNameMap["VectorGeometryToolVectorDispSurface"] = VectorGeometryToolVectorDispSurface

class VectorGeometryToolVectorFactory(SupportsDeleteCallback):
    """A Factory object to create vectors."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _is_type_supported_method_offset = 2
    _create_displacement_vector_method_offset = 3
    _get_available_vector_plugin_display_names_method_offset = 4
    _create_vector_plugin_from_display_name_method_offset = 5
    _create_cross_product_vector_method_offset = 6
    _metadata = {
        "iid_data" : (4961059317243966035, 3728998091371643287),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_VECTOR_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, vectorName:str, description:str, vectorType:"VECTOR_GEOMETRY_TOOL_VECTOR_TYPE") -> "IVectorGeometryToolVector":
        """Create a VGT vector using specified name, description and type."""
        return self._intf.invoke(VectorGeometryToolVectorFactory._metadata, VectorGeometryToolVectorFactory._create_metadata, vectorName, description, vectorType, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_VECTOR_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_VECTOR_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(VectorGeometryToolVectorFactory._metadata, VectorGeometryToolVectorFactory._is_type_supported_metadata, type, OutArg())

    _create_displacement_vector_metadata = { "offset" : _create_displacement_vector_method_offset,
            "arg_types" : (agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceOutArg,) }
    def create_displacement_vector(self, vectorName:str, originPoint:"IVectorGeometryToolPoint", destPoint:"IVectorGeometryToolPoint") -> "VectorGeometryToolVectorDisplacement":
        """Create a displacement vector."""
        return self._intf.invoke(VectorGeometryToolVectorFactory._metadata, VectorGeometryToolVectorFactory._create_displacement_vector_metadata, vectorName, originPoint, destPoint, OutArg())

    _get_available_vector_plugin_display_names_metadata = { "offset" : _get_available_vector_plugin_display_names_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_vector_plugin_display_names(self) -> list:
        """An array of display names associated with available vector plugins. The elements of the array are strings. Display names are used to create VGT vectors based on COM plugins using CreateVectorPluginFromDisplayName method."""
        return self._intf.get_property(VectorGeometryToolVectorFactory._metadata, VectorGeometryToolVectorFactory._get_available_vector_plugin_display_names_metadata)

    _create_vector_plugin_from_display_name_metadata = { "offset" : _create_vector_plugin_from_display_name_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_vector_plugin_from_display_name(self, vectorName:str, description:str, displayName:str) -> "IVectorGeometryToolVector":
        """Create a vector component based on a COM vector plugin. For information how to implement and register VGT plugins, see."""
        return self._intf.invoke(VectorGeometryToolVectorFactory._metadata, VectorGeometryToolVectorFactory._create_vector_plugin_from_display_name_metadata, vectorName, description, displayName, OutArg())

    _create_cross_product_vector_metadata = { "offset" : _create_cross_product_vector_method_offset,
            "arg_types" : (agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceInArg("IVectorGeometryToolVector"), agmarshall.InterfaceInArg("IVectorGeometryToolVector"), agmarshall.InterfaceOutArg,) }
    def create_cross_product_vector(self, vectorName:str, vectorA:"IVectorGeometryToolVector", vectorB:"IVectorGeometryToolVector") -> "VectorGeometryToolVectorCross":
        """Create a cross product C = A x B."""
        return self._intf.invoke(VectorGeometryToolVectorFactory._metadata, VectorGeometryToolVectorFactory._create_cross_product_vector_metadata, vectorName, vectorA, vectorB, OutArg())

    _property_names[available_vector_plugin_display_names] = "available_vector_plugin_display_names"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFactory, [VectorGeometryToolVectorFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5711359673983832545, 2530719800053651075), VectorGeometryToolVectorFactory)
agcls.AgTypeNameMap["VectorGeometryToolVectorFactory"] = VectorGeometryToolVectorFactory

class VectorGeometryToolAxesFactory(SupportsDeleteCallback):
    """A Factory object to create axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _is_type_supported_method_offset = 2
    _get_available_axes_plugin_display_names_method_offset = 3
    _create_axes_plugin_from_display_name_method_offset = 4
    _metadata = {
        "iid_data" : (5464957119791377790, 10054543613096150957),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_AXES_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, axesName:str, description:str, axesType:"VECTOR_GEOMETRY_TOOL_AXES_TYPE") -> "IVectorGeometryToolAxes":
        """Create a VGT axes using specified name, description and type."""
        return self._intf.invoke(VectorGeometryToolAxesFactory._metadata, VectorGeometryToolAxesFactory._create_metadata, axesName, description, axesType, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_AXES_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_AXES_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(VectorGeometryToolAxesFactory._metadata, VectorGeometryToolAxesFactory._is_type_supported_metadata, type, OutArg())

    _get_available_axes_plugin_display_names_metadata = { "offset" : _get_available_axes_plugin_display_names_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_axes_plugin_display_names(self) -> list:
        """An array of display names associated with available axes plugins. The elements of the array are strings. Display names are used to create VGT axes based on COM plugins using CreateAxesPluginFromDisplayName method."""
        return self._intf.get_property(VectorGeometryToolAxesFactory._metadata, VectorGeometryToolAxesFactory._get_available_axes_plugin_display_names_metadata)

    _create_axes_plugin_from_display_name_metadata = { "offset" : _create_axes_plugin_from_display_name_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_axes_plugin_from_display_name(self, axesName:str, description:str, displayName:str) -> "IVectorGeometryToolAxes":
        """Create an axes component based on a COM axes plugin. For information how to implement and register VGT plugins, see."""
        return self._intf.invoke(VectorGeometryToolAxesFactory._metadata, VectorGeometryToolAxesFactory._create_axes_plugin_from_display_name_metadata, axesName, description, displayName, OutArg())

    _property_names[available_axes_plugin_display_names] = "available_axes_plugin_display_names"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesFactory, [VectorGeometryToolAxesFactory, ])

agcls.AgClassCatalog.add_catalog_entry((4889816373028332546, 554355979822450875), VectorGeometryToolAxesFactory)
agcls.AgTypeNameMap["VectorGeometryToolAxesFactory"] = VectorGeometryToolAxesFactory

class VectorGeometryToolSystemFactory(SupportsDeleteCallback):
    """A Factory interface to create VGT systems."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _is_type_supported_method_offset = 2
    _metadata = {
        "iid_data" : (5404213079612697769, 6467374831321791143),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolSystemFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CRDN_SYSTEM_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, systemName:str, description:str, systemType:"CRDN_SYSTEM_TYPE") -> "IVectorGeometryToolSystem":
        """Create a VGT system using the specified name, description and type."""
        return self._intf.invoke(VectorGeometryToolSystemFactory._metadata, VectorGeometryToolSystemFactory._create_metadata, systemName, description, systemType, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_SYSTEM_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, type:"CRDN_SYSTEM_TYPE") -> bool:
        """Return true if the specified system type is supported."""
        return self._intf.invoke(VectorGeometryToolSystemFactory._metadata, VectorGeometryToolSystemFactory._is_type_supported_metadata, type, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolSystemFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolSystemFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemFactory, [VectorGeometryToolSystemFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5617038167667602452, 6460634208601245600), VectorGeometryToolSystemFactory)
agcls.AgTypeNameMap["VectorGeometryToolSystemFactory"] = VectorGeometryToolSystemFactory

class VectorGeometryToolPointFactory(SupportsDeleteCallback):
    """A Factory object to create points."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _is_type_supported_method_offset = 2
    _get_available_point_plugin_display_names_method_offset = 3
    _create_point_plugin_from_display_name_method_offset = 4
    _create_point_fixed_on_central_body_method_offset = 5
    _metadata = {
        "iid_data" : (4929115657145553370, 11800338428049833909),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_POINT_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, pointName:str, description:str, pointType:"VECTOR_GEOMETRY_TOOL_POINT_TYPE") -> "IVectorGeometryToolPoint":
        """Create a VGT point using the specified name, description and type."""
        return self._intf.invoke(VectorGeometryToolPointFactory._metadata, VectorGeometryToolPointFactory._create_metadata, pointName, description, pointType, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_POINT_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_POINT_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(VectorGeometryToolPointFactory._metadata, VectorGeometryToolPointFactory._is_type_supported_metadata, type, OutArg())

    _get_available_point_plugin_display_names_metadata = { "offset" : _get_available_point_plugin_display_names_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def available_point_plugin_display_names(self) -> list:
        """An array of display names associated with available point plugins. The elements of the array are strings. Display names are used to create VGT points based on COM plugins using CreatePointPluginFromDisplayName method."""
        return self._intf.get_property(VectorGeometryToolPointFactory._metadata, VectorGeometryToolPointFactory._get_available_point_plugin_display_names_metadata)

    _create_point_plugin_from_display_name_metadata = { "offset" : _create_point_plugin_from_display_name_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_point_plugin_from_display_name(self, pointName:str, description:str, displayName:str) -> "IVectorGeometryToolPoint":
        """Create a point component based on a COM point plugin. For information how to implement and register VGT plugins, see."""
        return self._intf.invoke(VectorGeometryToolPointFactory._metadata, VectorGeometryToolPointFactory._create_point_plugin_from_display_name_metadata, pointName, description, displayName, OutArg())

    _create_point_fixed_on_central_body_metadata = { "offset" : _create_point_fixed_on_central_body_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.Variant, agcom.Variant, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.VariantArg, agmarshall.VariantArg, agmarshall.DoubleArg, agmarshall.EnumArg(CRDN_REFERENCE_SHAPE_TYPE), agmarshall.InterfaceOutArg,) }
    def create_point_fixed_on_central_body(self, pointName:str, description:str, longitude:typing.Any, latitude:typing.Any, altitude:float, referenceShape:"CRDN_REFERENCE_SHAPE_TYPE") -> "IVectorGeometryToolPoint":
        """Create a point fixed on a central body."""
        return self._intf.invoke(VectorGeometryToolPointFactory._metadata, VectorGeometryToolPointFactory._create_point_fixed_on_central_body_metadata, pointName, description, longitude, latitude, altitude, referenceShape, OutArg())

    _property_names[available_point_plugin_display_names] = "available_point_plugin_display_names"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointFactory, [VectorGeometryToolPointFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5083027847413101490, 698993109512490900), VectorGeometryToolPointFactory)
agcls.AgTypeNameMap["VectorGeometryToolPointFactory"] = VectorGeometryToolPointFactory

class VectorGeometryToolPlaneFactory(SupportsDeleteCallback):
    """A Factory object to create VGT planes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _is_type_supported_method_offset = 2
    _metadata = {
        "iid_data" : (5511640648637398578, 16974349964803353223),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_PLANE_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, planeName:str, description:str, planeType:"VECTOR_GEOMETRY_TOOL_PLANE_TYPE") -> "IVectorGeometryToolPlane":
        """Create a VGT plane using the specified name, description and type."""
        return self._intf.invoke(VectorGeometryToolPlaneFactory._metadata, VectorGeometryToolPlaneFactory._create_metadata, planeName, description, planeType, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_PLANE_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_PLANE_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(VectorGeometryToolPlaneFactory._metadata, VectorGeometryToolPlaneFactory._is_type_supported_metadata, type, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneFactory, [VectorGeometryToolPlaneFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5201951119613614860, 18153886057905770686), VectorGeometryToolPlaneFactory)
agcls.AgTypeNameMap["VectorGeometryToolPlaneFactory"] = VectorGeometryToolPlaneFactory

class VectorGeometryToolAngleFactory(SupportsDeleteCallback):
    """A Factory object to create angles."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_method_offset = 1
    _is_type_supported_method_offset = 2
    _metadata = {
        "iid_data" : (5564081987267363827, 6995461227666747529),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleFactory)
    
    _create_metadata = { "offset" : _create_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_ANGLE_TYPE), agmarshall.InterfaceOutArg,) }
    def create(self, angleName:str, description:str, angleType:"VECTOR_GEOMETRY_TOOL_ANGLE_TYPE") -> "IVectorGeometryToolAngle":
        """Create a VGT angle using specified name, description and type."""
        return self._intf.invoke(VectorGeometryToolAngleFactory._metadata, VectorGeometryToolAngleFactory._create_metadata, angleName, description, angleType, OutArg())

    _is_type_supported_metadata = { "offset" : _is_type_supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(VECTOR_GEOMETRY_TOOL_ANGLE_TYPE), agmarshall.VariantBoolArg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_ANGLE_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(VectorGeometryToolAngleFactory._metadata, VectorGeometryToolAngleFactory._is_type_supported_metadata, type, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleFactory."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleFactory, [VectorGeometryToolAngleFactory, ])

agcls.AgClassCatalog.add_catalog_entry((5750706908768565407, 9728205924445128858), VectorGeometryToolAngleFactory)
agcls.AgTypeNameMap["VectorGeometryToolAngleFactory"] = VectorGeometryToolAngleFactory

class VectorGeometryToolVectorGroup(SupportsDeleteCallback):
    """Access or create VGT vectors associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5067430531265917149, 15298908306875818125),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolVectorGroup)
    def __iter__(self):
        """Create an iterator for the VectorGeometryToolVectorGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolVector":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, vectorName:str) -> None:
        """Remove a specified vector."""
        return self._intf.invoke(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._remove_metadata, vectorName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "VectorGeometryToolVectorFactory":
        """Return a Factory object used to create custom vectors."""
        return self._intf.get_property(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolVector":
        """Return a vector by name or at a specified position."""
        return self._intf.invoke(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolVector":
        """Retrieve a vector from the collection by index."""
        return self._intf.invoke(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolVector":
        """Retrieve a vector from the collection by name."""
        return self._intf.invoke(VectorGeometryToolVectorGroup._metadata, VectorGeometryToolVectorGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolVectorGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolVectorGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorGroup, [VectorGeometryToolVectorGroup, ])

agcls.AgClassCatalog.add_catalog_entry((4658897554848344558, 15380089491910203264), VectorGeometryToolVectorGroup)
agcls.AgTypeNameMap["VectorGeometryToolVectorGroup"] = VectorGeometryToolVectorGroup

class VectorGeometryToolPointGroup(SupportsDeleteCallback):
    """Access or create VGT points associated with an object or a central body."""

    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_common_tasks_method_offset = 8
    _get_item_by_index_method_offset = 9
    _get_item_by_name_method_offset = 10
    _metadata = {
        "iid_data" : (5147592896826917210, 897551216325447862),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPointGroup)
    def __iter__(self):
        """Create an iterator for the VectorGeometryToolPointGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolPoint":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, pointName:str) -> None:
        """Remove a specified point by name."""
        return self._intf.invoke(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._remove_metadata, pointName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "VectorGeometryToolPointFactory":
        """Return a Factory object used to create custom points."""
        return self._intf.get_property(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolPoint":
        """Return a point by name or at a specified position."""
        return self._intf.invoke(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._get__NewEnum_metadata)

    _get_common_tasks_metadata = { "offset" : _get_common_tasks_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def common_tasks(self) -> "VectorGeometryToolPointCommonTasks":
        """Provide access to common tasks that allow users quickly carry out tasks such as creating known point types, etc."""
        return self._intf.get_property(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._get_common_tasks_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolPoint":
        """Retrieve a point from the collection by index."""
        return self._intf.invoke(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolPoint":
        """Retrieve a point from the collection by name."""
        return self._intf.invoke(VectorGeometryToolPointGroup._metadata, VectorGeometryToolPointGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"
    _property_names[common_tasks] = "common_tasks"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPointGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPointGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPointGroup, [VectorGeometryToolPointGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5402006816162037363, 18282015196025052095), VectorGeometryToolPointGroup)
agcls.AgTypeNameMap["VectorGeometryToolPointGroup"] = VectorGeometryToolPointGroup

class VectorGeometryToolAngleGroup(SupportsDeleteCallback):
    """Access or create VGT angles associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5415288653434167738, 5002473860490802321),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAngleGroup)
    def __iter__(self):
        """Create an iterator for the VectorGeometryToolAngleGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolAngle":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, angleName:str) -> None:
        """Remove a specified Angle."""
        return self._intf.invoke(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._remove_metadata, angleName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "VectorGeometryToolAngleFactory":
        """Return a Factory object used to create custom angles."""
        return self._intf.get_property(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolAngle":
        """Return an angle by name or at a specified position."""
        return self._intf.invoke(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolAngle":
        """Retrieve an angle from the collection by index."""
        return self._intf.invoke(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolAngle":
        """Retrieve an angle from the collection by name."""
        return self._intf.invoke(VectorGeometryToolAngleGroup._metadata, VectorGeometryToolAngleGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAngleGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAngleGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleGroup, [VectorGeometryToolAngleGroup, ])

agcls.AgClassCatalog.add_catalog_entry((4777369427642171852, 17580629102303739534), VectorGeometryToolAngleGroup)
agcls.AgTypeNameMap["VectorGeometryToolAngleGroup"] = VectorGeometryToolAngleGroup

class VectorGeometryToolAxesGroup(SupportsDeleteCallback):
    """Access or create VGT axes associated with an object or a central body."""

    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_common_tasks_method_offset = 8
    _get_item_by_index_method_offset = 9
    _get_item_by_name_method_offset = 10
    _metadata = {
        "iid_data" : (5197040922718010994, 411996095013289911),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolAxesGroup)
    def __iter__(self):
        """Create an iterator for the VectorGeometryToolAxesGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolAxes":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, axesName:str) -> None:
        """Remove a specified Axes."""
        return self._intf.invoke(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._remove_metadata, axesName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "VectorGeometryToolAxesFactory":
        """Return a Factory object used to create custom axes."""
        return self._intf.get_property(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolAxes":
        """Return an axes by name or at a specified position."""
        return self._intf.invoke(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._get__NewEnum_metadata)

    _get_common_tasks_metadata = { "offset" : _get_common_tasks_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def common_tasks(self) -> "VectorGeometryToolAxesCommonTasks":
        """Provide access to common tasks that allow users quickly carry out tasks such as creating known axes, etc."""
        return self._intf.get_property(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._get_common_tasks_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolAxes":
        """Retrieve an axes from the collection by index."""
        return self._intf.invoke(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolAxes":
        """Retrieve an axes from the collection by name."""
        return self._intf.invoke(VectorGeometryToolAxesGroup._metadata, VectorGeometryToolAxesGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"
    _property_names[common_tasks] = "common_tasks"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolAxesGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolAxesGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesGroup, [VectorGeometryToolAxesGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5412936898680792663, 10695939728172755886), VectorGeometryToolAxesGroup)
agcls.AgTypeNameMap["VectorGeometryToolAxesGroup"] = VectorGeometryToolAxesGroup

class VectorGeometryToolPlaneGroup(SupportsDeleteCallback):
    """Represents a single entry point to manipulate VGT Planes associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_item_by_index_method_offset = 8
    _get_item_by_name_method_offset = 9
    _metadata = {
        "iid_data" : (5066623695270279789, 16340809960769038493),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolPlaneGroup)
    def __iter__(self):
        """Create an iterator for the VectorGeometryToolPlaneGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolPlane":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, planeName:str) -> None:
        """Remove a specified Plane."""
        return self._intf.invoke(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._remove_metadata, planeName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "VectorGeometryToolPlaneFactory":
        """Return a Factory object used to create custom planes."""
        return self._intf.get_property(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolPlane":
        """Return an Plane by name or at a specified position."""
        return self._intf.invoke(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolPlane":
        """Retrieve a plane from the collection by index."""
        return self._intf.invoke(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolPlane":
        """Retrieve a plane from the collection by name."""
        return self._intf.invoke(VectorGeometryToolPlaneGroup._metadata, VectorGeometryToolPlaneGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolPlaneGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolPlaneGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneGroup, [VectorGeometryToolPlaneGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5205667377203739266, 6175294865411825318), VectorGeometryToolPlaneGroup)
agcls.AgTypeNameMap["VectorGeometryToolPlaneGroup"] = VectorGeometryToolPlaneGroup

class VectorGeometryToolSystemGroup(SupportsDeleteCallback):
    """Access or create VGT systems associated with an object or a central body."""

    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _remove_method_offset = 1
    _get_context_method_offset = 2
    _contains_method_offset = 3
    _get_count_method_offset = 4
    _get_factory_method_offset = 5
    _item_method_offset = 6
    _get__NewEnum_method_offset = 7
    _get_common_tasks_method_offset = 8
    _get_item_by_index_method_offset = 9
    _get_item_by_name_method_offset = 10
    _metadata = {
        "iid_data" : (5433051316492395298, 2555101289839279763),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolSystemGroup)
    def __iter__(self):
        """Create an iterator for the VectorGeometryToolSystemGroup object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolSystem":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, systemName:str) -> None:
        """Remove a specified System."""
        return self._intf.invoke(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._remove_metadata, systemName)

    _get_context_metadata = { "offset" : _get_context_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._get_context_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._get_count_metadata)

    _get_factory_metadata = { "offset" : _get_factory_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def factory(self) -> "VectorGeometryToolSystemFactory":
        """Return a Factory object used to create custom VGT systems."""
        return self._intf.get_property(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._get_factory_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolSystem":
        """Return a System by name or at a specified position."""
        return self._intf.invoke(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._get__NewEnum_metadata)

    _get_common_tasks_metadata = { "offset" : _get_common_tasks_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def common_tasks(self) -> "VectorGeometryToolSystemCommonTasks":
        """Provide access to common tasks that allow users quickly carry out tasks such as creating known systems, etc."""
        return self._intf.get_property(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._get_common_tasks_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolSystem":
        """Retrieve a system from the collection by index."""
        return self._intf.invoke(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolSystem":
        """Retrieve a system from the collection by name."""
        return self._intf.invoke(VectorGeometryToolSystemGroup._metadata, VectorGeometryToolSystemGroup._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[context] = "context"
    _property_names[count] = "count"
    _property_names[factory] = "factory"
    _property_names[_NewEnum] = "_NewEnum"
    _property_names[common_tasks] = "common_tasks"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolSystemGroup."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolSystemGroup)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemGroup, [VectorGeometryToolSystemGroup, ])

agcls.AgClassCatalog.add_catalog_entry((5689988669908775372, 16308973306298787994), VectorGeometryToolSystemGroup)
agcls.AgTypeNameMap["VectorGeometryToolSystemGroup"] = VectorGeometryToolSystemGroup

class AnalysisWorkbenchProvider(SupportsDeleteCallback):
    """Allow accessing existing Vector Geometry Tool components."""

    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_vectors_method_offset = 1
    _get_points_method_offset = 2
    _get_angles_method_offset = 3
    _get_axes_method_offset = 4
    _get_planes_method_offset = 5
    _get_systems_method_offset = 6
    _get_well_known_systems_method_offset = 7
    _get_well_known_axes_method_offset = 8
    _get_events_method_offset = 9
    _get_event_intervals_method_offset = 10
    _get_calc_scalars_method_offset = 11
    _get_event_arrays_method_offset = 12
    _get_event_interval_lists_method_offset = 13
    _get_event_interval_collections_method_offset = 14
    _get_parameter_sets_method_offset = 15
    _get_conditions_method_offset = 16
    _supports_method_offset = 17
    _get_condition_sets_method_offset = 18
    _import_components_method_offset = 19
    _get_volume_grids_method_offset = 20
    _get_volumes_method_offset = 21
    _get_volume_calcs_method_offset = 22
    _metadata = {
        "iid_data" : (5369099696956109005, 7381995924612526267),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchProvider)
    
    _get_vectors_metadata = { "offset" : _get_vectors_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vectors(self) -> "VectorGeometryToolVectorGroup":
        """Return a group of vectors."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_vectors_metadata)

    _get_points_metadata = { "offset" : _get_points_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def points(self) -> "VectorGeometryToolPointGroup":
        """Return a group of points."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_points_metadata)

    _get_angles_metadata = { "offset" : _get_angles_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def angles(self) -> "VectorGeometryToolAngleGroup":
        """Return a group of angles."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_angles_metadata)

    _get_axes_metadata = { "offset" : _get_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def axes(self) -> "VectorGeometryToolAxesGroup":
        """Return a group of axes."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_axes_metadata)

    _get_planes_metadata = { "offset" : _get_planes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def planes(self) -> "VectorGeometryToolPlaneGroup":
        """Return a group of planes."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_planes_metadata)

    _get_systems_metadata = { "offset" : _get_systems_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def systems(self) -> "VectorGeometryToolSystemGroup":
        """Return a group of systems."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_systems_metadata)

    _get_well_known_systems_metadata = { "offset" : _get_well_known_systems_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def well_known_systems(self) -> "VectorGeometryToolWellKnownSystems":
        """Return well-known systems."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_well_known_systems_metadata)

    _get_well_known_axes_metadata = { "offset" : _get_well_known_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def well_known_axes(self) -> "VectorGeometryToolWellKnownAxes":
        """Return well-known axes."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_well_known_axes_metadata)

    _get_events_metadata = { "offset" : _get_events_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def events(self) -> "TimeToolEventGroup":
        """Return a group of events."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_events_metadata)

    _get_event_intervals_metadata = { "offset" : _get_event_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def event_intervals(self) -> "TimeToolEventIntervalGroup":
        """Return a group of event intervals."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_event_intervals_metadata)

    _get_calc_scalars_metadata = { "offset" : _get_calc_scalars_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def calc_scalars(self) -> "CalculationToolScalarGroup":
        """Return a group of calc scalars."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_calc_scalars_metadata)

    _get_event_arrays_metadata = { "offset" : _get_event_arrays_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def event_arrays(self) -> "TimeToolEventArrayGroup":
        """Return a group of event arrays."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_event_arrays_metadata)

    _get_event_interval_lists_metadata = { "offset" : _get_event_interval_lists_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def event_interval_lists(self) -> "TimeToolEventIntervalListGroup":
        """Return a group of event interval lists."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_event_interval_lists_metadata)

    _get_event_interval_collections_metadata = { "offset" : _get_event_interval_collections_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def event_interval_collections(self) -> "TimeToolEventIntervalCollectionGroup":
        """Return a group of event interval collections."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_event_interval_collections_metadata)

    _get_parameter_sets_metadata = { "offset" : _get_parameter_sets_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def parameter_sets(self) -> "CalculationToolParameterSetGroup":
        """Access, add new or remove existing parameter set components."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_parameter_sets_metadata)

    _get_conditions_metadata = { "offset" : _get_conditions_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def conditions(self) -> "CalculationToolConditionGroup":
        """Return a group of condition objects."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_conditions_metadata)

    _supports_metadata = { "offset" : _supports_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(CRDN_KIND), agmarshall.VariantBoolArg,) }
    def supports(self, feature:"CRDN_KIND") -> bool:
        """Test whether the specified VGT feature is supported."""
        return self._intf.invoke(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._supports_metadata, feature, OutArg())

    _get_condition_sets_metadata = { "offset" : _get_condition_sets_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def condition_sets(self) -> "CalculationToolConditionSetGroup":
        """Return a group of condition set objects."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_condition_sets_metadata)

    _import_components_metadata = { "offset" : _import_components_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def import_components(self, filename:str) -> "AnalysisWorkbenchCollection":
        """Import Analysis Workbench components from a file."""
        return self._intf.invoke(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._import_components_metadata, filename, OutArg())

    _get_volume_grids_metadata = { "offset" : _get_volume_grids_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def volume_grids(self) -> "SpatialAnalysisToolVolumeGridGroup":
        """Return a group of volume grid objects."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_volume_grids_metadata)

    _get_volumes_metadata = { "offset" : _get_volumes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def volumes(self) -> "SpatialAnalysisToolVolumeGroup":
        """Return a group of volume objects."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_volumes_metadata)

    _get_volume_calcs_metadata = { "offset" : _get_volume_calcs_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def volume_calcs(self) -> "SpatialAnalysisToolVolumeCalcGroup":
        """Return a group of volume calc objects."""
        return self._intf.get_property(AnalysisWorkbenchProvider._metadata, AnalysisWorkbenchProvider._get_volume_calcs_metadata)

    _property_names[vectors] = "vectors"
    _property_names[points] = "points"
    _property_names[angles] = "angles"
    _property_names[axes] = "axes"
    _property_names[planes] = "planes"
    _property_names[systems] = "systems"
    _property_names[well_known_systems] = "well_known_systems"
    _property_names[well_known_axes] = "well_known_axes"
    _property_names[events] = "events"
    _property_names[event_intervals] = "event_intervals"
    _property_names[calc_scalars] = "calc_scalars"
    _property_names[event_arrays] = "event_arrays"
    _property_names[event_interval_lists] = "event_interval_lists"
    _property_names[event_interval_collections] = "event_interval_collections"
    _property_names[parameter_sets] = "parameter_sets"
    _property_names[conditions] = "conditions"
    _property_names[condition_sets] = "condition_sets"
    _property_names[volume_grids] = "volume_grids"
    _property_names[volumes] = "volumes"
    _property_names[volume_calcs] = "volume_calcs"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchProvider."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchProvider)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchProvider, [AnalysisWorkbenchProvider, ])

agcls.AgClassCatalog.add_catalog_entry((5195044977180352481, 9063844977118760340), AnalysisWorkbenchProvider)
agcls.AgTypeNameMap["AnalysisWorkbenchProvider"] = AnalysisWorkbenchProvider

class AnalysisWorkbenchRoot(SupportsDeleteCallback):
    """Represents a VGT root object."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_template_provider_method_offset = 1
    _get_provider_method_offset = 2
    _get_well_known_systems_method_offset = 3
    _get_well_known_axes_method_offset = 4
    _metadata = {
        "iid_data" : (4798971245628011021, 838525928077489543),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchRoot)
    
    _get_template_provider_metadata = { "offset" : _get_template_provider_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_template_provider(self, className:str) -> "AnalysisWorkbenchProvider":
        """Return a template provider. The method takes a class name (i.e. ``Satellite``, ``Facility``, etc.)."""
        return self._intf.invoke(AnalysisWorkbenchRoot._metadata, AnalysisWorkbenchRoot._get_template_provider_metadata, className, OutArg())

    _get_provider_metadata = { "offset" : _get_provider_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_provider(self, instPath:str) -> "AnalysisWorkbenchProvider":
        """Return an instance provider. The method takes a short instance path to an STK object or a central body.(i.e. ``Satellite/Satellite1``, ``CentralBody/Earth``, etc.)."""
        return self._intf.invoke(AnalysisWorkbenchRoot._metadata, AnalysisWorkbenchRoot._get_provider_metadata, instPath, OutArg())

    _get_well_known_systems_metadata = { "offset" : _get_well_known_systems_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def well_known_systems(self) -> "VectorGeometryToolWellKnownSystems":
        """Return the most commonly used systems (e.g. Sun Fixed, Earth Fixed, etc.)."""
        return self._intf.get_property(AnalysisWorkbenchRoot._metadata, AnalysisWorkbenchRoot._get_well_known_systems_metadata)

    _get_well_known_axes_metadata = { "offset" : _get_well_known_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def well_known_axes(self) -> "VectorGeometryToolWellKnownAxes":
        """Return the most commonly used axes (e.g. Sun ICRF, Earth Inertial, etc.)."""
        return self._intf.get_property(AnalysisWorkbenchRoot._metadata, AnalysisWorkbenchRoot._get_well_known_axes_metadata)

    _property_names[well_known_systems] = "well_known_systems"
    _property_names[well_known_axes] = "well_known_axes"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchRoot."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchRoot)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchRoot, [AnalysisWorkbenchRoot, ])

agcls.AgClassCatalog.add_catalog_entry((4987483468362517359, 13532663607263998902), AnalysisWorkbenchRoot)
agcls.AgTypeNameMap["AnalysisWorkbenchRoot"] = AnalysisWorkbenchRoot

class VectorGeometryToolWellKnownEarthSystems(SupportsDeleteCallback):
    """Well-known Earth's coordinate systems."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_fixed_method_offset = 1
    _get_icrf_method_offset = 2
    _get_inertial_method_offset = 3
    _metadata = {
        "iid_data" : (4710478852462905673, 1995567772504852135),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolWellKnownEarthSystems)
    
    _get_fixed_metadata = { "offset" : _get_fixed_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolSystem":
        """Earth's Fixed coordinate system."""
        return self._intf.get_property(VectorGeometryToolWellKnownEarthSystems._metadata, VectorGeometryToolWellKnownEarthSystems._get_fixed_metadata)

    _get_icrf_metadata = { "offset" : _get_icrf_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolSystem":
        """Earth's ICRF."""
        return self._intf.get_property(VectorGeometryToolWellKnownEarthSystems._metadata, VectorGeometryToolWellKnownEarthSystems._get_icrf_metadata)

    _get_inertial_metadata = { "offset" : _get_inertial_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolSystem":
        """Earth's Inertial coordinate system (as defined in STK)."""
        return self._intf.get_property(VectorGeometryToolWellKnownEarthSystems._metadata, VectorGeometryToolWellKnownEarthSystems._get_inertial_metadata)

    _property_names[fixed] = "fixed"
    _property_names[icrf] = "icrf"
    _property_names[inertial] = "inertial"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolWellKnownEarthSystems."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolWellKnownEarthSystems)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownEarthSystems, [VectorGeometryToolWellKnownEarthSystems, ])

agcls.AgClassCatalog.add_catalog_entry((5520983060648290956, 1872839778996467101), VectorGeometryToolWellKnownEarthSystems)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownEarthSystems"] = VectorGeometryToolWellKnownEarthSystems

class VectorGeometryToolWellKnownEarthAxes(SupportsDeleteCallback):
    """Well-known Earth's axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_fixed_method_offset = 1
    _get_icrf_method_offset = 2
    _get_inertial_method_offset = 3
    _get_j2000_method_offset = 4
    _metadata = {
        "iid_data" : (5483010606787155483, 17339470825221630117),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolWellKnownEarthAxes)
    
    _get_fixed_metadata = { "offset" : _get_fixed_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolAxes":
        """Earth's Fixed axes."""
        return self._intf.get_property(VectorGeometryToolWellKnownEarthAxes._metadata, VectorGeometryToolWellKnownEarthAxes._get_fixed_metadata)

    _get_icrf_metadata = { "offset" : _get_icrf_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolAxes":
        """Earth's ICRF axes."""
        return self._intf.get_property(VectorGeometryToolWellKnownEarthAxes._metadata, VectorGeometryToolWellKnownEarthAxes._get_icrf_metadata)

    _get_inertial_metadata = { "offset" : _get_inertial_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolAxes":
        """Earth's Inertial axes (as defined in STK)."""
        return self._intf.get_property(VectorGeometryToolWellKnownEarthAxes._metadata, VectorGeometryToolWellKnownEarthAxes._get_inertial_metadata)

    _get_j2000_metadata = { "offset" : _get_j2000_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def j2000(self) -> "IVectorGeometryToolAxes":
        """The Earth's J2000 axes."""
        return self._intf.get_property(VectorGeometryToolWellKnownEarthAxes._metadata, VectorGeometryToolWellKnownEarthAxes._get_j2000_metadata)

    _property_names[fixed] = "fixed"
    _property_names[icrf] = "icrf"
    _property_names[inertial] = "inertial"
    _property_names[j2000] = "j2000"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolWellKnownEarthAxes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolWellKnownEarthAxes)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownEarthAxes, [VectorGeometryToolWellKnownEarthAxes, ])

agcls.AgClassCatalog.add_catalog_entry((5725997874657667260, 6446994798152480914), VectorGeometryToolWellKnownEarthAxes)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownEarthAxes"] = VectorGeometryToolWellKnownEarthAxes

class VectorGeometryToolWellKnownSunSystems(SupportsDeleteCallback):
    """The Sun's well-known coordinate reference systems."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_fixed_method_offset = 1
    _get_icrf_method_offset = 2
    _get_inertial_method_offset = 3
    _get_j2000_method_offset = 4
    _get_barycenter_method_offset = 5
    _metadata = {
        "iid_data" : (4865958749773106719, 13197055767931333526),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolWellKnownSunSystems)
    
    _get_fixed_metadata = { "offset" : _get_fixed_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolSystem":
        """The Sun's Fixed coordinate system."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunSystems._metadata, VectorGeometryToolWellKnownSunSystems._get_fixed_metadata)

    _get_icrf_metadata = { "offset" : _get_icrf_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolSystem":
        """The Sun's International Celestial Reference Frame (ICRF)."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunSystems._metadata, VectorGeometryToolWellKnownSunSystems._get_icrf_metadata)

    _get_inertial_metadata = { "offset" : _get_inertial_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolSystem":
        """The Sun's Inertial coordinate system (as defined in STK)."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunSystems._metadata, VectorGeometryToolWellKnownSunSystems._get_inertial_metadata)

    _get_j2000_metadata = { "offset" : _get_j2000_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def j2000(self) -> "IVectorGeometryToolSystem":
        """The Sun's J2000 coordinate system."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunSystems._metadata, VectorGeometryToolWellKnownSunSystems._get_j2000_metadata)

    _get_barycenter_metadata = { "offset" : _get_barycenter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def barycenter(self) -> "IVectorGeometryToolSystem":
        """The Inertial system at the Sun's barycenter."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunSystems._metadata, VectorGeometryToolWellKnownSunSystems._get_barycenter_metadata)

    _property_names[fixed] = "fixed"
    _property_names[icrf] = "icrf"
    _property_names[inertial] = "inertial"
    _property_names[j2000] = "j2000"
    _property_names[barycenter] = "barycenter"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolWellKnownSunSystems."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolWellKnownSunSystems)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownSunSystems, [VectorGeometryToolWellKnownSunSystems, ])

agcls.AgClassCatalog.add_catalog_entry((5186430568461414454, 3037754309494668210), VectorGeometryToolWellKnownSunSystems)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownSunSystems"] = VectorGeometryToolWellKnownSunSystems

class VectorGeometryToolWellKnownSunAxes(SupportsDeleteCallback):
    """Well-known Sun's axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_fixed_method_offset = 1
    _get_icrf_method_offset = 2
    _get_inertial_method_offset = 3
    _get_j2000_method_offset = 4
    _metadata = {
        "iid_data" : (4663702446183210292, 13434367744902099591),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolWellKnownSunAxes)
    
    _get_fixed_metadata = { "offset" : _get_fixed_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolAxes":
        """Sun's Fixed axes."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunAxes._metadata, VectorGeometryToolWellKnownSunAxes._get_fixed_metadata)

    _get_icrf_metadata = { "offset" : _get_icrf_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolAxes":
        """Sun's ICRF."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunAxes._metadata, VectorGeometryToolWellKnownSunAxes._get_icrf_metadata)

    _get_inertial_metadata = { "offset" : _get_inertial_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolAxes":
        """Sun's Inertial axes (as defined in STK)."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunAxes._metadata, VectorGeometryToolWellKnownSunAxes._get_inertial_metadata)

    _get_j2000_metadata = { "offset" : _get_j2000_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def j2000(self) -> "IVectorGeometryToolAxes":
        """The Sun's J2000 axes."""
        return self._intf.get_property(VectorGeometryToolWellKnownSunAxes._metadata, VectorGeometryToolWellKnownSunAxes._get_j2000_metadata)

    _property_names[fixed] = "fixed"
    _property_names[icrf] = "icrf"
    _property_names[inertial] = "inertial"
    _property_names[j2000] = "j2000"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolWellKnownSunAxes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolWellKnownSunAxes)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownSunAxes, [VectorGeometryToolWellKnownSunAxes, ])

agcls.AgClassCatalog.add_catalog_entry((5738861708789180979, 4473323686545115808), VectorGeometryToolWellKnownSunAxes)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownSunAxes"] = VectorGeometryToolWellKnownSunAxes

class VectorGeometryToolWellKnownSystems(SupportsDeleteCallback):
    """Well-known coordinate reference systems."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_earth_method_offset = 1
    _get_sun_method_offset = 2
    _metadata = {
        "iid_data" : (5557675413947050863, 3127155599466724282),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolWellKnownSystems)
    
    _get_earth_metadata = { "offset" : _get_earth_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def earth(self) -> "VectorGeometryToolWellKnownEarthSystems":
        """Earth's coordinate reference systems."""
        return self._intf.get_property(VectorGeometryToolWellKnownSystems._metadata, VectorGeometryToolWellKnownSystems._get_earth_metadata)

    _get_sun_metadata = { "offset" : _get_sun_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sun(self) -> "VectorGeometryToolWellKnownSunSystems":
        """The Sun's coordinate reference systems."""
        return self._intf.get_property(VectorGeometryToolWellKnownSystems._metadata, VectorGeometryToolWellKnownSystems._get_sun_metadata)

    _property_names[earth] = "earth"
    _property_names[sun] = "sun"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolWellKnownSystems."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolWellKnownSystems)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownSystems, [VectorGeometryToolWellKnownSystems, ])

agcls.AgClassCatalog.add_catalog_entry((4917156588932891059, 738175831204011941), VectorGeometryToolWellKnownSystems)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownSystems"] = VectorGeometryToolWellKnownSystems

class VectorGeometryToolWellKnownAxes(SupportsDeleteCallback):
    """Well-known Axes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_earth_method_offset = 1
    _get_sun_method_offset = 2
    _metadata = {
        "iid_data" : (5699529717700651363, 14210241021739064977),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, VectorGeometryToolWellKnownAxes)
    
    _get_earth_metadata = { "offset" : _get_earth_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def earth(self) -> "VectorGeometryToolWellKnownEarthAxes":
        """Earth's well-known axes."""
        return self._intf.get_property(VectorGeometryToolWellKnownAxes._metadata, VectorGeometryToolWellKnownAxes._get_earth_metadata)

    _get_sun_metadata = { "offset" : _get_sun_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sun(self) -> "VectorGeometryToolWellKnownSunAxes":
        """The Sun's well-known axes."""
        return self._intf.get_property(VectorGeometryToolWellKnownAxes._metadata, VectorGeometryToolWellKnownAxes._get_sun_metadata)

    _property_names[earth] = "earth"
    _property_names[sun] = "sun"

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorGeometryToolWellKnownAxes."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, VectorGeometryToolWellKnownAxes)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownAxes, [VectorGeometryToolWellKnownAxes, ])

agcls.AgClassCatalog.add_catalog_entry((5448146556058645578, 7798730398512524450), VectorGeometryToolWellKnownAxes)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownAxes"] = VectorGeometryToolWellKnownAxes

class AnalysisWorkbenchMethodCallAngleFindResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindResult, SupportsDeleteCallback):
    """Represents result returned with IVectorGeometryToolAngle.FindCoordinates method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAngleFindResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindResult])

agcls.AgClassCatalog.add_catalog_entry((5338744576563927160, 2966521297346615686), AnalysisWorkbenchMethodCallAngleFindResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindResult"] = AnalysisWorkbenchMethodCallAngleFindResult

class AnalysisWorkbenchMethodCallAngleFindWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolAngle.FindCoordinatesWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAngleFindWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((5683985578297816291, 14320833342729481856), AnalysisWorkbenchMethodCallAngleFindWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindWithRateResult"] = AnalysisWorkbenchMethodCallAngleFindWithRateResult

class AnalysisWorkbenchMethodCallAxesTransformResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFrom method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAxesTransformResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesTransformResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesTransformResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesTransformResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformResult])

agcls.AgClassCatalog.add_catalog_entry((4776430414755889351, 925017437207209092), AnalysisWorkbenchMethodCallAxesTransformResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesTransformResult"] = AnalysisWorkbenchMethodCallAxesTransformResult

class AnalysisWorkbenchMethodCallAxesTransformWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFromWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAxesTransformWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesTransformWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesTransformWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesTransformWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((5551248800008965786, 9162399115088396946), AnalysisWorkbenchMethodCallAxesTransformWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesTransformWithRateResult"] = AnalysisWorkbenchMethodCallAxesTransformWithRateResult

class AnalysisWorkbenchMethodCallAxesFindInAxesResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxes method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAxesFindInAxesResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesFindInAxesResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesResult])

agcls.AgClassCatalog.add_catalog_entry((5174479259770279351, 3364511849778566074), AnalysisWorkbenchMethodCallAxesFindInAxesResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesFindInAxesResult"] = AnalysisWorkbenchMethodCallAxesFindInAxesResult

class AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxesWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((5737719566038969118, 88673256768790167), AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult"] = AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult

class AnalysisWorkbenchMethodCallPlaneFindInAxesResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxes method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallPlaneFindInAxesResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInAxesResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesResult])

agcls.AgClassCatalog.add_catalog_entry((5573313095156225739, 2162996710023035835), AnalysisWorkbenchMethodCallPlaneFindInAxesResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInAxesResult"] = AnalysisWorkbenchMethodCallPlaneFindInAxesResult

class AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxesWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((5753478954477836794, 2404139334665332140), AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult"] = AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult

class AnalysisWorkbenchMethodCallPlaneFindInSystemResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystem method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallPlaneFindInSystemResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInSystemResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemResult])

agcls.AgClassCatalog.add_catalog_entry((4975921903591042021, 6262793899525063358), AnalysisWorkbenchMethodCallPlaneFindInSystemResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInSystemResult"] = AnalysisWorkbenchMethodCallPlaneFindInSystemResult

class AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystemWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInSystemWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInSystemWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((5341422434034558608, 8015115794607794853), AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult"] = AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult

class AnalysisWorkbenchMethodCallPointLocateInSystemResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystemWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallPointLocateInSystemResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPointLocateInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPointLocateInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPointLocateInSystemResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemResult])

agcls.AgClassCatalog.add_catalog_entry((4675192971753711238, 4056422737239134394), AnalysisWorkbenchMethodCallPointLocateInSystemResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPointLocateInSystemResult"] = AnalysisWorkbenchMethodCallPointLocateInSystemResult

class AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolPoint.LocateInSystemWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPointLocateInSystemWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPointLocateInSystemWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((4771085085991853208, 16712650806298139816), AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult"] = AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult

class AnalysisWorkbenchMethodCallSystemTransformResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFrom and IVectorGeometryToolSystem.TransformTo methods."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallSystemTransformResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemTransformResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolSystemTransformResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallSystemTransformResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformResult])

agcls.AgClassCatalog.add_catalog_entry((4732248531040369310, 11519390737172858259), AnalysisWorkbenchMethodCallSystemTransformResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallSystemTransformResult"] = AnalysisWorkbenchMethodCallSystemTransformResult

class AnalysisWorkbenchMethodCallSystemTransformWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFromWithRate and IVectorGeometryToolSystem.TransformToWithRate methods."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallSystemTransformWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemTransformWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolSystemTransformWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallSystemTransformWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((4773661828698350098, 14241460882684623754), AnalysisWorkbenchMethodCallSystemTransformWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallSystemTransformWithRateResult"] = AnalysisWorkbenchMethodCallSystemTransformWithRateResult

class AnalysisWorkbenchMethodCallSystemFindInSystemResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemFindInSystemResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolSystem.FindInSystem method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallSystemFindInSystemResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemFindInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolSystemFindInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallSystemFindInSystemResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemFindInSystemResult])

agcls.AgClassCatalog.add_catalog_entry((4901836917752659950, 3314518124226065597), AnalysisWorkbenchMethodCallSystemFindInSystemResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallSystemFindInSystemResult"] = AnalysisWorkbenchMethodCallSystemFindInSystemResult

class AnalysisWorkbenchMethodCallVectorFindInAxesResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxes method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallVectorFindInAxesResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolVectorFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolVectorFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallVectorFindInAxesResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesResult])

agcls.AgClassCatalog.add_catalog_entry((5305219641346644613, 3358734389861877669), AnalysisWorkbenchMethodCallVectorFindInAxesResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallVectorFindInAxesResult"] = AnalysisWorkbenchMethodCallVectorFindInAxesResult

class AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxesWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolVectorFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolVectorFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((5526758868339235638, 15327334100431991214), AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult"] = AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult

class AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleWithRateResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngleWithRate method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindAngleWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindAngleWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleWithRateResult])

agcls.AgClassCatalog.add_catalog_entry((4649475226236495161, 15745033739960350352), AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult"] = AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult

class AnalysisWorkbenchMethodCallAngleFindAngleResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleResult, SupportsDeleteCallback):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngle method."""
    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchMethodCallAngleFindAngleResult."""
        SupportsDeleteCallback.__init__(self)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindAngleResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindAngleResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindAngleResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleResult])

agcls.AgClassCatalog.add_catalog_entry((5703953535685278056, 1024662027560619958), AnalysisWorkbenchMethodCallAngleFindAngleResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindAngleResult"] = AnalysisWorkbenchMethodCallAngleFindAngleResult

class TimeToolInterval(SupportsDeleteCallback):
    """The interface represents an interval."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_start_method_offset = 1
    _get_stop_method_offset = 2
    _metadata = {
        "iid_data" : (5653501599416332732, 4402036093091942545),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolInterval)
    
    _get_start_metadata = { "offset" : _get_start_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def start(self) -> typing.Any:
        """The interval's start time."""
        return self._intf.get_property(TimeToolInterval._metadata, TimeToolInterval._get_start_metadata)

    _get_stop_metadata = { "offset" : _get_stop_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def stop(self) -> typing.Any:
        """The interval's stop time."""
        return self._intf.get_property(TimeToolInterval._metadata, TimeToolInterval._get_stop_metadata)

    _property_names[start] = "start"
    _property_names[stop] = "stop"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolInterval."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolInterval)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolInterval, [TimeToolInterval, ])

agcls.AgClassCatalog.add_catalog_entry((5110544547728130172, 9746137490123278240), TimeToolInterval)
agcls.AgTypeNameMap["TimeToolInterval"] = TimeToolInterval

class TimeToolIntervalCollection(SupportsDeleteCallback):
    """The interface represents a collection of intervals."""

    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (4991188993072027394, 12329114457855179136),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolIntervalCollection)
    def __iter__(self):
        """Create an iterator for the TimeToolIntervalCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "TimeToolInterval":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(TimeToolIntervalCollection._metadata, TimeToolIntervalCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "TimeToolInterval":
        """Return an interval at a specified index."""
        return self._intf.invoke(TimeToolIntervalCollection._metadata, TimeToolIntervalCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolIntervalCollection._metadata, TimeToolIntervalCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolIntervalCollection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolIntervalCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolIntervalCollection, [TimeToolIntervalCollection, ])

agcls.AgClassCatalog.add_catalog_entry((5721855665807758542, 12102008155485723271), TimeToolIntervalCollection)
agcls.AgTypeNameMap["TimeToolIntervalCollection"] = TimeToolIntervalCollection

class AnalysisWorkbenchCentralBody(SupportsDeleteCallback):
    """The interface represents a central body."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_name_method_offset = 1
    _metadata = {
        "iid_data" : (5605880252896253198, 15894328407293903524),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchCentralBody)
    
    _get_name_metadata = { "offset" : _get_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def name(self) -> str:
        """A name of the central body."""
        return self._intf.get_property(AnalysisWorkbenchCentralBody._metadata, AnalysisWorkbenchCentralBody._get_name_metadata)

    _property_names[name] = "name"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchCentralBody."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchCentralBody)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCentralBody, [AnalysisWorkbenchCentralBody, ])

agcls.AgClassCatalog.add_catalog_entry((4920377372252981471, 2995698768068563878), AnalysisWorkbenchCentralBody)
agcls.AgTypeNameMap["AnalysisWorkbenchCentralBody"] = AnalysisWorkbenchCentralBody

class AnalysisWorkbenchCentralBodyRefTo(IAnalysisWorkbenchRefTo, SupportsDeleteCallback):
    """Represents a reference to a VGT CentralBody."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_path_method_offset = 1
    _set_central_body_method_offset = 2
    _get_central_body_method_offset = 3
    _metadata = {
        "iid_data" : (4901691415447825012, 18175271878169526149),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchCentralBodyRefTo)
    
    _set_path_metadata = { "offset" : _set_path_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def set_path(self, path:str) -> None:
        """Set a new central body using specified path."""
        return self._intf.invoke(AnalysisWorkbenchCentralBodyRefTo._metadata, AnalysisWorkbenchCentralBodyRefTo._set_path_metadata, path)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("AnalysisWorkbenchCentralBody"),) }
    def set_central_body(self, centralBody:"AnalysisWorkbenchCentralBody") -> None:
        """Set a new central body."""
        return self._intf.invoke(AnalysisWorkbenchCentralBodyRefTo._metadata, AnalysisWorkbenchCentralBodyRefTo._set_central_body_metadata, centralBody)

    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def get_central_body(self) -> "AnalysisWorkbenchCentralBody":
        """Return a central body or null if the central body is invalid."""
        return self._intf.invoke(AnalysisWorkbenchCentralBodyRefTo._metadata, AnalysisWorkbenchCentralBodyRefTo._get_central_body_metadata, OutArg())


    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchCentralBodyRefTo."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchCentralBodyRefTo)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCentralBodyRefTo, [AnalysisWorkbenchCentralBodyRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry((5340102991488887384, 6469328972034659504), AnalysisWorkbenchCentralBodyRefTo)
agcls.AgTypeNameMap["AnalysisWorkbenchCentralBodyRefTo"] = AnalysisWorkbenchCentralBodyRefTo

class AnalysisWorkbenchCentralBodyCollection(SupportsDeleteCallback):
    """A collection of central body names."""

    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _add_method_offset = 4
    _remove_method_offset = 5
    _metadata = {
        "iid_data" : (5402404744674331130, 9115936032301068435),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchCentralBodyCollection)
    def __iter__(self):
        """Create an iterator for the AnalysisWorkbenchCentralBodyCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> str:
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(AnalysisWorkbenchCentralBodyCollection._metadata, AnalysisWorkbenchCentralBodyCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.LongArg, agmarshall.BStrArg,) }
    def item(self, index:int) -> str:
        """Return a central body name at a specified index."""
        return self._intf.invoke(AnalysisWorkbenchCentralBodyCollection._metadata, AnalysisWorkbenchCentralBodyCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(AnalysisWorkbenchCentralBodyCollection._metadata, AnalysisWorkbenchCentralBodyCollection._get__NewEnum_metadata)

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def add(self, centralBodyName:str) -> bool:
        """Add a central body to the collection of central bodies. True indicates success."""
        return self._intf.invoke(AnalysisWorkbenchCentralBodyCollection._metadata, AnalysisWorkbenchCentralBodyCollection._add_metadata, centralBodyName, OutArg())

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def remove(self, centralBodyName:str) -> None:
        """Remove a central body with the specified name from the collection of the central bodies."""
        return self._intf.invoke(AnalysisWorkbenchCentralBodyCollection._metadata, AnalysisWorkbenchCentralBodyCollection._remove_metadata, centralBodyName)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchCentralBodyCollection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchCentralBodyCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCentralBodyCollection, [AnalysisWorkbenchCentralBodyCollection, ])

agcls.AgClassCatalog.add_catalog_entry((4794614344527977359, 14146463188074571153), AnalysisWorkbenchCentralBodyCollection)
agcls.AgTypeNameMap["AnalysisWorkbenchCentralBodyCollection"] = AnalysisWorkbenchCentralBodyCollection

class AnalysisWorkbenchCollection(SupportsDeleteCallback):
    """A collection of VGT objects."""

    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _contains_method_offset = 1
    _get_count_method_offset = 2
    _item_method_offset = 3
    _get__NewEnum_method_offset = 4
    _get_item_by_index_method_offset = 5
    _get_item_by_name_method_offset = 6
    _metadata = {
        "iid_data" : (5267645902216178612, 12942001774476864927),
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, AnalysisWorkbenchCollection)
    def __iter__(self):
        """Create an iterator for the AnalysisWorkbenchCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAnalysisWorkbenchComponent":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(AnalysisWorkbenchCollection._metadata, AnalysisWorkbenchCollection._contains_metadata, name, OutArg())

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(AnalysisWorkbenchCollection._metadata, AnalysisWorkbenchCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.Variant, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantArg, agmarshall.InterfaceOutArg,) }
    def item(self, indexOrName:typing.Any) -> "IAnalysisWorkbenchComponent":
        """Retrieve an element of the collection using the name of the element or a position in the collection."""
        return self._intf.invoke(AnalysisWorkbenchCollection._metadata, AnalysisWorkbenchCollection._item_metadata, indexOrName, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(AnalysisWorkbenchCollection._metadata, AnalysisWorkbenchCollection._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "offset" : _get_item_by_index_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_index(self, index:int) -> "IAnalysisWorkbenchComponent":
        """Retrieve an item from the crdn collection by index."""
        return self._intf.invoke(AnalysisWorkbenchCollection._metadata, AnalysisWorkbenchCollection._get_item_by_index_metadata, index, OutArg())

    _get_item_by_name_metadata = { "offset" : _get_item_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_name(self, name:str) -> "IAnalysisWorkbenchComponent":
        """Retrieve an item from the crdn collection by name."""
        return self._intf.invoke(AnalysisWorkbenchCollection._metadata, AnalysisWorkbenchCollection._get_item_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type AnalysisWorkbenchCollection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, AnalysisWorkbenchCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCollection, [AnalysisWorkbenchCollection, ])

agcls.AgClassCatalog.add_catalog_entry((5079329608783990074, 10222245566471765161), AnalysisWorkbenchCollection)
agcls.AgTypeNameMap["AnalysisWorkbenchCollection"] = AnalysisWorkbenchCollection

class TimeToolPointSamplingResult(SupportsDeleteCallback):
    """Contains tabulated positions and velocities of a point created by Sample method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_intervals_method_offset = 2
    _metadata = {
        "iid_data" : (4621238482322447175, 1700458122111206846),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolPointSamplingResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolPointSamplingResult._metadata, TimeToolPointSamplingResult._get_is_valid_metadata)

    _get_intervals_metadata = { "offset" : _get_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def intervals(self) -> "TimeToolPointSamplingIntervalCollection":
        """A collection of sampling intervals."""
        return self._intf.get_property(TimeToolPointSamplingResult._metadata, TimeToolPointSamplingResult._get_intervals_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[intervals] = "intervals"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolPointSamplingResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolPointSamplingResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolPointSamplingResult, [TimeToolPointSamplingResult, ])

agcls.AgClassCatalog.add_catalog_entry((5583924698373366089, 2165026541174367877), TimeToolPointSamplingResult)
agcls.AgTypeNameMap["TimeToolPointSamplingResult"] = TimeToolPointSamplingResult

class TimeToolPointSamplingInterval(SupportsDeleteCallback):
    """The interface represents an interval with the time, position and velocity arrays."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_times_method_offset = 1
    _get_positions_method_offset = 2
    _get_velocities_method_offset = 3
    _get_start_method_offset = 4
    _get_stop_method_offset = 5
    _metadata = {
        "iid_data" : (5591284094447967730, 3613680757386286218),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolPointSamplingInterval)
    
    _get_times_metadata = { "offset" : _get_times_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def times(self) -> list:
        """A time array associated with the interval."""
        return self._intf.get_property(TimeToolPointSamplingInterval._metadata, TimeToolPointSamplingInterval._get_times_metadata)

    _get_positions_metadata = { "offset" : _get_positions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def positions(self) -> list:
        """An array of 3-tuples each tuple representing the point's cartesian position (x,y,z)."""
        return self._intf.get_property(TimeToolPointSamplingInterval._metadata, TimeToolPointSamplingInterval._get_positions_metadata)

    _get_velocities_metadata = { "offset" : _get_velocities_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def velocities(self) -> list:
        """An array of velocities."""
        return self._intf.get_property(TimeToolPointSamplingInterval._metadata, TimeToolPointSamplingInterval._get_velocities_metadata)

    _get_start_metadata = { "offset" : _get_start_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def start(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(TimeToolPointSamplingInterval._metadata, TimeToolPointSamplingInterval._get_start_metadata)

    _get_stop_metadata = { "offset" : _get_stop_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def stop(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(TimeToolPointSamplingInterval._metadata, TimeToolPointSamplingInterval._get_stop_metadata)

    _property_names[times] = "times"
    _property_names[positions] = "positions"
    _property_names[velocities] = "velocities"
    _property_names[start] = "start"
    _property_names[stop] = "stop"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolPointSamplingInterval."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolPointSamplingInterval)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolPointSamplingInterval, [TimeToolPointSamplingInterval, ])

agcls.AgClassCatalog.add_catalog_entry((4785358452219528936, 17228713367816098194), TimeToolPointSamplingInterval)
agcls.AgTypeNameMap["TimeToolPointSamplingInterval"] = TimeToolPointSamplingInterval

class TimeToolPointSamplingIntervalCollection(SupportsDeleteCallback):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5530358145792459749, 592623579709177530),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolPointSamplingIntervalCollection)
    def __iter__(self):
        """Create an iterator for the TimeToolPointSamplingIntervalCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "TimeToolPointSamplingInterval":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(TimeToolPointSamplingIntervalCollection._metadata, TimeToolPointSamplingIntervalCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "TimeToolPointSamplingInterval":
        """Access an element at the specified position."""
        return self._intf.invoke(TimeToolPointSamplingIntervalCollection._metadata, TimeToolPointSamplingIntervalCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolPointSamplingIntervalCollection._metadata, TimeToolPointSamplingIntervalCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolPointSamplingIntervalCollection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolPointSamplingIntervalCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolPointSamplingIntervalCollection, [TimeToolPointSamplingIntervalCollection, ])

agcls.AgClassCatalog.add_catalog_entry((5287350835476231857, 6426093684585889170), TimeToolPointSamplingIntervalCollection)
agcls.AgTypeNameMap["TimeToolPointSamplingIntervalCollection"] = TimeToolPointSamplingIntervalCollection

class TimeToolAxesSamplingResult(SupportsDeleteCallback):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_valid_method_offset = 1
    _get_intervals_method_offset = 2
    _metadata = {
        "iid_data" : (4642131052752284166, 17374449711146834072),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolAxesSamplingResult)
    
    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(TimeToolAxesSamplingResult._metadata, TimeToolAxesSamplingResult._get_is_valid_metadata)

    _get_intervals_metadata = { "offset" : _get_intervals_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def intervals(self) -> "TimeToolAxesSamplingIntervalCollection":
        """A collection of sampling intervals."""
        return self._intf.get_property(TimeToolAxesSamplingResult._metadata, TimeToolAxesSamplingResult._get_intervals_metadata)

    _property_names[is_valid] = "is_valid"
    _property_names[intervals] = "intervals"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolAxesSamplingResult."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolAxesSamplingResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolAxesSamplingResult, [TimeToolAxesSamplingResult, ])

agcls.AgClassCatalog.add_catalog_entry((5514187429032108392, 5428366094586886549), TimeToolAxesSamplingResult)
agcls.AgTypeNameMap["TimeToolAxesSamplingResult"] = TimeToolAxesSamplingResult

class TimeToolAxesSamplingInterval(SupportsDeleteCallback):
    """The interface represents an interval with the time, orientation and velocity arrays."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_times_method_offset = 1
    _get_quaternions_method_offset = 2
    _get_velocities_method_offset = 3
    _get_start_method_offset = 4
    _get_stop_method_offset = 5
    _metadata = {
        "iid_data" : (5256164116345950850, 14989044375958505861),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolAxesSamplingInterval)
    
    _get_times_metadata = { "offset" : _get_times_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def times(self) -> list:
        """A time array associated with the interval."""
        return self._intf.get_property(TimeToolAxesSamplingInterval._metadata, TimeToolAxesSamplingInterval._get_times_metadata)

    _get_quaternions_metadata = { "offset" : _get_quaternions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def quaternions(self) -> list:
        """An array of 4-tuples each tuple representing the orientation of the axes as a quaternion (q1,q2,q3,q4)."""
        return self._intf.get_property(TimeToolAxesSamplingInterval._metadata, TimeToolAxesSamplingInterval._get_quaternions_metadata)

    _get_velocities_metadata = { "offset" : _get_velocities_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def velocities(self) -> list:
        """An array of angular velocities."""
        return self._intf.get_property(TimeToolAxesSamplingInterval._metadata, TimeToolAxesSamplingInterval._get_velocities_metadata)

    _get_start_metadata = { "offset" : _get_start_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def start(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(TimeToolAxesSamplingInterval._metadata, TimeToolAxesSamplingInterval._get_start_metadata)

    _get_stop_metadata = { "offset" : _get_stop_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def stop(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(TimeToolAxesSamplingInterval._metadata, TimeToolAxesSamplingInterval._get_stop_metadata)

    _property_names[times] = "times"
    _property_names[quaternions] = "quaternions"
    _property_names[velocities] = "velocities"
    _property_names[start] = "start"
    _property_names[stop] = "stop"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolAxesSamplingInterval."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolAxesSamplingInterval)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolAxesSamplingInterval, [TimeToolAxesSamplingInterval, ])

agcls.AgClassCatalog.add_catalog_entry((5352164953331321351, 3394555340664015013), TimeToolAxesSamplingInterval)
agcls.AgTypeNameMap["TimeToolAxesSamplingInterval"] = TimeToolAxesSamplingInterval

class TimeToolAxesSamplingIntervalCollection(SupportsDeleteCallback):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5710623310116775291, 12435953586864494518),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def _get_property(self, attrname):
        return get_interface_property(attrname, TimeToolAxesSamplingIntervalCollection)
    def __iter__(self):
        """Create an iterator for the TimeToolAxesSamplingIntervalCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "TimeToolAxesSamplingInterval":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(TimeToolAxesSamplingIntervalCollection._metadata, TimeToolAxesSamplingIntervalCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "TimeToolAxesSamplingInterval":
        """Access an element at the specified position."""
        return self._intf.invoke(TimeToolAxesSamplingIntervalCollection._metadata, TimeToolAxesSamplingIntervalCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return a COM enumerator."""
        return self._intf.get_property(TimeToolAxesSamplingIntervalCollection._metadata, TimeToolAxesSamplingIntervalCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeToolAxesSamplingIntervalCollection."""
        SupportsDeleteCallback.__init__(self)
        initialize_from_source_object(self, sourceObject, TimeToolAxesSamplingIntervalCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeToolAxesSamplingIntervalCollection, [TimeToolAxesSamplingIntervalCollection, ])

agcls.AgClassCatalog.add_catalog_entry((5527858769336517270, 17257249824002230947), TimeToolAxesSamplingIntervalCollection)
agcls.AgTypeNameMap["TimeToolAxesSamplingIntervalCollection"] = TimeToolAxesSamplingIntervalCollection


################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################
