################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = ["AgECrdnAngleType", "AgECrdnAxesType", "AgECrdnCalcScalarType", "AgECrdnConditionCombinedOperationType", "AgECrdnConditionSetType", 
"AgECrdnConditionThresholdOption", "AgECrdnConditionType", "AgECrdnDimensionInheritance", "AgECrdnDirectionType", "AgECrdnDisplayAxisSelector", 
"AgECrdnEventArrayFilterType", "AgECrdnEventArrayType", "AgECrdnEventIntervalCollectionType", "AgECrdnEventIntervalListType", 
"AgECrdnEventIntervalType", "AgECrdnEventListMergeOperation", "AgECrdnEventType", "AgECrdnExtremumConstants", "AgECrdnFileInterpolatorType", 
"AgECrdnIntegralType", "AgECrdnIntegrationWindowType", "AgECrdnInterpolatorType", "AgECrdnIntersectionSurface", "AgECrdnIntervalDurationKind", 
"AgECrdnIntervalSelection", "AgECrdnKind", "AgECrdnLagrangeLibrationPointType", "AgECrdnMeanElementTheory", "AgECrdnParameterSetType", 
"AgECrdnPlaneType", "AgECrdnPointBPlaneType", "AgECrdnPointType", "AgECrdnPruneFilter", "AgECrdnQuadrantType", "AgECrdnReferenceShapeType", 
"AgECrdnSampledReferenceTime", "AgECrdnSamplingMethod", "AgECrdnSatisfactionCrossing", "AgECrdnSaveDataOption", "AgECrdnSignalPathReferenceSystem", 
"AgECrdnSignalSense", "AgECrdnSignedAngleType", "AgECrdnSmartEpochState", "AgECrdnSmartIntervalState", "AgECrdnSpeedOptions", 
"AgECrdnStartStopOption", "AgECrdnSurfaceType", "AgECrdnSweepMode", "AgECrdnSystemType", "AgECrdnThreshConvergeSense", "AgECrdnTrajectoryAxesType", 
"AgECrdnVectorComponentType", "AgECrdnVectorScaledDimensionInheritance", "AgECrdnVectorType", "AgECrdnVolumeAberrationType", 
"AgECrdnVolumeCalcAltitudeReferenceType", "AgECrdnVolumeCalcAngleOffVectorType", "AgECrdnVolumeCalcRangeDistanceType", "AgECrdnVolumeCalcRangeSpeedType", 
"AgECrdnVolumeCalcType", "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType", "AgECrdnVolumeCalcVolumeSatisfactionDurationType", 
"AgECrdnVolumeCalcVolumeSatisfactionFilterType", "AgECrdnVolumeCalcVolumeSatisfactionMetricType", "AgECrdnVolumeClockHostType", 
"AgECrdnVolumeCombinedOperationType", "AgECrdnVolumeFromGridEdgeType", "AgECrdnVolumeGridType", "AgECrdnVolumeLightingConditionsType", 
"AgECrdnVolumeOverTimeDurationType", "AgECrdnVolumeResultVectorRequest", "AgECrdnVolumeTimeSenseType", "AgECrdnVolumeType", 
"AgECrdnVolumetricGridValuesMethodType", "Angle", "AngleBetweenPlanes", "AngleBetweenVectors", "AngleDihedral", "AngleFactory", 
"AngleGroup", "AngleRefTo", "AngleRotation", "AngleToPlane", "Axes", "AxesAlignedAndConstrained", "AxesAngularOffset", "AxesAtTimeInstant", 
"AxesAttitudeFile", "AxesBPlane", "AxesCommonTasks", "AxesCustomScript", "AxesFactory", "AxesFixed", "AxesFixedAtEpoch", 
"AxesGroup", "AxesLabels", "AxesLagrangeLibration", "AxesModelAttach", "AxesOnSurface", "AxesPlugin", "AxesRefTo", "AxesSamplingInterval", 
"AxesSamplingIntervalCollection", "AxesSamplingResult", "AxesSpinning", "AxesTrajectory", "CalcScalar", "CalcScalarAngle", 
"CalcScalarConstant", "CalcScalarCustom", "CalcScalarDataElement", "CalcScalarDerivative", "CalcScalarDotProduct", "CalcScalarElapsedTime", 
"CalcScalarFactory", "CalcScalarFile", "CalcScalarFixedAtTimeInstant", "CalcScalarFunction", "CalcScalarFunction2Var", "CalcScalarGroup", 
"CalcScalarIntegral", "CalcScalarPlugin", "CalcScalarSurfaceDistanceBetweenPoints", "CalcScalarVectorComponent", "CalcScalarVectorMagnitude", 
"CentralBody", "CentralBodyCollection", "CentralBodyRefTo", "Collection", "Condition", "ConditionCombined", "ConditionFactory", 
"ConditionGroup", "ConditionPointInVolume", "ConditionScalarBounds", "ConditionSet", "ConditionSetEvaluateResult", "ConditionSetEvaluateWithRateResult", 
"ConditionSetFactory", "ConditionSetGroup", "ConditionSetScalarThresholds", "Converge", "ConvergeBasic", "Derivative", "DerivativeBasic", 
"EvaluateResult", "EvaluateWithRateResult", "Event", "EventArray", "EventArrayConditionCrossings", "EventArrayExtrema", 
"EventArrayFactory", "EventArrayFiltered", "EventArrayFixedStep", "EventArrayFixedTimes", "EventArrayGroup", "EventArrayMerged", 
"EventArraySignaled", "EventArrayStartStopTimes", "EventEpoch", "EventExtremum", "EventFactory", "EventFindOccurrenceResult", 
"EventGroup", "EventInterval", "EventIntervalBetweenTimeInstants", "EventIntervalCollection", "EventIntervalCollectionCondition", 
"EventIntervalCollectionFactory", "EventIntervalCollectionGroup", "EventIntervalCollectionLighting", "EventIntervalCollectionOccurredResult", 
"EventIntervalCollectionSignaled", "EventIntervalFactory", "EventIntervalFixed", "EventIntervalFixedDuration", "EventIntervalFromIntervalList", 
"EventIntervalGroup", "EventIntervalList", "EventIntervalListCondition", "EventIntervalListFactory", "EventIntervalListFile", 
"EventIntervalListFiltered", "EventIntervalListFixed", "EventIntervalListGroup", "EventIntervalListMerged", "EventIntervalListScaled", 
"EventIntervalListSignaled", "EventIntervalListTimeOffset", "EventIntervalResult", "EventIntervalScaled", "EventIntervalSignaled", 
"EventIntervalSmartInterval", "EventIntervalTimeOffset", "EventSignaled", "EventSmartEpoch", "EventStartStopTime", "EventTimeOffset", 
"FindTimesResult", "FirstIntervalsFilter", "GapsFilter", "Generic", "GridCoordinateDefinition", "GridValuesCustom", "GridValuesFixedNumberOfSteps", 
"GridValuesFixedStep", "GridValuesMethod", "IAngle", "IAngleBetweenPlanes", "IAngleBetweenVectors", "IAngleDihedral", "IAngleFactory", 
"IAngleFindAngleResult", "IAngleFindAngleWithRateResult", "IAngleFindResult", "IAngleFindWithRateResult", "IAngleGroup", 
"IAngleRefTo", "IAngleRotation", "IAngleToPlane", "IAxes", "IAxesAlignedAndConstrained", "IAxesAngularOffset", "IAxesAtTimeInstant", 
"IAxesAttitudeFile", "IAxesBPlane", "IAxesCommonTasks", "IAxesCustomScript", "IAxesFactory", "IAxesFindInAxesResult", "IAxesFindInAxesWithRateResult", 
"IAxesFixed", "IAxesFixedAtEpoch", "IAxesGroup", "IAxesLabels", "IAxesLagrangeLibration", "IAxesModelAttach", "IAxesOnSurface", 
"IAxesPlugin", "IAxesRefTo", "IAxesSamplingInterval", "IAxesSamplingIntervalCollection", "IAxesSamplingResult", "IAxesSpinning", 
"IAxesTrajectory", "IAxesTransformResult", "IAxesTransformWithRateResult", "ICalcScalar", "ICalcScalarAngle", "ICalcScalarConstant", 
"ICalcScalarCustom", "ICalcScalarDataElement", "ICalcScalarDerivative", "ICalcScalarDotProduct", "ICalcScalarElapsedTime", 
"ICalcScalarFactory", "ICalcScalarFile", "ICalcScalarFixedAtTimeInstant", "ICalcScalarFunction", "ICalcScalarFunction2Var", 
"ICalcScalarGroup", "ICalcScalarIntegral", "ICalcScalarPlugin", "ICalcScalarSurfaceDistanceBetweenPoints", "ICalcScalarVectorComponent", 
"ICalcScalarVectorMagnitude", "ICentralBody", "ICentralBodyCollection", "ICentralBodyRefTo", "ICollection", "ICondition", 
"IConditionCombined", "IConditionFactory", "IConditionGroup", "IConditionPointInVolume", "IConditionScalarBounds", "IConditionSet", 
"IConditionSetEvaluateResult", "IConditionSetEvaluateWithRateResult", "IConditionSetFactory", "IConditionSetGroup", "IConditionSetScalarThresholds", 
"IContext", "IConverge", "IConvergeBasic", "ICoordinate", "IDerivative", "IDerivativeBasic", "IEvaluateResult", "IEvaluateWithRateResult", 
"IEvent", "IEventArray", "IEventArrayConditionCrossings", "IEventArrayExtrema", "IEventArrayFactory", "IEventArrayFiltered", 
"IEventArrayFixedStep", "IEventArrayFixedTimes", "IEventArrayGroup", "IEventArrayMerged", "IEventArraySignaled", "IEventArrayStartStopTimes", 
"IEventEpoch", "IEventExtremum", "IEventFactory", "IEventFindOccurrenceResult", "IEventGroup", "IEventInterval", "IEventIntervalBetweenTimeInstants", 
"IEventIntervalCollection", "IEventIntervalCollectionCondition", "IEventIntervalCollectionFactory", "IEventIntervalCollectionGroup", 
"IEventIntervalCollectionLighting", "IEventIntervalCollectionOccurredResult", "IEventIntervalCollectionSignaled", "IEventIntervalFactory", 
"IEventIntervalFixed", "IEventIntervalFixedDuration", "IEventIntervalFromIntervalList", "IEventIntervalGroup", "IEventIntervalList", 
"IEventIntervalListCondition", "IEventIntervalListFactory", "IEventIntervalListFile", "IEventIntervalListFiltered", "IEventIntervalListFixed", 
"IEventIntervalListGroup", "IEventIntervalListMerged", "IEventIntervalListScaled", "IEventIntervalListSignaled", "IEventIntervalListTimeOffset", 
"IEventIntervalResult", "IEventIntervalScaled", "IEventIntervalSignaled", "IEventIntervalSmartInterval", "IEventIntervalTimeOffset", 
"IEventSignaled", "IEventSmartEpoch", "IEventStartStopTime", "IEventTimeOffset", "IFindTimesResult", "IFirstIntervalsFilter", 
"IGapsFilter", "IGridCoordinateDefinition", "IGridValuesCustom", "IGridValuesFixedNumberOfSteps", "IGridValuesFixedStep", 
"IGridValuesMethod", "IInstance", "IIntegral", "IIntegralBasic", "IInterp", "IInterpBasic", "IInterval", "IIntervalCollection", 
"IIntervalListResult", "IIntervalVectorCollection", "IIntervalsFilter", "IIntervalsVectorResult", "ILLAPosition", "ILastIntervalsFilter", 
"ILightTimeDelay", "IMethodCallResult", "IParameterSet", "IParameterSetAttitude", "IParameterSetFactory", "IParameterSetGroundTrajectory", 
"IParameterSetGroup", "IParameterSetOrbit", "IParameterSetTrajectory", "IParameterSetVector", "IPlane", "IPlaneFactory", 
"IPlaneFindInAxesResult", "IPlaneFindInAxesWithRateResult", "IPlaneFindInSystemResult", "IPlaneFindInSystemWithRateResult", 
"IPlaneGroup", "IPlaneLabels", "IPlaneNormal", "IPlaneQuadrant", "IPlaneRefTo", "IPlaneTrajectory", "IPlaneTriad", "IPlaneTwoVector", 
"IPoint", "IPointAtTimeInstant", "IPointBPlane", "IPointCBFixedOffset", "IPointCentBodyIntersect", "IPointCommonTasks", 
"IPointCovarianceGrazing", "IPointFactory", "IPointFile", "IPointFixedInSystem", "IPointGlint", "IPointGrazing", "IPointGroup", 
"IPointLagrangeLibration", "IPointLocateInSystemResult", "IPointLocateInSystemWithRateResult", "IPointModelAttach", "IPointOnSurface", 
"IPointPlaneIntersection", "IPointPlaneProjection", "IPointPlugin", "IPointRefTo", "IPointSamplingInterval", "IPointSamplingIntervalCollection", 
"IPointSamplingResult", "IPointSatelliteCollectionEntry", "IProvider", "IPruneFilter", "IPruneFilterFactory", "IRefTo", 
"IRelativeSatisfactionConditionFilter", "IRoot", "ISampling", "ISamplingBasic", "ISamplingCurvatureTolerance", "ISamplingFixedStep", 
"ISamplingMethod", "ISamplingMethodFactory", "ISamplingRelativeTolerance", "ISatisfactionConditionFilter", "ISignalDelay", 
"ISignalDelayBasic", "ISystem", "ISystemAssembled", "ISystemCommonTasks", "ISystemFactory", "ISystemFindInSystemResult", 
"ISystemGroup", "ISystemOnSurface", "ISystemRefTo", "ISystemTransformResult", "ISystemTransformWithRateResult", "ITemplate", 
"ITimeProperties", "ITypeInfo", "IVector", "IVectorAngleRate", "IVectorAngularVelocity", "IVectorApoapsis", "IVectorConing", 
"IVectorCross", "IVectorCustomScript", "IVectorDerivative", "IVectorDirectionToStar", "IVectorDispSurface", "IVectorDisplacement", 
"IVectorEccentricity", "IVectorFactory", "IVectorFindInAxesResult", "IVectorFindInAxesWithRateResult", "IVectorFixedAtEpoch", 
"IVectorFixedAtTimeInstant", "IVectorFixedInAxes", "IVectorGroup", "IVectorLineOfNodes", "IVectorLinearCombination", "IVectorModelAttach", 
"IVectorOrbitAngularMomentum", "IVectorOrbitNormal", "IVectorPeriapsis", "IVectorPlugin", "IVectorProjectAlongVector", "IVectorProjection", 
"IVectorRefTo", "IVectorReflection", "IVectorRotationVector", "IVectorScalarLinearCombination", "IVectorScalarScaled", "IVectorScaled", 
"IVectorTwoPlanesIntersection", "IVectorVelocityAcceleration", "IVolume", "IVolumeCalc", "IVolumeCalcAltitude", "IVolumeCalcAngleOffVector", 
"IVolumeCalcConditionSatMetric", "IVolumeCalcDelayRange", "IVolumeCalcFactory", "IVolumeCalcFile", "IVolumeCalcFromScalar", 
"IVolumeCalcGroup", "IVolumeCalcRange", "IVolumeCalcSolarIntensity", "IVolumeCombined", "IVolumeFactory", "IVolumeFromCalc", 
"IVolumeFromCondition", "IVolumeFromGrid", "IVolumeFromTimeSatisfaction", "IVolumeGrid", "IVolumeGridBearingAlt", "IVolumeGridCartesian", 
"IVolumeGridConstrained", "IVolumeGridCylindrical", "IVolumeGridFactory", "IVolumeGridGroup", "IVolumeGridLatLonAlt", "IVolumeGridResult", 
"IVolumeGridSpherical", "IVolumeGroup", "IVolumeInview", "IVolumeLighting", "IVolumeOverTime", "IWellKnownAxes", "IWellKnownEarthAxes", 
"IWellKnownEarthSystems", "IWellKnownSunAxes", "IWellKnownSunSystems", "IWellKnownSystems", "Instance", "Integral", "IntegralBasic", 
"Interp", "InterpBasic", "Interval", "IntervalCollection", "IntervalListResult", "IntervalVectorCollection", "IntervalsFilter", 
"IntervalsVectorResult", "LLAPosition", "LastIntervalsFilter", "LightTimeDelay", "MethodCallResult", "ParameterSet", "ParameterSetAttitude", 
"ParameterSetFactory", "ParameterSetGroundTrajectory", "ParameterSetGroup", "ParameterSetOrbit", "ParameterSetTrajectory", 
"ParameterSetVector", "Plane", "PlaneFactory", "PlaneGroup", "PlaneLabels", "PlaneNormal", "PlaneQuadrant", "PlaneRefTo", 
"PlaneTrajectory", "PlaneTriad", "PlaneTwoVector", "Point", "PointAtTimeInstant", "PointBPlane", "PointCBFixedOffset", "PointCentBodyIntersect", 
"PointCommonTasks", "PointCovarianceGrazing", "PointFactory", "PointFile", "PointFixedInSystem", "PointGlint", "PointGrazing", 
"PointGroup", "PointLagrangeLibration", "PointModelAttach", "PointOnSurface", "PointPlaneIntersection", "PointPlaneProjection", 
"PointPlugin", "PointRefTo", "PointSamplingInterval", "PointSamplingIntervalCollection", "PointSamplingResult", "PointSatelliteCollectionEntry", 
"Provider", "PruneFilter", "PruneFilterFactory", "RelativeSatisfactionConditionFilter", "Root", "Sampling", "SamplingBasic", 
"SamplingCurvatureTolerance", "SamplingFixedStep", "SamplingMethod", "SamplingMethodFactory", "SamplingRelativeTolerance", 
"SatisfactionConditionFilter", "SignalDelay", "SignalDelayBasic", "System", "SystemAssembled", "SystemCommonTasks", "SystemFactory", 
"SystemGroup", "SystemOnSurface", "SystemRefTo", "Template", "TypeInfo", "Vector", "VectorAngleRate", "VectorAngularVelocity", 
"VectorApoapsis", "VectorConing", "VectorCross", "VectorCustomScript", "VectorDerivative", "VectorDirectionToStar", "VectorDispSurface", 
"VectorDisplacement", "VectorEccentricity", "VectorFactory", "VectorFixedAtEpoch", "VectorFixedAtTimeInstant", "VectorFixedInAxes", 
"VectorGroup", "VectorLineOfNodes", "VectorLinearCombination", "VectorModelAttach", "VectorOrbitAngularMomentum", "VectorOrbitNormal", 
"VectorPeriapsis", "VectorPlugin", "VectorProjectAlongVector", "VectorProjection", "VectorRefTo", "VectorReflection", "VectorRotationVector", 
"VectorScalarLinearCombination", "VectorScalarScaled", "VectorScaled", "VectorTwoPlanesIntersection", "VectorVelocityAcceleration", 
"Volume", "VolumeCalc", "VolumeCalcAltitude", "VolumeCalcAngleOffVector", "VolumeCalcConditionSatMetric", "VolumeCalcDelayRange", 
"VolumeCalcFactory", "VolumeCalcFile", "VolumeCalcFromScalar", "VolumeCalcGroup", "VolumeCalcRange", "VolumeCalcSolarIntensity", 
"VolumeCombined", "VolumeFactory", "VolumeFromCalc", "VolumeFromCondition", "VolumeFromGrid", "VolumeFromTimeSatisfaction", 
"VolumeGrid", "VolumeGridBearingAlt", "VolumeGridCartesian", "VolumeGridConstrained", "VolumeGridCylindrical", "VolumeGridFactory", 
"VolumeGridGroup", "VolumeGridLatLonAlt", "VolumeGridResult", "VolumeGridSpherical", "VolumeGroup", "VolumeInview", "VolumeLighting", 
"VolumeOverTime", "WellKnownAxes", "WellKnownEarthAxes", "WellKnownEarthSystems", "WellKnownSunAxes", "WellKnownSunSystems", 
"WellKnownSystems"]

import typing

from ctypes   import byref, POINTER
from datetime import datetime
from enum     import IntEnum, IntFlag

try:
    from numpy import ndarray
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame
except ModuleNotFoundError:
    pass

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .internal  import dataanalysisutil as agdata
from .utilities import colors           as agcolor
from .internal.comutil     import IUnknown, IDispatch, IPictureDisp, IAGFUNCTYPE, IEnumVARIANT
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgECrdnCalcScalarType(IntEnum):
    """Defines available calculation scalar types."""
    # Unknown or unsupported calculation scalar types
    eCrdnCalcScalarTypeUnknown = -1
    # Scalar equal to angular displacement obtained from any angle in VGT.
    eCrdnCalcScalarTypeAngle = 0
    # Constant scalar created by evaluating input scalar calculation at specified reference time instant.
    eCrdnCalcScalarTypeFixedAtTimeInstant = 1
    # Constant scalar value of specified dimension.
    eCrdnCalcScalarTypeConstant = 2
    # Any time-dependent data element from STK data providers available for parent STK object.
    eCrdnCalcScalarTypeDataElement = 3
    # Derivative of input scalar calculation.
    eCrdnCalcScalarTypeDerivative = 4
    # Time elapsed since reference time instant.
    eCrdnCalcScalarTypeElapsedTime = 5
    # Tabulated scalar calculation data loaded from specified file.
    eCrdnCalcScalarTypeFile = 6
    # Defined by performing one of specified functions on input scalar.
    eCrdnCalcScalarTypeFunction = 7
    # Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types.
    eCrdnCalcScalarTypeIntegral = 8
    # Defined by performing one of specified binary operations on two scalar arguments.
    eCrdnCalcScalarTypeFunction2Var = 9
    # Scalar equal to magnitude of specified vector.
    eCrdnCalcScalarTypeVectorMagnitude = 10
    # A calc scalar plugin based on a COM object.
    eCrdnCalcScalarTypePlugin = 11
    # A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate.
    eCrdnCalcScalarTypeCustomScript = 12
    # Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude).
    eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints = 13
    # Scalar equal to the dot product between two vectors.
    eCrdnCalcScalarTypeDotProduct = 14
    # Scalar equal to the specified component of a vector when resolved in the specified axes.
    eCrdnCalcScalarTypeVectorComponent = 15

AgECrdnCalcScalarType.eCrdnCalcScalarTypeUnknown.__doc__ = "Unknown or unsupported calculation scalar types"
AgECrdnCalcScalarType.eCrdnCalcScalarTypeAngle.__doc__ = "Scalar equal to angular displacement obtained from any angle in VGT."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFixedAtTimeInstant.__doc__ = "Constant scalar created by evaluating input scalar calculation at specified reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeConstant.__doc__ = "Constant scalar value of specified dimension."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDataElement.__doc__ = "Any time-dependent data element from STK data providers available for parent STK object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDerivative.__doc__ = "Derivative of input scalar calculation."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeElapsedTime.__doc__ = "Time elapsed since reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFile.__doc__ = "Tabulated scalar calculation data loaded from specified file."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction.__doc__ = "Defined by performing one of specified functions on input scalar."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeIntegral.__doc__ = "Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction2Var.__doc__ = "Defined by performing one of specified binary operations on two scalar arguments."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorMagnitude.__doc__ = "Scalar equal to magnitude of specified vector."
AgECrdnCalcScalarType.eCrdnCalcScalarTypePlugin.__doc__ = "A calc scalar plugin based on a COM object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeCustomScript.__doc__ = "A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints.__doc__ = "Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDotProduct.__doc__ = "Scalar equal to the dot product between two vectors."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorComponent.__doc__ = "Scalar equal to the specified component of a vector when resolved in the specified axes."

agcls.AgTypeNameMap["AgECrdnCalcScalarType"] = AgECrdnCalcScalarType

class AgECrdnConditionCombinedOperationType(IntEnum):
    """Defines scalar condition combined operation types."""
    # Scalar condition combined AND operation.
    eCrdnConditionCombinedOperationTypeAND = 1
    # Scalar condition combined OR operation.
    eCrdnConditionCombinedOperationTypeOR = 2
    # Scalar condition combined XOR operation.
    eCrdnConditionCombinedOperationTypeXOR = 3
    # Scalar condition combined MINUS operation.
    eCrdnConditionCombinedOperationTypeMINUS = 4

AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeAND.__doc__ = "Scalar condition combined AND operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeOR.__doc__ = "Scalar condition combined OR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeXOR.__doc__ = "Scalar condition combined XOR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeMINUS.__doc__ = "Scalar condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnConditionCombinedOperationType"] = AgECrdnConditionCombinedOperationType

class AgECrdnConditionSetType(IntEnum):
    """Defines available condition set types."""
    # Unknown or unsupported condition set types.
    eCrdnConditionSetTypeUnknown = -1
    # Condition set placing multiple thresholds on specified scalar.
    eCrdnConditionSetTypeScalarThresholds = 0

AgECrdnConditionSetType.eCrdnConditionSetTypeUnknown.__doc__ = "Unknown or unsupported condition set types."
AgECrdnConditionSetType.eCrdnConditionSetTypeScalarThresholds.__doc__ = "Condition set placing multiple thresholds on specified scalar."

agcls.AgTypeNameMap["AgECrdnConditionSetType"] = AgECrdnConditionSetType

class AgECrdnConditionThresholdOption(IntEnum):
    """Operations for Scalar Bounds Condition"""
    # Bound is above a minimum value
    eCrdnConditionThresholdOptionAboveMin = 1
    # Bound is below a maximum value
    eCrdnConditionThresholdOptionBelowMax = 2
    # Bound is between a minimum and maximum value
    eCrdnConditionThresholdOptionInsideMinMax = 3
    # Bound is outside a minimum and maximum value
    eCrdnConditionThresholdOptionOutsideMinMax = 4

AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionAboveMin.__doc__ = "Bound is above a minimum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionBelowMax.__doc__ = "Bound is below a maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionInsideMinMax.__doc__ = "Bound is between a minimum and maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionOutsideMinMax.__doc__ = "Bound is outside a minimum and maximum value"

agcls.AgTypeNameMap["AgECrdnConditionThresholdOption"] = AgECrdnConditionThresholdOption

class AgECrdnConditionType(IntEnum):
    """Defines available condition types."""
    # Unknown or unsupported condition type
    eCrdnConditionTypeUnknown = -1
    # Condition placing bounds on specified scalar.
    eCrdnConditionTypeScalarBounds = 0
    # Multiple conditiones on specified scalar.
    eCrdnConditionTypeCombined = 1
    # Condition placing point in volume.
    eCrdnConditionTypePointInVolume = 2

AgECrdnConditionType.eCrdnConditionTypeUnknown.__doc__ = "Unknown or unsupported condition type"
AgECrdnConditionType.eCrdnConditionTypeScalarBounds.__doc__ = "Condition placing bounds on specified scalar."
AgECrdnConditionType.eCrdnConditionTypeCombined.__doc__ = "Multiple conditiones on specified scalar."
AgECrdnConditionType.eCrdnConditionTypePointInVolume.__doc__ = "Condition placing point in volume."

agcls.AgTypeNameMap["AgECrdnConditionType"] = AgECrdnConditionType

class AgECrdnDimensionInheritance(IntEnum):
    """Defines how dimension is inherited"""
    # Do not inherit dimension.
    eCrdnDimensionInheritanceNone = 0
    # Inherit dimension from X scalar.
    eCrdnDimensionInheritanceFromX = 1
    # Inherit dimension from Y scalar.
    eCrdnDimensionInheritanceFromY = 2

AgECrdnDimensionInheritance.eCrdnDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromX.__doc__ = "Inherit dimension from X scalar."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromY.__doc__ = "Inherit dimension from Y scalar."

agcls.AgTypeNameMap["AgECrdnDimensionInheritance"] = AgECrdnDimensionInheritance

class AgECrdnEventArrayFilterType(IntEnum):
    """Event array filter types."""
    # Skip time step
    eCrdnEventArrayFilterTypeSkipTimeStep = 0
    # Skip count
    eCrdnEventArrayFilterTypeSkipCount = 1
    # Intervals
    eCrdnEventArrayFilterTypeIntervals = 2

AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipTimeStep.__doc__ = "Skip time step"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipCount.__doc__ = "Skip count"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeIntervals.__doc__ = "Intervals"

agcls.AgTypeNameMap["AgECrdnEventArrayFilterType"] = AgECrdnEventArrayFilterType

class AgECrdnEventArrayType(IntEnum):
    """Defines available time array types."""
    # Unknown or unsupported time array types
    eCrdnEventArrayTypeUnknown = -1
    # Determines time of local minimum and/or maximum of specified scalar calculation.
    eCrdnEventArrayTypeExtrema = 0
    # Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array.
    eCrdnEventArrayTypeStartStopTimes = 1
    # Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays.
    eCrdnEventArrayTypeMerged = 2
    # Defined by filtering times from original time array according to specified filtering method.
    eCrdnEventArrayTypeFiltered = 3
    # Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list.
    eCrdnEventArrayTypeFixedStep = 4
    # Time array containing times at which specified condition changes its satisfaction status.
    eCrdnEventArrayTypeConditionCrossings = 5
    # Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations.
    eCrdnEventArrayTypeSignaled = 6
    # Time array containing specific times.
    eCrdnEventArrayTypeFixedTimes = 7

AgECrdnEventArrayType.eCrdnEventArrayTypeUnknown.__doc__ = "Unknown or unsupported time array types"
AgECrdnEventArrayType.eCrdnEventArrayTypeExtrema.__doc__ = "Determines time of local minimum and/or maximum of specified scalar calculation."
AgECrdnEventArrayType.eCrdnEventArrayTypeStartStopTimes.__doc__ = "Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."
AgECrdnEventArrayType.eCrdnEventArrayTypeMerged.__doc__ = "Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."
AgECrdnEventArrayType.eCrdnEventArrayTypeFiltered.__doc__ = "Defined by filtering times from original time array according to specified filtering method."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedStep.__doc__ = "Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."
AgECrdnEventArrayType.eCrdnEventArrayTypeConditionCrossings.__doc__ = "Time array containing times at which specified condition changes its satisfaction status."
AgECrdnEventArrayType.eCrdnEventArrayTypeSignaled.__doc__ = "Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedTimes.__doc__ = "Time array containing specific times."

agcls.AgTypeNameMap["AgECrdnEventArrayType"] = AgECrdnEventArrayType

class AgECrdnEventIntervalCollectionType(IntEnum):
    """Defines available interval collection types."""
    # Unknown or unsupported interval collection types
    eCrdnEventIntervalCollectionTypeUnknown = -1
    # Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies.
    eCrdnEventIntervalCollectionTypeLighting = 0
    # Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations.
    eCrdnEventIntervalCollectionTypeSignaled = 1
    # Interval collection containing intervals during which condition set is satisfied.
    eCrdnEventIntervalCollectionTypeCondition = 2

AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeUnknown.__doc__ = "Unknown or unsupported interval collection types"
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeLighting.__doc__ = "Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeSignaled.__doc__ = "Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeCondition.__doc__ = "Interval collection containing intervals during which condition set is satisfied."

agcls.AgTypeNameMap["AgECrdnEventIntervalCollectionType"] = AgECrdnEventIntervalCollectionType

class AgECrdnEventIntervalListType(IntEnum):
    """Defines available interval list types."""
    # Unknown or unsupported interval list types
    eCrdnEventIntervalListTypeUnknown = -1
    # Interval list created by merging two constituent interval lists using specified logical operation.
    eCrdnEventIntervalListTypeMerged = 1
    # Defined by filtering intervals from original interval list using specified filtering method.
    eCrdnEventIntervalListTypeFiltered = 2
    # Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction).
    eCrdnEventIntervalListTypeCondition = 3
    # Interval List defined by scaling every interval in original interval list using either absolute or relative scale.
    eCrdnEventIntervalListTypeScaled = 4
    # Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations.
    eCrdnEventIntervalListTypeSignaled = 5
    # Interval List defined by shifting specified reference interval list by fixed time offset.
    eCrdnEventIntervalListTypeTimeOffset = 6
    # Interval list loaded from specified interval file
    eCrdnEventIntervalListTypeFile = 0
    # Interval list with individual intervals defined between explicitly specified start and stop times.
    eCrdnEventIntervalListTypeFixed = 7

AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeUnknown.__doc__ = "Unknown or unsupported interval list types"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeMerged.__doc__ = "Interval list created by merging two constituent interval lists using specified logical operation."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFiltered.__doc__ = "Defined by filtering intervals from original interval list using specified filtering method."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeCondition.__doc__ = "Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeScaled.__doc__ = "Interval List defined by scaling every interval in original interval list using either absolute or relative scale."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeSignaled.__doc__ = "Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeTimeOffset.__doc__ = "Interval List defined by shifting specified reference interval list by fixed time offset."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFile.__doc__ = "Interval list loaded from specified interval file"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFixed.__doc__ = "Interval list with individual intervals defined between explicitly specified start and stop times."

agcls.AgTypeNameMap["AgECrdnEventIntervalListType"] = AgECrdnEventIntervalListType

class AgECrdnEventIntervalType(IntEnum):
    """Defines available interval types."""
    # Unknown or unsupported interval types
    eCrdnEventIntervalTypeUnknown = -1
    # Interval defined between two explicitly specified start and stop times.
    eCrdnEventIntervalTypeFixed = 0
    # Interval of fixed duration specified using start and stop offsets relative to specified reference time instant.
    eCrdnEventIntervalTypeFixedDuration = 1
    # Interval between specified start and stop time instants.
    eCrdnEventIntervalTypeBetweenTimeInstants = 2
    # Interval created from specified interval list by using one of several selection methods.
    eCrdnEventIntervalTypeFromIntervalList = 3
    # Interval defined by scaling original interval using either absolute or relative scale.
    eCrdnEventIntervalTypeScaled = 4
    # Determines an interval recorded at a target clock location by performing signal transmission.
    eCrdnEventIntervalTypeSignaled = 5
    # Interval defined by shifting specified reference interval by fixed time offset.
    eCrdnEventIntervalTypeTimeOffset = 6
    # A smart interval.
    eCrdnEventIntervalTypeSmartInterval = 7

AgECrdnEventIntervalType.eCrdnEventIntervalTypeUnknown.__doc__ = "Unknown or unsupported interval types"
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixed.__doc__ = "Interval defined between two explicitly specified start and stop times."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixedDuration.__doc__ = "Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeBetweenTimeInstants.__doc__ = "Interval between specified start and stop time instants."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFromIntervalList.__doc__ = "Interval created from specified interval list by using one of several selection methods."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeScaled.__doc__ = "Interval defined by scaling original interval using either absolute or relative scale."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSignaled.__doc__ = "Determines an interval recorded at a target clock location by performing signal transmission."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeTimeOffset.__doc__ = "Interval defined by shifting specified reference interval by fixed time offset."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSmartInterval.__doc__ = "A smart interval."

agcls.AgTypeNameMap["AgECrdnEventIntervalType"] = AgECrdnEventIntervalType

class AgECrdnEventListMergeOperation(IntEnum):
    """Defines merge operations for interval lists."""
    # Intervals both in A and B
    eCrdnEventListMergeOperationAND = 0
    # Intervals in A or B
    eCrdnEventListMergeOperationOR = 1
    # Intervals in A or B but not in both
    eCrdnEventListMergeOperationXOR = 2
    # Intervals in A and not in B
    eCrdnEventListMergeOperationMINUS = 3

AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationAND.__doc__ = "Intervals both in A and B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationOR.__doc__ = "Intervals in A or B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationXOR.__doc__ = "Intervals in A or B but not in both"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationMINUS.__doc__ = "Intervals in A and not in B"

agcls.AgTypeNameMap["AgECrdnEventListMergeOperation"] = AgECrdnEventListMergeOperation

class AgECrdnEventType(IntEnum):
    """Defines available time instant types."""
    # Unknown or unsupported time instant types
    eCrdnEventTypeUnknown = -1
    # Time instant set at specified date/time
    eCrdnEventTypeEpoch = 0
    # Determines time of global minimum or maximum of specified scalar calculation.
    eCrdnEventTypeExtremum = 1
    # Start or stop time of selected reference interval
    eCrdnEventTypeFromInterval = 2
    # Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations.
    eCrdnEventTypeSignaled = 3
    # Time instant at fixed offset from specified reference time instant
    eCrdnEventTypeTimeOffset = 4
    # A smart epoch.
    eCrdnEventTypeSmartEpoch = 5

AgECrdnEventType.eCrdnEventTypeUnknown.__doc__ = "Unknown or unsupported time instant types"
AgECrdnEventType.eCrdnEventTypeEpoch.__doc__ = "Time instant set at specified date/time"
AgECrdnEventType.eCrdnEventTypeExtremum.__doc__ = "Determines time of global minimum or maximum of specified scalar calculation."
AgECrdnEventType.eCrdnEventTypeFromInterval.__doc__ = "Start or stop time of selected reference interval"
AgECrdnEventType.eCrdnEventTypeSignaled.__doc__ = "Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."
AgECrdnEventType.eCrdnEventTypeTimeOffset.__doc__ = "Time instant at fixed offset from specified reference time instant"
AgECrdnEventType.eCrdnEventTypeSmartEpoch.__doc__ = "A smart epoch."

agcls.AgTypeNameMap["AgECrdnEventType"] = AgECrdnEventType

class AgECrdnExtremumConstants(IntFlag):
    """These constants are utilized when finding a local or global minimum or maximum, or the threshold crossing."""
    # Find the minimum value
    eCrdnExtremumMinimum = 1
    # Find the maximum value
    eCrdnExtremumMaximum = 2

AgECrdnExtremumConstants.eCrdnExtremumMinimum.__doc__ = "Find the minimum value"
AgECrdnExtremumConstants.eCrdnExtremumMaximum.__doc__ = "Find the maximum value"

agcls.AgTypeNameMap["AgECrdnExtremumConstants"] = AgECrdnExtremumConstants

class AgECrdnFileInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnFileInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnFileInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnFileInterpolatorTypeHermite = 2
    # Holds the value at the closest previous sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldPrevious = 3
    # Holds the value at the closest next sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldNext = 4
    # Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time.
    eCrdnFileInterpolatorTypeHoldNearest = 5

AgECrdnFileInterpolatorType.eCrdnFileInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHermite.__doc__ = "Hermite interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldPrevious.__doc__ = "Holds the value at the closest previous sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNext.__doc__ = "Holds the value at the closest next sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNearest.__doc__ = "Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."

agcls.AgTypeNameMap["AgECrdnFileInterpolatorType"] = AgECrdnFileInterpolatorType

class AgECrdnIntegralType(IntEnum):
    """Integral types."""
    # Simpson integral method
    eCrdnIntegralTypeFixedStepSimpson = 2
    # Trapezoidal integral method
    eCrdnIntegralTypeFixedStepTrapz = 1
    # Adaptive Lobatto integral method
    eCrdnIntegralTypeAdaptiveStep = 3

AgECrdnIntegralType.eCrdnIntegralTypeFixedStepSimpson.__doc__ = "Simpson integral method"
AgECrdnIntegralType.eCrdnIntegralTypeFixedStepTrapz.__doc__ = "Trapezoidal integral method"
AgECrdnIntegralType.eCrdnIntegralTypeAdaptiveStep.__doc__ = "Adaptive Lobatto integral method"

agcls.AgTypeNameMap["AgECrdnIntegralType"] = AgECrdnIntegralType

class AgECrdnIntegrationWindowType(IntEnum):
    """Defines the interval of times during which an integral is evaluated."""
    # Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant.
    eCrdnIntegrationWindowTypeTotal = 0
    # Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time.
    eCrdnIntegrationWindowTypeCumulativeToCurrent = 1
    # Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time.
    eCrdnIntegrationWindowTypeCumulativeFromCurrent = 2
    # Defines the integral's window as the interval of times centered around the current time with the specified front and back durations.
    eCrdnIntegrationWindowTypeSlidingWindow = 3

AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeTotal.__doc__ = "Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeToCurrent.__doc__ = "Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeFromCurrent.__doc__ = "Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeSlidingWindow.__doc__ = "Defines the integral's window as the interval of times centered around the current time with the specified front and back durations."

agcls.AgTypeNameMap["AgECrdnIntegrationWindowType"] = AgECrdnIntegrationWindowType

class AgECrdnInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnInterpolatorTypeHermite = 2

AgECrdnInterpolatorType.eCrdnInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeHermite.__doc__ = "Hermite interpolation."

agcls.AgTypeNameMap["AgECrdnInterpolatorType"] = AgECrdnInterpolatorType

class AgECrdnIntervalDurationKind(IntEnum):
    """Duration for filtering intervals or gaps from interval lists or time arrays"""
    # Filter by at least a specified number of seconds
    eCrdnIntervalDurationKindAtLeast = 0
    # Filter by at most a specified number of seconds
    eCrdnIntervalDurationKindAtMost = 1

AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtLeast.__doc__ = "Filter by at least a specified number of seconds"
AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtMost.__doc__ = "Filter by at most a specified number of seconds"

agcls.AgTypeNameMap["AgECrdnIntervalDurationKind"] = AgECrdnIntervalDurationKind

class AgECrdnIntervalSelection(IntEnum):
    """Select the method to choose an interval from an interval list"""
    # Select an interval by counting a specified number from the first interval
    eCrdnIntervalSelectionFromStart = 1
    # Select an interval by counting a specified number back from the last interval
    eCrdnIntervalSelectionFromEnd = 2
    # Select the interval with the largest duration
    eCrdnIntervalSelectionMaxDuration = 4
    # Select the interval with the smallest duration
    eCrdnIntervalSelectionMinDuration = 5
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMaxGap = 9
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMinGap = 10
    # Select the interval that is the span of the interval list
    eCrdnIntervalSelectionSpan = 100

AgECrdnIntervalSelection.eCrdnIntervalSelectionFromStart.__doc__ = "Select an interval by counting a specified number from the first interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionFromEnd.__doc__ = "Select an interval by counting a specified number back from the last interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxDuration.__doc__ = "Select the interval with the largest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinDuration.__doc__ = "Select the interval with the smallest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionSpan.__doc__ = "Select the interval that is the span of the interval list"

agcls.AgTypeNameMap["AgECrdnIntervalSelection"] = AgECrdnIntervalSelection

class AgECrdnParameterSetType(IntEnum):
    """Defines parameter set types."""
    # Unknown or unsupported parameter set
    eCrdnParameterSetTypeUnknown = -1
    # A parameter set type is defined by identifying one set of axes in reference to another.
    eCrdnParameterSetTypeAttitude = 0
    # A parameter set type is defined by identifying location in reference central body.
    eCrdnParameterSetTypeGroundTrajectory = 1
    # A parameter set type is defined by identifying location in reference coordinate system.
    eCrdnParameterSetTypeTrajectory = 2
    # A parameter set type is defined by identifying orbiting point and its central body.
    eCrdnParameterSetTypeOrbit = 3
    # A parameter set type is defined by identifying vector in reference axes.
    eCrdnParameterSetTypeVector = 4

AgECrdnParameterSetType.eCrdnParameterSetTypeUnknown.__doc__ = "Unknown or unsupported parameter set"
AgECrdnParameterSetType.eCrdnParameterSetTypeAttitude.__doc__ = "A parameter set type is defined by identifying one set of axes in reference to another."
AgECrdnParameterSetType.eCrdnParameterSetTypeGroundTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference coordinate system."
AgECrdnParameterSetType.eCrdnParameterSetTypeOrbit.__doc__ = "A parameter set type is defined by identifying orbiting point and its central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeVector.__doc__ = "A parameter set type is defined by identifying vector in reference axes."

agcls.AgTypeNameMap["AgECrdnParameterSetType"] = AgECrdnParameterSetType

class AgECrdnPruneFilter(IntEnum):
    """Specify the filter for filtering interval lists or time arrays"""
    # Unknown or unsupported prune filter
    eCrdnPruneFilterUnknown = 0
    # Selects specified number of first intervals from original list
    eCrdnPruneFilterFirstIntervals = 1
    # Selects specified number of last intervals from original list
    eCrdnPruneFilterLastIntervals = 2
    # Selects intervals which satisfy additional duration condition.
    eCrdnPruneFilterIntervals = 3
    # Selects gaps between intervals which satisfy additional duration condition.
    eCrdnPruneFilterGaps = 4
    # Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterSatisfactionIntervals = 5
    # Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterRelativeSatisfactionIntervals = 6

AgECrdnPruneFilter.eCrdnPruneFilterUnknown.__doc__ = "Unknown or unsupported prune filter"
AgECrdnPruneFilter.eCrdnPruneFilterFirstIntervals.__doc__ = "Selects specified number of first intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterLastIntervals.__doc__ = "Selects specified number of last intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterIntervals.__doc__ = "Selects intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterGaps.__doc__ = "Selects gaps between intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterSatisfactionIntervals.__doc__ = "Satisfaction Intervals selects intervals which satisfy additional condition and duration."
AgECrdnPruneFilter.eCrdnPruneFilterRelativeSatisfactionIntervals.__doc__ = "Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."

agcls.AgTypeNameMap["AgECrdnPruneFilter"] = AgECrdnPruneFilter

class AgECrdnSampledReferenceTime(IntEnum):
    """Event array reference type."""
    # Use a Time Instant as the reference time
    eCrdnSampledReferenceTimeReferenceEvent = 0
    # Use the start of each interval as the reference time
    eCrdnSampledReferenceTimeStartOfEachInterval = 1
    # Use the stop of each interval as the reference time
    eCrdnSampledReferenceTimeStopOfEachInterval = 2
    # Use the start of each interval list as the reference time
    eCrdnSampledReferenceTimeStartOfIntervalList = 3
    # Use the stop of each interval list as the reference time
    eCrdnSampledReferenceTimeStopOfIntervalList = 4

AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeReferenceEvent.__doc__ = "Use a Time Instant as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfEachInterval.__doc__ = "Use the start of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfEachInterval.__doc__ = "Use the stop of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfIntervalList.__doc__ = "Use the start of each interval list as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfIntervalList.__doc__ = "Use the stop of each interval list as the reference time"

agcls.AgTypeNameMap["AgECrdnSampledReferenceTime"] = AgECrdnSampledReferenceTime

class AgECrdnSamplingMethod(IntEnum):
    """Defines the Sampling Method"""
    # Unknown or unsupported sampling method
    eCrdnSamplingMethodUnknown = 0
    # Fixed step sampling method
    eCrdnSamplingMethodFixedStep = 1
    # Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples.
    eCrdnSamplingMethodRelativeTolerance = 2
    # Curvature tolerance also uses changes in slope between samples
    eCrdnSamplingMethodCurvatureTolerance = 3

AgECrdnSamplingMethod.eCrdnSamplingMethodUnknown.__doc__ = "Unknown or unsupported sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodFixedStep.__doc__ = "Fixed step sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodRelativeTolerance.__doc__ = "Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."
AgECrdnSamplingMethod.eCrdnSamplingMethodCurvatureTolerance.__doc__ = "Curvature tolerance also uses changes in slope between samples"

agcls.AgTypeNameMap["AgECrdnSamplingMethod"] = AgECrdnSamplingMethod

class AgECrdnSatisfactionCrossing(IntEnum):
    """Direction crossing flags."""
    # Use either off-to-on or on-to-off condition to determine satisfaction
    eCrdnSatisfactionCrossingNone = 0
    # Satisfaction occurs when crossing from off to on condition
    eCrdnSatisfactionCrossingIn = 1
    # Satisfaction occurs when crossing from on to off condition
    eCrdnSatisfactionCrossingOut = 2

AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingNone.__doc__ = "Use either off-to-on or on-to-off condition to determine satisfaction"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingIn.__doc__ = "Satisfaction occurs when crossing from off to on condition"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingOut.__doc__ = "Satisfaction occurs when crossing from on to off condition"

agcls.AgTypeNameMap["AgECrdnSatisfactionCrossing"] = AgECrdnSatisfactionCrossing

class AgECrdnSaveDataOption(IntEnum):
    """Method for saving computed data"""
    # Use the application setting to determine whether computed data should be saved/loaded.
    eCrdnSaveDataOptionApplicationSettings = -1
    # Save/load computed data.
    eCrdnSaveDataOptionYes = 100
    # Don't save computed data, recompute data on load.
    eCrdnSaveDataOptionNo = 10

AgECrdnSaveDataOption.eCrdnSaveDataOptionApplicationSettings.__doc__ = "Use the application setting to determine whether computed data should be saved/loaded."
AgECrdnSaveDataOption.eCrdnSaveDataOptionYes.__doc__ = "Save/load computed data."
AgECrdnSaveDataOption.eCrdnSaveDataOptionNo.__doc__ = "Don't save computed data, recompute data on load."

agcls.AgTypeNameMap["AgECrdnSaveDataOption"] = AgECrdnSaveDataOption

class AgECrdnSignalPathReferenceSystem(IntEnum):
    """Signal path reference system types."""
    # Use Access default system
    eCrdnSignalPathReferenceSystemUseAccessDefault = -1
    # Use central body inertial system
    eCrdnSignalPathReferenceSystemCentralBodyInertial = 0
    # Use solar system barycenter system
    eCrdnSignalPathReferenceSystemSolarSystemBarycenter = 1
    # User will specify a system
    eCrdnSignalPathReferenceSystemCustom = 2

AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemUseAccessDefault.__doc__ = "Use Access default system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCentralBodyInertial.__doc__ = "Use central body inertial system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemSolarSystemBarycenter.__doc__ = "Use solar system barycenter system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCustom.__doc__ = "User will specify a system"

agcls.AgTypeNameMap["AgECrdnSignalPathReferenceSystem"] = AgECrdnSignalPathReferenceSystem

class AgECrdnSmartEpochState(IntEnum):
    """Smart epoch states."""
    # Smart epoch is specified explicitly using a time.
    eCrdnSmartEpochStateExplicit = 0
    # Smart epoch is specified implicitly.
    eCrdnSmartEpochStateImplicit = 3

AgECrdnSmartEpochState.eCrdnSmartEpochStateExplicit.__doc__ = "Smart epoch is specified explicitly using a time."
AgECrdnSmartEpochState.eCrdnSmartEpochStateImplicit.__doc__ = "Smart epoch is specified implicitly."

agcls.AgTypeNameMap["AgECrdnSmartEpochState"] = AgECrdnSmartEpochState

class AgECrdnSmartIntervalState(IntEnum):
    """Smart interval states."""
    # Smart interval is specified explicitly using start/stop times.
    eCrdnSmartIntervalStateExplicit = 0
    # Smart interval is specified implicitly using start/stop times.
    eCrdnSmartIntervalStateImplicit = 1
    # Smart interval is specified using smart epochs.
    eCrdnSmartIntervalStateStartStop = 2
    # Smart interval is specified using a start epoch and duration.
    eCrdnSmartIntervalStateStartDuration = 4
    # Smart interval is specified using a start time and explicit duration.
    eCrdnSmartIntervalStateExplicitDuration = 3

AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicit.__doc__ = "Smart interval is specified explicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateImplicit.__doc__ = "Smart interval is specified implicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartStop.__doc__ = "Smart interval is specified using smart epochs."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartDuration.__doc__ = "Smart interval is specified using a start epoch and duration."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicitDuration.__doc__ = "Smart interval is specified using a start time and explicit duration."

agcls.AgTypeNameMap["AgECrdnSmartIntervalState"] = AgECrdnSmartIntervalState

class AgECrdnSpeedOptions(IntEnum):
    """Defines various speed options."""
    # Light transmission speed.
    eCrdnLightTransmissionSpeed = 1
    # Custom transmission speed.
    eCrdnCustomTransmissionSpeed = 2

AgECrdnSpeedOptions.eCrdnLightTransmissionSpeed.__doc__ = "Light transmission speed."
AgECrdnSpeedOptions.eCrdnCustomTransmissionSpeed.__doc__ = "Custom transmission speed."

agcls.AgTypeNameMap["AgECrdnSpeedOptions"] = AgECrdnSpeedOptions

class AgECrdnStartStopOption(IntEnum):
    """Start/stop options."""
    # Use the start time of the interval
    eCrdnStartStopOptionCountStartOnly = 1
    # Use the stop time of the interval
    eCrdnStartStopOptionCountStopOnly = 2
    # Use the start time and stop time of the interval
    eCrdnStartStopOptionCountStartStop = 3

AgECrdnStartStopOption.eCrdnStartStopOptionCountStartOnly.__doc__ = "Use the start time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStopOnly.__doc__ = "Use the stop time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStartStop.__doc__ = "Use the start time and stop time of the interval"

agcls.AgTypeNameMap["AgECrdnStartStopOption"] = AgECrdnStartStopOption

class AgECrdnThreshConvergeSense(IntEnum):
    """Specifies the desired sense of the results from threshold crossing computations."""
    # Just converge within tolerance.
    eCrdnThreshConvergeSenseSimple = 0
    # Result above or at threshold.
    eCrdnThreshConvergeSenseAbove = 1
    # Result below or at threshold.
    eCrdnThreshConvergeSenseBelow = 2

AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseSimple.__doc__ = "Just converge within tolerance."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseAbove.__doc__ = "Result above or at threshold."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseBelow.__doc__ = "Result below or at threshold."

agcls.AgTypeNameMap["AgECrdnThreshConvergeSense"] = AgECrdnThreshConvergeSense

class AgECrdnVectorComponentType(IntEnum):
    """Defines component directions for a vector."""
    # X component.
    eCrdnVectorComponentX = 0
    # Y component.
    eCrdnVectorComponentY = 1
    # Z component.
    eCrdnVectorComponentZ = 2
    # -X component.
    eCrdnVectorComponentMinusX = 3
    # -Y component.
    eCrdnVectorComponentMinusY = 4
    # -Z component.
    eCrdnVectorComponentMinusZ = 5

AgECrdnVectorComponentType.eCrdnVectorComponentX.__doc__ = "X component."
AgECrdnVectorComponentType.eCrdnVectorComponentY.__doc__ = "Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentZ.__doc__ = "Z component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusX.__doc__ = "-X component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusY.__doc__ = "-Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusZ.__doc__ = "-Z component."

agcls.AgTypeNameMap["AgECrdnVectorComponentType"] = AgECrdnVectorComponentType

class AgECrdnVolumeCalcAltitudeReferenceType(IntEnum):
    """Defines volume calc altitude reference types."""
    # Volume calc altitude above reference ellipsoid.
    eCrdnVolumeCalcAltitudeReferenceEllipsoid = 0
    # Volume calc altitude reference above terrain.
    eCrdnVolumeCalcAltitudeReferenceTerrain = 1
    # Volume calc altitude reference above mean sea level.
    eCrdnVolumeCalcAltitudeReferenceMSL = 2

AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceEllipsoid.__doc__ = "Volume calc altitude above reference ellipsoid."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceTerrain.__doc__ = "Volume calc altitude reference above terrain."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceMSL.__doc__ = "Volume calc altitude reference above mean sea level."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAltitudeReferenceType"] = AgECrdnVolumeCalcAltitudeReferenceType

class AgECrdnVolumeCalcAngleOffVectorType(IntEnum):
    """Defines volume calc angle off vector reference types."""
    # Volume calc angle off plane signed.
    eCrdnVolumeCalcAngleOffPlaneSigned = 1
    # Volume calc angle off plane unsigned.
    eCrdnVolumeCalcAngleOffPlaneUnsigned = 2
    # Volume calc angle about vector signed.
    eCrdnVolumeCalcAngleAboutVectorSigned = 4
    # Volume calc angle about vector unsigned.
    eCrdnVolumeCalcAngleAboutVectorUnsigned = 8
    # Volume calc angle off vector.
    eCrdnVolumeCalcAngleOffVector = 16

AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneSigned.__doc__ = "Volume calc angle off plane signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneUnsigned.__doc__ = "Volume calc angle off plane unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorSigned.__doc__ = "Volume calc angle about vector signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorUnsigned.__doc__ = "Volume calc angle about vector unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffVector.__doc__ = "Volume calc angle off vector."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAngleOffVectorType"] = AgECrdnVolumeCalcAngleOffVectorType

class AgECrdnVolumeCalcRangeDistanceType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceFromPoint = 0
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceAlongVectorSigned = 1
    # Volume calc range distance type along vector unsigned
    eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned = 2
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneSigned = 4
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneUnsigned = 8

AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceFromPoint.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorSigned.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned.__doc__ = "Volume calc range distance type along vector unsigned"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneSigned.__doc__ = "Volume calc range distance type plane signed"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneUnsigned.__doc__ = "Volume calc range distance type plane signed"

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeDistanceType"] = AgECrdnVolumeCalcRangeDistanceType

class AgECrdnVolumeCalcRangeSpeedType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedLight = 1
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedCustom = 2

AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedLight.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedCustom.__doc__ = "Volume calc range distance type from point."

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeSpeedType"] = AgECrdnVolumeCalcRangeSpeedType

class AgECrdnVolumeCalcType(IntEnum):
    """Defines volume calc types."""
    # Unknown or unsupported volume calc.
    eCrdnVolumeCalcTypeUnknown = -1
    # volume calc type altitude to location.
    eCrdnVolumeCalcTypeAltitude = 0
    # volume calc type angle to location.
    eCrdnVolumeCalcTypeAngleOffVector = 1
    # volume calc type File.
    eCrdnVolumeCalcTypeFile = 2
    # volume calc type scalar at location.
    eCrdnVolumeCalcTypeFromScalar = 3
    # volume calc type Solar Intensity.
    eCrdnVolumeCalcTypeSolarIntensity = 4
    # volume calc type Spatial Condition Satisfaction Metric.
    eCrdnVolumeCalcTypeVolumeSatisfactionMetric = 5
    # volume calc type Distance to Location.
    eCrdnVolumeCalcTypeRange = 6
    # volume calc type Propagation Delay to Location.
    eCrdnVolumeCalcTypeDelayRange = 7

AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeUnknown.__doc__ = "Unknown or unsupported volume calc."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAltitude.__doc__ = "volume calc type altitude to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAngleOffVector.__doc__ = "volume calc type angle to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFile.__doc__ = "volume calc type File."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFromScalar.__doc__ = "volume calc type scalar at location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeSolarIntensity.__doc__ = "volume calc type Solar Intensity."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeVolumeSatisfactionMetric.__doc__ = "volume calc type Spatial Condition Satisfaction Metric."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeRange.__doc__ = "volume calc type Distance to Location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeDelayRange.__doc__ = "volume calc type Propagation Delay to Location."

agcls.AgTypeNameMap["AgECrdnVolumeCalcType"] = AgECrdnVolumeCalcType

class AgECrdnVolumeCalcVolumeSatisfactionAccumulationType(IntEnum):
    """Defines volume calc spatial condition accumulation types."""
    # Volume calc spatial condition satisfaction accumulation type up to current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime = -1
    # Volume calc spatial condition satisfaction accumulation type current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime = 0
    # Volume calc spatial condition satisfaction accumulation type from current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime = 1
    # Volume calc spatial condition satisfaction accumulation type total.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal = 10

AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type up to current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type from current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal.__doc__ = "Volume calc spatial condition satisfaction accumulation type total."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionAccumulationType"] = AgECrdnVolumeCalcVolumeSatisfactionAccumulationType

class AgECrdnVolumeCalcVolumeSatisfactionDurationType(IntEnum):
    """Defines volume calc spatial condition duration types."""
    # Volume calc spatial condition satisfaction duration type minimum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMin = -1
    # Volume calc spatial condition satisfaction duration type sum.
    eCrdnVolumeCalcVolumeSatisfactionDurationSum = 0
    # Volume calc spatial condition satisfaction duration type maximum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMax = 1

AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMin.__doc__ = "Volume calc spatial condition satisfaction duration type minimum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationSum.__doc__ = "Volume calc spatial condition satisfaction duration type sum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMax.__doc__ = "Volume calc spatial condition satisfaction duration type maximum."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionDurationType"] = AgECrdnVolumeCalcVolumeSatisfactionDurationType

class AgECrdnVolumeCalcVolumeSatisfactionFilterType(IntEnum):
    """Defines volume calc spatial condition filter types."""
    # Volume calc spatial condition satisfaction filter type first intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals = -10
    # Volume calc spatial condition satisfaction filter type last intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals = -20
    # Volume calc spatial condition satisfaction filter type none.
    eCrdnVolumeCalcVolumeSatisfactionFilterNone = 0
    # Volume calc spatial condition satisfaction filter type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration = 1
    # Volume calc spatial condition satisfaction filter type interval duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration = 2

AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type first intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type last intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterNone.__doc__ = "Volume calc spatial condition satisfaction filter type none."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration.__doc__ = "Volume calc spatial condition satisfaction filter type gap duration."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction filter type interval duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionFilterType"] = AgECrdnVolumeCalcVolumeSatisfactionFilterType

class AgECrdnVolumeCalcVolumeSatisfactionMetricType(IntEnum):
    """Defines volume calc spatial condition satisfaction metric types."""
    # Volume calc spatial condition satisfaction metric type number of gaps.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps = -2
    # Volume calc spatial condition satisfaction metric type number of intervals.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals = -1
    # Volume calc spatial condition satisfaction metric type time since last satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction = 1
    # Volume calc spatial condition satisfaction metric type time until next satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction = 2
    # Volume calc spatial condition satisfaction metric type interbnal duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration = 10
    # Volume calc spatial condition satisfaction metric type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration = 20

AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps.__doc__ = "Volume calc spatial condition satisfaction metric type number of gaps."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals.__doc__ = "Volume calc spatial condition satisfaction metric type number of intervals."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time since last satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time until next satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction metric type interbnal duration."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration.__doc__ = "Volume calc spatial condition satisfaction metric type gap duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionMetricType"] = AgECrdnVolumeCalcVolumeSatisfactionMetricType

class AgECrdnVolumeGridType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume grid.
    eCrdnVolumeGridTypeUnknown = -1
    # volume grid type cartesian.
    eCrdnVolumeGridTypeCartesian = 0
    # volume grid type Cylindrical.
    eCrdnVolumeGridTypeCylindrical = 1
    # volume grid type Spherical.
    eCrdnVolumeGridTypeSpherical = 2
    # volume grid type Constrained.
    eCrdnVolumeGridTypeConstrained = 3
    # volume grid type LatLonAlt (Cartographic).
    eCrdnVolumeGridTypeLatLonAlt = 4
    # volume grid type BearingAlt (Surface Bearing).
    eCrdnVolumeGridTypeBearingAlt = 5

AgECrdnVolumeGridType.eCrdnVolumeGridTypeUnknown.__doc__ = "Unknown or unsupported volume grid."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCartesian.__doc__ = "volume grid type cartesian."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCylindrical.__doc__ = "volume grid type Cylindrical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeSpherical.__doc__ = "volume grid type Spherical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeConstrained.__doc__ = "volume grid type Constrained."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeLatLonAlt.__doc__ = "volume grid type LatLonAlt (Cartographic)."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeBearingAlt.__doc__ = "volume grid type BearingAlt (Surface Bearing)."

agcls.AgTypeNameMap["AgECrdnVolumeGridType"] = AgECrdnVolumeGridType

class AgECrdnVolumeResultVectorRequest(IntEnum):
    """Defines volume result vector request types."""
    # volume result vector request pos type
    eCrdnVolumeResultVectorRequestPos = 1
    # volume result vector request native pos type
    eCrdnVolumeResultVectorRequestNativePos = 2
    # volume result vector request metric type
    eCrdnVolumeResultVectorRequestMetric = 16
    # volume result vector request satisfaction type
    eCrdnVolumeResultVectorRequestSatisfaction = 32
    # volume result vector request gradient type
    eCrdnVolumeResultVectorRequestGradient = 256

AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestPos.__doc__ = "volume result vector request pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestNativePos.__doc__ = "volume result vector request native pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestMetric.__doc__ = "volume result vector request metric type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestSatisfaction.__doc__ = "volume result vector request satisfaction type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestGradient.__doc__ = "volume result vector request gradient type"

agcls.AgTypeNameMap["AgECrdnVolumeResultVectorRequest"] = AgECrdnVolumeResultVectorRequest

class AgECrdnVolumeType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume.
    eCrdnVolumeTypeUnknown = -1
    # volume type combined.
    eCrdnVolumeTypeCombined = 0
    # volume type lighting.
    eCrdnVolumeTypeLighting = 1
    # volume type over time.
    eCrdnVolumeTypeOverTime = 2
    # volume type from grid (Grid Bounding Volume).
    eCrdnVolumeTypeFromGrid = 3
    # volume type from calc (Spatial Calculation Bounds).
    eCrdnVolumeTypeFromCalc = 4
    # volume type from time satisfaction (Valid Time At Location).
    eCrdnVolumeTypeFromTimeSatisfaction = 5
    # volume type from condition (Condition At Location).
    eCrdnVolumeTypeFromCondition = 6
    # volume type Inview (Access To Location).
    eCrdnVolumeTypeInview = 7

AgECrdnVolumeType.eCrdnVolumeTypeUnknown.__doc__ = "Unknown or unsupported volume."
AgECrdnVolumeType.eCrdnVolumeTypeCombined.__doc__ = "volume type combined."
AgECrdnVolumeType.eCrdnVolumeTypeLighting.__doc__ = "volume type lighting."
AgECrdnVolumeType.eCrdnVolumeTypeOverTime.__doc__ = "volume type over time."
AgECrdnVolumeType.eCrdnVolumeTypeFromGrid.__doc__ = "volume type from grid (Grid Bounding Volume)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCalc.__doc__ = "volume type from calc (Spatial Calculation Bounds)."
AgECrdnVolumeType.eCrdnVolumeTypeFromTimeSatisfaction.__doc__ = "volume type from time satisfaction (Valid Time At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCondition.__doc__ = "volume type from condition (Condition At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeInview.__doc__ = "volume type Inview (Access To Location)."

agcls.AgTypeNameMap["AgECrdnVolumeType"] = AgECrdnVolumeType

class AgECrdnVolumeAberrationType(IntEnum):
    """Defines the model of aberration to use."""
    # Aberration type unknown.
    eCrdnVolumeAberrationUnknown = -1
    # Aberration type total.
    eCrdnVolumeAberrationTotal = 0
    # SAberration type annual.
    eCrdnVolumeAberrationAnnual = 1
    # Aberration type none.
    eCrdnVolumeAberrationNone = 2

AgECrdnVolumeAberrationType.eCrdnVolumeAberrationUnknown.__doc__ = "Aberration type unknown."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationTotal.__doc__ = "Aberration type total."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationAnnual.__doc__ = "SAberration type annual."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationNone.__doc__ = "Aberration type none."

agcls.AgTypeNameMap["AgECrdnVolumeAberrationType"] = AgECrdnVolumeAberrationType

class AgECrdnVolumeClockHostType(IntEnum):
    """Defines whether base or target of an Access instance holds the clock for Access times."""
    # Unknown
    eCrdnVolumeClockHostUnknown = -1
    # Base object holds time instance.
    eCrdnVolumeClockHostBase = 0
    # Target object holds time instance.
    eCrdnVolumeClockHostTarget = 1

AgECrdnVolumeClockHostType.eCrdnVolumeClockHostUnknown.__doc__ = "Unknown"
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostBase.__doc__ = "Base object holds time instance."
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostTarget.__doc__ = "Target object holds time instance."

agcls.AgTypeNameMap["AgECrdnVolumeClockHostType"] = AgECrdnVolumeClockHostType

class AgECrdnVolumeCombinedOperationType(IntEnum):
    """Defines spatial condition combined operation types."""
    # Spatial condition combined AND operation.
    eCrdnVolumeCombinedOperationTypeAND = 1
    # Spatial condition combined OR operation.
    eCrdnVolumeCombinedOperationTypeOR = 2
    # Spatial condition combined XOR operation.
    eCrdnVolumeCombinedOperationTypeXOR = 3
    # Spatial condition combined MINUS operation.
    eCrdnVolumeCombinedOperationTypeMINUS = 4

AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeAND.__doc__ = "Spatial condition combined AND operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeOR.__doc__ = "Spatial condition combined OR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeXOR.__doc__ = "Spatial condition combined XOR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeMINUS.__doc__ = "Spatial condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnVolumeCombinedOperationType"] = AgECrdnVolumeCombinedOperationType

class AgECrdnVolumeFromGridEdgeType(IntEnum):
    """Defines spatial condition from grid edge type."""
    # Spatial condition over time from grid edge type mask points.
    eCrdnVolumeFromGridEdgeTypeMaskPoints = 16
    # Spatial condition over time from grid edge type mask voxels.
    eCrdnVolumeFromGridEdgeTypeMaskVoxels = 32

AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskPoints.__doc__ = "Spatial condition over time from grid edge type mask points."
AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskVoxels.__doc__ = "Spatial condition over time from grid edge type mask voxels."

agcls.AgTypeNameMap["AgECrdnVolumeFromGridEdgeType"] = AgECrdnVolumeFromGridEdgeType

class AgECrdnVolumeLightingConditionsType(IntFlag):
    """Defines spatial condition lighting conditions types."""
    # Spatial condition lighting undefined.
    eCrdnVolumeLightingConditionTypeUndefined = 0
    # Spatial condition lighting sun light.
    eCrdnVolumeLightingConditionTypeSunlight = 1
    # Spatial condition lighting penumbra.
    eCrdnVolumeLightingConditionTypePenumbra = 2
    # Spatial condition lighting umbra.
    eCrdnVolumeLightingConditionTypeUmbra = 4

AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUndefined.__doc__ = "Spatial condition lighting undefined."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeSunlight.__doc__ = "Spatial condition lighting sun light."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypePenumbra.__doc__ = "Spatial condition lighting penumbra."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUmbra.__doc__ = "Spatial condition lighting umbra."

agcls.AgTypeNameMap["AgECrdnVolumeLightingConditionsType"] = AgECrdnVolumeLightingConditionsType

class AgECrdnVolumeOverTimeDurationType(IntEnum):
    """Defines spatial condition over time duration type."""
    # Spatial condition over time duration type Static.
    eCrdnVolumeOverTimeDurationTypeStatic = 0
    # Spatial condition over time duration type CumulativeToCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent = 1
    # Spatial condition over time duration type CumulativeFromCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent = 2
    # Spatial condition over time duration type SlidingWindow.
    eCrdnVolumeOverTimeDurationTypeSlidingWindow = 3

AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeStatic.__doc__ = "Spatial condition over time duration type Static."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent.__doc__ = "Spatial condition over time duration type CumulativeToCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent.__doc__ = "Spatial condition over time duration type CumulativeFromCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeSlidingWindow.__doc__ = "Spatial condition over time duration type SlidingWindow."

agcls.AgTypeNameMap["AgECrdnVolumeOverTimeDurationType"] = AgECrdnVolumeOverTimeDurationType

class AgECrdnVolumeTimeSenseType(IntEnum):
    """Defines whether object1 or object2 of an Access instance holds the clock for Access times."""
    # Unklnown
    eCrdnVolumeTimeSenseUnknown = -1
    # Position is computed in Time Sense
    eCrdnVolumeTimeSenseTransmit = 0
    # Position is computed in Receive Sense
    eCrdnVolumeTimeSenseReceive = 1

AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseUnknown.__doc__ = "Unklnown"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseTransmit.__doc__ = "Position is computed in Time Sense"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseReceive.__doc__ = "Position is computed in Receive Sense"

agcls.AgTypeNameMap["AgECrdnVolumeTimeSenseType"] = AgECrdnVolumeTimeSenseType

class AgECrdnVolumetricGridValuesMethodType(IntEnum):
    """Defines volumetric grid values method types."""
    # Unknown or unsupportedgrid values method.
    eCrdnVolumetricGridValuesMethodMethodUnknown = -1
    # Fixed number steps grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedNumSteps = 0
    # Fixed step size grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedStepSize = 1
    # Custom grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodCustomValues = 2

AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodUnknown.__doc__ = "Unknown or unsupportedgrid values method."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedNumSteps.__doc__ = "Fixed number steps grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedStepSize.__doc__ = "Fixed step size grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodCustomValues.__doc__ = "Custom grid values method for volumetric grid."

agcls.AgTypeNameMap["AgECrdnVolumetricGridValuesMethodType"] = AgECrdnVolumetricGridValuesMethodType

class AgECrdnKind(IntEnum):
    """Represents kinds of vectory geometry components."""
    # Unsupported component kind.
    eCrdnKindUnknown = -1
    # Invalid component.
    eCrdnKindInvalid = 0
    # Axes component.
    eCrdnKindAxes = 1
    # Angle component.
    eCrdnKindAngle = 2
    # Vector component.
    eCrdnKindVector = 3
    # Point component.
    eCrdnKindPoint = 4
    # Plane component.
    eCrdnKindPlane = 5
    # System component.
    eCrdnKindSystem = 6
    # An event.
    eCrdnKindEvent = 7
    # An event array.
    eCrdnKindEventArray = 8
    # An event interval.
    eCrdnKindEventInterval = 9
    # An event interval collection.
    eCrdnKindEventIntervalCollection = 10
    # A list of event intervals.
    eCrdnKindEventIntervalList = 11
    # A parameter set.
    eCrdnKindParameterSet = 12
    # A scalar.
    eCrdnKindCalcScalar = 13
    # A condition.
    eCrdnKindCondition = 14
    # A condition set.
    eCrdnKindConditionSet = 15
    # A volume grid.
    eCrdnKindVolumeGrid = 16
    # A volume.
    eCrdnKindVolume = 17
    # A volume calc.
    eCrdnKindVolumeCalc = 18

AgECrdnKind.eCrdnKindUnknown.__doc__ = "Unsupported component kind."
AgECrdnKind.eCrdnKindInvalid.__doc__ = "Invalid component."
AgECrdnKind.eCrdnKindAxes.__doc__ = "Axes component."
AgECrdnKind.eCrdnKindAngle.__doc__ = "Angle component."
AgECrdnKind.eCrdnKindVector.__doc__ = "Vector component."
AgECrdnKind.eCrdnKindPoint.__doc__ = "Point component."
AgECrdnKind.eCrdnKindPlane.__doc__ = "Plane component."
AgECrdnKind.eCrdnKindSystem.__doc__ = "System component."
AgECrdnKind.eCrdnKindEvent.__doc__ = "An event."
AgECrdnKind.eCrdnKindEventArray.__doc__ = "An event array."
AgECrdnKind.eCrdnKindEventInterval.__doc__ = "An event interval."
AgECrdnKind.eCrdnKindEventIntervalCollection.__doc__ = "An event interval collection."
AgECrdnKind.eCrdnKindEventIntervalList.__doc__ = "A list of event intervals."
AgECrdnKind.eCrdnKindParameterSet.__doc__ = "A parameter set."
AgECrdnKind.eCrdnKindCalcScalar.__doc__ = "A scalar."
AgECrdnKind.eCrdnKindCondition.__doc__ = "A condition."
AgECrdnKind.eCrdnKindConditionSet.__doc__ = "A condition set."
AgECrdnKind.eCrdnKindVolumeGrid.__doc__ = "A volume grid."
AgECrdnKind.eCrdnKindVolume.__doc__ = "A volume."
AgECrdnKind.eCrdnKindVolumeCalc.__doc__ = "A volume calc."

agcls.AgTypeNameMap["AgECrdnKind"] = AgECrdnKind

class AgECrdnAngleType(IntEnum):
    """Represents angle types."""
    # Unknown or unsupported type.
    eCrdnAngleTypeUnknown = -1
    # An angle between two vectors.
    eCrdnAngleTypeBetweenVectors = 0
    # An angle between two planes.
    eCrdnAngleTypeBetweenPlanes = 1
    # An angle between two vectors about an axis.
    eCrdnAngleTypeDihedralAngle = 2
    # Angle of the shortest rotation between the two specified axes.
    eCrdnAngleTypeRotation = 3
    # An angle between a vector and a plane.
    eCrdnAngleTypeToPlane = 4
    # Represents a VGT angle created from a template. This type of angle is not creatable.
    eCrdnAngleTypeTemplate = 5

AgECrdnAngleType.eCrdnAngleTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAngleType.eCrdnAngleTypeBetweenVectors.__doc__ = "An angle between two vectors."
AgECrdnAngleType.eCrdnAngleTypeBetweenPlanes.__doc__ = "An angle between two planes."
AgECrdnAngleType.eCrdnAngleTypeDihedralAngle.__doc__ = "An angle between two vectors about an axis."
AgECrdnAngleType.eCrdnAngleTypeRotation.__doc__ = "Angle of the shortest rotation between the two specified axes."
AgECrdnAngleType.eCrdnAngleTypeToPlane.__doc__ = "An angle between a vector and a plane."
AgECrdnAngleType.eCrdnAngleTypeTemplate.__doc__ = "Represents a VGT angle created from a template. This type of angle is not creatable."

agcls.AgTypeNameMap["AgECrdnAngleType"] = AgECrdnAngleType

class AgECrdnAxesType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported type.
    eCrdnAxesTypeUnknown = -1
    # Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type.
    eCrdnAxesTypeLagrangeLibration = 0
    # Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset.
    eCrdnAxesTypeAngularOffset = 1
    # Axes based on another set fixed at a specified epoch.
    eCrdnAxesTypeFixedAtEpoch = 2
    # B-Plane axes using the selected target body and reference vector.
    eCrdnAxesTypeBPlane = 3
    # Customized axes offset with respect to a set of reference Axes.
    eCrdnAxesTypeCustomScript = 4
    # Axes fixed in reference axes.
    eCrdnAxesTypeFixed = 6
    # Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference.
    eCrdnAxesTypeAlignedAndConstrained = 7
    # Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element.
    eCrdnAxesTypeModelAttachment = 8
    # Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset.
    eCrdnAxesTypeSpinning = 9
    # Projection of the reference point onto the central body.
    eCrdnAxesTypeOnSurface = 10
    # Axes based on trajectory of the point relative to the reference coordinate system.
    eCrdnAxesTypeTrajectory = 11
    # Represents a VGT axes created from a template. This type of axes is not creatable.
    eCrdnAxesTypeTemplate = 12
    # Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant.
    eCrdnAxesTypeAtTimeInstant = 13
    # An axes plugin point.
    eCrdnAxesTypePlugin = 14
    # Axes specified by data from a file.
    eCrdnAxesTypeFile = 5

AgECrdnAxesType.eCrdnAxesTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAxesType.eCrdnAxesTypeLagrangeLibration.__doc__ = "Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."
AgECrdnAxesType.eCrdnAxesTypeAngularOffset.__doc__ = "Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeFixedAtEpoch.__doc__ = "Axes based on another set fixed at a specified epoch."
AgECrdnAxesType.eCrdnAxesTypeBPlane.__doc__ = "B-Plane axes using the selected target body and reference vector."
AgECrdnAxesType.eCrdnAxesTypeCustomScript.__doc__ = "Customized axes offset with respect to a set of reference Axes."
AgECrdnAxesType.eCrdnAxesTypeFixed.__doc__ = "Axes fixed in reference axes."
AgECrdnAxesType.eCrdnAxesTypeAlignedAndConstrained.__doc__ = "Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."
AgECrdnAxesType.eCrdnAxesTypeModelAttachment.__doc__ = "Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."
AgECrdnAxesType.eCrdnAxesTypeSpinning.__doc__ = "Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeOnSurface.__doc__ = "Projection of the reference point onto the central body."
AgECrdnAxesType.eCrdnAxesTypeTrajectory.__doc__ = "Axes based on trajectory of the point relative to the reference coordinate system."
AgECrdnAxesType.eCrdnAxesTypeTemplate.__doc__ = "Represents a VGT axes created from a template. This type of axes is not creatable."
AgECrdnAxesType.eCrdnAxesTypeAtTimeInstant.__doc__ = "Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."
AgECrdnAxesType.eCrdnAxesTypePlugin.__doc__ = "An axes plugin point."
AgECrdnAxesType.eCrdnAxesTypeFile.__doc__ = "Axes specified by data from a file."

agcls.AgTypeNameMap["AgECrdnAxesType"] = AgECrdnAxesType

class AgECrdnPlaneType(IntEnum):
    """Represents plane types."""
    # Unknown or unsupported type.
    eCrdnPlaneTypeUnknown = -1
    # A plane normal to a vector at a given point.
    eCrdnPlaneTypeNormal = 0
    # A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system.
    eCrdnPlaneTypeQuadrant = 1
    # A plane is defined on the basis of a trajectory of a selected point with respect to a reference point.
    eCrdnPlaneTypeTrajectory = 2
    # A plane is defined by the three points.
    eCrdnPlaneTypeTriad = 3
    # Represents a VGT plane created from a template. This type of plane is not creatable.
    eCrdnPlaneTypeTemplate = 4
    # A plane passing through point and containing two given vectors.
    eCrdnPlaneTypeTwoVector = 5

AgECrdnPlaneType.eCrdnPlaneTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPlaneType.eCrdnPlaneTypeNormal.__doc__ = "A plane normal to a vector at a given point."
AgECrdnPlaneType.eCrdnPlaneTypeQuadrant.__doc__ = "A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."
AgECrdnPlaneType.eCrdnPlaneTypeTrajectory.__doc__ = "A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."
AgECrdnPlaneType.eCrdnPlaneTypeTriad.__doc__ = "A plane is defined by the three points."
AgECrdnPlaneType.eCrdnPlaneTypeTemplate.__doc__ = "Represents a VGT plane created from a template. This type of plane is not creatable."
AgECrdnPlaneType.eCrdnPlaneTypeTwoVector.__doc__ = "A plane passing through point and containing two given vectors."

agcls.AgTypeNameMap["AgECrdnPlaneType"] = AgECrdnPlaneType

class AgECrdnPointType(IntEnum):
    """Represents point types."""
    # Unknown or unsupported type.
    eCrdnPointTypeUnknown = -1
    # B-Plane point using the selected target body.
    eCrdnPointTypeBPlane = 0
    # The grazing point is the point of closest approach to the surface of the selected central body along a defined direction.
    eCrdnPointTypeGrazing = 1
    # The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option.
    eCrdnPointTypeCovarianceGrazing = 2
    # Point fixed in a reference coordinate system.
    eCrdnPointTypeFixedInSystem = 4
    # Point on central body surface that reflects from source to observer.
    eCrdnPointTypeGlint = 5
    # Point on a plane located along a given direction looking from a given origin.
    eCrdnPointTypePlaneIntersection = 6
    # Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point.
    eCrdnPointTypeModelAttachment = 7
    # The projection of a point onto a reference plane.
    eCrdnPointTypePlaneProjection = 8
    # The detic subpoint of the reference point as projected onto the central body.
    eCrdnPointTypeOnSurface = 9
    # Libration point using one primary and multiple secondary central bodies.
    eCrdnPointTypeLagrangeLibration = 10
    # Represents a VGT point created from a template. This type of point is not creatable.
    eCrdnPointTypeTemplate = 11
    # Point on central body surface along direction vector originating at source point.
    eCrdnPointTypeCentralBodyIntersect = 12
    # Point fixed relative to reference system based on another point evaluated at specified time instant.
    eCrdnPointTypeAtTimeInstant = 13
    # A point plugin point.
    eCrdnPointTypePlugin = 14
    # Point specified by data from a file.
    eCrdnPointTypeFile = 3
    # Point fixed on a central body.
    eCrdnPointTypeFixedOnCentralBody = 15
    # A point placed at the center of mass of a specified satellite of the satellite collection.
    eCrdnPointTypeSatelliteCollectionEntry = 16

AgECrdnPointType.eCrdnPointTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPointType.eCrdnPointTypeBPlane.__doc__ = "B-Plane point using the selected target body."
AgECrdnPointType.eCrdnPointTypeGrazing.__doc__ = "The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."
AgECrdnPointType.eCrdnPointTypeCovarianceGrazing.__doc__ = "The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."
AgECrdnPointType.eCrdnPointTypeFixedInSystem.__doc__ = "Point fixed in a reference coordinate system."
AgECrdnPointType.eCrdnPointTypeGlint.__doc__ = "Point on central body surface that reflects from source to observer."
AgECrdnPointType.eCrdnPointTypePlaneIntersection.__doc__ = "Point on a plane located along a given direction looking from a given origin."
AgECrdnPointType.eCrdnPointTypeModelAttachment.__doc__ = "Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."
AgECrdnPointType.eCrdnPointTypePlaneProjection.__doc__ = "The projection of a point onto a reference plane."
AgECrdnPointType.eCrdnPointTypeOnSurface.__doc__ = "The detic subpoint of the reference point as projected onto the central body."
AgECrdnPointType.eCrdnPointTypeLagrangeLibration.__doc__ = "Libration point using one primary and multiple secondary central bodies."
AgECrdnPointType.eCrdnPointTypeTemplate.__doc__ = "Represents a VGT point created from a template. This type of point is not creatable."
AgECrdnPointType.eCrdnPointTypeCentralBodyIntersect.__doc__ = "Point on central body surface along direction vector originating at source point."
AgECrdnPointType.eCrdnPointTypeAtTimeInstant.__doc__ = "Point fixed relative to reference system based on another point evaluated at specified time instant."
AgECrdnPointType.eCrdnPointTypePlugin.__doc__ = "A point plugin point."
AgECrdnPointType.eCrdnPointTypeFile.__doc__ = "Point specified by data from a file."
AgECrdnPointType.eCrdnPointTypeFixedOnCentralBody.__doc__ = "Point fixed on a central body."
AgECrdnPointType.eCrdnPointTypeSatelliteCollectionEntry.__doc__ = "A point placed at the center of mass of a specified satellite of the satellite collection."

agcls.AgTypeNameMap["AgECrdnPointType"] = AgECrdnPointType

class AgECrdnSystemType(IntEnum):
    """Represents system types."""
    # Unknown or unsupported system type.
    eCrdnSystemTypeUnknown = -1
    # A system assembled from an origin point and a set of reference axes.
    eCrdnSystemTypeAssembled = 0
    # A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle.
    eCrdnSystemTypeOnSurface = 1
    # Represents a VGT system created from a template. This type of system is not creatable.
    eCrdnSystemTypeTemplate = 2

AgECrdnSystemType.eCrdnSystemTypeUnknown.__doc__ = "Unknown or unsupported system type."
AgECrdnSystemType.eCrdnSystemTypeAssembled.__doc__ = "A system assembled from an origin point and a set of reference axes."
AgECrdnSystemType.eCrdnSystemTypeOnSurface.__doc__ = "A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."
AgECrdnSystemType.eCrdnSystemTypeTemplate.__doc__ = "Represents a VGT system created from a template. This type of system is not creatable."

agcls.AgTypeNameMap["AgECrdnSystemType"] = AgECrdnSystemType

class AgECrdnVectorType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported vector type.
    eCrdnVectorTypeUnknown = -1
    # Vector defined by its start and end points.
    eCrdnVectorTypeDisplacement = 0
    # Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeApoapsis = 1
    # Based on another vector fixed at a specified epoch.
    eCrdnVectorTypeFixedAtEpoch = 2
    # Angular velocity vector of one set of axes computed with respect to the reference set.
    eCrdnVectorTypeAngularVelocity = 3
    # Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode.
    eCrdnVectorTypeConing = 4
    # The vector cross product of two vectors.
    eCrdnVectorTypeCrossProduct = 5
    # Customized vector components defined with respect to reference axes.
    eCrdnVectorTypeCustomScript = 6
    # Derivative of a vector computed with respect to specified axes.
    eCrdnVectorTypeDerivative = 7
    # Angle rate vector perpendicular to the plane in which the angle is defined.
    eCrdnVectorTypeAngleRate = 8
    # Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeEccentricity = 9
    # Vector fixed in reference axes.
    eCrdnVectorTypeFixedInAxes = 10
    # Defined along the intersection of two planes.
    eCrdnVectorTypeTwoPlanesIntersection = 12
    # Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body.
    eCrdnVectorTypeLineOfNodes = 13
    # Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element.
    eCrdnVectorTypeModelAttachment = 14
    # Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitAngularMomentum = 15
    # Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitNormal = 16
    # Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypePeriapsis = 17
    # A projection of a vector computed with respect to a reference plane.
    eCrdnVectorTypeProjection = 18
    # Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane.
    eCrdnVectorTypeReflection = 19
    # Scaled version of the input vector.
    eCrdnVectorTypeScaled = 20
    # Defined with respect to a star object.
    eCrdnVectorTypeDirectionToStar = 21
    # Represents a VGT vector created from a template. This type of vector is not creatable.
    eCrdnVectorTypeTemplate = 22
    # Vector fixed relative to reference axes based on another vector evaluated at specified time instant.
    eCrdnVectorTypeAtTimeInstant = 23
    # Linear combination of two input vectors.
    eCrdnVectorTypeLinearCombination = 24
    # A projection of a source vector in the direction of another vector.
    eCrdnVectorTypeProjectAlong = 25
    # Linear combination of two input vectors using scalars.
    eCrdnVectorTypeScalarLinearCombination = 26
    # Scaled version of the input vector using scalar.
    eCrdnVectorTypeScalarScaled = 27
    # Velocity vector of a point in a coordinate system.
    eCrdnVectorTypeVelocity = 28
    # A vector plugin point.
    eCrdnVectorTypePlugin = 29
    # Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis.
    eCrdnVectorTypeRotationVector = 30
    # Displacement between origin and destination points using surface distance and altitude difference.
    eCrdnVectorTypeDisplacementOnSurface = 31

AgECrdnVectorType.eCrdnVectorTypeUnknown.__doc__ = "Unknown or unsupported vector type."
AgECrdnVectorType.eCrdnVectorTypeDisplacement.__doc__ = "Vector defined by its start and end points."
AgECrdnVectorType.eCrdnVectorTypeApoapsis.__doc__ = "Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedAtEpoch.__doc__ = "Based on another vector fixed at a specified epoch."
AgECrdnVectorType.eCrdnVectorTypeAngularVelocity.__doc__ = "Angular velocity vector of one set of axes computed with respect to the reference set."
AgECrdnVectorType.eCrdnVectorTypeConing.__doc__ = "Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."
AgECrdnVectorType.eCrdnVectorTypeCrossProduct.__doc__ = "The vector cross product of two vectors."
AgECrdnVectorType.eCrdnVectorTypeCustomScript.__doc__ = "Customized vector components defined with respect to reference axes."
AgECrdnVectorType.eCrdnVectorTypeDerivative.__doc__ = "Derivative of a vector computed with respect to specified axes."
AgECrdnVectorType.eCrdnVectorTypeAngleRate.__doc__ = "Angle rate vector perpendicular to the plane in which the angle is defined."
AgECrdnVectorType.eCrdnVectorTypeEccentricity.__doc__ = "Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedInAxes.__doc__ = "Vector fixed in reference axes."
AgECrdnVectorType.eCrdnVectorTypeTwoPlanesIntersection.__doc__ = "Defined along the intersection of two planes."
AgECrdnVectorType.eCrdnVectorTypeLineOfNodes.__doc__ = "Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeModelAttachment.__doc__ = "Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."
AgECrdnVectorType.eCrdnVectorTypeOrbitAngularMomentum.__doc__ = "Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeOrbitNormal.__doc__ = "Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypePeriapsis.__doc__ = "Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeProjection.__doc__ = "A projection of a vector computed with respect to a reference plane."
AgECrdnVectorType.eCrdnVectorTypeReflection.__doc__ = "Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."
AgECrdnVectorType.eCrdnVectorTypeScaled.__doc__ = "Scaled version of the input vector."
AgECrdnVectorType.eCrdnVectorTypeDirectionToStar.__doc__ = "Defined with respect to a star object."
AgECrdnVectorType.eCrdnVectorTypeTemplate.__doc__ = "Represents a VGT vector created from a template. This type of vector is not creatable."
AgECrdnVectorType.eCrdnVectorTypeAtTimeInstant.__doc__ = "Vector fixed relative to reference axes based on another vector evaluated at specified time instant."
AgECrdnVectorType.eCrdnVectorTypeLinearCombination.__doc__ = "Linear combination of two input vectors."
AgECrdnVectorType.eCrdnVectorTypeProjectAlong.__doc__ = "A projection of a source vector in the direction of another vector."
AgECrdnVectorType.eCrdnVectorTypeScalarLinearCombination.__doc__ = "Linear combination of two input vectors using scalars."
AgECrdnVectorType.eCrdnVectorTypeScalarScaled.__doc__ = "Scaled version of the input vector using scalar."
AgECrdnVectorType.eCrdnVectorTypeVelocity.__doc__ = "Velocity vector of a point in a coordinate system."
AgECrdnVectorType.eCrdnVectorTypePlugin.__doc__ = "A vector plugin point."
AgECrdnVectorType.eCrdnVectorTypeRotationVector.__doc__ = "Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."
AgECrdnVectorType.eCrdnVectorTypeDisplacementOnSurface.__doc__ = "Displacement between origin and destination points using surface distance and altitude difference."

agcls.AgTypeNameMap["AgECrdnVectorType"] = AgECrdnVectorType

class AgECrdnMeanElementTheory(IntEnum):
    """Mean element theory types for approximating motion."""
    # Osculating elements (six standard Keplerian orbital elements).
    eCrdnMeanElementTheoryOsculating = 1
    # The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377.
    eCrdnMeanElementTheoryKozai = 2
    # Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2.
    eCrdnMeanElementTheoryBrouwerLyddane_Long = 3
    # Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term.
    eCrdnMeanElementTheoryBrouwerLyddane_Short = 4

AgECrdnMeanElementTheory.eCrdnMeanElementTheoryOsculating.__doc__ = "Osculating elements (six standard Keplerian orbital elements)."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryKozai.__doc__ = "The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Long.__doc__ = "Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Short.__doc__ = "Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."

agcls.AgTypeNameMap["AgECrdnMeanElementTheory"] = AgECrdnMeanElementTheory

class AgECrdnDirectionType(IntEnum):
    """Direction options."""
    # Incoming direction.
    eCrdnDirectionIncomingAsymptote = 1
    # Outgoing direction.
    eCrdnDirectionOutgoingAsymptote = 2

AgECrdnDirectionType.eCrdnDirectionIncomingAsymptote.__doc__ = "Incoming direction."
AgECrdnDirectionType.eCrdnDirectionOutgoingAsymptote.__doc__ = "Outgoing direction."

agcls.AgTypeNameMap["AgECrdnDirectionType"] = AgECrdnDirectionType

class AgECrdnLagrangeLibrationPointType(IntEnum):
    """Types of the Lagrange points, also known as libration points. Lagrange points are points in space where gravitational forces and the orbital motion of a body balance each other."""
    # A point between the Sun and Earth.
    eCrdnLagrangeLibrationPointTypeL1 = 1
    # Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth.
    eCrdnLagrangeLibrationPointTypeL2 = 2
    # L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times.
    eCrdnLagrangeLibrationPointTypeL3 = 3
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL4 = 4
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL5 = 5

AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL1.__doc__ = "A point between the Sun and Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL2.__doc__ = "Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL3.__doc__ = "L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL4.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL5.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."

agcls.AgTypeNameMap["AgECrdnLagrangeLibrationPointType"] = AgECrdnLagrangeLibrationPointType

class AgECrdnQuadrantType(IntEnum):
    """Quadrants from a reference system (e.g., XY, XZ, YZ, YX, ZX, ZY),"""
    # XY quadrant.
    eCrdnQuadrantXY = 1
    # YX quadrant.
    eCrdnQuadrantYX = 2
    # XZ quadrant.
    eCrdnQuadrantXZ = 3
    # ZX quadrant.
    eCrdnQuadrantZX = 4
    # YZ quadrant.
    eCrdnQuadrantYZ = 5
    # ZY quadrant.
    eCrdnQuadrantZY = 6

AgECrdnQuadrantType.eCrdnQuadrantXY.__doc__ = "XY quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYX.__doc__ = "YX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantXZ.__doc__ = "XZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZX.__doc__ = "ZX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYZ.__doc__ = "YZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZY.__doc__ = "ZY quadrant."

agcls.AgTypeNameMap["AgECrdnQuadrantType"] = AgECrdnQuadrantType

class AgECrdnTrajectoryAxesType(IntEnum):
    """Trajectory axes coordinate types."""
    # Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack).
    eCrdnTrajectoryAxesICR = 0
    # Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal).
    eCrdnTrajectoryAxesVNC = 1
    # Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack).
    eCrdnTrajectoryAxesRIC = 2
    # Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal).
    eCrdnTrajectoryAxesLVLH = 3
    # Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity).
    eCrdnTrajectoryAxesVVLH = 4
    # Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesBBR = 5
    # Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesEquinoctial = 6
    # Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal).
    eCrdnTrajectoryAxesNTC = 7

AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesICR.__doc__ = "Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVNC.__doc__ = "Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesRIC.__doc__ = "Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesLVLH.__doc__ = "Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVVLH.__doc__ = "Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesBBR.__doc__ = "Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesEquinoctial.__doc__ = "Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesNTC.__doc__ = "Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."

agcls.AgTypeNameMap["AgECrdnTrajectoryAxesType"] = AgECrdnTrajectoryAxesType

class AgECrdnDisplayAxisSelector(IntEnum):
    """Rotation directions."""
    # Rotate about Axis X.
    eCrdnDisplayAxisX = 0
    # Rotate about Axis Y.
    eCrdnDisplayAxisY = 1
    # Rotate about Axis Z.
    eCrdnDisplayAxisZ = 2

AgECrdnDisplayAxisSelector.eCrdnDisplayAxisX.__doc__ = "Rotate about Axis X."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisY.__doc__ = "Rotate about Axis Y."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisZ.__doc__ = "Rotate about Axis Z."

agcls.AgTypeNameMap["AgECrdnDisplayAxisSelector"] = AgECrdnDisplayAxisSelector

class AgECrdnSignedAngleType(IntEnum):
    """Defines options for computing an angle."""
    # Choose the option to use unsigned angle.
    eCrdnSignedAngleNone = 0
    # Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAnglePositive = 1
    # Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAngleNegative = 2

AgECrdnSignedAngleType.eCrdnSignedAngleNone.__doc__ = "Choose the option to use unsigned angle."
AgECrdnSignedAngleType.eCrdnSignedAnglePositive.__doc__ = "Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."
AgECrdnSignedAngleType.eCrdnSignedAngleNegative.__doc__ = "Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."

agcls.AgTypeNameMap["AgECrdnSignedAngleType"] = AgECrdnSignedAngleType

class AgECrdnPointBPlaneType(IntEnum):
    """B-Plane point types."""
    # Asymptote.
    eCrdnPointBPlaneAsymptote = 1
    # Two body.
    eCrdnPointBPlaneATwoBody = 2

AgECrdnPointBPlaneType.eCrdnPointBPlaneAsymptote.__doc__ = "Asymptote."
AgECrdnPointBPlaneType.eCrdnPointBPlaneATwoBody.__doc__ = "Two body."

agcls.AgTypeNameMap["AgECrdnPointBPlaneType"] = AgECrdnPointBPlaneType

class AgECrdnReferenceShapeType(IntEnum):
    """Surface shape types."""
    # An ellipsoid reference shape as defined by the central body (by default, it is WSG84).
    eCrdnReferenceShapeEllipsoid = 1
    # Terrain as the terrain reference.
    eCrdnReferenceShapeTerrain = 2
    # Mean Sea Level as the terrain reference.
    eCrdnReferenceShapeMSL = 3

AgECrdnReferenceShapeType.eCrdnReferenceShapeEllipsoid.__doc__ = "An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."
AgECrdnReferenceShapeType.eCrdnReferenceShapeTerrain.__doc__ = "Terrain as the terrain reference."
AgECrdnReferenceShapeType.eCrdnReferenceShapeMSL.__doc__ = "Mean Sea Level as the terrain reference."

agcls.AgTypeNameMap["AgECrdnReferenceShapeType"] = AgECrdnReferenceShapeType

class AgECrdnSurfaceType(IntEnum):
    """Surface types."""
    # Detic surface model.
    eCrdnSurfaceDetic = 1
    # Centric surface model.
    eCrdnSurfaceCentric = 2

AgECrdnSurfaceType.eCrdnSurfaceDetic.__doc__ = "Detic surface model."
AgECrdnSurfaceType.eCrdnSurfaceCentric.__doc__ = "Centric surface model."

agcls.AgTypeNameMap["AgECrdnSurfaceType"] = AgECrdnSurfaceType

class AgECrdnSweepMode(IntEnum):
    """The rotation sweeping modes."""
    # Bidirectional sweeping mode.
    eCrdnSweepModeBidirectional = 1
    # Unidirectional sweeping mode.
    eCrdnSweepModeUnidirectional = 2

AgECrdnSweepMode.eCrdnSweepModeBidirectional.__doc__ = "Bidirectional sweeping mode."
AgECrdnSweepMode.eCrdnSweepModeUnidirectional.__doc__ = "Unidirectional sweeping mode."

agcls.AgTypeNameMap["AgECrdnSweepMode"] = AgECrdnSweepMode

class AgECrdnSignalSense(IntEnum):
    """Signal sense transmission options."""
    # Signal receive.
    eCrdnSignalSenseReceive = 1
    # Signal transmit.
    eCrdnSignalSenseTransmit = 2

AgECrdnSignalSense.eCrdnSignalSenseReceive.__doc__ = "Signal receive."
AgECrdnSignalSense.eCrdnSignalSenseTransmit.__doc__ = "Signal transmit."

agcls.AgTypeNameMap["AgECrdnSignalSense"] = AgECrdnSignalSense

class AgECrdnIntersectionSurface(IntEnum):
    """Intersection surface flags."""
    # Intersection with central body ellipsoid.
    eCrdnIntersectionSurfaceAtCentralBodyEllipsoid = 0
    # Intersection at altitude.
    eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid = 1
    # Use terrain as intersection surface.
    eCrdnIntersectionSurfaceAtTerrain = 2

AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtCentralBodyEllipsoid.__doc__ = "Intersection with central body ellipsoid."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid.__doc__ = "Intersection at altitude."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtTerrain.__doc__ = "Use terrain as intersection surface."

agcls.AgTypeNameMap["AgECrdnIntersectionSurface"] = AgECrdnIntersectionSurface

class AgECrdnVectorScaledDimensionInheritance(IntEnum):
    """Dimension inheritance constants used to configure the dimension inheritance of a vector scaled by a scalar."""
    # Do not inherit dimension.
    eCrdnVectorScaledDimensionInheritanceNone = 0
    # Inherit dimension from scalar.
    eCrdnVectorScaledDimensionInheritanceFromScalar = 1
    # Inherit dimension from vector.
    eCrdnVectorScaledDimensionInheritanceFromVector = 2

AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromScalar.__doc__ = "Inherit dimension from scalar."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromVector.__doc__ = "Inherit dimension from vector."

agcls.AgTypeNameMap["AgECrdnVectorScaledDimensionInheritance"] = AgECrdnVectorScaledDimensionInheritance


class IIntervalCollection(object):
    """The interface represents a collection of intervals."""
    _uuid = "{DAE5D702-43F1-4544-8039-97E746D019AB}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIntervalCollection = agcom.GUID(IIntervalCollection._uuid)
        vtable_offset_local = IIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIntervalCollection.__dict__ and type(IIntervalCollection.__dict__[attrname]) == property:
            return IIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Return a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IInterval":
        """Returns an interval at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DAE5D702-43F1-4544-8039-97E746D019AB}", IIntervalCollection)
agcls.AgTypeNameMap["IIntervalCollection"] = IIntervalCollection

class IInterval(object):
    """The interface represents an interval."""
    _uuid = "{4A5031BC-45C0-4E75-9190-31F1802C173D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IInterval = agcom.GUID(IInterval._uuid)
        vtable_offset_local = IInterval._vtable_offset - 1
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_IInterval, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_IInterval, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IInterval.__dict__ and type(IInterval.__dict__[attrname]) == property:
            return IInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IInterval.")
    
    @property
    def Start(self) -> typing.Any:
        """The interval's start time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The interval's stop time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4A5031BC-45C0-4E75-9190-31F1802C173D}", IInterval)
agcls.AgTypeNameMap["IInterval"] = IInterval

class IPoint(object):
    """The interface defines methods and properties common to all points."""
    _uuid = "{086D1AA7-D85D-402D-9347-0B51EB552537}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_LocateInSystemWithRate"] = _raise_uninitialized_error
        self.__dict__["_LocateInSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPoint = agcom.GUID(IPoint._uuid)
        vtable_offset_local = IPoint._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IPoint, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_LocateInSystemWithRate"] = IAGFUNCTYPE(pUnk, IID_IPoint, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_LocateInSystem"] = IAGFUNCTYPE(pUnk, IID_IPoint, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPoint.__dict__ and type(IPoint.__dict__[attrname]) == property:
            return IPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPoint.")
    
    @property
    def Type(self) -> "AgECrdnPointType":
        """Returns a type of the point object."""
        with agmarshall.AgEnum_arg(AgECrdnPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def LocateInSystemWithRate(self, epoch:typing.Any, system:"ISystem") -> "IPointLocateInSystemWithRateResult":
        """Locates the point's position and velocity in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ISystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_LocateInSystemWithRate"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def LocateInSystem(self, epoch:typing.Any, system:"ISystem") -> "IPointLocateInSystemResult":
        """Locates the point's position in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ISystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_LocateInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{086D1AA7-D85D-402D-9347-0B51EB552537}", IPoint)
agcls.AgTypeNameMap["IPoint"] = IPoint

class IVector(object):
    """The interface defines methods and properties common to all vectors."""
    _uuid = "{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVector = agcom.GUID(IVector._uuid)
        vtable_offset_local = IVector._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_IVector, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_IVector, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVector.__dict__ and type(IVector.__dict__[attrname]) == property:
            return IVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVector.")
    
    @property
    def Type(self) -> "AgECrdnVectorType":
        """Returns a type of the vector object."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IAxes") -> "IVectorFindInAxesResult":
        """Computes the vector in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAxes") -> "IVectorFindInAxesWithRateResult":
        """Computes the vector and its rate in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}", IVector)
agcls.AgTypeNameMap["IVector"] = IVector

class ISystem(object):
    """The interface contains methods and properties shared by all VGT systems."""
    _uuid = "{14687421-5E90-4275-9DE5-21295EC14F65}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInSystem"] = _raise_uninitialized_error
        self.__dict__["_Transform"] = _raise_uninitialized_error
        self.__dict__["_TransformWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystem = agcom.GUID(ISystem._uuid)
        vtable_offset_local = ISystem._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ISystem, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInSystem"] = IAGFUNCTYPE(pUnk, IID_ISystem, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_Transform"] = IAGFUNCTYPE(pUnk, IID_ISystem, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_TransformWithRate"] = IAGFUNCTYPE(pUnk, IID_ISystem, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystem.__dict__ and type(ISystem.__dict__[attrname]) == property:
            return ISystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystem.")
    
    @property
    def Type(self) -> "AgECrdnSystemType":
        """Returns a type of the system object."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"ISystem") -> "ISystemFindInSystemResult":
        """Find position, velocity, rate and orientation using the specified system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ISystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputSystem:"ISystem", positionInMySystem:"ICartesian3Vector") -> "ISystemTransformResult":
        """Translates the position vector from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, ISystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, ICartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Transform"](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputSystem:"ISystem", positionInMySystem:"ICartesian3Vector", velocityInMySystem:"ICartesian3Vector") -> "ISystemTransformWithRateResult":
        """Translates the position and rate vectors from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, ISystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, ICartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_in_arg(velocityInMySystem, ICartesian3Vector) as arg_velocityInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_TransformWithRate"](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, arg_velocityInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{14687421-5E90-4275-9DE5-21295EC14F65}", ISystem)
agcls.AgTypeNameMap["ISystem"] = ISystem

class IAxes(object):
    """The interface defines methods and properties common to all axes."""
    _uuid = "{EE2FCF98-9315-406A-835C-40C56428C888}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_GetZ"] = _raise_uninitialized_error
        self.__dict__["_Transform"] = _raise_uninitialized_error
        self.__dict__["_TransformWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxes = agcom.GUID(IAxes._uuid)
        vtable_offset_local = IAxes._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetZ"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_Transform"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+8, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_TransformWithRate"] = IAGFUNCTYPE(pUnk, IID_IAxes, vtable_offset_local+9, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxes.__dict__ and type(IAxes.__dict__[attrname]) == property:
            return IAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxes.")
    
    @property
    def Type(self) -> "AgECrdnAxesType":
        """Returns a type of the axes object."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAxes") -> "IAxesFindInAxesWithRateResult":
        """Find an angular velocity and orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IAxes") -> "IAxesFindInAxesResult":
        """Find an orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "IAxesLabels":
        """Returns an object that allows modifying the axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def X(self) -> "IVector":
        """Returns the X axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Y(self) -> "IVector":
        """Returns the Y axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Z(self) -> "IVector":
        """Returns the Z axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetZ"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputAxes:"IAxes", vectorInMyAxes:"ICartesian3Vector") -> "IAxesTransformResult":
        """Transforms the input vector from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, IAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, ICartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Transform"](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputAxes:"IAxes", vectorInMyAxes:"ICartesian3Vector", rateInMyAxes:"ICartesian3Vector") -> "IAxesTransformWithRateResult":
        """Transforms the input vector and vector's rate from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, IAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, ICartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_in_arg(rateInMyAxes, ICartesian3Vector) as arg_rateInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_TransformWithRate"](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, arg_rateInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EE2FCF98-9315-406A-835C-40C56428C888}", IAxes)
agcls.AgTypeNameMap["IAxes"] = IAxes

class IAngle(object):
    """The interface defines methods and properties common to all angles."""
    _uuid = "{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindAngle"] = _raise_uninitialized_error
        self.__dict__["_FindAngleWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindCoordinates"] = _raise_uninitialized_error
        self.__dict__["_FindCoordinatesWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngle = agcom.GUID(IAngle._uuid)
        vtable_offset_local = IAngle._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IAngle, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindAngle"] = IAGFUNCTYPE(pUnk, IID_IAngle, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_FindAngleWithRate"] = IAGFUNCTYPE(pUnk, IID_IAngle, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_FindCoordinates"] = IAGFUNCTYPE(pUnk, IID_IAngle, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindCoordinatesWithRate"] = IAGFUNCTYPE(pUnk, IID_IAngle, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngle.__dict__ and type(IAngle.__dict__[attrname]) == property:
            return IAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngle.")
    
    @property
    def Type(self) -> "AgECrdnAngleType":
        """Returns a type of the angle object."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindAngle(self, epoch:typing.Any) -> "IAngleFindAngleResult":
        """Finds an angle at the specified epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindAngle"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindAngleWithRate(self, epoch:typing.Any) -> "IAngleFindAngleWithRateResult":
        """Finds an angle and angle rate."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindAngleWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinates(self, epoch:typing.Any, axes:"IAxes") -> "IAngleFindResult":
        """Finds the angle value and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindCoordinates"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinatesWithRate(self, epoch:typing.Any, axes:"IAxes") -> "IAngleFindWithRateResult":
        """Finds the angle value, the angle rate and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindCoordinatesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}", IAngle)
agcls.AgTypeNameMap["IAngle"] = IAngle

class IPlane(object):
    """The interface defines methods and properties common to all VGT planes."""
    _uuid = "{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindInSystem"] = _raise_uninitialized_error
        self.__dict__["_FindInSystemWithRate"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlane = agcom.GUID(IPlane._uuid)
        vtable_offset_local = IPlane._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IPlane, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_IPlane, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_IPlane, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInSystem"] = IAGFUNCTYPE(pUnk, IID_IPlane, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInSystemWithRate"] = IAGFUNCTYPE(pUnk, IID_IPlane, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_IPlane, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlane.__dict__ and type(IPlane.__dict__[attrname]) == property:
            return IPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlane.")
    
    @property
    def Type(self) -> "AgECrdnPlaneType":
        """Returns a type of the plane object."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IAxes") -> "IPlaneFindInAxesResult":
        """Computes the plane's axes vectors in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAxes") -> "IPlaneFindInAxesWithRateResult":
        """Computes the plane's axes vectors and their rates in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"ISystem") -> "IPlaneFindInSystemResult":
        """Computes the position and X and Y axes in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ISystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystemWithRate(self, epoch:typing.Any, system:"ISystem") -> "IPlaneFindInSystemWithRateResult":
        """Computes the position, X and Y axes and their rates of change in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ISystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystemWithRate"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "IPlaneLabels":
        """Allows configuring the plane's X and Y axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}", IPlane)
agcls.AgTypeNameMap["IPlane"] = IPlane

class IContext(object):
    """The interface represents a context associated with a VGT component. All VGT components are associated with a valid context. A context can represent a VGT instance or a VGT template."""
    _uuid = "{1003D700-A64E-438C-954A-AD3AA9EA9773}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsTemplate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IContext._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IContext from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IContext = agcom.GUID(IContext._uuid)
        vtable_offset_local = IContext._vtable_offset - 1
        self.__dict__["_GetIsTemplate"] = IAGFUNCTYPE(pUnk, IID_IContext, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IContext.__dict__ and type(IContext.__dict__[attrname]) == property:
            return IContext.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IContext.")
    
    @property
    def IsTemplate(self) -> bool:
        """Returns whether the current instance is a VGT template."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsTemplate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1003D700-A64E-438C-954A-AD3AA9EA9773}", IContext)
agcls.AgTypeNameMap["IContext"] = IContext

class ICoordinate(object):
    """A base interface implemented by all VGT components. The methods and properties of the interface provide type information about the VGT component."""
    _uuid = "{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetKind"] = _raise_uninitialized_error
        self.__dict__["_GetCategory"] = _raise_uninitialized_error
        self.__dict__["_SetCategory"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetDescription"] = _raise_uninitialized_error
        self.__dict__["_GetPath"] = _raise_uninitialized_error
        self.__dict__["_GetIsDuplicable"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_GetTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_GetQualifiedPath"] = _raise_uninitialized_error
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIsReady"] = _raise_uninitialized_error
        self.__dict__["_GetIsReadOnly"] = _raise_uninitialized_error
        self.__dict__["_Duplicate"] = _raise_uninitialized_error
        self.__dict__["_AnonymousDuplicate"] = _raise_uninitialized_error
        self.__dict__["_DependsOn"] = _raise_uninitialized_error
        self.__dict__["_GetEmbeddedComponents"] = _raise_uninitialized_error
        self.__dict__["_Export"] = _raise_uninitialized_error
        self.__dict__["_Rename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICoordinate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICoordinate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICoordinate = agcom.GUID(ICoordinate._uuid)
        vtable_offset_local = ICoordinate._vtable_offset - 1
        self.__dict__["_GetKind"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetCategory"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetCategory"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetDescription"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetPath"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_GetIsDuplicable"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetTypeInfo"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetQualifiedPath"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIsReady"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIsReadOnly"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Duplicate"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_AnonymousDuplicate"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_DependsOn"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+16, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetEmbeddedComponents"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_Export"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+18, agcom.BSTR, agcom.BSTR)
        self.__dict__["_Rename"] = IAGFUNCTYPE(pUnk, IID_ICoordinate, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICoordinate.__dict__ and type(ICoordinate.__dict__[attrname]) == property:
            return ICoordinate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICoordinate.")
    
    @property
    def Kind(self) -> "AgECrdnKind":
        """Returns the component kind."""
        with agmarshall.AgEnum_arg(AgECrdnKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Category(self) -> str:
        """Allows the user to access or change the component category (Folder)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCategory"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Category.setter
    def Category(self, category:str) -> None:
        with agmarshall.BSTR_arg(category) as arg_category:
            agcls.evaluate_hresult(self.__dict__["_SetCategory"](arg_category.COM_val))

    @property
    def Name(self) -> str:
        """Returns the component name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Description(self) -> str:
        """Returns the component description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Path(self) -> str:
        """Returns the component's fully qualified path (ie. \"CentralBody/Earth Body\", etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsDuplicable(self) -> bool:
        """Returns whether the VGT component can be duplicated."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsDuplicable"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Context(self) -> "IContext":
        """Returns the context object associated with the instance. The returned object is either an instance of IAgCrdnInstance or IAgCrdnTemplate interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TypeInfo(self) -> "ITypeInfo":
        """Returns the component type information."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def QualifiedPath(self) -> str:
        """An STK-conformant path to the VGT component that can be used to visualize the VGT components in 3D (i.e. \"CentralBody/Earth Body Vector\", etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQualifiedPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsValid(self) -> bool:
        """Returns whether the component is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReady(self) -> bool:
        """Returns whether the component is ready. The component is ready if it's been fully initialized."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsReady"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReadOnly(self) -> bool:
        """Returns whether the component is modifiable."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsReadOnly"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Duplicate(self, newName:str, description:str) -> "ICoordinate":
        """Creates a copy of the instance of a VGT component. The new component is automatically registered and will be persisted or restored when a scenario is saved or loaded."""
        with agmarshall.BSTR_arg(newName) as arg_newName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Duplicate"](arg_newName.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def AnonymousDuplicate(self) -> "ICoordinate":
        """Creates an anonymous copy of the instance of a VGT component. The new component is not registered and will not be persisted nor restored when a scenario is saved or loaded."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_AnonymousDuplicate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def DependsOn(self, component:"ICoordinate") -> bool:
        """Tests if the instance depends on another component."""
        with agmarshall.AgInterface_in_arg(component, ICoordinate) as arg_component, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_DependsOn"](arg_component.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def EmbeddedComponents(self) -> "ICollection":
        """Returns a collection of embedded components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEmbeddedComponents"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Export(self, filename:str, comments:str) -> None:
        """Exports the component to a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.BSTR_arg(comments) as arg_comments:
            agcls.evaluate_hresult(self.__dict__["_Export"](arg_filename.COM_val, arg_comments.COM_val))

    def Rename(self, newName:str) -> None:
        """Renames the component."""
        with agmarshall.BSTR_arg(newName) as arg_newName:
            agcls.evaluate_hresult(self.__dict__["_Rename"](arg_newName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}", ICoordinate)
agcls.AgTypeNameMap["ICoordinate"] = ICoordinate

class IEvaluateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = "{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEvaluateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEvaluateResult = agcom.GUID(IEvaluateResult._uuid)
        vtable_offset_local = IEvaluateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_IEvaluateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEvaluateResult.__dict__ and type(IEvaluateResult.__dict__[attrname]) == property:
            return IEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEvaluateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """The scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}", IEvaluateResult)
agcls.AgTypeNameMap["IEvaluateResult"] = IEvaluateResult

class IEvaluateWithRateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = "{E9B2DA30-1317-43E2-8D47-9D675A28F748}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEvaluateWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEvaluateWithRateResult = agcom.GUID(IEvaluateWithRateResult._uuid)
        vtable_offset_local = IEvaluateWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_IEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_IEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEvaluateWithRateResult.__dict__ and type(IEvaluateWithRateResult.__dict__[attrname]) == property:
            return IEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEvaluateWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """Computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Rate(self) -> float:
        """A rate of change of the computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E9B2DA30-1317-43E2-8D47-9D675A28F748}", IEvaluateWithRateResult)
agcls.AgTypeNameMap["IEvaluateWithRateResult"] = IEvaluateWithRateResult

class IEventIntervalResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = "{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalResult = agcom.GUID(IEventIntervalResult._uuid)
        vtable_offset_local = IEventIntervalResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalResult.__dict__ and type(IEventIntervalResult.__dict__[attrname]) == property:
            return IEventIntervalResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interval(self) -> "IInterval":
        """An interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}", IEventIntervalResult)
agcls.AgTypeNameMap["IEventIntervalResult"] = IEventIntervalResult

class IEventFindOccurrenceResult(object):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    _uuid = "{20F964F0-8466-415E-9344-D6FBA53AF8B0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventFindOccurrenceResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventFindOccurrenceResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventFindOccurrenceResult = agcom.GUID(IEventFindOccurrenceResult._uuid)
        vtable_offset_local = IEventFindOccurrenceResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IEventFindOccurrenceResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventFindOccurrenceResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventFindOccurrenceResult.__dict__ and type(IEventFindOccurrenceResult.__dict__[attrname]) == property:
            return IEventFindOccurrenceResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventFindOccurrenceResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """The epoch at which the event occurs."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{20F964F0-8466-415E-9344-D6FBA53AF8B0}", IEventFindOccurrenceResult)
agcls.AgTypeNameMap["IEventFindOccurrenceResult"] = IEventFindOccurrenceResult

class IFindTimesResult(object):
    """Returns a collection of intervals and an array of times."""
    _uuid = "{F7B644F0-0728-434D-8C86-C6267B625860}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFindTimesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFindTimesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFindTimesResult = agcom.GUID(IFindTimesResult._uuid)
        vtable_offset_local = IFindTimesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IFindTimesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_IFindTimesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_IFindTimesResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_IFindTimesResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_IFindTimesResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFindTimesResult.__dict__ and type(IFindTimesResult.__dict__[attrname]) == property:
            return IFindTimesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFindTimesResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IIntervalCollection":
        """A collection of found intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Times(self) -> list:
        """An array of found times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F7B644F0-0728-434D-8C86-C6267B625860}", IFindTimesResult)
agcls.AgTypeNameMap["IFindTimesResult"] = IFindTimesResult

class IIntervalsVectorResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    _uuid = "{87F76F41-61FB-4DFF-A76E-25270023BE34}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalCollections"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIntervalsVectorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIntervalsVectorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIntervalsVectorResult = agcom.GUID(IIntervalsVectorResult._uuid)
        vtable_offset_local = IIntervalsVectorResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IIntervalsVectorResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervalCollections"] = IAGFUNCTYPE(pUnk, IID_IIntervalsVectorResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIntervalsVectorResult.__dict__ and type(IIntervalsVectorResult.__dict__[attrname]) == property:
            return IIntervalsVectorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIntervalsVectorResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IntervalCollections(self) -> "IIntervalVectorCollection":
        """A collection of interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalCollections"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{87F76F41-61FB-4DFF-A76E-25270023BE34}", IIntervalsVectorResult)
agcls.AgTypeNameMap["IIntervalsVectorResult"] = IIntervalsVectorResult

class IEventIntervalCollectionOccurredResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    _uuid = "{A829181E-A9CD-452D-AC81-19C2DA96C490}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIndex"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalCollectionOccurredResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalCollectionOccurredResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalCollectionOccurredResult = agcom.GUID(IEventIntervalCollectionOccurredResult._uuid)
        vtable_offset_local = IEventIntervalCollectionOccurredResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionOccurredResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIndex"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionOccurredResult, vtable_offset_local+2, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalCollectionOccurredResult.__dict__ and type(IEventIntervalCollectionOccurredResult.__dict__[attrname]) == property:
            return IEventIntervalCollectionOccurredResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalCollectionOccurredResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Index(self) -> int:
        """Index of an interval in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIndex"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A829181E-A9CD-452D-AC81-19C2DA96C490}", IEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap["IEventIntervalCollectionOccurredResult"] = IEventIntervalCollectionOccurredResult

class IIntervalListResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = "{D0FDA46F-8B86-4052-8EC7-1448284EABCF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIntervalListResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIntervalListResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIntervalListResult = agcom.GUID(IIntervalListResult._uuid)
        vtable_offset_local = IIntervalListResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IIntervalListResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_IIntervalListResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIntervalListResult.__dict__ and type(IIntervalListResult.__dict__[attrname]) == property:
            return IIntervalListResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIntervalListResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IIntervalCollection":
        """A list of intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D0FDA46F-8B86-4052-8EC7-1448284EABCF}", IIntervalListResult)
agcls.AgTypeNameMap["IIntervalListResult"] = IIntervalListResult

class IIntervalVectorCollection(object):
    """A collection of interval collections."""
    _uuid = "{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIntervalVectorCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIntervalVectorCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIntervalVectorCollection = agcom.GUID(IIntervalVectorCollection._uuid)
        vtable_offset_local = IIntervalVectorCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IIntervalVectorCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IIntervalVectorCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IIntervalVectorCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIntervalVectorCollection.__dict__ and type(IIntervalVectorCollection.__dict__[attrname]) == property:
            return IIntervalVectorCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIntervalVectorCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IIntervalCollection":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IIntervalCollection":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}", IIntervalVectorCollection)
agcls.AgTypeNameMap["IIntervalVectorCollection"] = IIntervalVectorCollection

class IEventGroup(object):
    """Access or create VGT events associated with an object."""
    _uuid = "{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventGroup = agcom.GUID(IEventGroup._uuid)
        vtable_offset_local = IEventGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IEventGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventGroup.__dict__ and type(IEventGroup.__dict__[attrname]) == property:
            return IEventGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IEvent":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IEventFactory":
        """Returns a Factory object used to create custom events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IEvent":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IEvent":
        """Retrieves an event from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IEvent":
        """Retrieves an event from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}", IEventGroup)
agcls.AgTypeNameMap["IEventGroup"] = IEventGroup

class IEventIntervalGroup(object):
    """Access or create VGT event intervals associated with an object."""
    _uuid = "{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalGroup = agcom.GUID(IEventIntervalGroup._uuid)
        vtable_offset_local = IEventIntervalGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalGroup.__dict__ and type(IEventIntervalGroup.__dict__[attrname]) == property:
            return IEventIntervalGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IEventInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventIntervalName:str) -> None:
        """Removes an element by name."""
        with agmarshall.BSTR_arg(eventIntervalName) as arg_eventIntervalName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventIntervalName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IEventIntervalFactory":
        """Returns a Factory object used to create custom event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IEventInterval":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IEventInterval":
        """Retrieves an event interval from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IEventInterval":
        """Retrieves an event interval from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}", IEventIntervalGroup)
agcls.AgTypeNameMap["IEventIntervalGroup"] = IEventIntervalGroup

class IEventIntervalListGroup(object):
    """Access or create VGT event interval lists associated with an object."""
    _uuid = "{E5721039-AE57-448A-9891-048ECB8BDC63}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListGroup = agcom.GUID(IEventIntervalListGroup._uuid)
        vtable_offset_local = IEventIntervalListGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListGroup.__dict__ and type(IEventIntervalListGroup.__dict__[attrname]) == property:
            return IEventIntervalListGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IEventIntervalList":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IEventIntervalListFactory":
        """Returns a factory object used to create custom event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IEventIntervalList":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IEventIntervalList":
        """Retrieves an event interval list from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IEventIntervalList":
        """Retrieves an event interval list from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{E5721039-AE57-448A-9891-048ECB8BDC63}", IEventIntervalListGroup)
agcls.AgTypeNameMap["IEventIntervalListGroup"] = IEventIntervalListGroup

class IEventArrayGroup(object):
    """Access or create VGT event arrays associated with an object."""
    _uuid = "{37A14DB3-3A49-4A6B-B238-922B59737548}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayGroup = agcom.GUID(IEventArrayGroup._uuid)
        vtable_offset_local = IEventArrayGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IEventArrayGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayGroup.__dict__ and type(IEventArrayGroup.__dict__[attrname]) == property:
            return IEventArrayGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IEventArray":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IEventArrayFactory":
        """Returns a Factory object used to create event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IEventArray":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IEventArray":
        """Retrieves an event array from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IEventArray":
        """Retrieves an event array from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{37A14DB3-3A49-4A6B-B238-922B59737548}", IEventArrayGroup)
agcls.AgTypeNameMap["IEventArrayGroup"] = IEventArrayGroup

class ICalcScalarGroup(object):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    _uuid = "{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarGroup = agcom.GUID(ICalcScalarGroup._uuid)
        vtable_offset_local = ICalcScalarGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarGroup.__dict__ and type(ICalcScalarGroup.__dict__[attrname]) == property:
            return ICalcScalarGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICalcScalar":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICalcScalarFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICalcScalar":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICalcScalar":
        """Retrieves an element from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICalcScalar":
        """Retrieves an element from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}", ICalcScalarGroup)
agcls.AgTypeNameMap["ICalcScalarGroup"] = ICalcScalarGroup

class IEventIntervalCollectionGroup(object):
    """Access or create VGT event interval collections associated with an object."""
    _uuid = "{0166467D-9328-4E1B-A982-D9B1396A025E}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalCollectionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalCollectionGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalCollectionGroup = agcom.GUID(IEventIntervalCollectionGroup._uuid)
        vtable_offset_local = IEventIntervalCollectionGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalCollectionGroup.__dict__ and type(IEventIntervalCollectionGroup.__dict__[attrname]) == property:
            return IEventIntervalCollectionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalCollectionGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IEventIntervalCollection":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IEventIntervalCollectionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IEventIntervalCollection":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IEventIntervalCollection":
        """Retrieves an event interval from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IEventIntervalCollection":
        """Retrieves an event interval from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{0166467D-9328-4E1B-A982-D9B1396A025E}", IEventIntervalCollectionGroup)
agcls.AgTypeNameMap["IEventIntervalCollectionGroup"] = IEventIntervalCollectionGroup

class IParameterSetGroup(object):
    """Access or create VGT parameter sets associated with an object or a central body."""
    _uuid = "{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSetGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSetGroup = agcom.GUID(IParameterSetGroup._uuid)
        vtable_offset_local = IParameterSetGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSetGroup.__dict__ and type(IParameterSetGroup.__dict__[attrname]) == property:
            return IParameterSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSetGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IParameterSet":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IParameterSetFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IParameterSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IParameterSet":
        """Retrieves an element from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IParameterSet":
        """Retrieves an element from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}", IParameterSetGroup)
agcls.AgTypeNameMap["IParameterSetGroup"] = IParameterSetGroup

class IConditionGroup(object):
    """Access or create VGT conditions associated with an object or a central body."""
    _uuid = "{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionGroup = agcom.GUID(IConditionGroup._uuid)
        vtable_offset_local = IConditionGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IConditionGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionGroup.__dict__ and type(IConditionGroup.__dict__[attrname]) == property:
            return IConditionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICondition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IConditionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICondition":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICondition":
        """Retrieves a condition from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICondition":
        """Retrieves a condition from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}", IConditionGroup)
agcls.AgTypeNameMap["IConditionGroup"] = IConditionGroup

class IConditionSetGroup(object):
    """Allows accessing and creating condition set components."""
    _uuid = "{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionSetGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionSetGroup = agcom.GUID(IConditionSetGroup._uuid)
        vtable_offset_local = IConditionSetGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IConditionSetGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionSetGroup.__dict__ and type(IConditionSetGroup.__dict__[attrname]) == property:
            return IConditionSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionSetGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IConditionSet":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IConditionSetFactory":
        """Returns a factory object used to create condition set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IConditionSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IConditionSet":
        """Retrieves a condition set from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IConditionSet":
        """Retrieves a condition set from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}", IConditionSetGroup)
agcls.AgTypeNameMap["IConditionSetGroup"] = IConditionSetGroup

class IConditionSetEvaluateResult(object):
    """Represents the results returned by ConditionSet.Evaluate."""
    _uuid = "{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionSetEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionSetEvaluateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionSetEvaluateResult = agcom.GUID(IConditionSetEvaluateResult._uuid)
        vtable_offset_local = IConditionSetEvaluateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IConditionSetEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_IConditionSetEvaluateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionSetEvaluateResult.__dict__ and type(IConditionSetEvaluateResult.__dict__[attrname]) == property:
            return IConditionSetEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionSetEvaluateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}", IConditionSetEvaluateResult)
agcls.AgTypeNameMap["IConditionSetEvaluateResult"] = IConditionSetEvaluateResult

class IConditionSetEvaluateWithRateResult(object):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    _uuid = "{39814D49-3CF5-42B0-A46C-766781F45AB7}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        self.__dict__["_GetRates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionSetEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionSetEvaluateWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionSetEvaluateWithRateResult = agcom.GUID(IConditionSetEvaluateWithRateResult._uuid)
        vtable_offset_local = IConditionSetEvaluateWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IConditionSetEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_IConditionSetEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetRates"] = IAGFUNCTYPE(pUnk, IID_IConditionSetEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionSetEvaluateWithRateResult.__dict__ and type(IConditionSetEvaluateWithRateResult.__dict__[attrname]) == property:
            return IConditionSetEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionSetEvaluateWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rates(self) -> list:
        """Computed rates."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{39814D49-3CF5-42B0-A46C-766781F45AB7}", IConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap["IConditionSetEvaluateWithRateResult"] = IConditionSetEvaluateWithRateResult

class IVolumeGridGroup(object):
    """Access or create VGT volume grids associated with an object or a central body."""
    _uuid = "{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridGroup = agcom.GUID(IVolumeGridGroup._uuid)
        vtable_offset_local = IVolumeGridGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridGroup.__dict__ and type(IVolumeGridGroup.__dict__[attrname]) == property:
            return IVolumeGridGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVolumeGrid":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVolumeGridFactory":
        """Returns a factory object used to create volume grid components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVolumeGrid":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVolumeGrid":
        """Retrieves a volume grid from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVolumeGrid":
        """Retrieves a volume grid from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}", IVolumeGridGroup)
agcls.AgTypeNameMap["IVolumeGridGroup"] = IVolumeGridGroup

class IVolumeGroup(object):
    """Access or create spatial conditions associated with a volume grid."""
    _uuid = "{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGroup = agcom.GUID(IVolumeGroup._uuid)
        vtable_offset_local = IVolumeGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVolumeGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGroup.__dict__ and type(IVolumeGroup.__dict__[attrname]) == property:
            return IVolumeGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVolume":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVolumeFactory":
        """Returns a factory object used to create spatial condition components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVolume":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVolume":
        """Retrieves an volume from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVolume":
        """Retrieves volume from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}", IVolumeGroup)
agcls.AgTypeNameMap["IVolumeGroup"] = IVolumeGroup

class IVolumeCalcGroup(object):
    """Access or create VGT volume calcs associated with an object or a central body."""
    _uuid = "{02991465-35ec-486a-913d-bf204afc9fb6}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcGroup = agcom.GUID(IVolumeCalcGroup._uuid)
        vtable_offset_local = IVolumeCalcGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcGroup.__dict__ and type(IVolumeCalcGroup.__dict__[attrname]) == property:
            return IVolumeCalcGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVolumeCalc":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVolumeCalcFactory":
        """Returns a factory object used to create volume calc components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVolumeCalc":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVolumeCalc":
        """Retrieves a volume calculation from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVolumeCalc":
        """Retrieves a volume calculation from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{02991465-35ec-486a-913d-bf204afc9fb6}", IVolumeCalcGroup)
agcls.AgTypeNameMap["IVolumeCalcGroup"] = IVolumeCalcGroup

class ICalcScalar(object):
    """Any scalar calculation that is not constant by construction."""
    _uuid = "{55A75307-E283-4146-A456-732D08E47070}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRate"] = _raise_uninitialized_error
        self.__dict__["_GetAvailability"] = _raise_uninitialized_error
        self.__dict__["_GetUnitOfMeasure"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRateArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateEventArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRateEventArray"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalar = agcom.GUID(ICalcScalar._uuid)
        vtable_offset_local = ICalcScalar._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_QuickEvaluate"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_QuickEvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetAvailability"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetUnitOfMeasure"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_QuickEvaluateArray"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+8, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateWithRateArray"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateEventArray"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateWithRateEventArray"] = IAGFUNCTYPE(pUnk, IID_ICalcScalar, vtable_offset_local+11, agcom.PVOID, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalar.__dict__ and type(ICalcScalar.__dict__[attrname]) == property:
            return ICalcScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalar.")
    
    @property
    def Type(self) -> "AgECrdnCalcScalarType":
        """Returns the scalar calculation type."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "IEvaluateResult":
        """Evaluates the scalar calculation at the specified time instant."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with two elements, the first element being of boolean type indicating whether the computation succeeded, followed by a double-precision value representing..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "IEvaluateWithRateResult":
        """Evaluates the scalar calculation at the specified time instant. The result is a scalar value and its rate of change."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with three elements, the first element being of boolean type indicating whether the computation succeeded, followed by two double-precision values one rep..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetAvailability(self) -> "IIntervalCollection":
        """Returns a list of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailability"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UnitOfMeasure(self) -> str:
        """Returns calc scalar's unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitOfMeasure"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def QuickEvaluateArray(self, times:list) -> list:
        """Evaluates the scalar calculation, and rate, over an array of times, entered as strings in the Scenario date unit. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateArray"](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateArray(self, times:list) -> list:
        """Evaluates the scalar calculation over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRateArray"](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateEventArray(self, refArray:"IEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, IEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateEventArray"](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateEventArray(self, refArray:"IEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, IEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRateEventArray"](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{55A75307-E283-4146-A456-732D08E47070}", ICalcScalar)
agcls.AgTypeNameMap["ICalcScalar"] = ICalcScalar

class ICalcScalarAngle(object):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    _uuid = "{52FB9533-9332-44D2-92B2-8AA2D8633112}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputAngle"] = _raise_uninitialized_error
        self.__dict__["_SetInputAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarAngle = agcom.GUID(ICalcScalarAngle._uuid)
        vtable_offset_local = ICalcScalarAngle._vtable_offset - 1
        self.__dict__["_GetInputAngle"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarAngle, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputAngle"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarAngle, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarAngle.__dict__ and type(ICalcScalarAngle.__dict__[attrname]) == property:
            return ICalcScalarAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarAngle.")
    
    @property
    def InputAngle(self) -> "IAngle":
        """The input angle, which is a VGT angle component. Note angle computation in VGT may involve more than just angular displacement value: in VGT angles may be drawn in 3D which requires knowledge and evaluation of supporting vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputAngle.setter
    def InputAngle(self, inputAngle:"IAngle") -> None:
        with agmarshall.AgInterface_in_arg(inputAngle, IAngle) as arg_inputAngle:
            agcls.evaluate_hresult(self.__dict__["_SetInputAngle"](arg_inputAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{52FB9533-9332-44D2-92B2-8AA2D8633112}", ICalcScalarAngle)
agcls.AgTypeNameMap["ICalcScalarAngle"] = ICalcScalarAngle

class ICalcScalarConstant(object):
    """Constant scalar value of specified dimension."""
    _uuid = "{96A1ABA9-663C-4CCC-A066-0166E285C3C2}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_SetValue"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarConstant = agcom.GUID(ICalcScalarConstant._uuid)
        vtable_offset_local = ICalcScalarConstant._vtable_offset - 1
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarConstant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetValue"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarConstant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarConstant, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarConstant, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarConstant.__dict__ and type(ICalcScalarConstant.__dict__[attrname]) == property:
            return ICalcScalarConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarConstant.")
    
    @property
    def Value(self) -> float:
        """A value which can be in any STK supported unit available for selected dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Value.setter
    def Value(self, value:float) -> None:
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetValue"](arg_value.COM_val))

    @property
    def Dimension(self) -> str:
        """The dimension of the constant value, this can be any of the STK supported dimensions."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{96A1ABA9-663C-4CCC-A066-0166E285C3C2}", ICalcScalarConstant)
agcls.AgTypeNameMap["ICalcScalarConstant"] = ICalcScalarConstant

class ICalcScalarCustom(object):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    _uuid = "{6267B685-4486-4B11-A2CA-056D6A9B558C}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarCustom = agcom.GUID(ICalcScalarCustom._uuid)
        vtable_offset_local = ICalcScalarCustom._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarCustom, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarCustom, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarCustom, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarCustom.__dict__ and type(ICalcScalarCustom.__dict__[attrname]) == property:
            return ICalcScalarCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarCustom.")
    
    @property
    def Filename(self) -> str:
        """A path to MATLAB (.m or .dll), Perl or VBScript file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())


agcls.AgClassCatalog.add_catalog_entry("{6267B685-4486-4B11-A2CA-056D6A9B558C}", ICalcScalarCustom)
agcls.AgTypeNameMap["ICalcScalarCustom"] = ICalcScalarCustom

class ICalcScalarDataElement(object):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    _uuid = "{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDataProvider"] = _raise_uninitialized_error
        self.__dict__["_GetElementName"] = _raise_uninitialized_error
        self.__dict__["_GetGroup"] = _raise_uninitialized_error
        self.__dict__["_GetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_SetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetUseSamples"] = _raise_uninitialized_error
        self.__dict__["_SetUseSamples"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        self.__dict__["_SetWithGroup"] = _raise_uninitialized_error
        self.__dict__["_GetInvalidDataIndicator"] = _raise_uninitialized_error
        self.__dict__["_SetInvalidDataIndicator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarDataElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarDataElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarDataElement = agcom.GUID(ICalcScalarDataElement._uuid)
        vtable_offset_local = ICalcScalarDataElement._vtable_offset - 1
        self.__dict__["_GetDataProvider"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetElementName"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetGroup"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_SetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_GetUseSamples"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSamples"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+12, agcom.BSTR, agcom.BSTR)
        self.__dict__["_SetWithGroup"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetInvalidDataIndicator"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInvalidDataIndicator"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDataElement, vtable_offset_local+15, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarDataElement.__dict__ and type(ICalcScalarDataElement.__dict__[attrname]) == property:
            return ICalcScalarDataElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarDataElement.")
    
    @property
    def DataProvider(self) -> str:
        """The name of the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataProvider"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ElementName(self) -> str:
        """The name of the data element within the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Group(self) -> str:
        """A group name the data element is a part of. If the element is not a part of a group, the property will return an empty string."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGroup"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interpolation(self) -> "IInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterpolation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"IInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, IInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__["_SetInterpolation"](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """Relative tolerance uses a combination of relative and absolute changes in scalar values between samples. Curvature tolerance also uses changes in slope between samples."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def UseSamples(self) -> bool:
        """If set to true, selected data provider is presampled over its entire availability span using sampling method specified in Advanced options..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSamples"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseSamples.setter
    def UseSamples(self, useSamples:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useSamples) as arg_useSamples:
            agcls.evaluate_hresult(self.__dict__["_SetUseSamples"](arg_useSamples.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed samples are saved/loaded, otherwise if using samples they are recomputed on load."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    def Set(self, dataProvider:str, elementName:str) -> None:
        """Set the data provider and the element name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_dataProvider.COM_val, arg_elementName.COM_val))

    def SetWithGroup(self, dataProvider:str, typeName:str, elementName:str) -> None:
        """Set the data provider name, the element name, and data provider type name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(typeName) as arg_typeName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__["_SetWithGroup"](arg_dataProvider.COM_val, arg_typeName.COM_val, arg_elementName.COM_val))

    @property
    def InvalidDataIndicator(self) -> float:
        """Sets the value to display in a report or graph when the actual value is not a valid real number"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInvalidDataIndicator"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InvalidDataIndicator.setter
    def InvalidDataIndicator(self, invalidDataIndicator:float) -> None:
        with agmarshall.DOUBLE_arg(invalidDataIndicator) as arg_invalidDataIndicator:
            agcls.evaluate_hresult(self.__dict__["_SetInvalidDataIndicator"](arg_invalidDataIndicator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}", ICalcScalarDataElement)
agcls.AgTypeNameMap["ICalcScalarDataElement"] = ICalcScalarDataElement

class ICalcScalarDerivative(object):
    """Derivative of an input scalar calculation."""
    _uuid = "{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        self.__dict__["_SetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarDerivative = agcom.GUID(ICalcScalarDerivative._uuid)
        vtable_offset_local = ICalcScalarDerivative._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDerivative, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarDerivative.__dict__ and type(ICalcScalarDerivative.__dict__[attrname]) == property:
            return ICalcScalarDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarDerivative.")
    
    @property
    def Scalar(self) -> "ICalcScalar":
        """The input scalar component used to compute the derivative."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """The time step used, if necessary, in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceUseOfNumericalDifferences"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__["_SetForceUseOfNumericalDifferences"](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}", ICalcScalarDerivative)
agcls.AgTypeNameMap["ICalcScalarDerivative"] = ICalcScalarDerivative

class ICalcScalarDotProduct(object):
    """Dot product between two vectors."""
    _uuid = "{ffb69fa2-d123-413e-bb34-db750b7775ea}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarDotProduct._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarDotProduct from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarDotProduct = agcom.GUID(ICalcScalarDotProduct._uuid)
        vtable_offset_local = ICalcScalarDotProduct._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarDotProduct, vtable_offset_local+10, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarDotProduct.__dict__ and type(ICalcScalarDotProduct.__dict__[attrname]) == property:
            return ICalcScalarDotProduct.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarDotProduct.")
    
    @property
    def VectorA(self) -> "IVector":
        """First vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "IVector":
        """Second vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'Angle', 'Distance', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ffb69fa2-d123-413e-bb34-db750b7775ea}", ICalcScalarDotProduct)
agcls.AgTypeNameMap["ICalcScalarDotProduct"] = ICalcScalarDotProduct

class ICalcScalarElapsedTime(object):
    """Time elapsed since the reference time instant. Negative if in the past."""
    _uuid = "{81238610-6A1B-499A-8C43-12337F64BC42}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarElapsedTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarElapsedTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarElapsedTime = agcom.GUID(ICalcScalarElapsedTime._uuid)
        vtable_offset_local = ICalcScalarElapsedTime._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarElapsedTime, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarElapsedTime, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarElapsedTime.__dict__ and type(ICalcScalarElapsedTime.__dict__[attrname]) == property:
            return ICalcScalarElapsedTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarElapsedTime.")
    
    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{81238610-6A1B-499A-8C43-12337F64BC42}", ICalcScalarElapsedTime)
agcls.AgTypeNameMap["ICalcScalarElapsedTime"] = ICalcScalarElapsedTime

class ICalcScalarFactory(object):
    """The factory creates scalar calculation components."""
    _uuid = "{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarAngle"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFixedAtTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarConstant"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDataElement"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDataElementWithGroup"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDerivative"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarElapsedTime"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFile"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFunction"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarIntegral"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFunction2Var"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarVectorMagnitude"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFromCustomScript"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDotProduct"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarVectorComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarFactory = agcom.GUID(ICalcScalarFactory._uuid)
        vtable_offset_local = ICalcScalarFactory._vtable_offset - 1
        self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarAngle"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFixedAtTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarConstant"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDataElement"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDataElementWithGroup"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDerivative"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarElapsedTime"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFile"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFunction"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+11, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarIntegral"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+12, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFunction2Var"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarVectorMagnitude"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+15, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+16, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateCalcScalarFromCustomScript"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+17, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+18, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDotProduct"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+19, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarVectorComponent"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFactory, vtable_offset_local+20, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarFactory.__dict__ and type(ICalcScalarFactory.__dict__[attrname]) == property:
            return ICalcScalarFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarFactory.")
    
    @property
    def AvailableCalcScalarPluginDisplayNames(self) -> list:
        """An array of display names associated with available scalar calculation plugins. The elements of the array are strings. Display names are used to create Calc scalars based on COM plugins using CreateCalcScalarPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnCalcScalarType") -> "ICalcScalar":
        """Creates and registers a scalar calculation using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnCalcScalarType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarAngle(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation equal to angular displacement obtained from any angle in VGT."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarAngle"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFixedAtTimeInstant(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation defined by evaluating the input scalar calculation at the specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFixedAtTimeInstant"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarConstant(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation of constant value of the specified dimension."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarConstant"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElement(self, name:str, description:str, dataProvider:str, elementName:str) -> "ICalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDataElement"](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElementWithGroup(self, name:str, description:str, dataProvider:str, groupName:str, elementName:str) -> "ICalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(groupName) as arg_groupName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDataElementWithGroup"](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_groupName.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDerivative(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation that is the derivative of an input scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDerivative"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarElapsedTime(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation that is the time elapsed since a reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarElapsedTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFile(self, name:str, description:str, filepath:str) -> "ICalcScalar":
        """Create scalar calculation specified by external data file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFile"](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation that is defined by performing the specified function on the input scalar or time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFunction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarIntegral(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation that is the integral of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarIntegral"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction2Var(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation that is defined by performing a function(x,y) on two scalar arguments."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFunction2Var"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorMagnitude(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation equal to the magnitude of a specified vector."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarVectorMagnitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarPluginFromDisplayName(self, name:str, description:str, displayName:str) -> "ICalcScalar":
        """Create a scalar calculation based on a COM plugin. For information how to implement and register VGT plugins, see <topic name='Engine Plugins: COM-based Engine Plugin Components'>COM-based Engine Plugins.</topic>."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarPluginFromDisplayName"](arg_name.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnCalcScalarType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateCalcScalarFromCustomScript(self, name:str, description:str, filepath:str) -> "ICalcScalar":
        """Create a calc scalar calculation that uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFromCustomScript"](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarSurfaceDistanceBetweenPoints(self, name:str, description:str) -> "ICalcScalar":
        """Create a calc scalar calculation that is surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDotProduct(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation that is defined by a dot product between two vectors."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDotProduct"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorComponent(self, name:str, description:str) -> "ICalcScalar":
        """Create a scalar calculation that is defined by a specified component of a vector when resolved in specified axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarVectorComponent"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}", ICalcScalarFactory)
agcls.AgTypeNameMap["ICalcScalarFactory"] = ICalcScalarFactory

class ICalcScalarFile(object):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    _uuid = "{98BC97CE-DA0B-4783-BB98-A988CA16447A}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        self.__dict__["_GetFileSpan"] = _raise_uninitialized_error
        self.__dict__["_GetFileInterpolationType"] = _raise_uninitialized_error
        self.__dict__["_SetFileInterpolationType"] = _raise_uninitialized_error
        self.__dict__["_GetFileInterpolationOrder"] = _raise_uninitialized_error
        self.__dict__["_SetFileInterpolationOrder"] = _raise_uninitialized_error
        self.__dict__["_GetUseNativeFileInterpolationSettings"] = _raise_uninitialized_error
        self.__dict__["_SetUseNativeFileInterpolationSettings"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarFile = agcom.GUID(ICalcScalarFile._uuid)
        vtable_offset_local = ICalcScalarFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+3, )
        self.__dict__["_GetFileSpan"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetFileInterpolationType"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetFileInterpolationType"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetFileInterpolationOrder"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+7, POINTER(agcom.INT))
        self.__dict__["_SetFileInterpolationOrder"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+8, agcom.INT)
        self.__dict__["_GetUseNativeFileInterpolationSettings"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseNativeFileInterpolationSettings"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFile, vtable_offset_local+10, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarFile.__dict__ and type(ICalcScalarFile.__dict__[attrname]) == property:
            return ICalcScalarFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarFile.")
    
    @property
    def Filename(self) -> str:
        """The path to an ASCII file with .csc extension."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())

    def GetFileSpan(self) -> "IEventIntervalResult":
        """Computes the interval time span of the file."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileSpan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FileInterpolationType(self) -> "AgECrdnFileInterpolatorType":
        """The interpolation method used with the data."""
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileInterpolationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationType.setter
    def FileInterpolationType(self, fileInterpolationType:"AgECrdnFileInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType, fileInterpolationType) as arg_fileInterpolationType:
            agcls.evaluate_hresult(self.__dict__["_SetFileInterpolationType"](arg_fileInterpolationType.COM_val))

    @property
    def FileInterpolationOrder(self) -> int:
        """The interpolation order used with the interpolation method to interrogate the data."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileInterpolationOrder"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationOrder.setter
    def FileInterpolationOrder(self, fileInterpolationOrder:int) -> None:
        with agmarshall.INT_arg(fileInterpolationOrder) as arg_fileInterpolationOrder:
            agcls.evaluate_hresult(self.__dict__["_SetFileInterpolationOrder"](arg_fileInterpolationOrder.COM_val))

    @property
    def UseNativeFileInterpolationSettings(self) -> bool:
        """Flag indicating whether the interpolation method and order settings specified within the file, if any, will be honored."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseNativeFileInterpolationSettings"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseNativeFileInterpolationSettings.setter
    def UseNativeFileInterpolationSettings(self, useNativeFileInterpolationSettings:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useNativeFileInterpolationSettings) as arg_useNativeFileInterpolationSettings:
            agcls.evaluate_hresult(self.__dict__["_SetUseNativeFileInterpolationSettings"](arg_useNativeFileInterpolationSettings.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{98BC97CE-DA0B-4783-BB98-A988CA16447A}", ICalcScalarFile)
agcls.AgTypeNameMap["ICalcScalarFile"] = ICalcScalarFile

class ICalcScalarFixedAtTimeInstant(object):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    _uuid = "{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarFixedAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarFixedAtTimeInstant = agcom.GUID(ICalcScalarFixedAtTimeInstant._uuid)
        vtable_offset_local = ICalcScalarFixedAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarFixedAtTimeInstant.__dict__ and type(ICalcScalarFixedAtTimeInstant.__dict__[attrname]) == property:
            return ICalcScalarFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarFixedAtTimeInstant.")
    
    @property
    def InputScalar(self) -> "ICalcScalar":
        """The input scalar component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}", ICalcScalarFixedAtTimeInstant)
agcls.AgTypeNameMap["ICalcScalarFixedAtTimeInstant"] = ICalcScalarFixedAtTimeInstant

class ICalcScalarFunction(object):
    """Defined by performing the specified function on the input scalar or time instant."""
    _uuid = "{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}"
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseScalar"] = _raise_uninitialized_error
        self.__dict__["_SetUseScalar"] = _raise_uninitialized_error
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetInputTime"] = _raise_uninitialized_error
        self.__dict__["_SetInputTime"] = _raise_uninitialized_error
        self.__dict__["_GetInputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetInputUnit"] = _raise_uninitialized_error
        self.__dict__["_GetA"] = _raise_uninitialized_error
        self.__dict__["_SetA"] = _raise_uninitialized_error
        self.__dict__["_GetB"] = _raise_uninitialized_error
        self.__dict__["_SetB"] = _raise_uninitialized_error
        self.__dict__["_GetC"] = _raise_uninitialized_error
        self.__dict__["_SetC"] = _raise_uninitialized_error
        self.__dict__["_GetD"] = _raise_uninitialized_error
        self.__dict__["_SetD"] = _raise_uninitialized_error
        self.__dict__["_GetCoefficients"] = _raise_uninitialized_error
        self.__dict__["_SetCoefficients"] = _raise_uninitialized_error
        self.__dict__["_GetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetInheritDimensionFromInput"] = _raise_uninitialized_error
        self.__dict__["_SetInheritDimensionFromInput"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_GetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarFunction = agcom.GUID(ICalcScalarFunction._uuid)
        vtable_offset_local = ICalcScalarFunction._vtable_offset - 1
        self.__dict__["_GetUseScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetInputTime"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetInputTime"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetInputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetInputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetD"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetD"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetCoefficients"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetCoefficients"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+18, agcom.SAFEARRAY)
        self.__dict__["_GetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetAvailableFunctions"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+21, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetInheritDimensionFromInput"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetInheritDimensionFromInput"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+23, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+29, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction, vtable_offset_local+31, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarFunction.__dict__ and type(ICalcScalarFunction.__dict__[attrname]) == property:
            return ICalcScalarFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarFunction.")
    
    @property
    def UseScalar(self) -> bool:
        """Specify whether to use the input scalar calculation or the time elapsed from the input time instant. Set to true to use the scalar."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScalar"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScalar.setter
    def UseScalar(self, useScalar:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScalar) as arg_useScalar:
            agcls.evaluate_hresult(self.__dict__["_SetUseScalar"](arg_useScalar.COM_val))

    @property
    def InputScalar(self) -> "ICalcScalar":
        """The input scalar calculation (used if UseScalar is true). The UseScalar property should be set to true before this property can be set."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def InputTime(self) -> "IEvent":
        """The input time instant (used if UseScalar is false)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputTime"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputTime.setter
    def InputTime(self, inputTime:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(inputTime, IEvent) as arg_inputTime:
            agcls.evaluate_hresult(self.__dict__["_SetInputTime"](arg_inputTime.COM_val))

    @property
    def InputUnit(self) -> str:
        """The input time unit to interpret input time."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InputUnit.setter
    def InputUnit(self, inputUnit:str) -> None:
        with agmarshall.BSTR_arg(inputUnit) as arg_inputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetInputUnit"](arg_inputUnit.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__["_SetA"](arg_a.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__["_SetB"](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetC"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__["_SetC"](arg_c.COM_val))

    @property
    def D(self) -> float:
        """The constant coefficient D."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetD"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @D.setter
    def D(self, d:float) -> None:
        with agmarshall.DOUBLE_arg(d) as arg_d:
            agcls.evaluate_hresult(self.__dict__["_SetD"](arg_d.COM_val))

    @property
    def Coefficients(self) -> list:
        """The array of constant coefficients, whose dimension and units are determined by those of input and output."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoefficients"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Coefficients.setter
    def Coefficients(self, coefficients:list) -> None:
        with agmarshall.SAFEARRAY_arg(coefficients) as arg_coefficients:
            agcls.evaluate_hresult(self.__dict__["_SetCoefficients"](arg_coefficients.COM_val))

    @property
    def SelectedFunction(self) -> str:
        """The function which will use the input scalar or time instant in some combination with the constant coefficients A, B, C, D."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedFunction"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedFunction"](arg_selectedFunction.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """Get the available function names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableFunctions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def InheritDimensionFromInput(self) -> bool:
        """Specify whether to inherit the output dimension from the input scalar or time instant."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInheritDimensionFromInput"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InheritDimensionFromInput.setter
    def InheritDimensionFromInput(self, inheritDimensionFromInput:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inheritDimensionFromInput) as arg_inheritDimensionFromInput:
            agcls.evaluate_hresult(self.__dict__["_SetInheritDimensionFromInput"](arg_inheritDimensionFromInput.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if InheritDimensionFromInput is false. The InheritDimensionFromInput property should be set to false before this property can be fixed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))

    @property
    def OutputUnit(self) -> str:
        """Specify a unit for the selected output dimension. This is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetOutputUnit"](arg_outputUnit.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IConverge":
        """The Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}", ICalcScalarFunction)
agcls.AgTypeNameMap["ICalcScalarFunction"] = ICalcScalarFunction

class ICalcScalarFunction2Var(object):
    """Defined by performing a function(x,y) on two scalar arguments."""
    _uuid = "{E56D021E-AD96-4ABE-857E-708CDCC4FF14}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_SetX"] = _raise_uninitialized_error
        self.__dict__["_GetUnitX"] = _raise_uninitialized_error
        self.__dict__["_SetUnitX"] = _raise_uninitialized_error
        self.__dict__["_GetA"] = _raise_uninitialized_error
        self.__dict__["_SetA"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_SetY"] = _raise_uninitialized_error
        self.__dict__["_GetUnitY"] = _raise_uninitialized_error
        self.__dict__["_SetUnitY"] = _raise_uninitialized_error
        self.__dict__["_GetB"] = _raise_uninitialized_error
        self.__dict__["_SetB"] = _raise_uninitialized_error
        self.__dict__["_GetC"] = _raise_uninitialized_error
        self.__dict__["_SetC"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_GetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetOutputUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarFunction2Var._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarFunction2Var from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarFunction2Var = agcom.GUID(ICalcScalarFunction2Var._uuid)
        vtable_offset_local = ICalcScalarFunction2Var._vtable_offset - 1
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetX"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetUnitX"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitX"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetY"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetUnitY"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitY"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetAvailableFunctions"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+19, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_GetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+22, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarFunction2Var, vtable_offset_local+23, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarFunction2Var.__dict__ and type(ICalcScalarFunction2Var.__dict__[attrname]) == property:
            return ICalcScalarFunction2Var.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarFunction2Var.")
    
    @property
    def X(self) -> "ICalcScalar":
        """The scalar argument X."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @X.setter
    def X(self, x:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(x, ICalcScalar) as arg_x:
            agcls.evaluate_hresult(self.__dict__["_SetX"](arg_x.COM_val))

    @property
    def UnitX(self) -> str:
        """The unit used to interpret numerical values of scalar argument X."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitX"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitX.setter
    def UnitX(self, unitX:str) -> None:
        with agmarshall.BSTR_arg(unitX) as arg_unitX:
            agcls.evaluate_hresult(self.__dict__["_SetUnitX"](arg_unitX.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__["_SetA"](arg_a.COM_val))

    @property
    def Y(self) -> "ICalcScalar":
        """The scalar argument Y."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Y.setter
    def Y(self, y:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(y, ICalcScalar) as arg_y:
            agcls.evaluate_hresult(self.__dict__["_SetY"](arg_y.COM_val))

    @property
    def UnitY(self) -> str:
        """The unit used to interpret numerical values of scalar argument Y."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitY"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitY.setter
    def UnitY(self, unitY:str) -> None:
        with agmarshall.BSTR_arg(unitY) as arg_unitY:
            agcls.evaluate_hresult(self.__dict__["_SetUnitY"](arg_unitY.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__["_SetB"](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetC"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__["_SetC"](arg_c.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Specifies whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if OutputDimensionInheritance is false."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """The available functions. A function(x,y) uses some combination of two scalar arguments x and y as well as one to three constant coefficients a, b, c."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableFunctions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SelectedFunction(self) -> str:
        """The selected function."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedFunction"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedFunction"](arg_selectedFunction.COM_val))

    @property
    def OutputUnit(self) -> str:
        """The unit for the selected dimension. The unit is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetOutputUnit"](arg_outputUnit.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E56D021E-AD96-4ABE-857E-708CDCC4FF14}", ICalcScalarFunction2Var)
agcls.AgTypeNameMap["ICalcScalarFunction2Var"] = ICalcScalarFunction2Var

class ICalcScalarIntegral(object):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    _uuid = "{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetComputeAsAverage"] = _raise_uninitialized_error
        self.__dict__["_SetComputeAsAverage"] = _raise_uninitialized_error
        self.__dict__["_GetIntegrationWindowType"] = _raise_uninitialized_error
        self.__dict__["_SetIntegrationWindowType"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_SetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetIntegral"] = _raise_uninitialized_error
        self.__dict__["_SetIntegral"] = _raise_uninitialized_error
        self.__dict__["_GetKeepConstantOutsideTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetKeepConstantOutsideTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetOffsets"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarIntegral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarIntegral = agcom.GUID(ICalcScalarIntegral._uuid)
        vtable_offset_local = ICalcScalarIntegral._vtable_offset - 1
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetComputeAsAverage"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetComputeAsAverage"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetIntegrationWindowType"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetIntegrationWindowType"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_SetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+18, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+20, agcom.PVOID)
        self.__dict__["_GetIntegral"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_SetIntegral"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+22, agcom.PVOID)
        self.__dict__["_GetKeepConstantOutsideTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetKeepConstantOutsideTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+24, agcom.VARIANT_BOOL)
        self.__dict__["_SetOffsets"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarIntegral, vtable_offset_local+25, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarIntegral.__dict__ and type(ICalcScalarIntegral.__dict__[attrname]) == property:
            return ICalcScalarIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarIntegral.")
    
    @property
    def InputScalar(self) -> "ICalcScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ComputeAsAverage(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputeAsAverage"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ComputeAsAverage.setter
    def ComputeAsAverage(self, computeAsAverage:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(computeAsAverage) as arg_computeAsAverage:
            agcls.evaluate_hresult(self.__dict__["_SetComputeAsAverage"](arg_computeAsAverage.COM_val))

    @property
    def IntegrationWindowType(self) -> "AgECrdnIntegrationWindowType":
        """The integration window, or accumulation, type."""
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntegrationWindowType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntegrationWindowType.setter
    def IntegrationWindowType(self, integrationWindowType:"AgECrdnIntegrationWindowType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType, integrationWindowType) as arg_integrationWindowType:
            agcls.evaluate_hresult(self.__dict__["_SetIntegrationWindowType"](arg_integrationWindowType.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "IEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Interpolation(self) -> "IInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterpolation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"IInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, IInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__["_SetInterpolation"](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Integral(self) -> "IIntegral":
        """The numerical integration method."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntegral"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Integral.setter
    def Integral(self, integral:"IIntegral") -> None:
        with agmarshall.AgInterface_in_arg(integral, IIntegral) as arg_integral:
            agcls.evaluate_hresult(self.__dict__["_SetIntegral"](arg_integral.COM_val))

    @property
    def KeepConstantOutsideTimeLimits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetKeepConstantOutsideTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @KeepConstantOutsideTimeLimits.setter
    def KeepConstantOutsideTimeLimits(self, keepConstantOutsideTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(keepConstantOutsideTimeLimits) as arg_keepConstantOutsideTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetKeepConstantOutsideTimeLimits"](arg_keepConstantOutsideTimeLimits.COM_val))

    def SetOffsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset, \
             agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetOffsets"](arg_startOffset.COM_val, arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}", ICalcScalarIntegral)
agcls.AgTypeNameMap["ICalcScalarIntegral"] = ICalcScalarIntegral

class ICalcScalarPlugin(object):
    """Use a scalar calculation plugin."""
    _uuid = "{1459313C-59BD-42FF-9F0D-AF4604F13D4C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarPlugin = agcom.GUID(ICalcScalarPlugin._uuid)
        vtable_offset_local = ICalcScalarPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarPlugin.__dict__ and type(ICalcScalarPlugin.__dict__[attrname]) == property:
            return ICalcScalarPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """The plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, an invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1459313C-59BD-42FF-9F0D-AF4604F13D4C}", ICalcScalarPlugin)
agcls.AgTypeNameMap["ICalcScalarPlugin"] = ICalcScalarPlugin

class ICalcScalarSurfaceDistanceBetweenPoints(object):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    _uuid = "{DC5C0166-111F-4E8A-9650-012CE6A57911}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint1"] = _raise_uninitialized_error
        self.__dict__["_SetPoint1"] = _raise_uninitialized_error
        self.__dict__["_GetPoint2"] = _raise_uninitialized_error
        self.__dict__["_SetPoint2"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarSurfaceDistanceBetweenPoints._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarSurfaceDistanceBetweenPoints from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarSurfaceDistanceBetweenPoints = agcom.GUID(ICalcScalarSurfaceDistanceBetweenPoints._uuid)
        vtable_offset_local = ICalcScalarSurfaceDistanceBetweenPoints._vtable_offset - 1
        self.__dict__["_GetPoint1"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint1"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint2"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint2"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarSurfaceDistanceBetweenPoints.__dict__ and type(ICalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]) == property:
            return ICalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarSurfaceDistanceBetweenPoints.")
    
    @property
    def Point1(self) -> "IPoint":
        """Starting point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint1"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point1.setter
    def Point1(self, point1:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(point1, IPoint) as arg_point1:
            agcls.evaluate_hresult(self.__dict__["_SetPoint1"](arg_point1.COM_val))

    @property
    def Point2(self) -> "IPoint":
        """Terminating point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint2"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point2.setter
    def Point2(self, point2:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(point2, IPoint) as arg_point2:
            agcls.evaluate_hresult(self.__dict__["_SetPoint2"](arg_point2.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """Central body on which the surface distance between points is to be calculated."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceCentralBody"](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of scalar calculation time rate of change (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DC5C0166-111F-4E8A-9650-012CE6A57911}", ICalcScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap["ICalcScalarSurfaceDistanceBetweenPoints"] = ICalcScalarSurfaceDistanceBetweenPoints

class ICalcScalarVectorComponent(object):
    """The specified component of a vector when resolved in the specified axes."""
    _uuid = "{2adb8ac1-7836-45af-b7f1-77b13a9db586}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetComponent"] = _raise_uninitialized_error
        self.__dict__["_SetComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarVectorComponent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarVectorComponent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarVectorComponent = agcom.GUID(ICalcScalarVectorComponent._uuid)
        vtable_offset_local = ICalcScalarVectorComponent._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorComponent, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorComponent, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorComponent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorComponent, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetComponent"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorComponent, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetComponent"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorComponent, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarVectorComponent.__dict__ and type(ICalcScalarVectorComponent.__dict__[attrname]) == property:
            return ICalcScalarVectorComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarVectorComponent.")
    
    @property
    def InputVector(self) -> "IVector":
        """Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))

    @property
    def ReferenceAxes(self) -> "IAxes":
        """Axes used to resolve the vector's components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))

    @property
    def Component(self) -> "AgECrdnVectorComponentType":
        """The component of the vector to return as the value of the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetComponent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Component.setter
    def Component(self, component:"AgECrdnVectorComponentType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType, component) as arg_component:
            agcls.evaluate_hresult(self.__dict__["_SetComponent"](arg_component.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2adb8ac1-7836-45af-b7f1-77b13a9db586}", ICalcScalarVectorComponent)
agcls.AgTypeNameMap["ICalcScalarVectorComponent"] = ICalcScalarVectorComponent

class ICalcScalarVectorMagnitude(object):
    """Scalar equal to the magnitude of a specified vector."""
    _uuid = "{57FC76A1-A63F-4A25-A3A6-3953275A15E4}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcScalarVectorMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcScalarVectorMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcScalarVectorMagnitude = agcom.GUID(ICalcScalarVectorMagnitude._uuid)
        vtable_offset_local = ICalcScalarVectorMagnitude._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorMagnitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalcScalarVectorMagnitude, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcScalarVectorMagnitude.__dict__ and type(ICalcScalarVectorMagnitude.__dict__[attrname]) == property:
            return ICalcScalarVectorMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcScalarVectorMagnitude.")
    
    @property
    def InputVector(self) -> "IVector":
        """Specify any vector in VGT. Note that its magnitude is reference axes independent which is why it is not specified."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{57FC76A1-A63F-4A25-A3A6-3953275A15E4}", ICalcScalarVectorMagnitude)
agcls.AgTypeNameMap["ICalcScalarVectorMagnitude"] = ICalcScalarVectorMagnitude

class ICondition(object):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    _uuid = "{8CA43B7E-6345-4F97-97B2-A4C4517739C8}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICondition = agcom.GUID(ICondition._uuid)
        vtable_offset_local = ICondition._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICondition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICondition, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICondition, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICondition.__dict__ and type(ICondition.__dict__[attrname]) == property:
            return ICondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICondition.")
    
    @property
    def Type(self) -> "AgECrdnConditionType":
        """Returns the type of condition."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "IEvaluateResult":
        """Returns result of evaluating continuously varying condition metric at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "IEvaluateWithRateResult":
        """Returns result of evaluating continuously varying condition metric and its rate of change at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8CA43B7E-6345-4F97-97B2-A4C4517739C8}", ICondition)
agcls.AgTypeNameMap["ICondition"] = ICondition

class IConditionCombined(object):
    """Defines a condition which combines multiple conditions."""
    _uuid = "{EB19E942-0C28-4AB9-B2C0-D31693564C99}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_SetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_GetConditionCount"] = _raise_uninitialized_error
        self.__dict__["_GetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_RemoveCondition"] = _raise_uninitialized_error
        self.__dict__["_AddCondition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionCombined from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionCombined = agcom.GUID(IConditionCombined._uuid)
        vtable_offset_local = IConditionCombined._vtable_offset - 1
        self.__dict__["_GetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetConditionCount"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetAllConditions"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetAllConditions"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+6, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+7, agcom.PVOID, agcom.INT)
        self.__dict__["_RemoveCondition"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+8, agcom.INT)
        self.__dict__["_AddCondition"] = IAGFUNCTYPE(pUnk, IID_IConditionCombined, vtable_offset_local+9, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionCombined.__dict__ and type(IConditionCombined.__dict__[attrname]) == property:
            return IConditionCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionCombined.")
    
    @property
    def CombineOperation(self) -> "AgECrdnConditionCombinedOperationType":
        """Get the operation from the condition that determines how the conditions are combined. The operation can be set to AND, OR, XOR, MINUS."""
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCombineOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnConditionCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__["_SetCombineOperation"](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Gets the number of conditions in the combined condition."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all conditions that are being combined."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all conditions to be combined."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__["_SetAllConditions"](byref(arg_conditions.COM_val)))

    def GetCondition(self, pos:int) -> "ICondition":
        """Get the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetCondition(self, ref:"ICondition", pos:int) -> None:
        """Set the condition at the position specified."""
        with agmarshall.AgInterface_in_arg(ref, ICondition) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_ref.COM_val, arg_pos.COM_val))

    def RemoveCondition(self, pos:int) -> None:
        """Remove the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveCondition"](arg_pos.COM_val))

    def AddCondition(self, ref:"ICondition") -> None:
        """Adds a condition at the end of the list."""
        with agmarshall.AgInterface_in_arg(ref, ICondition) as arg_ref:
            agcls.evaluate_hresult(self.__dict__["_AddCondition"](arg_ref.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB19E942-0C28-4AB9-B2C0-D31693564C99}", IConditionCombined)
agcls.AgTypeNameMap["IConditionCombined"] = IConditionCombined

class IConditionFactory(object):
    """The factory creates condition components."""
    _uuid = "{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionScalarBounds"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionCombined"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionPointInVolume"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionFactory = agcom.GUID(IConditionFactory._uuid)
        vtable_offset_local = IConditionFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IConditionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateConditionScalarBounds"] = IAGFUNCTYPE(pUnk, IID_IConditionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IConditionFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateConditionCombined"] = IAGFUNCTYPE(pUnk, IID_IConditionFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateConditionPointInVolume"] = IAGFUNCTYPE(pUnk, IID_IConditionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionFactory.__dict__ and type(IConditionFactory.__dict__[attrname]) == property:
            return IConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionType") -> "ICondition":
        """Creates and registers a condition using specified name, description and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionScalarBounds(self, name:str, description:str) -> "ICondition":
        """Creates a condition placing bounds on specified scalar."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionScalarBounds"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateConditionCombined(self, name:str, description:str) -> "ICondition":
        """Creates a condition which combines multiple conditions."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionCombined"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionPointInVolume(self, name:str, description:str) -> "ICondition":
        """Creates a condition for point in volume."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionPointInVolume"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}", IConditionFactory)
agcls.AgTypeNameMap["IConditionFactory"] = IConditionFactory

class IConditionPointInVolume(object):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    _uuid = "{3C354DF9-E914-4542-9E21-F70A637C4EA4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetConstraint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionPointInVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionPointInVolume from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionPointInVolume = agcom.GUID(IConditionPointInVolume._uuid)
        vtable_offset_local = IConditionPointInVolume._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IConditionPointInVolume, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_IConditionPointInVolume, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetConstraint"] = IAGFUNCTYPE(pUnk, IID_IConditionPointInVolume, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetConstraint"] = IAGFUNCTYPE(pUnk, IID_IConditionPointInVolume, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionPointInVolume.__dict__ and type(IConditionPointInVolume.__dict__[attrname]) == property:
            return IConditionPointInVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionPointInVolume.")
    
    @property
    def Point(self) -> "IPoint":
        """Get the trajectory point from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def Constraint(self) -> "IVolume":
        """Get the volume constraint on trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"IVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, IVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__["_SetConstraint"](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3C354DF9-E914-4542-9E21-F70A637C4EA4}", IConditionPointInVolume)
agcls.AgTypeNameMap["IConditionPointInVolume"] = IConditionPointInVolume

class IConditionScalarBounds(object):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    _uuid = "{FE3FB52B-9784-4707-8266-28F1E13B79D1}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetOperation"] = _raise_uninitialized_error
        self.__dict__["_SetOperation"] = _raise_uninitialized_error
        self.__dict__["_GetMinimum"] = _raise_uninitialized_error
        self.__dict__["_SetMinimum"] = _raise_uninitialized_error
        self.__dict__["_GetMaximum"] = _raise_uninitialized_error
        self.__dict__["_SetMaximum"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumUnitless"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetUnitless"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionScalarBounds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionScalarBounds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionScalarBounds = agcom.GUID(IConditionScalarBounds._uuid)
        vtable_offset_local = IConditionScalarBounds._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetOperation"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOperation"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetMinimum"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetMinimum"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetMaximum"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMaximum"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
        self.__dict__["_GetMinimumUnitless"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumUnitless"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetMaximumUnitless"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumUnitless"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_SetUnitless"] = IAGFUNCTYPE(pUnk, IID_IConditionScalarBounds, vtable_offset_local+14, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionScalarBounds.__dict__ and type(IConditionScalarBounds.__dict__[attrname]) == property:
            return IConditionScalarBounds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionScalarBounds.")
    
    @property
    def Scalar(self) -> "ICalcScalar":
        """Get the scalar calculation from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__["_SetOperation"](arg_operation.COM_val))

    def GetMinimum(self) -> "IQuantity":
        """Get the minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimum"](arg_value.COM_val))

    def GetMaximum(self) -> "IQuantity":
        """Get the maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximum"](arg_value.COM_val))

    def Set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_min.COM_val, arg_max.COM_val))

    def GetMinimumUnitless(self) -> float:
        """Get the unitless minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumUnitless"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMinimumUnitless(self, value:float) -> None:
        """Set the unitless minimum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumUnitless"](arg_value.COM_val))

    def GetMaximumUnitless(self) -> float:
        """Get the unitless maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumUnitless"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMaximumUnitless(self, value:float) -> None:
        """Set the unitless maximum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumUnitless"](arg_value.COM_val))

    def SetUnitless(self, min:float, max:float) -> None:
        """Set the unitless min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetUnitless"](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FE3FB52B-9784-4707-8266-28F1E13B79D1}", IConditionScalarBounds)
agcls.AgTypeNameMap["IConditionScalarBounds"] = IConditionScalarBounds

class IConditionSet(object):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    _uuid = "{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionSet = agcom.GUID(IConditionSet._uuid)
        vtable_offset_local = IConditionSet._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IConditionSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_IConditionSet, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_IConditionSet, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionSet.__dict__ and type(IConditionSet.__dict__[attrname]) == property:
            return IConditionSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionSet.")
    
    @property
    def Type(self) -> "AgECrdnConditionSetType":
        """Returns the type of condition set."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "IConditionSetEvaluateResult":
        """Returns an array of results of evaluating continuously varying condition metrics, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "IConditionSetEvaluateWithRateResult":
        """Returns an array of results of evaluating continuously varying condition metrics and their rates of change, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}", IConditionSet)
agcls.AgTypeNameMap["IConditionSet"] = IConditionSet

class IConditionSetFactory(object):
    """The factory creates condition set components."""
    _uuid = "{698D592C-B264-426D-8577-AC7087E3EE44}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateScalarThresholds"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionSetFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionSetFactory = agcom.GUID(IConditionSetFactory._uuid)
        vtable_offset_local = IConditionSetFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IConditionSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateScalarThresholds"] = IAGFUNCTYPE(pUnk, IID_IConditionSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IConditionSetFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionSetFactory.__dict__ and type(IConditionSetFactory.__dict__[attrname]) == property:
            return IConditionSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionSetFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionSetType") -> "IConditionSet":
        """Creates and registers a condition set using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateScalarThresholds(self, name:str, description:str) -> "IConditionSet":
        """Create a scalar thresholds condition set."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateScalarThresholds"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{698D592C-B264-426D-8577-AC7087E3EE44}", IConditionSetFactory)
agcls.AgTypeNameMap["IConditionSetFactory"] = IConditionSetFactory

class IConditionSetScalarThresholds(object):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    _uuid = "{57392078-7821-4910-B734-76B5C70CB6D9}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetThresholds"] = _raise_uninitialized_error
        self.__dict__["_GetThresholdLabels"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeAboveHighestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeAboveHighestThreshold"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBelowLowestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBelowLowestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetThresholdsAndLabels"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConditionSetScalarThresholds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConditionSetScalarThresholds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConditionSetScalarThresholds = agcom.GUID(IConditionSetScalarThresholds._uuid)
        vtable_offset_local = IConditionSetScalarThresholds._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetThresholds"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetThresholdLabels"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetIncludeAboveHighestThreshold"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeAboveHighestThreshold"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetIncludeBelowLowestThreshold"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBelowLowestThreshold"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_SetThresholdsAndLabels"] = IAGFUNCTYPE(pUnk, IID_IConditionSetScalarThresholds, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConditionSetScalarThresholds.__dict__ and type(IConditionSetScalarThresholds.__dict__[attrname]) == property:
            return IConditionSetScalarThresholds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConditionSetScalarThresholds.")
    
    @property
    def Scalar(self) -> "ICalcScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def Thresholds(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThresholds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ThresholdLabels(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThresholdLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IncludeAboveHighestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions above the highest threhsold."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeAboveHighestThreshold"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeAboveHighestThreshold.setter
    def IncludeAboveHighestThreshold(self, includeAboveHighestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeAboveHighestThreshold) as arg_includeAboveHighestThreshold:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeAboveHighestThreshold"](arg_includeAboveHighestThreshold.COM_val))

    @property
    def IncludeBelowLowestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions below the lowest threhsolds."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBelowLowestThreshold"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeBelowLowestThreshold.setter
    def IncludeBelowLowestThreshold(self, includeBelowLowestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeBelowLowestThreshold) as arg_includeBelowLowestThreshold:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBelowLowestThreshold"](arg_includeBelowLowestThreshold.COM_val))

    def SetThresholdsAndLabels(self, thresholds:list, thresholdLabels:list) -> None:
        """Set thresholds and threshold labels."""
        with agmarshall.SAFEARRAY_arg(thresholds) as arg_thresholds, \
             agmarshall.SAFEARRAY_arg(thresholdLabels) as arg_thresholdLabels:
            agcls.evaluate_hresult(self.__dict__["_SetThresholdsAndLabels"](byref(arg_thresholds.COM_val), byref(arg_thresholdLabels.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{57392078-7821-4910-B734-76B5C70CB6D9}", IConditionSetScalarThresholds)
agcls.AgTypeNameMap["IConditionSetScalarThresholds"] = IConditionSetScalarThresholds

class IConverge(object):
    """Represents a base class for convergence definitions."""
    _uuid = "{28B17124-9BE6-4437-A7ED-0DDC24353430}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConverge._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConverge from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConverge = agcom.GUID(IConverge._uuid)
        vtable_offset_local = IConverge._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConverge.__dict__ and type(IConverge.__dict__[attrname]) == property:
            return IConverge.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConverge.")
    

agcls.AgClassCatalog.add_catalog_entry("{28B17124-9BE6-4437-A7ED-0DDC24353430}", IConverge)
agcls.AgTypeNameMap["IConverge"] = IConverge

class IConvergeBasic(object):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    _uuid = "{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSense"] = _raise_uninitialized_error
        self.__dict__["_SetSense"] = _raise_uninitialized_error
        self.__dict__["_GetTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConvergeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConvergeBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConvergeBasic = agcom.GUID(IConvergeBasic._uuid)
        vtable_offset_local = IConvergeBasic._vtable_offset - 1
        self.__dict__["_GetSense"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSense"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_IConvergeBasic, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConvergeBasic.__dict__ and type(IConvergeBasic.__dict__[attrname]) == property:
            return IConvergeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConvergeBasic.")
    
    @property
    def Sense(self) -> "AgECrdnThreshConvergeSense":
        """Get the convergence sense which determines whether the converged value should be limited to just within or just outside of condition boundaries."""
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Sense.setter
    def Sense(self, sense:"AgECrdnThreshConvergeSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense, sense) as arg_sense:
            agcls.evaluate_hresult(self.__dict__["_SetSense"](arg_sense.COM_val))

    @property
    def TimeTolerance(self) -> float:
        """Get the time tolerance which determines the time accuracy of the converged value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeTolerance.setter
    def TimeTolerance(self, timeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(timeTolerance) as arg_timeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetTimeTolerance"](arg_timeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines the distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines the relative distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}", IConvergeBasic)
agcls.AgTypeNameMap["IConvergeBasic"] = IConvergeBasic

class IDerivative(object):
    """Represents a base class for derivative definitions."""
    _uuid = "{737042BD-D873-4CF6-B5D5-6769849156FD}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDerivative = agcom.GUID(IDerivative._uuid)
        vtable_offset_local = IDerivative._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDerivative.__dict__ and type(IDerivative.__dict__[attrname]) == property:
            return IDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDerivative.")
    

agcls.AgClassCatalog.add_catalog_entry("{737042BD-D873-4CF6-B5D5-6769849156FD}", IDerivative)
agcls.AgTypeNameMap["IDerivative"] = IDerivative

class IDerivativeBasic(object):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    _uuid = "{CD450BBA-9F54-4F15-B067-C5A80C970FA9}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDerivativeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDerivativeBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDerivativeBasic = agcom.GUID(IDerivativeBasic._uuid)
        vtable_offset_local = IDerivativeBasic._vtable_offset - 1
        self.__dict__["_GetTimeStep"] = IAGFUNCTYPE(pUnk, IID_IDerivativeBasic, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeStep"] = IAGFUNCTYPE(pUnk, IID_IDerivativeBasic, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDerivativeBasic.__dict__ and type(IDerivativeBasic.__dict__[attrname]) == property:
            return IDerivativeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDerivativeBasic.")
    
    @property
    def TimeStep(self) -> float:
        """Get the time step used for numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__["_SetTimeStep"](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CD450BBA-9F54-4F15-B067-C5A80C970FA9}", IDerivativeBasic)
agcls.AgTypeNameMap["IDerivativeBasic"] = IDerivativeBasic

class IEvent(object):
    """Defines an event (time instant)."""
    _uuid = "{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetToday"] = _raise_uninitialized_error
        self.__dict__["_GetTomorrow"] = _raise_uninitialized_error
        self.__dict__["_GetNoonToday"] = _raise_uninitialized_error
        self.__dict__["_GetNoonTomorrow"] = _raise_uninitialized_error
        self.__dict__["_FindOccurrence"] = _raise_uninitialized_error
        self.__dict__["_OccursBefore"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEvent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEvent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEvent = agcom.GUID(IEvent._uuid)
        vtable_offset_local = IEvent._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IEvent, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetToday"] = IAGFUNCTYPE(pUnk, IID_IEvent, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTomorrow"] = IAGFUNCTYPE(pUnk, IID_IEvent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetNoonToday"] = IAGFUNCTYPE(pUnk, IID_IEvent, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetNoonTomorrow"] = IAGFUNCTYPE(pUnk, IID_IEvent, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_FindOccurrence"] = IAGFUNCTYPE(pUnk, IID_IEvent, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_OccursBefore"] = IAGFUNCTYPE(pUnk, IID_IEvent, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEvent.__dict__ and type(IEvent.__dict__[attrname]) == property:
            return IEvent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEvent.")
    
    @property
    def Type(self) -> "AgECrdnEventType":
        """Return the type of time instant."""
        with agmarshall.AgEnum_arg(AgECrdnEventType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Today(self) -> "IEvent":
        """Return time instant that corresponds to today's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "IEvent":
        """Return time instant that corresponds to tomorrow's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonToday(self) -> "IEvent":
        """Return time instant that corresponds to today's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNoonToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonTomorrow(self) -> "IEvent":
        """Return time instant that corresponds to tomorrow's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNoonTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindOccurrence(self) -> "IEventFindOccurrenceResult":
        """Return computed time instance if it occurs."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindOccurrence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def OccursBefore(self, epoch:typing.Any) -> bool:
        """Return true if computed time instance occurs before or at specified time, return false otherwise."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_OccursBefore"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}", IEvent)
agcls.AgTypeNameMap["IEvent"] = IEvent

class IEventArray(object):
    """An ordered array of times, which may or may not be evenly spaced."""
    _uuid = "{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArray._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArray from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArray = agcom.GUID(IEventArray._uuid)
        vtable_offset_local = IEventArray._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IEventArray, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindTimes"] = IAGFUNCTYPE(pUnk, IID_IEventArray, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArray.__dict__ and type(IEventArray.__dict__[attrname]) == property:
            return IEventArray.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArray.")
    
    @property
    def Type(self) -> "AgECrdnEventArrayType":
        """Return the type of time array."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindTimes(self) -> "IFindTimesResult":
        """Return computed array of times."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}", IEventArray)
agcls.AgTypeNameMap["IEventArray"] = IEventArray

class IEventArrayConditionCrossings(object):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    _uuid = "{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSatisfactionCrossing"] = _raise_uninitialized_error
        self.__dict__["_SetSatisfactionCrossing"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayConditionCrossings._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayConditionCrossings from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayConditionCrossings = agcom.GUID(IEventArrayConditionCrossings._uuid)
        vtable_offset_local = IEventArrayConditionCrossings._vtable_offset - 1
        self.__dict__["_GetSatisfactionCrossing"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSatisfactionCrossing"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventArrayConditionCrossings, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayConditionCrossings.__dict__ and type(IEventArrayConditionCrossings.__dict__[attrname]) == property:
            return IEventArrayConditionCrossings.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayConditionCrossings.")
    
    @property
    def SatisfactionCrossing(self) -> "AgECrdnSatisfactionCrossing":
        """The direction of interest for satisfaction crossing."""
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSatisfactionCrossing"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionCrossing.setter
    def SatisfactionCrossing(self, satisfactionCrossing:"AgECrdnSatisfactionCrossing") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing, satisfactionCrossing) as arg_satisfactionCrossing:
            agcls.evaluate_hresult(self.__dict__["_SetSatisfactionCrossing"](arg_satisfactionCrossing.COM_val))

    @property
    def Condition(self) -> "ICondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "IEventIntervalList":
        """Specify the interval list within which satisfaction crossing times are sought. The default is set to overall availability of host object. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed satisfaction crossing times are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IConverge":
        """The Convergence definition, which uses time tolerance to determine when crossing times are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}", IEventArrayConditionCrossings)
agcls.AgTypeNameMap["IEventArrayConditionCrossings"] = IEventArrayConditionCrossings

class IEventArrayExtrema(object):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{664C3048-BB87-4841-988A-0580F2976C0D}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_SetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_GetIsGlobal"] = _raise_uninitialized_error
        self.__dict__["_SetIsGlobal"] = _raise_uninitialized_error
        self.__dict__["_GetCalculation"] = _raise_uninitialized_error
        self.__dict__["_SetCalculation"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayExtrema._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayExtrema from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayExtrema = agcom.GUID(IEventArrayExtrema._uuid)
        vtable_offset_local = IEventArrayExtrema._vtable_offset - 1
        self.__dict__["_GetExtremumType"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetExtremumType"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetIsGlobal"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsGlobal"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetCalculation"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCalculation"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventArrayExtrema, vtable_offset_local+16, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayExtrema.__dict__ and type(IEventArrayExtrema.__dict__[attrname]) == property:
            return IEventArrayExtrema.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayExtrema.")
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetExtremumType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__["_SetExtremumType"](arg_extremumType.COM_val))

    @property
    def IsGlobal(self) -> bool:
        """Indicates whether to perform local or global search. The default is false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsGlobal"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsGlobal.setter
    def IsGlobal(self, isGlobal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isGlobal) as arg_isGlobal:
            agcls.evaluate_hresult(self.__dict__["_SetIsGlobal"](arg_isGlobal.COM_val))

    @property
    def Calculation(self) -> "ICalcScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalculation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, ICalcScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__["_SetCalculation"](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "IEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Specify whether computed times of extrema are saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{664C3048-BB87-4841-988A-0580F2976C0D}", IEventArrayExtrema)
agcls.AgTypeNameMap["IEventArrayExtrema"] = IEventArrayExtrema

class IEventArrayFactory(object):
    """The factory creates event arrays."""
    _uuid = "{CE43C07E-4626-4CEA-A625-C42052111CDE}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayExtrema"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayStartStopTimes"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayMerged"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFiltered"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFixedStep"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayConditionCrossings"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArraySignaled"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFixedTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayFactory = agcom.GUID(IEventArrayFactory._uuid)
        vtable_offset_local = IEventArrayFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayExtrema"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayStartStopTimes"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayMerged"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayFiltered"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayFixedStep"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayConditionCrossings"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArraySignaled"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventArrayFixedTimes"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayFactory.__dict__ and type(IEventArrayFactory.__dict__[attrname]) == property:
            return IEventArrayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventArrayType") -> "IEventArray":
        """Create and register an event array using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventArrayType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayExtrema(self, name:str, description:str) -> "IEventArray":
        """Create an event array by determining times of local minimum and/or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayExtrema"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayStartStopTimes(self, name:str, description:str) -> "IEventArray":
        """Create an event array by taking start and/or stop times of every interval in the specified reference interval list and adding them to array."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayStartStopTimes"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayMerged(self, name:str, description:str) -> "IEventArray":
        """Create an event array by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayMerged"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFiltered(self, name:str, description:str) -> "IEventArray":
        """Create an event array by filtering times from an original time array according to specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFiltered"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFixedStep(self, name:str, description:str) -> "IEventArray":
        """Create an event array using fixed time steps from the specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFixedStep"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayConditionCrossings(self, name:str, description:str) -> "IEventArray":
        """Create an event array containing times at which the specified condition will change its satisfaction status."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayConditionCrossings"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArraySignaled(self, name:str, description:str) -> "IEventArray":
        """Create an event array recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArraySignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventArrayType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventArrayFixedTimes(self, name:str, description:str) -> "IEventArray":
        """Create an event array using specified times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFixedTimes"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CE43C07E-4626-4CEA-A625-C42052111CDE}", IEventArrayFactory)
agcls.AgTypeNameMap["IEventArrayFactory"] = IEventArrayFactory

class IEventArrayFiltered(object):
    """Defined by filtering times from original time array according to specified filtering method."""
    _uuid = "{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_GetFilterType"] = _raise_uninitialized_error
        self.__dict__["_SetFilterType"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_SetCount"] = _raise_uninitialized_error
        self.__dict__["_GetStep"] = _raise_uninitialized_error
        self.__dict__["_SetStep"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeIntervalStopTimes"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeIntervalStopTimes"] = _raise_uninitialized_error
        self.__dict__["_GetFilterIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetFilterIntervalList"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayFiltered from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayFiltered = agcom.GUID(IEventArrayFiltered._uuid)
        vtable_offset_local = IEventArrayFiltered._vtable_offset - 1
        self.__dict__["_GetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetFilterType"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetFilterType"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetCount"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+6, agcom.INT)
        self.__dict__["_GetStep"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStep"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetIncludeIntervalStopTimes"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeIntervalStopTimes"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetFilterIntervalList"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetFilterIntervalList"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFiltered, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayFiltered.__dict__ and type(IEventArrayFiltered.__dict__[attrname]) == property:
            return IEventArrayFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayFiltered.")
    
    @property
    def OriginalTimeArray(self) -> "IEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeArray"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"IEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, IEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeArray"](arg_originalTimeArray.COM_val))

    @property
    def FilterType(self) -> "AgECrdnEventArrayFilterType":
        """Skip Time Steps filter type omits from filtered time array any times that fall within specified time step of last accepted time sample. Skip Count filter type omits specified number of time samples since last accepted time sample..."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FilterType.setter
    def FilterType(self, filterType:"AgECrdnEventArrayFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType, filterType) as arg_filterType:
            agcls.evaluate_hresult(self.__dict__["_SetFilterType"](arg_filterType.COM_val))

    @property
    def Count(self) -> int:
        """Specify the number of times skipped between accepted samples when FilterType is set to Skip Count..."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Count.setter
    def Count(self, count:int) -> None:
        with agmarshall.INT_arg(count) as arg_count:
            agcls.evaluate_hresult(self.__dict__["_SetCount"](arg_count.COM_val))

    @property
    def Step(self) -> float:
        """The number of steps skipped between accepted samples when FilterType is set to Skip Time Steps."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__["_SetStep"](arg_step.COM_val))

    @property
    def IncludeIntervalStopTimes(self) -> bool:
        """If set to true, includes stop times of each interval from original time array."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeIntervalStopTimes"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalStopTimes.setter
    def IncludeIntervalStopTimes(self, includeIntervalStopTimes:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalStopTimes) as arg_includeIntervalStopTimes:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeIntervalStopTimes"](arg_includeIntervalStopTimes.COM_val))

    @property
    def FilterIntervalList(self) -> "IEventIntervalList":
        """The interval list used to filter samples when FilterType is set to Skip Intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterIntervalList"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @FilterIntervalList.setter
    def FilterIntervalList(self, filterIntervalList:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(filterIntervalList, IEventIntervalList) as arg_filterIntervalList:
            agcls.evaluate_hresult(self.__dict__["_SetFilterIntervalList"](arg_filterIntervalList.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}", IEventArrayFiltered)
agcls.AgTypeNameMap["IEventArrayFiltered"] = IEventArrayFiltered

class IEventArrayFixedStep(object):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    _uuid = "{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetBoundingIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetBoundingIntervalList"] = _raise_uninitialized_error
        self.__dict__["_GetSamplingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetSamplingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeIntervalEdges"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeIntervalEdges"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayFixedStep = agcom.GUID(IEventArrayFixedStep._uuid)
        vtable_offset_local = IEventArrayFixedStep._vtable_offset - 1
        self.__dict__["_GetBoundingIntervalList"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetBoundingIntervalList"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSamplingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSamplingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIncludeIntervalEdges"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeIntervalEdges"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceType"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceType"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedStep, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayFixedStep.__dict__ and type(IEventArrayFixedStep.__dict__[attrname]) == property:
            return IEventArrayFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayFixedStep.")
    
    @property
    def BoundingIntervalList(self) -> "IEventIntervalList":
        """The bounding interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBoundingIntervalList"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BoundingIntervalList.setter
    def BoundingIntervalList(self, boundingIntervalList:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(boundingIntervalList, IEventIntervalList) as arg_boundingIntervalList:
            agcls.evaluate_hresult(self.__dict__["_SetBoundingIntervalList"](arg_boundingIntervalList.COM_val))

    @property
    def SamplingTimeStep(self) -> float:
        """The sampling time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSamplingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SamplingTimeStep.setter
    def SamplingTimeStep(self, samplingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(samplingTimeStep) as arg_samplingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetSamplingTimeStep"](arg_samplingTimeStep.COM_val))

    @property
    def IncludeIntervalEdges(self) -> bool:
        """Specify whether to include interval edges."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeIntervalEdges"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalEdges.setter
    def IncludeIntervalEdges(self, includeIntervalEdges:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalEdges) as arg_includeIntervalEdges:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeIntervalEdges"](arg_includeIntervalEdges.COM_val))

    @property
    def ReferenceType(self) -> "AgECrdnSampledReferenceTime":
        """Specify the time reference from which fixed sampling time steps are taken. Note: selecting Start/Stop of each Interval resets the time reference for each interval, whereas other types maintain single reference for entire array."""
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceType.setter
    def ReferenceType(self, referenceType:"AgECrdnSampledReferenceTime") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime, referenceType) as arg_referenceType:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceType"](arg_referenceType.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """The reference time instant. Only applicable if the ReferenceType is set to time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}", IEventArrayFixedStep)
agcls.AgTypeNameMap["IEventArrayFixedStep"] = IEventArrayFixedStep

class IEventArrayFixedTimes(object):
    """Array defined by time ordered instants each explicitly specified."""
    _uuid = "{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetArrayTimes"] = _raise_uninitialized_error
        self.__dict__["_SetArrayTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayFixedTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayFixedTimes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayFixedTimes = agcom.GUID(IEventArrayFixedTimes._uuid)
        vtable_offset_local = IEventArrayFixedTimes._vtable_offset - 1
        self.__dict__["_GetArrayTimes"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedTimes, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetArrayTimes"] = IAGFUNCTYPE(pUnk, IID_IEventArrayFixedTimes, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayFixedTimes.__dict__ and type(IEventArrayFixedTimes.__dict__[attrname]) == property:
            return IEventArrayFixedTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayFixedTimes.")
    
    @property
    def ArrayTimes(self) -> list:
        """The array of times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetArrayTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetArrayTimes(self, times:list) -> None:
        """Sets array of times."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times:
            agcls.evaluate_hresult(self.__dict__["_SetArrayTimes"](byref(arg_times.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}", IEventArrayFixedTimes)
agcls.AgTypeNameMap["IEventArrayFixedTimes"] = IEventArrayFixedTimes

class IEventArrayMerged(object):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    _uuid = "{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeArrayA"] = _raise_uninitialized_error
        self.__dict__["_SetTimeArrayA"] = _raise_uninitialized_error
        self.__dict__["_GetTimeArrayB"] = _raise_uninitialized_error
        self.__dict__["_SetTimeArrayB"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayMerged from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayMerged = agcom.GUID(IEventArrayMerged._uuid)
        vtable_offset_local = IEventArrayMerged._vtable_offset - 1
        self.__dict__["_GetTimeArrayA"] = IAGFUNCTYPE(pUnk, IID_IEventArrayMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeArrayA"] = IAGFUNCTYPE(pUnk, IID_IEventArrayMerged, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeArrayB"] = IAGFUNCTYPE(pUnk, IID_IEventArrayMerged, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeArrayB"] = IAGFUNCTYPE(pUnk, IID_IEventArrayMerged, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayMerged.__dict__ and type(IEventArrayMerged.__dict__[attrname]) == property:
            return IEventArrayMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayMerged.")
    
    @property
    def TimeArrayA(self) -> "IEventArray":
        """The first time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeArrayA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayA.setter
    def TimeArrayA(self, timeArrayA:"IEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayA, IEventArray) as arg_timeArrayA:
            agcls.evaluate_hresult(self.__dict__["_SetTimeArrayA"](arg_timeArrayA.COM_val))

    @property
    def TimeArrayB(self) -> "IEventArray":
        """The second time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeArrayB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayB.setter
    def TimeArrayB(self, timeArrayB:"IEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayB, IEventArray) as arg_timeArrayB:
            agcls.evaluate_hresult(self.__dict__["_SetTimeArrayB"](arg_timeArrayB.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}", IEventArrayMerged)
agcls.AgTypeNameMap["IEventArrayMerged"] = IEventArrayMerged

class IEventArraySignaled(object):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    _uuid = "{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArraySignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArraySignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArraySignaled = agcom.GUID(IEventArraySignaled._uuid)
        vtable_offset_local = IEventArraySignaled._vtable_offset - 1
        self.__dict__["_GetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventArraySignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArraySignaled.__dict__ and type(IEventArraySignaled.__dict__[attrname]) == property:
            return IEventArraySignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArraySignaled.")
    
    @property
    def OriginalTimeArray(self) -> "IEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeArray"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"IEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, IEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeArray"](arg_originalTimeArray.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ISignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ISignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ISignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}", IEventArraySignaled)
agcls.AgTypeNameMap["IEventArraySignaled"] = IEventArraySignaled

class IEventArrayStartStopTimes(object):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    _uuid = "{1AB79442-7711-4342-B944-81C51D14FBE4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartStopOption"] = _raise_uninitialized_error
        self.__dict__["_SetStartStopOption"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventArrayStartStopTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventArrayStartStopTimes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventArrayStartStopTimes = agcom.GUID(IEventArrayStartStopTimes._uuid)
        vtable_offset_local = IEventArrayStartStopTimes._vtable_offset - 1
        self.__dict__["_GetStartStopOption"] = IAGFUNCTYPE(pUnk, IID_IEventArrayStartStopTimes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetStartStopOption"] = IAGFUNCTYPE(pUnk, IID_IEventArrayStartStopTimes, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventArrayStartStopTimes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventArrayStartStopTimes, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventArrayStartStopTimes.__dict__ and type(IEventArrayStartStopTimes.__dict__[attrname]) == property:
            return IEventArrayStartStopTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventArrayStartStopTimes.")
    
    @property
    def StartStopOption(self) -> "AgECrdnStartStopOption":
        """The edge type. At least one of the two edge types must be selected."""
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartStopOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartStopOption.setter
    def StartStopOption(self, startStopOption:"AgECrdnStartStopOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption, startStopOption) as arg_startStopOption:
            agcls.evaluate_hresult(self.__dict__["_SetStartStopOption"](arg_startStopOption.COM_val))

    @property
    def ReferenceIntervals(self) -> "IEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1AB79442-7711-4342-B944-81C51D14FBE4}", IEventArrayStartStopTimes)
agcls.AgTypeNameMap["IEventArrayStartStopTimes"] = IEventArrayStartStopTimes

class IEventEpoch(object):
    """Event set at specified date/time."""
    _uuid = "{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventEpoch = agcom.GUID(IEventEpoch._uuid)
        vtable_offset_local = IEventEpoch._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventEpoch, vtable_offset_local+2, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventEpoch.__dict__ and type(IEventEpoch.__dict__[attrname]) == property:
            return IEventEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventEpoch.")
    
    @property
    def Epoch(self) -> typing.Any:
        """An explicit date/time, set using any STK date format."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}", IEventEpoch)
agcls.AgTypeNameMap["IEventEpoch"] = IEventEpoch

class IEventExtremum(object):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{C588FDD4-2008-4C33-AA63-1C59565AE4F3}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_SetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_GetCalculation"] = _raise_uninitialized_error
        self.__dict__["_SetCalculation"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventExtremum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventExtremum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventExtremum = agcom.GUID(IEventExtremum._uuid)
        vtable_offset_local = IEventExtremum._vtable_offset - 1
        self.__dict__["_GetExtremumType"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetExtremumType"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetCalculation"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCalculation"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventExtremum, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventExtremum.__dict__ and type(IEventExtremum.__dict__[attrname]) == property:
            return IEventExtremum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventExtremum.")
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetExtremumType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__["_SetExtremumType"](arg_extremumType.COM_val))

    @property
    def Calculation(self) -> "ICalcScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalculation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, ICalcScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__["_SetCalculation"](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "IEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C588FDD4-2008-4C33-AA63-1C59565AE4F3}", IEventExtremum)
agcls.AgTypeNameMap["IEventExtremum"] = IEventExtremum

class IEventFactory(object):
    """The factory creates events."""
    _uuid = "{803DD343-F271-47D9-8D71-2092DD2A3387}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetToday"] = _raise_uninitialized_error
        self.__dict__["_GetTomorrow"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventEpoch"] = _raise_uninitialized_error
        self.__dict__["_CreateEventExtremum"] = _raise_uninitialized_error
        self.__dict__["_CreateEventStartStopTime"] = _raise_uninitialized_error
        self.__dict__["_CreateEventSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_CreateSmartEpochFromTime"] = _raise_uninitialized_error
        self.__dict__["_CreateSmartEpochFromEvent"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventFactory = agcom.GUID(IEventFactory._uuid)
        vtable_offset_local = IEventFactory._vtable_offset - 1
        self.__dict__["_GetToday"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTomorrow"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventExtremum"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventStartStopTime"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventSignaled"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateSmartEpochFromTime"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+9, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_CreateSmartEpochFromEvent"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IEventFactory, vtable_offset_local+11, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventFactory.__dict__ and type(IEventFactory.__dict__[attrname]) == property:
            return IEventFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventFactory.")
    
    @property
    def Today(self) -> "IEvent":
        """Returns Today time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "IEvent":
        """Returns Tomorrow time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnEventType") -> "IEvent":
        """Creates and registers an event using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventEpoch(self, name:str, description:str) -> "IEvent":
        """Creates an event set at a specified date/time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventEpoch"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventExtremum(self, name:str, description:str) -> "IEvent":
        """Creates an event that determines the time of global minimum or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventExtremum"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventStartStopTime(self, name:str, description:str) -> "IEvent":
        """Creates an event that is either the start or stop time selected from a reference interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventStartStopTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventSignaled(self, name:str, description:str) -> "IEvent":
        """Creates an event recorded on a specified clock via signal transmission from an original time instant recorded on different clock."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventTimeOffset(self, name:str, description:str) -> "IEvent":
        """Creates an event at fixed offset from specified reference event."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromTime(self, epoch:typing.Any) -> "IEventSmartEpoch":
        """Creates a smart epoch from STK epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateSmartEpochFromTime"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromEvent(self, refEvent:"IEvent") -> "IEventSmartEpoch":
        """Creates a smart epoch from an event."""
        with agmarshall.AgInterface_in_arg(refEvent, IEvent) as arg_refEvent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateSmartEpochFromEvent"](arg_refEvent.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{803DD343-F271-47D9-8D71-2092DD2A3387}", IEventFactory)
agcls.AgTypeNameMap["IEventFactory"] = IEventFactory

class IEventInterval(object):
    """A single time interval."""
    _uuid = "{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStartDescription"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStopDescription"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStart"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStop"] = _raise_uninitialized_error
        self.__dict__["_FindInterval"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventInterval = agcom.GUID(IEventInterval._uuid)
        vtable_offset_local = IEventInterval._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IEventInterval, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabelStartDescription"] = IAGFUNCTYPE(pUnk, IID_IEventInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStopDescription"] = IAGFUNCTYPE(pUnk, IID_IEventInterval, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStart"] = IAGFUNCTYPE(pUnk, IID_IEventInterval, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStop"] = IAGFUNCTYPE(pUnk, IID_IEventInterval, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_FindInterval"] = IAGFUNCTYPE(pUnk, IID_IEventInterval, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_IEventInterval, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventInterval.__dict__ and type(IEventInterval.__dict__[attrname]) == property:
            return IEventInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventInterval.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalType":
        """Return the type of interval."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStartDescription(self) -> str:
        """The start description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStartDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStopDescription(self) -> str:
        """The stop description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStopDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStart(self) -> str:
        """A label associated with the interval start."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStop(self) -> str:
        """A label associated with the interval stop."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInterval(self) -> "IEventIntervalResult":
        """Return computed interval if it exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval if it exists."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}", IEventInterval)
agcls.AgTypeNameMap["IEventInterval"] = IEventInterval

class IEventIntervalBetweenTimeInstants(object):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    _uuid = "{18236EC1-B691-4FFD-995B-FB4896BAFD71}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetStartTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetStopTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetStopTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalBetweenTimeInstants._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalBetweenTimeInstants from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalBetweenTimeInstants = agcom.GUID(IEventIntervalBetweenTimeInstants._uuid)
        vtable_offset_local = IEventIntervalBetweenTimeInstants._vtable_offset - 1
        self.__dict__["_GetStartTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalBetweenTimeInstants, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetStartTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalBetweenTimeInstants, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetStopTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalBetweenTimeInstants, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetStopTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalBetweenTimeInstants, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalBetweenTimeInstants.__dict__ and type(IEventIntervalBetweenTimeInstants.__dict__[attrname]) == property:
            return IEventIntervalBetweenTimeInstants.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalBetweenTimeInstants.")
    
    @property
    def StartTimeInstant(self) -> "IEvent":
        """The start time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StartTimeInstant.setter
    def StartTimeInstant(self, startTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(startTimeInstant, IEvent) as arg_startTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetStartTimeInstant"](arg_startTimeInstant.COM_val))

    @property
    def StopTimeInstant(self) -> "IEvent":
        """The stop time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StopTimeInstant.setter
    def StopTimeInstant(self, stopTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(stopTimeInstant, IEvent) as arg_stopTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetStopTimeInstant"](arg_stopTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18236EC1-B691-4FFD-995B-FB4896BAFD71}", IEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap["IEventIntervalBetweenTimeInstants"] = IEventIntervalBetweenTimeInstants

class IEventIntervalCollection(object):
    """A collection of related interval lists."""
    _uuid = "{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_FindIntervalCollection"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalCollection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalCollection = agcom.GUID(IEventIntervalCollection._uuid)
        vtable_offset_local = IEventIntervalCollection._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollection, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_FindIntervalCollection"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollection, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalCollection.__dict__ and type(IEventIntervalCollection.__dict__[attrname]) == property:
            return IEventIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalCollection.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalCollectionType":
        """Return the type of collection of interval lists."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels associated with the interval lists in the collection."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervalCollection(self) -> "IIntervalsVectorResult":
        """Return computed collection of interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindIntervalCollection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> "IEventIntervalCollectionOccurredResult":
        """Determine if specified time falls within any of the computed interval lists in the collection."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}", IEventIntervalCollection)
agcls.AgTypeNameMap["IEventIntervalCollection"] = IEventIntervalCollection

class IEventIntervalCollectionCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{0253FA16-73AA-4F0A-9904-0789EC873ECB}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetConditionSet"] = _raise_uninitialized_error
        self.__dict__["_SetConditionSet"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalCollectionCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalCollectionCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalCollectionCondition = agcom.GUID(IEventIntervalCollectionCondition._uuid)
        vtable_offset_local = IEventIntervalCollectionCondition._vtable_offset - 1
        self.__dict__["_GetConditionSet"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetConditionSet"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalCollectionCondition.__dict__ and type(IEventIntervalCollectionCondition.__dict__[attrname]) == property:
            return IEventIntervalCollectionCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalCollectionCondition.")
    
    @property
    def ConditionSet(self) -> "IConditionSet":
        """Get/set the condition set object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionSet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ConditionSet.setter
    def ConditionSet(self, conditionSet:"IConditionSet") -> None:
        with agmarshall.AgInterface_in_arg(conditionSet, IConditionSet) as arg_conditionSet:
            agcls.evaluate_hresult(self.__dict__["_SetConditionSet"](arg_conditionSet.COM_val))

    @property
    def CustomTimeLimits(self) -> "IEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use specified custom interval list (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0253FA16-73AA-4F0A-9904-0789EC873ECB}", IEventIntervalCollectionCondition)
agcls.AgTypeNameMap["IEventIntervalCollectionCondition"] = IEventIntervalCollectionCondition

class IEventIntervalCollectionFactory(object):
    """The factory creates collections of event interval lists."""
    _uuid = "{15E2D2CF-61F9-4468-A5E1-770149F6B08C}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionLighting"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionSignaled"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionSatisfaction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalCollectionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalCollectionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalCollectionFactory = agcom.GUID(IEventIntervalCollectionFactory._uuid)
        vtable_offset_local = IEventIntervalCollectionFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalCollectionLighting"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalCollectionSignaled"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionFactory, vtable_offset_local+4, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventIntervalCollectionSatisfaction"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalCollectionFactory.__dict__ and type(IEventIntervalCollectionFactory.__dict__[attrname]) == property:
            return IEventIntervalCollectionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalCollectionFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalCollectionType") -> "IEventIntervalCollection":
        """Create and register an event interval collection using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionLighting(self, name:str, description:str) -> "IEventIntervalCollection":
        """Create an event interval collection defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionLighting"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionSignaled(self, name:str, description:str) -> "IEventIntervalCollection":
        """Create an event interval collection recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalCollectionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalCollectionSatisfaction(self, name:str, description:str) -> "IEventIntervalCollection":
        """Create an event interval collection containing intervals during which condition set is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionSatisfaction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{15E2D2CF-61F9-4468-A5E1-770149F6B08C}", IEventIntervalCollectionFactory)
agcls.AgTypeNameMap["IEventIntervalCollectionFactory"] = IEventIntervalCollectionFactory

class IEventIntervalCollectionLighting(object):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    _uuid = "{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLocation"] = _raise_uninitialized_error
        self.__dict__["_SetLocation"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalCollectionLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalCollectionLighting from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalCollectionLighting = agcom.GUID(IEventIntervalCollectionLighting._uuid)
        vtable_offset_local = IEventIntervalCollectionLighting._vtable_offset - 1
        self.__dict__["_GetLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionLighting, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionLighting, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionLighting, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionLighting, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionLighting, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionLighting, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalCollectionLighting.__dict__ and type(IEventIntervalCollectionLighting.__dict__[attrname]) == property:
            return IEventIntervalCollectionLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalCollectionLighting.")
    
    @property
    def Location(self) -> "IPoint":
        """The location point to compute sunlight, penumbra and umbra."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, IPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__["_SetLocation"](arg_location.COM_val))

    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}", IEventIntervalCollectionLighting)
agcls.AgTypeNameMap["IEventIntervalCollectionLighting"] = IEventIntervalCollectionLighting

class IEventIntervalCollectionSignaled(object):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    _uuid = "{AE464683-EEEC-46CF-8886-91F7A30B7859}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalCollection"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalCollection"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalCollectionSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalCollectionSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalCollectionSignaled = agcom.GUID(IEventIntervalCollectionSignaled._uuid)
        vtable_offset_local = IEventIntervalCollectionSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalCollection"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalCollection"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalCollectionSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalCollectionSignaled.__dict__ and type(IEventIntervalCollectionSignaled.__dict__[attrname]) == property:
            return IEventIntervalCollectionSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalCollectionSignaled.")
    
    @property
    def OriginalCollection(self) -> "IEventIntervalCollection":
        """The original interval list collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalCollection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalCollection.setter
    def OriginalCollection(self, originalCollection:"IEventIntervalCollection") -> None:
        with agmarshall.AgInterface_in_arg(originalCollection, IEventIntervalCollection) as arg_originalCollection:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalCollection"](arg_originalCollection.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ISignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ISignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ISignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AE464683-EEEC-46CF-8886-91F7A30B7859}", IEventIntervalCollectionSignaled)
agcls.AgTypeNameMap["IEventIntervalCollectionSignaled"] = IEventIntervalCollectionSignaled

class IEventIntervalFactory(object):
    """The factory creates event intervals."""
    _uuid = "{F87C00CA-725C-425C-941E-6987709D788F}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFixed"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFixedDuration"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalBetweenTimeInstants"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFromIntervalList"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalScaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalFactory = agcom.GUID(IEventIntervalFactory._uuid)
        vtable_offset_local = IEventIntervalFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFixed"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFixedDuration"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalBetweenTimeInstants"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFromIntervalList"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalScaled"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalSignaled"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalFactory.__dict__ and type(IEventIntervalFactory.__dict__[attrname]) == property:
            return IEventIntervalFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalType") -> "IEventInterval":
        """Create and register an interval using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixed(self, name:str, description:str) -> "IEventInterval":
        """Create an interval defined between two explicitly specified start and stop times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFixed"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixedDuration(self, name:str, description:str) -> "IEventInterval":
        """Create an interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFixedDuration"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalBetweenTimeInstants(self, name:str, description:str) -> "IEventInterval":
        """Create an interval using specified start and stop time instants."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalBetweenTimeInstants"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFromIntervalList(self, name:str, description:str) -> "IEventInterval":
        """Create an interval from a specified interval list by using one of several selection methods."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFromIntervalList"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalScaled(self, name:str, description:str) -> "IEventInterval":
        """Create an interval by scaling an original interval using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalScaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalSignaled(self, name:str, description:str) -> "IEventInterval":
        """Create an interval that is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalTimeOffset(self, name:str, description:str) -> "IEventInterval":
        """Create an interval defined by shifting the specified reference interval by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F87C00CA-725C-425C-941E-6987709D788F}", IEventIntervalFactory)
agcls.AgTypeNameMap["IEventIntervalFactory"] = IEventIntervalFactory

class IEventIntervalFixed(object):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    _uuid = "{2DBC4523-FDD0-413B-B933-9F74B9B17BED}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartTime"] = _raise_uninitialized_error
        self.__dict__["_GetStopTime"] = _raise_uninitialized_error
        self.__dict__["_SetInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalFixed = agcom.GUID(IEventIntervalFixed._uuid)
        vtable_offset_local = IEventIntervalFixed._vtable_offset - 1
        self.__dict__["_GetStartTime"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixed, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetStopTime"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixed, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_SetInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixed, vtable_offset_local+3, agcom.VARIANT, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalFixed.__dict__ and type(IEventIntervalFixed.__dict__[attrname]) == property:
            return IEventIntervalFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalFixed.")
    
    @property
    def StartTime(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def StopTime(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetInterval(self, startEpoch:typing.Any, stopEpoch:typing.Any) -> None:
        """Set interval's start and stop times."""
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch, \
             agmarshall.VARIANT_arg(stopEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetInterval"](arg_startEpoch.COM_val, arg_stopEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2DBC4523-FDD0-413B-B933-9F74B9B17BED}", IEventIntervalFixed)
agcls.AgTypeNameMap["IEventIntervalFixed"] = IEventIntervalFixed

class IEventIntervalFixedDuration(object):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    _uuid = "{2A20830B-D576-4DF1-9C15-51EB59AEC23F}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalFixedDuration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalFixedDuration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalFixedDuration = agcom.GUID(IEventIntervalFixedDuration._uuid)
        vtable_offset_local = IEventIntervalFixedDuration._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixedDuration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixedDuration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixedDuration, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixedDuration, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixedDuration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFixedDuration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalFixedDuration.__dict__ and type(IEventIntervalFixedDuration.__dict__[attrname]) == property:
            return IEventIntervalFixedDuration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalFixedDuration.")
    
    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def StartOffset(self) -> float:
        """The start time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """The stop time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2A20830B-D576-4DF1-9C15-51EB59AEC23F}", IEventIntervalFixedDuration)
agcls.AgTypeNameMap["IEventIntervalFixedDuration"] = IEventIntervalFixedDuration

class IEventIntervalFromIntervalList(object):
    """Interval created from specified interval list by using one of several selection methods."""
    _uuid = "{DCF8AA30-67A3-4856-956D-C4952BF3818E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalSelection"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalSelection"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalNumber"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalNumber"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalFromIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalFromIntervalList from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalFromIntervalList = agcom.GUID(IEventIntervalFromIntervalList._uuid)
        vtable_offset_local = IEventIntervalFromIntervalList._vtable_offset - 1
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFromIntervalList, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFromIntervalList, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetIntervalSelection"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFromIntervalList, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetIntervalSelection"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFromIntervalList, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetIntervalNumber"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFromIntervalList, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetIntervalNumber"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalFromIntervalList, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalFromIntervalList.__dict__ and type(IEventIntervalFromIntervalList.__dict__[attrname]) == property:
            return IEventIntervalFromIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalFromIntervalList.")
    
    @property
    def ReferenceIntervals(self) -> "IEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def IntervalSelection(self) -> "AgECrdnIntervalSelection":
        """The method used to select an interval from the reference interval list."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalSelection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalSelection.setter
    def IntervalSelection(self, intervalSelection:"AgECrdnIntervalSelection") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection, intervalSelection) as arg_intervalSelection:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalSelection"](arg_intervalSelection.COM_val))

    @property
    def IntervalNumber(self) -> int:
        """An interval number. Applicable only if IntervalSelection is IntervalSelectionFromStart or IntervalSelectionFromEnd"""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalNumber"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalNumber.setter
    def IntervalNumber(self, intervalNumber:int) -> None:
        with agmarshall.INT_arg(intervalNumber) as arg_intervalNumber:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalNumber"](arg_intervalNumber.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DCF8AA30-67A3-4856-956D-C4952BF3818E}", IEventIntervalFromIntervalList)
agcls.AgTypeNameMap["IEventIntervalFromIntervalList"] = IEventIntervalFromIntervalList

class IEventIntervalList(object):
    """An ordered list of time intervals."""
    _uuid = "{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetDescriptions"] = _raise_uninitialized_error
        self.__dict__["_FindIntervals"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalList from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalList = agcom.GUID(IEventIntervalList._uuid)
        vtable_offset_local = IEventIntervalList._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalList, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalList, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetDescriptions"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalList, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_FindIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalList, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalList, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalList.__dict__ and type(IEventIntervalList.__dict__[attrname]) == property:
            return IEventIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalList.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalListType":
        """Return the type of interval list."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the label descriptions associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Descriptions(self) -> list:
        """Get the labels associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDescriptions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervals(self) -> "IIntervalListResult":
        """Return computed interval list that can be empty."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval list."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}", IEventIntervalList)
agcls.AgTypeNameMap["IEventIntervalList"] = IEventIntervalList

class IEventIntervalListCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{D073568A-7398-45C2-998A-CD2EC12F06E0}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListCondition = agcom.GUID(IEventIntervalListCondition._uuid)
        vtable_offset_local = IEventIntervalListCondition._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListCondition.__dict__ and type(IEventIntervalListCondition.__dict__[attrname]) == property:
            return IEventIntervalListCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListCondition.")
    
    @property
    def Condition(self) -> "ICondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "IEventIntervalList":
        """The interval list or single interval within which intervals of satisfaction are sought. The specified value is used if UseCustomTimeLimits is true. The default is set to overall availability of host object..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed intervals of satisfaction are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IConverge":
        """The Convergence definition, which uses time tolerance to determine when times for intervals of satisfaction are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D073568A-7398-45C2-998A-CD2EC12F06E0}", IEventIntervalListCondition)
agcls.AgTypeNameMap["IEventIntervalListCondition"] = IEventIntervalListCondition

class IEventIntervalListFactory(object):
    """The factory creates event interval lists."""
    _uuid = "{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListMerged"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFiltered"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListCondition"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListScaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFile"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFixed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListFactory = agcom.GUID(IEventIntervalListFactory._uuid)
        vtable_offset_local = IEventIntervalListFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListMerged"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListFiltered"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListCondition"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListScaled"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListSignaled"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+8, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventIntervalListFile"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListFixed"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListFactory.__dict__ and type(IEventIntervalListFactory.__dict__[attrname]) == property:
            return IEventIntervalListFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalListType") -> "IEventIntervalList":
        """Create and register an interval list using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListMerged(self, name:str, description:str) -> "IEventIntervalList":
        """Create an interval list by merging two constituent interval lists using specified logical operation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListMerged"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFiltered(self, name:str, description:str) -> "IEventIntervalList":
        """Create an interval list by filtering intervals from original interval list using specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFiltered"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListCondition(self, name:str, description:str) -> "IEventIntervalList":
        """Create an interval list containing intervals during which specified condition is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListCondition"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListScaled(self, name:str, description:str) -> "IEventIntervalList":
        """Create an interval list defined by scaling every interval in original interval list using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListScaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListSignaled(self, name:str, description:str) -> "IEventIntervalList":
        """Create an interval list recorded at the target clock location by performing signal transmission of original interval list between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListTimeOffset(self, name:str, description:str) -> "IEventIntervalList":
        """Create an interval list defined by shifting the specified reference interval list by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalListType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalListFile(self, name:str, description:str, filePath:str) -> "IEventIntervalList":
        """Create an interval list based on specified interval file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filePath) as arg_filePath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFile"](arg_name.COM_val, arg_description.COM_val, arg_filePath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFixed(self, name:str, description:str) -> "IEventIntervalList":
        """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFixed"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}", IEventIntervalListFactory)
agcls.AgTypeNameMap["IEventIntervalListFactory"] = IEventIntervalListFactory

class IEventIntervalListFile(object):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    _uuid = "{A17588F4-C944-44F8-B8D8-275B13D27E3A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        self.__dict__["_GetFileSpan"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListFile = agcom.GUID(IEventIntervalListFile._uuid)
        vtable_offset_local = IEventIntervalListFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFile, vtable_offset_local+3, )
        self.__dict__["_GetFileSpan"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFile, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListFile.__dict__ and type(IEventIntervalListFile.__dict__[attrname]) == property:
            return IEventIntervalListFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListFile.")
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the time interval list."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the interval list file."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())

    def GetFileSpan(self) -> "IEventIntervalResult":
        """Computes the interval list file span."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileSpan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A17588F4-C944-44F8-B8D8-275B13D27E3A}", IEventIntervalListFile)
agcls.AgTypeNameMap["IEventIntervalListFile"] = IEventIntervalListFile

class IEventIntervalListFiltered(object):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    _uuid = "{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetFilterFactory"] = _raise_uninitialized_error
        self.__dict__["_GetFilter"] = _raise_uninitialized_error
        self.__dict__["_SetFilter"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListFiltered from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListFiltered = agcom.GUID(IEventIntervalListFiltered._uuid)
        vtable_offset_local = IEventIntervalListFiltered._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetFilterFactory"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFiltered, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetFilter"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFiltered, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_SetFilter"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFiltered, vtable_offset_local+5, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListFiltered.__dict__ and type(IEventIntervalListFiltered.__dict__[attrname]) == property:
            return IEventIntervalListFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListFiltered.")
    
    @property
    def OriginalIntervals(self) -> "IEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, IEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def FilterFactory(self) -> "IPruneFilterFactory":
        """Get the prune filter factory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filter(self) -> "IPruneFilter":
        """The pruning filter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"IPruneFilter") -> None:
        with agmarshall.AgInterface_in_arg(filter, IPruneFilter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_SetFilter"](arg_filter.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}", IEventIntervalListFiltered)
agcls.AgTypeNameMap["IEventIntervalListFiltered"] = IEventIntervalListFiltered

class IEventIntervalListFixed(object):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    _uuid = "{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListFixed = agcom.GUID(IEventIntervalListFixed._uuid)
        vtable_offset_local = IEventIntervalListFixed._vtable_offset - 1
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFixed, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListFixed, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListFixed.__dict__ and type(IEventIntervalListFixed.__dict__[attrname]) == property:
            return IEventIntervalListFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListFixed.")
    
    def GetIntervals(self) -> list:
        """Get intervals with explicitly specified start and stop times from interval list. The method returns a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetIntervals(self, intervals:list) -> None:
        """Set interval list from intervals with explicitly specified start and stop times. The method takes a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg(intervals) as arg_intervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervals"](byref(arg_intervals.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}", IEventIntervalListFixed)
agcls.AgTypeNameMap["IEventIntervalListFixed"] = IEventIntervalListFixed

class IEventIntervalListMerged(object):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    _uuid = "{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIntervalListOrIntervalA"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalListOrIntervalB"] = _raise_uninitialized_error
        self.__dict__["_GetMergeOperation"] = _raise_uninitialized_error
        self.__dict__["_SetMergeOperation"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalListA"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalA"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalListB"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalB"] = _raise_uninitialized_error
        self.__dict__["_AddInterval"] = _raise_uninitialized_error
        self.__dict__["_AddIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetInterval"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalList"] = _raise_uninitialized_error
        self.__dict__["_GetTimeComponent"] = _raise_uninitialized_error
        self.__dict__["_GetTimeComponentSize"] = _raise_uninitialized_error
        self.__dict__["_RemoveTimeComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListMerged from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListMerged = agcom.GUID(IEventIntervalListMerged._uuid)
        vtable_offset_local = IEventIntervalListMerged._vtable_offset - 1
        self.__dict__["_GetIntervalListOrIntervalA"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetIntervalListOrIntervalB"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMergeOperation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMergeOperation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_SetIntervalListA"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_SetIntervalA"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_SetIntervalListB"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_SetIntervalB"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_AddInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_AddIntervalList"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_SetInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+11, agcom.PVOID, agcom.INT)
        self.__dict__["_SetIntervalList"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+12, agcom.PVOID, agcom.INT)
        self.__dict__["_GetTimeComponent"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+13, agcom.INT, POINTER(agcom.BSTR))
        self.__dict__["_GetTimeComponentSize"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+14, POINTER(agcom.INT))
        self.__dict__["_RemoveTimeComponent"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListMerged, vtable_offset_local+15, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListMerged.__dict__ and type(IEventIntervalListMerged.__dict__[attrname]) == property:
            return IEventIntervalListMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListMerged.")
    
    @property
    def IntervalListOrIntervalA(self) -> "ICoordinate":
        """The interval list or interval A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalListOrIntervalA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IntervalListOrIntervalB(self) -> "ICoordinate":
        """The interval list or interval B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalListOrIntervalB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MergeOperation(self) -> "AgECrdnEventListMergeOperation":
        """The merge operation."""
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMergeOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MergeOperation.setter
    def MergeOperation(self, mergeOperation:"AgECrdnEventListMergeOperation") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation, mergeOperation) as arg_mergeOperation:
            agcls.evaluate_hresult(self.__dict__["_SetMergeOperation"](arg_mergeOperation.COM_val))

    def SetIntervalListA(self, refIntervals:"IEventIntervalList") -> None:
        """Sets the interval list A."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalListA"](arg_refIntervals.COM_val))

    def SetIntervalA(self, refIntervals:"IEventInterval") -> None:
        """Sets the interval A."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalA"](arg_refIntervals.COM_val))

    def SetIntervalListB(self, refIntervals:"IEventIntervalList") -> None:
        """Sets the interval list B."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalListB"](arg_refIntervals.COM_val))

    def SetIntervalB(self, refIntervals:"IEventInterval") -> None:
        """Sets the interval B."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalB"](arg_refIntervals.COM_val))

    def AddInterval(self, refIntervals:"IEventInterval") -> None:
        """Add interval."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_AddInterval"](arg_refIntervals.COM_val))

    def AddIntervalList(self, refIntervals:"IEventIntervalList") -> None:
        """Add interval list."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_AddIntervalList"](arg_refIntervals.COM_val))

    def SetInterval(self, refIntervals:"IEventInterval", pos:int) -> None:
        """Sets the interval at given index."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventInterval) as arg_refIntervals, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetInterval"](arg_refIntervals.COM_val, arg_pos.COM_val))

    def SetIntervalList(self, refIntervals:"IEventIntervalList", pos:int) -> None:
        """Sets the interval list at given index."""
        with agmarshall.AgInterface_in_arg(refIntervals, IEventIntervalList) as arg_refIntervals, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalList"](arg_refIntervals.COM_val, arg_pos.COM_val))

    def GetTimeComponent(self, pos:int) -> str:
        """Gets time component at given position."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeComponent"](arg_pos.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetTimeComponentSize(self) -> int:
        """Gets time component list size."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeComponentSize"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def RemoveTimeComponent(self, pos:int) -> None:
        """Remove time component at given position."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveTimeComponent"](arg_pos.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}", IEventIntervalListMerged)
agcls.AgTypeNameMap["IEventIntervalListMerged"] = IEventIntervalListMerged

class IEventIntervalListScaled(object):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    _uuid = "{7DDA88F8-A738-464E-9CDC-613E107F57D0}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetUseAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetUseAbsoluteIncrement"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListScaled = agcom.GUID(IEventIntervalListScaled._uuid)
        vtable_offset_local = IEventIntervalListScaled._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListScaled.__dict__ and type(IEventIntervalListScaled.__dict__[attrname]) == property:
            return IEventIntervalListScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListScaled.")
    
    @property
    def OriginalIntervals(self) -> "IEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, IEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a new interval list by expanding (or shortening if negative) every interval in the original interval list by shifting interval's start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteIncrement"](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIncrement"](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetUseAbsoluteIncrement"](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7DDA88F8-A738-464E-9CDC-613E107F57D0}", IEventIntervalListScaled)
agcls.AgTypeNameMap["IEventIntervalListScaled"] = IEventIntervalListScaled

class IEventIntervalListSignaled(object):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    _uuid = "{C40EA24E-E258-4B0E-8A0F-89424F93F837}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListSignaled = agcom.GUID(IEventIntervalListSignaled._uuid)
        vtable_offset_local = IEventIntervalListSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListSignaled.__dict__ and type(IEventIntervalListSignaled.__dict__[attrname]) == property:
            return IEventIntervalListSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListSignaled.")
    
    @property
    def OriginalIntervals(self) -> "IEventIntervalList":
        """The original time interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, IEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ISignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ISignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ISignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C40EA24E-E258-4B0E-8A0F-89424F93F837}", IEventIntervalListSignaled)
agcls.AgTypeNameMap["IEventIntervalListSignaled"] = IEventIntervalListSignaled

class IEventIntervalListTimeOffset(object):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    _uuid = "{EEA120D3-8E9F-419B-B11C-A034007EB2D0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalListTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalListTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalListTimeOffset = agcom.GUID(IEventIntervalListTimeOffset._uuid)
        vtable_offset_local = IEventIntervalListTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalListTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalListTimeOffset.__dict__ and type(IEventIntervalListTimeOffset.__dict__[attrname]) == property:
            return IEventIntervalListTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalListTimeOffset.")
    
    @property
    def ReferenceIntervals(self) -> "IEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset"](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEA120D3-8E9F-419B-B11C-A034007EB2D0}", IEventIntervalListTimeOffset)
agcls.AgTypeNameMap["IEventIntervalListTimeOffset"] = IEventIntervalListTimeOffset

class IEventIntervalScaled(object):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    _uuid = "{FA9613FB-7341-4785-AD95-51CFA2B605BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetUseAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetUseAbsoluteIncrement"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalScaled = agcom.GUID(IEventIntervalScaled._uuid)
        vtable_offset_local = IEventIntervalScaled._vtable_offset - 1
        self.__dict__["_GetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalScaled.__dict__ and type(IEventIntervalScaled.__dict__[attrname]) == property:
            return IEventIntervalScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalScaled.")
    
    @property
    def OriginalInterval(self) -> "IEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"IEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, IEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalInterval"](arg_originalInterval.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a interval by expanding (or shortening if negative) the original interval by shifting its start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteIncrement"](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIncrement"](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetUseAbsoluteIncrement"](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FA9613FB-7341-4785-AD95-51CFA2B605BC}", IEventIntervalScaled)
agcls.AgTypeNameMap["IEventIntervalScaled"] = IEventIntervalScaled

class IEventIntervalSignaled(object):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    _uuid = "{51B9DE87-9220-40B2-AA57-01F7B17BD945}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalSignaled = agcom.GUID(IEventIntervalSignaled._uuid)
        vtable_offset_local = IEventIntervalSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalSignaled.__dict__ and type(IEventIntervalSignaled.__dict__[attrname]) == property:
            return IEventIntervalSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalSignaled.")
    
    @property
    def OriginalInterval(self) -> "IEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"IEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, IEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalInterval"](arg_originalInterval.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ISignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ISignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ISignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{51B9DE87-9220-40B2-AA57-01F7B17BD945}", IEventIntervalSignaled)
agcls.AgTypeNameMap["IEventIntervalSignaled"] = IEventIntervalSignaled

class IEventIntervalSmartInterval(object):
    """A smart interval."""
    _uuid = "{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_GetDurationAsString"] = _raise_uninitialized_error
        self.__dict__["_SetDurationAsString"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        self.__dict__["_SetImplicitInterval"] = _raise_uninitialized_error
        self.__dict__["_FindStartTime"] = _raise_uninitialized_error
        self.__dict__["_FindStopTime"] = _raise_uninitialized_error
        self.__dict__["_GetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetStopEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStopEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetExplicitInterval"] = _raise_uninitialized_error
        self.__dict__["_SetStartAndStopEpochs"] = _raise_uninitialized_error
        self.__dict__["_SetStartAndStopTimes"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpochAndDuration"] = _raise_uninitialized_error
        self.__dict__["_SetStartTimeAndDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalSmartInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalSmartInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalSmartInterval = agcom.GUID(IEventIntervalSmartInterval._uuid)
        vtable_offset_local = IEventIntervalSmartInterval._vtable_offset - 1
        self.__dict__["_GetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDurationAsString"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetDurationAsString"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_SetImplicitInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_FindStartTime"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_FindStopTime"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_GetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetStopEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetStopEpoch"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_SetExplicitInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+13, agcom.VARIANT, agcom.VARIANT)
        self.__dict__["_SetStartAndStopEpochs"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+14, agcom.PVOID, agcom.PVOID)
        self.__dict__["_SetStartAndStopTimes"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+15, agcom.VARIANT, agcom.VARIANT)
        self.__dict__["_SetStartEpochAndDuration"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+16, agcom.PVOID, agcom.BSTR)
        self.__dict__["_SetStartTimeAndDuration"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalSmartInterval, vtable_offset_local+17, agcom.VARIANT, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalSmartInterval.__dict__ and type(IEventIntervalSmartInterval.__dict__[attrname]) == property:
            return IEventIntervalSmartInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalSmartInterval.")
    
    @property
    def ReferenceInterval(self) -> "IEventInterval":
        """The reference interval used to compute start/stop times of this interval if the state of the interval is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DurationAsString(self) -> str:
        """The duration of the interval"""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationAsString"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationAsString.setter
    def DurationAsString(self, durationAsString:str) -> None:
        with agmarshall.BSTR_arg(durationAsString) as arg_durationAsString:
            agcls.evaluate_hresult(self.__dict__["_SetDurationAsString"](arg_durationAsString.COM_val))

    @property
    def State(self) -> "AgECrdnSmartIntervalState":
        """A state of the smart interval."""
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartIntervalState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_state.COM_val))

    def SetImplicitInterval(self, eventInterval:"IEventInterval") -> None:
        """Set the reference interval and changes the state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventInterval, IEventInterval) as arg_eventInterval:
            agcls.evaluate_hresult(self.__dict__["_SetImplicitInterval"](arg_eventInterval.COM_val))

    def FindStartTime(self) -> typing.Any:
        """Finds a start time of the interval. An exception is thrown if the start time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindStartTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindStopTime(self) -> typing.Any:
        """Finds a stop time of the interval. An exception is thrown if the stop time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindStopTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetStartEpoch(self) -> "IEventSmartEpoch":
        """Returns a copy of the start epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartEpoch"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStartEpoch(self, startEpoch:"IEventSmartEpoch") -> None:
        """Sets a start of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(startEpoch, IEventSmartEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpoch"](arg_startEpoch.COM_val))

    def GetStopEpoch(self) -> "IEventSmartEpoch":
        """Returns a copy of the stop epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopEpoch"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStopEpoch(self, stopEpoch:"IEventSmartEpoch") -> None:
        """Sets a stop of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(stopEpoch, IEventSmartEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStopEpoch"](arg_stopEpoch.COM_val))

    def SetExplicitInterval(self, start:typing.Any, stop:typing.Any) -> None:
        """Set the interval's start and the stop times changes the interval's state to explicit. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(start) as arg_start, \
             agmarshall.VARIANT_arg(stop) as arg_stop:
            agcls.evaluate_hresult(self.__dict__["_SetExplicitInterval"](arg_start.COM_val, arg_stop.COM_val))

    def SetStartAndStopEpochs(self, refStartEpoch:"IEventSmartEpoch", refStopEpoch:"IEventSmartEpoch") -> None:
        """Sets the interval's start and stop epochs as two smart epoch components. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, IEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.AgInterface_in_arg(refStopEpoch, IEventSmartEpoch) as arg_refStopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartAndStopEpochs"](arg_refStartEpoch.COM_val, arg_refStopEpoch.COM_val))

    def SetStartAndStopTimes(self, startTime:typing.Any, stopTime:typing.Any) -> None:
        """Sets the interval's start and stop epochs as explicit times. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(startTime) as arg_startTime, \
             agmarshall.VARIANT_arg(stopTime) as arg_stopTime:
            agcls.evaluate_hresult(self.__dict__["_SetStartAndStopTimes"](arg_startTime.COM_val, arg_stopTime.COM_val))

    def SetStartEpochAndDuration(self, refStartEpoch:"IEventSmartEpoch", durationStr:str) -> None:
        """Sets the interval's start epoch and the interval's duration."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, IEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpochAndDuration"](arg_refStartEpoch.COM_val, arg_durationStr.COM_val))

    def SetStartTimeAndDuration(self, epoch:typing.Any, durationStr:str) -> None:
        """Sets the interval's start time and the interval's duration."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__["_SetStartTimeAndDuration"](arg_epoch.COM_val, arg_durationStr.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}", IEventIntervalSmartInterval)
agcls.AgTypeNameMap["IEventIntervalSmartInterval"] = IEventIntervalSmartInterval

class IEventIntervalTimeOffset(object):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    _uuid = "{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventIntervalTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventIntervalTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventIntervalTimeOffset = agcom.GUID(IEventIntervalTimeOffset._uuid)
        vtable_offset_local = IEventIntervalTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IEventIntervalTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventIntervalTimeOffset.__dict__ and type(IEventIntervalTimeOffset.__dict__[attrname]) == property:
            return IEventIntervalTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventIntervalTimeOffset.")
    
    @property
    def ReferenceInterval(self) -> "IEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceInterval.setter
    def ReferenceInterval(self, referenceInterval:"IEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceInterval, IEventInterval) as arg_referenceInterval:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceInterval"](arg_referenceInterval.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset"](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}", IEventIntervalTimeOffset)
agcls.AgTypeNameMap["IEventIntervalTimeOffset"] = IEventIntervalTimeOffset

class IEventSignaled(object):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    _uuid = "{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventSignaled = agcom.GUID(IEventSignaled._uuid)
        vtable_offset_local = IEventSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_IEventSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventSignaled.__dict__ and type(IEventSignaled.__dict__[attrname]) == property:
            return IEventSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventSignaled.")
    
    @property
    def OriginalTimeInstant(self) -> "IEvent":
        """The original time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeInstant.setter
    def OriginalTimeInstant(self, originalTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeInstant, IEvent) as arg_originalTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeInstant"](arg_originalTimeInstant.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ISignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ISignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ISignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}", IEventSignaled)
agcls.AgTypeNameMap["IEventSignaled"] = IEventSignaled

class IEventSmartEpoch(object):
    """A smart epoch."""
    _uuid = "{4C5542F5-5B94-498B-90BC-CC7CB7C86629}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEvent"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        self.__dict__["_SetExplicitTime"] = _raise_uninitialized_error
        self.__dict__["_SetImplicitTime"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventSmartEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventSmartEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventSmartEpoch = agcom.GUID(IEventSmartEpoch._uuid)
        vtable_offset_local = IEventSmartEpoch._vtable_offset - 1
        self.__dict__["_GetTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventSmartEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetReferenceEvent"] = IAGFUNCTYPE(pUnk, IID_IEventSmartEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_IEventSmartEpoch, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_IEventSmartEpoch, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_SetExplicitTime"] = IAGFUNCTYPE(pUnk, IID_IEventSmartEpoch, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_SetImplicitTime"] = IAGFUNCTYPE(pUnk, IID_IEventSmartEpoch, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventSmartEpoch.__dict__ and type(IEventSmartEpoch.__dict__[attrname]) == property:
            return IEventSmartEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventSmartEpoch.")
    
    @property
    def TimeInstant(self) -> typing.Any:
        """Represents the time instant if the state is set to explicit."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeInstant"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ReferenceEvent(self) -> "IEvent":
        """A reference event object used to compute time instant if the state is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEvent"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def State(self) -> "AgECrdnSmartEpochState":
        """State of the event."""
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartEpochState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_state.COM_val))

    def SetExplicitTime(self, epoch:typing.Any) -> None:
        """Sets explicit time instant and the smart epoch's state to Explicit."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetExplicitTime"](arg_epoch.COM_val))

    def SetImplicitTime(self, eventEpoch:"IEvent") -> None:
        """Sets the reference event and the smart epoch's state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventEpoch, IEvent) as arg_eventEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetImplicitTime"](arg_eventEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4C5542F5-5B94-498B-90BC-CC7CB7C86629}", IEventSmartEpoch)
agcls.AgTypeNameMap["IEventSmartEpoch"] = IEventSmartEpoch

class IEventStartStopTime(object):
    """Event is either start or stop time selected from a reference interval."""
    _uuid = "{EB96850C-18E7-4269-8D35-67FB7E55BD59}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseStart"] = _raise_uninitialized_error
        self.__dict__["_SetUseStart"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEventInterval"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEventInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventStartStopTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventStartStopTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventStartStopTime = agcom.GUID(IEventStartStopTime._uuid)
        vtable_offset_local = IEventStartStopTime._vtable_offset - 1
        self.__dict__["_GetUseStart"] = IAGFUNCTYPE(pUnk, IID_IEventStartStopTime, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseStart"] = IAGFUNCTYPE(pUnk, IID_IEventStartStopTime, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceEventInterval"] = IAGFUNCTYPE(pUnk, IID_IEventStartStopTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceEventInterval"] = IAGFUNCTYPE(pUnk, IID_IEventStartStopTime, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventStartStopTime.__dict__ and type(IEventStartStopTime.__dict__[attrname]) == property:
            return IEventStartStopTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventStartStopTime.")
    
    @property
    def UseStart(self) -> bool:
        """Indicates whether to use start (true) or stop (false)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseStart.setter
    def UseStart(self, useStart:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useStart) as arg_useStart:
            agcls.evaluate_hresult(self.__dict__["_SetUseStart"](arg_useStart.COM_val))

    @property
    def ReferenceEventInterval(self) -> "IEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEventInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceEventInterval.setter
    def ReferenceEventInterval(self, referenceEventInterval:"IEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceEventInterval, IEventInterval) as arg_referenceEventInterval:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEventInterval"](arg_referenceEventInterval.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB96850C-18E7-4269-8D35-67FB7E55BD59}", IEventStartStopTime)
agcls.AgTypeNameMap["IEventStartStopTime"] = IEventStartStopTime

class IEventTimeOffset(object):
    """Event at fixed offset from specified reference event."""
    _uuid = "{EB95E24E-6BDF-434C-A278-BF64475E4EB5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset2"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset2"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEventTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEventTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEventTimeOffset = agcom.GUID(IEventTimeOffset._uuid)
        vtable_offset_local = IEventTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IEventTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset2"] = IAGFUNCTYPE(pUnk, IID_IEventTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset2"] = IAGFUNCTYPE(pUnk, IID_IEventTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEventTimeOffset.__dict__ and type(IEventTimeOffset.__dict__[attrname]) == property:
            return IEventTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEventTimeOffset.")
    
    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def TimeOffset2(self) -> float:
        """The time offset from the ReferenceTimeInstant. The value is in \'TimeUnit\' dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset2"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset2.setter
    def TimeOffset2(self, timeOffset2:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset2) as arg_timeOffset2:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset2"](arg_timeOffset2.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB95E24E-6BDF-434C-A278-BF64475E4EB5}", IEventTimeOffset)
agcls.AgTypeNameMap["IEventTimeOffset"] = IEventTimeOffset

class IFirstIntervalsFilter(object):
    """The filter selects a portion of first intervals."""
    _uuid = "{032A1F18-16B1-48B3-BB59-AFE83A834880}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFirstIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFirstIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFirstIntervalsFilter = agcom.GUID(IFirstIntervalsFilter._uuid)
        vtable_offset_local = IFirstIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_IFirstIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_IFirstIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFirstIntervalsFilter.__dict__ and type(IFirstIntervalsFilter.__dict__[attrname]) == property:
            return IFirstIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFirstIntervalsFilter.")
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{032A1F18-16B1-48B3-BB59-AFE83A834880}", IFirstIntervalsFilter)
agcls.AgTypeNameMap["IFirstIntervalsFilter"] = IFirstIntervalsFilter

class IGapsFilter(object):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    _uuid = "{97B393F6-5E70-4D67-80C1-F85080D818F3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetGapDuration"] = _raise_uninitialized_error
        self.__dict__["_SetGapDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGapsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGapsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGapsFilter = agcom.GUID(IGapsFilter._uuid)
        vtable_offset_local = IGapsFilter._vtable_offset - 1
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_IGapsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_IGapsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetGapDuration"] = IAGFUNCTYPE(pUnk, IID_IGapsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGapDuration"] = IAGFUNCTYPE(pUnk, IID_IGapsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGapsFilter.__dict__ and type(IGapsFilter.__dict__[attrname]) == property:
            return IGapsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGapsFilter.")
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def GapDuration(self) -> float:
        """Duration of the gap."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGapDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GapDuration.setter
    def GapDuration(self, gapDuration:float) -> None:
        with agmarshall.DOUBLE_arg(gapDuration) as arg_gapDuration:
            agcls.evaluate_hresult(self.__dict__["_SetGapDuration"](arg_gapDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{97B393F6-5E70-4D67-80C1-F85080D818F3}", IGapsFilter)
agcls.AgTypeNameMap["IGapsFilter"] = IGapsFilter

class IIntegral(object):
    """Represents a base class for integral definitions."""
    _uuid = "{61D34977-CC2E-43C1-9103-692FF9B3DEF0}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIntegral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIntegral = agcom.GUID(IIntegral._uuid)
        vtable_offset_local = IIntegral._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIntegral.__dict__ and type(IIntegral.__dict__[attrname]) == property:
            return IIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIntegral.")
    

agcls.AgClassCatalog.add_catalog_entry("{61D34977-CC2E-43C1-9103-692FF9B3DEF0}", IIntegral)
agcls.AgTypeNameMap["IIntegral"] = IIntegral

class IIntegralBasic(object):
    """Integral definition determines how scalar calculation is numerically integrated."""
    _uuid = "{19DEEA25-F655-487B-86FF-429B55093F77}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_SetType"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumIterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIntegralBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIntegralBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIntegralBasic = agcom.GUID(IIntegralBasic._uuid)
        vtable_offset_local = IIntegralBasic._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IIntegralBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetType"] = IAGFUNCTYPE(pUnk, IID_IIntegralBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_IIntegralBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_IIntegralBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_IIntegralBasic, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_IIntegralBasic, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIntegralBasic.__dict__ and type(IIntegralBasic.__dict__[attrname]) == property:
            return IIntegralBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIntegralBasic.")
    
    @property
    def Type(self) -> "AgECrdnIntegralType":
        """Get the integral type which determines the method of integration and can be set to trapezoidal, Simplson or adaptive Lobatto."""
        with agmarshall.AgEnum_arg(AgECrdnIntegralType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnIntegralType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegralType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_SetType"](arg_type.COM_val))

    @property
    def Tolerance(self) -> float:
        """Get the tolerance which determines how accurate integral is computed by finding relative difference between refined and unrefined integral evaluations. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Tolerance.setter
    def Tolerance(self, tolerance:float) -> None:
        with agmarshall.DOUBLE_arg(tolerance) as arg_tolerance:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_tolerance.COM_val))

    @property
    def MaximumIterations(self) -> int:
        """Get the number of iteration which determines how many refinement iterations are allowed. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumIterations"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumIterations.setter
    def MaximumIterations(self, maximumIterations:int) -> None:
        with agmarshall.INT_arg(maximumIterations) as arg_maximumIterations:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumIterations"](arg_maximumIterations.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{19DEEA25-F655-487B-86FF-429B55093F77}", IIntegralBasic)
agcls.AgTypeNameMap["IIntegralBasic"] = IIntegralBasic

class IInterp(object):
    """Represents a base class for interpolation definitions."""
    _uuid = "{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IInterp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IInterp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IInterp = agcom.GUID(IInterp._uuid)
        vtable_offset_local = IInterp._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IInterp.__dict__ and type(IInterp.__dict__[attrname]) == property:
            return IInterp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IInterp.")
    

agcls.AgClassCatalog.add_catalog_entry("{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}", IInterp)
agcls.AgTypeNameMap["IInterp"] = IInterp

class IInterpBasic(object):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    _uuid = "{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_SetType"] = _raise_uninitialized_error
        self.__dict__["_GetOrder"] = _raise_uninitialized_error
        self.__dict__["_SetOrder"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IInterpBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IInterpBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IInterpBasic = agcom.GUID(IInterpBasic._uuid)
        vtable_offset_local = IInterpBasic._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IInterpBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetType"] = IAGFUNCTYPE(pUnk, IID_IInterpBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetOrder"] = IAGFUNCTYPE(pUnk, IID_IInterpBasic, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_SetOrder"] = IAGFUNCTYPE(pUnk, IID_IInterpBasic, vtable_offset_local+4, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IInterpBasic.__dict__ and type(IInterpBasic.__dict__[attrname]) == property:
            return IInterpBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IInterpBasic.")
    
    @property
    def Type(self) -> "AgECrdnInterpolatorType":
        """Get the interpolation type, which can be Lagrange or Hermite interpolation. See STK help on interpolation for further details."""
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_SetType"](arg_type.COM_val))

    @property
    def Order(self) -> int:
        """Get the interpolation order, which determines the order of interpolation polynomial and is related to how many samples are used during interpolation. See STK help on interpolation for further details."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrder"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Order.setter
    def Order(self, order:int) -> None:
        with agmarshall.INT_arg(order) as arg_order:
            agcls.evaluate_hresult(self.__dict__["_SetOrder"](arg_order.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}", IInterpBasic)
agcls.AgTypeNameMap["IInterpBasic"] = IInterpBasic

class IIntervalsFilter(object):
    """The filter selects intervals of at least/most certain duration."""
    _uuid = "{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIntervalsFilter = agcom.GUID(IIntervalsFilter._uuid)
        vtable_offset_local = IIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_IIntervalsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_IIntervalsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_IIntervalsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_IIntervalsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIntervalsFilter.__dict__ and type(IIntervalsFilter.__dict__[attrname]) == property:
            return IIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIntervalsFilter.")
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """The interval duration."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalDuration"](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}", IIntervalsFilter)
agcls.AgTypeNameMap["IIntervalsFilter"] = IIntervalsFilter

class ILastIntervalsFilter(object):
    """The filter selects a portion of last intervals."""
    _uuid = "{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILastIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILastIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILastIntervalsFilter = agcom.GUID(ILastIntervalsFilter._uuid)
        vtable_offset_local = ILastIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ILastIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ILastIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILastIntervalsFilter.__dict__ and type(ILastIntervalsFilter.__dict__[attrname]) == property:
            return ILastIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILastIntervalsFilter.")
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}", ILastIntervalsFilter)
agcls.AgTypeNameMap["ILastIntervalsFilter"] = ILastIntervalsFilter

class IParameterSet(object):
    """Parameter set contains various sets of scalar computations."""
    _uuid = "{285664E8-604B-4C0A-9ED0-5EE27CA1539D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetDimensions"] = _raise_uninitialized_error
        self.__dict__["_GetScalarNames"] = _raise_uninitialized_error
        self.__dict__["_Calculate"] = _raise_uninitialized_error
        self.__dict__["_CalculateWithDerivative"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSet = agcom.GUID(IParameterSet._uuid)
        vtable_offset_local = IParameterSet._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IParameterSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_IParameterSet, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetDimensions"] = IAGFUNCTYPE(pUnk, IID_IParameterSet, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetScalarNames"] = IAGFUNCTYPE(pUnk, IID_IParameterSet, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Calculate"] = IAGFUNCTYPE(pUnk, IID_IParameterSet, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CalculateWithDerivative"] = IAGFUNCTYPE(pUnk, IID_IParameterSet, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSet.__dict__ and type(IParameterSet.__dict__[attrname]) == property:
            return IParameterSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSet.")
    
    @property
    def Type(self) -> "AgECrdnParameterSetType":
        """Get the type of parameter set."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels identifying hierarchy of representations within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Dimensions(self) -> list:
        """Get the names identifying types of dimensions of individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimensions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScalarNames(self) -> list:
        """Get the names identifying individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Calculate(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Calculate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CalculateWithDerivative(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars and their time derivatives within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CalculateWithDerivative"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{285664E8-604B-4C0A-9ED0-5EE27CA1539D}", IParameterSet)
agcls.AgTypeNameMap["IParameterSet"] = IParameterSet

class IParameterSetAttitude(object):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    _uuid = "{8B7DCF32-3CA4-4794-8468-81A3627B4043}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_SetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSetAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSetAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSetAttitude = agcom.GUID(IParameterSetAttitude._uuid)
        vtable_offset_local = IParameterSetAttitude._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IParameterSetAttitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetAxes"] = IAGFUNCTYPE(pUnk, IID_IParameterSetAttitude, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IParameterSetAttitude, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IParameterSetAttitude, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSetAttitude.__dict__ and type(IParameterSetAttitude.__dict__[attrname]) == property:
            return IParameterSetAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSetAttitude.")
    
    @property
    def Axes(self) -> "IAxes":
        """Get the axes for which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Axes.setter
    def Axes(self, axes:"IAxes") -> None:
        with agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_SetAxes"](arg_axes.COM_val))

    @property
    def ReferenceAxes(self) -> "IAxes":
        """Get the reference axes relative to which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8B7DCF32-3CA4-4794-8468-81A3627B4043}", IParameterSetAttitude)
agcls.AgTypeNameMap["IParameterSetAttitude"] = IParameterSetAttitude

class IParameterSetFactory(object):
    """The factory is used to create instances of available parameter set types."""
    _uuid = "{4D20E85F-1DEA-4963-9114-6B0407E53C5E}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetAttitude"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetGroundTrajectory"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetOrbit"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetVector"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSetFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSetFactory = agcom.GUID(IParameterSetFactory._uuid)
        vtable_offset_local = IParameterSetFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IParameterSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetAttitude"] = IAGFUNCTYPE(pUnk, IID_IParameterSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetGroundTrajectory"] = IAGFUNCTYPE(pUnk, IID_IParameterSetFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetTrajectory"] = IAGFUNCTYPE(pUnk, IID_IParameterSetFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetOrbit"] = IAGFUNCTYPE(pUnk, IID_IParameterSetFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetVector"] = IAGFUNCTYPE(pUnk, IID_IParameterSetFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IParameterSetFactory, vtable_offset_local+7, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSetFactory.__dict__ and type(IParameterSetFactory.__dict__[attrname]) == property:
            return IParameterSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSetFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnParameterSetType") -> "IParameterSet":
        """Creates and registers a parameter set using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnParameterSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetAttitude(self, name:str, description:str) -> "IParameterSet":
        """Creates a parameter set defined by identifying one set of axes in reference to another."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetAttitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetGroundTrajectory(self, name:str, description:str) -> "IParameterSet":
        """Creates a parameter set defined by identifying location in reference central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetGroundTrajectory"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetTrajectory(self, name:str, description:str) -> "IParameterSet":
        """Creates a parameter set defined by identifying location in reference coordinate system."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetTrajectory"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetOrbit(self, name:str, description:str) -> "IParameterSet":
        """Creates a parameter set defined by identifying orbiting point and its central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetOrbit"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetVector(self, name:str, description:str) -> "IParameterSet":
        """Creates a parameter set defined by identifying vector in reference axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetVector"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnParameterSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4D20E85F-1DEA-4963-9114-6B0407E53C5E}", IParameterSetFactory)
agcls.AgTypeNameMap["IParameterSetFactory"] = IParameterSetFactory

class IParameterSetGroundTrajectory(object):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    _uuid = "{53ABEB95-F846-4574-BA87-C76220FDC19F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLocation"] = _raise_uninitialized_error
        self.__dict__["_SetLocation"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSetGroundTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSetGroundTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSetGroundTrajectory = agcom.GUID(IParameterSetGroundTrajectory._uuid)
        vtable_offset_local = IParameterSetGroundTrajectory._vtable_offset - 1
        self.__dict__["_GetLocation"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroundTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetLocation"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroundTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroundTrajectory, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IParameterSetGroundTrajectory, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSetGroundTrajectory.__dict__ and type(IParameterSetGroundTrajectory.__dict__[attrname]) == property:
            return IParameterSetGroundTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSetGroundTrajectory.")
    
    @property
    def Location(self) -> "IPoint":
        """Get the point for which ground trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, IPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__["_SetLocation"](arg_location.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which ground trajectory representations are computed. Both the central body reference shape and its CBF (central body centered fixed) system are used by this parameter set."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{53ABEB95-F846-4574-BA87-C76220FDC19F}", IParameterSetGroundTrajectory)
agcls.AgTypeNameMap["IParameterSetGroundTrajectory"] = IParameterSetGroundTrajectory

class IParameterSetOrbit(object):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    _uuid = "{141AEAB7-C017-4044-BE2C-EFE4AD724022}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOrbitingPoint"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitingPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_SetGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetUseCentralBodyGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_SetUseCentralBodyGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_GetUseCentralBodyInertial"] = _raise_uninitialized_error
        self.__dict__["_SetUseCentralBodyInertial"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSetOrbit._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSetOrbit from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSetOrbit = agcom.GUID(IParameterSetOrbit._uuid)
        vtable_offset_local = IParameterSetOrbit._vtable_offset - 1
        self.__dict__["_GetOrbitingPoint"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOrbitingPoint"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetUseCentralBodyGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCentralBodyGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseCentralBodyInertial"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCentralBodyInertial"] = IAGFUNCTYPE(pUnk, IID_IParameterSetOrbit, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSetOrbit.__dict__ and type(IParameterSetOrbit.__dict__[attrname]) == property:
            return IParameterSetOrbit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSetOrbit.")
    
    @property
    def OrbitingPoint(self) -> "IPoint":
        """Get the point for which orbital parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitingPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OrbitingPoint.setter
    def OrbitingPoint(self, orbitingPoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(orbitingPoint, IPoint) as arg_orbitingPoint:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitingPoint"](arg_orbitingPoint.COM_val))

    @property
    def ReferenceSystem(self) -> "ISystem":
        """Get the reference system in which orbital parameters are computed. Only used if the option to specify reference system is selected."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def GravitationalParameter(self) -> float:
        """Get the gravitational parameter for the mass relative to which orbital parameters are computed. Only used if the option to specify gravitational parameter is selected."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravitationalParameter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GravitationalParameter.setter
    def GravitationalParameter(self, gravitationalParameter:float) -> None:
        with agmarshall.DOUBLE_arg(gravitationalParameter) as arg_gravitationalParameter:
            agcls.evaluate_hresult(self.__dict__["_SetGravitationalParameter"](arg_gravitationalParameter.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which orbital parameters are computed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def UseCentralBodyGravitationalParameter(self) -> bool:
        """Get the option that determines whether to specify the gravitational parameter value or to inherit it from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCentralBodyGravitationalParameter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyGravitationalParameter.setter
    def UseCentralBodyGravitationalParameter(self, useCentralBodyGravitationalParameter:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyGravitationalParameter) as arg_useCentralBodyGravitationalParameter:
            agcls.evaluate_hresult(self.__dict__["_SetUseCentralBodyGravitationalParameter"](arg_useCentralBodyGravitationalParameter.COM_val))

    @property
    def UseCentralBodyInertial(self) -> bool:
        """Get the option that determines whether to specify the reference coordinate system or to the inherit inertial reference system from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCentralBodyInertial"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyInertial.setter
    def UseCentralBodyInertial(self, useCentralBodyInertial:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyInertial) as arg_useCentralBodyInertial:
            agcls.evaluate_hresult(self.__dict__["_SetUseCentralBodyInertial"](arg_useCentralBodyInertial.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{141AEAB7-C017-4044-BE2C-EFE4AD724022}", IParameterSetOrbit)
agcls.AgTypeNameMap["IParameterSetOrbit"] = IParameterSetOrbit

class IParameterSetTrajectory(object):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    _uuid = "{0FE9C601-61BB-4579-B91F-B1123A19AFB4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSetTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSetTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSetTrajectory = agcom.GUID(IParameterSetTrajectory._uuid)
        vtable_offset_local = IParameterSetTrajectory._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IParameterSetTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_IParameterSetTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IParameterSetTrajectory, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IParameterSetTrajectory, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSetTrajectory.__dict__ and type(IParameterSetTrajectory.__dict__[attrname]) == property:
            return IParameterSetTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSetTrajectory.")
    
    @property
    def Point(self) -> "IPoint":
        """Get the point for which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def ReferenceSystem(self) -> "ISystem":
        """Get the reference system relative to which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0FE9C601-61BB-4579-B91F-B1123A19AFB4}", IParameterSetTrajectory)
agcls.AgTypeNameMap["IParameterSetTrajectory"] = IParameterSetTrajectory

class IParameterSetVector(object):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    _uuid = "{5B99EEC1-21BD-48B5-96A0-0230894532F1}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_SetVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IParameterSetVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IParameterSetVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IParameterSetVector = agcom.GUID(IParameterSetVector._uuid)
        vtable_offset_local = IParameterSetVector._vtable_offset - 1
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IParameterSetVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVector"] = IAGFUNCTYPE(pUnk, IID_IParameterSetVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IParameterSetVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IParameterSetVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IParameterSetVector.__dict__ and type(IParameterSetVector.__dict__[attrname]) == property:
            return IParameterSetVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IParameterSetVector.")
    
    @property
    def Vector(self) -> "IVector":
        """Get the vector for which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Vector.setter
    def Vector(self, vector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(vector, IVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__["_SetVector"](arg_vector.COM_val))

    @property
    def ReferenceAxes(self) -> "IAxes":
        """Get the reference axes relative to which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5B99EEC1-21BD-48B5-96A0-0230894532F1}", IParameterSetVector)
agcls.AgTypeNameMap["IParameterSetVector"] = IParameterSetVector

class IPruneFilter(object):
    """A filter used with event interval list pruned class to prune interval lists..."""
    _uuid = "{89E95CD7-CDB2-4B17-9E47-DE17F551F873}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilterType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPruneFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPruneFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPruneFilter = agcom.GUID(IPruneFilter._uuid)
        vtable_offset_local = IPruneFilter._vtable_offset - 1
        self.__dict__["_GetFilterType"] = IAGFUNCTYPE(pUnk, IID_IPruneFilter, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPruneFilter.__dict__ and type(IPruneFilter.__dict__[attrname]) == property:
            return IPruneFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPruneFilter.")
    
    @property
    def FilterType(self) -> "AgECrdnPruneFilter":
        """Returns a type of the filter."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{89E95CD7-CDB2-4B17-9E47-DE17F551F873}", IPruneFilter)
agcls.AgTypeNameMap["IPruneFilter"] = IPruneFilter

class IPruneFilterFactory(object):
    """The factory creates pruning filters."""
    _uuid = "{77E7099E-9B41-45FA-B50F-F8DE5964FABD}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPruneFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPruneFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPruneFilterFactory = agcom.GUID(IPruneFilterFactory._uuid)
        vtable_offset_local = IPruneFilterFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IPruneFilterFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPruneFilterFactory.__dict__ and type(IPruneFilterFactory.__dict__[attrname]) == property:
            return IPruneFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPruneFilterFactory.")
    
    def Create(self, eFilter:"AgECrdnPruneFilter") -> "IPruneFilter":
        """Create and initializes a new prune filter using default configuration."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter, eFilter) as arg_eFilter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_eFilter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{77E7099E-9B41-45FA-B50F-F8DE5964FABD}", IPruneFilterFactory)
agcls.AgTypeNameMap["IPruneFilterFactory"] = IPruneFilterFactory

class IRelativeSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    _uuid = "{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRelativeSatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRelativeSatisfactionConditionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRelativeSatisfactionConditionFilter = agcom.GUID(IRelativeSatisfactionConditionFilter._uuid)
        vtable_offset_local = IRelativeSatisfactionConditionFilter._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_IRelativeSatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_IRelativeSatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_IRelativeSatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_IRelativeSatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetRelativeIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_IRelativeSatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_IRelativeSatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRelativeSatisfactionConditionFilter.__dict__ and type(IRelativeSatisfactionConditionFilter.__dict__[attrname]) == property:
            return IRelativeSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRelativeSatisfactionConditionFilter.")
    
    @property
    def Condition(self) -> "ICondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def RelativeIntervalDuration(self) -> float:
        """A percentage of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIntervalDuration.setter
    def RelativeIntervalDuration(self, relativeIntervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIntervalDuration) as arg_relativeIntervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIntervalDuration"](arg_relativeIntervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}", IRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap["IRelativeSatisfactionConditionFilter"] = IRelativeSatisfactionConditionFilter

class ISampling(object):
    """Base sampling interface."""
    _uuid = "{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISampling._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISampling from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISampling = agcom.GUID(ISampling._uuid)
        vtable_offset_local = ISampling._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISampling.__dict__ and type(ISampling.__dict__[attrname]) == property:
            return ISampling.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISampling.")
    

agcls.AgClassCatalog.add_catalog_entry("{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}", ISampling)
agcls.AgTypeNameMap["ISampling"] = ISampling

class ISamplingBasic(object):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    _uuid = "{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSamplingMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSamplingMethod"] = _raise_uninitialized_error
        self.__dict__["_GetMethodFactory"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISamplingBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISamplingBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISamplingBasic = agcom.GUID(ISamplingBasic._uuid)
        vtable_offset_local = ISamplingBasic._vtable_offset - 1
        self.__dict__["_GetSamplingMethod"] = IAGFUNCTYPE(pUnk, IID_ISamplingBasic, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSamplingMethod"] = IAGFUNCTYPE(pUnk, IID_ISamplingBasic, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetMethodFactory"] = IAGFUNCTYPE(pUnk, IID_ISamplingBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISamplingBasic.__dict__ and type(ISamplingBasic.__dict__[attrname]) == property:
            return ISamplingBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISamplingBasic.")
    
    @property
    def SamplingMethod(self) -> "ISamplingMethod":
        """Get the sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSamplingMethod"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SamplingMethod.setter
    def SamplingMethod(self, samplingMethod:"ISamplingMethod") -> None:
        with agmarshall.AgInterface_in_arg(samplingMethod, ISamplingMethod) as arg_samplingMethod:
            agcls.evaluate_hresult(self.__dict__["_SetSamplingMethod"](arg_samplingMethod.COM_val))

    @property
    def MethodFactory(self) -> "ISamplingMethodFactory":
        """Creates sampling definitions, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}", ISamplingBasic)
agcls.AgTypeNameMap["ISamplingBasic"] = ISamplingBasic

class ISamplingCurvatureTolerance(object):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    _uuid = "{618ADA55-9E3D-4CEC-815A-B028995774CB}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_SetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetCurvatureTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetCurvatureTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISamplingCurvatureTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISamplingCurvatureTolerance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISamplingCurvatureTolerance = agcom.GUID(ISamplingCurvatureTolerance._uuid)
        vtable_offset_local = ISamplingCurvatureTolerance._vtable_offset - 1
        self.__dict__["_GetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingCurvatureTolerance, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISamplingCurvatureTolerance.__dict__ and type(ISamplingCurvatureTolerance.__dict__[attrname]) == property:
            return ISamplingCurvatureTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISamplingCurvatureTolerance.")
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumTimeStep"](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumTimeStep"](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepAtBoundaries"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__["_SetStepAtBoundaries"](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))

    @property
    def CurvatureTolerance(self) -> float:
        """Get the curvature tolerance which determines acceptable angular difference between slopes over consecutive steps"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurvatureTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CurvatureTolerance.setter
    def CurvatureTolerance(self, curvatureTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetCurvatureTolerance"](arg_curvatureTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{618ADA55-9E3D-4CEC-815A-B028995774CB}", ISamplingCurvatureTolerance)
agcls.AgTypeNameMap["ISamplingCurvatureTolerance"] = ISamplingCurvatureTolerance

class ISamplingFixedStep(object):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    _uuid = "{68784D1E-776C-4212-B35E-121FFE569627}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISamplingFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISamplingFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISamplingFixedStep = agcom.GUID(ISamplingFixedStep._uuid)
        vtable_offset_local = ISamplingFixedStep._vtable_offset - 1
        self.__dict__["_GetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingFixedStep, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISamplingFixedStep.__dict__ and type(ISamplingFixedStep.__dict__[attrname]) == property:
            return ISamplingFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISamplingFixedStep.")
    
    @property
    def TimeStep(self) -> float:
        """Get the fixed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__["_SetTimeStep"](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{68784D1E-776C-4212-B35E-121FFE569627}", ISamplingFixedStep)
agcls.AgTypeNameMap["ISamplingFixedStep"] = ISamplingFixedStep

class ISamplingMethod(object):
    """A sampling method."""
    _uuid = "{1D14391E-F22F-42FF-B3FA-902F061A6F7B}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISamplingMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISamplingMethod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISamplingMethod = agcom.GUID(ISamplingMethod._uuid)
        vtable_offset_local = ISamplingMethod._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_ISamplingMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISamplingMethod.__dict__ and type(ISamplingMethod.__dict__[attrname]) == property:
            return ISamplingMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISamplingMethod.")
    
    @property
    def MethodType(self) -> "AgECrdnSamplingMethod":
        """A sampling method type."""
        with agmarshall.AgEnum_arg(AgECrdnSamplingMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1D14391E-F22F-42FF-B3FA-902F061A6F7B}", ISamplingMethod)
agcls.AgTypeNameMap["ISamplingMethod"] = ISamplingMethod

class ISamplingMethodFactory(object):
    """The factory creates sampling method components."""
    _uuid = "{C214929B-45FA-4023-9C40-6DCE747C151B}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateFixedStep"] = _raise_uninitialized_error
        self.__dict__["_CreateCurvatureTolerance"] = _raise_uninitialized_error
        self.__dict__["_CreateRelativeTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISamplingMethodFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISamplingMethodFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISamplingMethodFactory = agcom.GUID(ISamplingMethodFactory._uuid)
        vtable_offset_local = ISamplingMethodFactory._vtable_offset - 1
        self.__dict__["_CreateFixedStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingMethodFactory, vtable_offset_local+1, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingMethodFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingMethodFactory, vtable_offset_local+3, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISamplingMethodFactory.__dict__ and type(ISamplingMethodFactory.__dict__[attrname]) == property:
            return ISamplingMethodFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISamplingMethodFactory.")
    
    def CreateFixedStep(self, fixedStep:float) -> "ISamplingMethod":
        """Create a fixed time step sampling definition."""
        with agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedStep"](arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCurvatureTolerance(self, curvatureTolerance:float) -> "ISamplingMethod":
        """Create a curvature tolerance sampling definition. Curvature tolerance uses changes in slope between samples."""
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCurvatureTolerance"](arg_curvatureTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateRelativeTolerance(self, relativeTolerance:float) -> "ISamplingMethod":
        """Create a relative tolerance sampling definition. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples."""
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateRelativeTolerance"](arg_relativeTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C214929B-45FA-4023-9C40-6DCE747C151B}", ISamplingMethodFactory)
agcls.AgTypeNameMap["ISamplingMethodFactory"] = ISamplingMethodFactory

class ISamplingRelativeTolerance(object):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    _uuid = "{32BB5026-A93C-41F7-ADE8-0A04A43627BC}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_SetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISamplingRelativeTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISamplingRelativeTolerance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISamplingRelativeTolerance = agcom.GUID(ISamplingRelativeTolerance._uuid)
        vtable_offset_local = ISamplingRelativeTolerance._vtable_offset - 1
        self.__dict__["_GetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ISamplingRelativeTolerance, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISamplingRelativeTolerance.__dict__ and type(ISamplingRelativeTolerance.__dict__[attrname]) == property:
            return ISamplingRelativeTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISamplingRelativeTolerance.")
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumTimeStep"](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumTimeStep"](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepAtBoundaries"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__["_SetStepAtBoundaries"](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{32BB5026-A93C-41F7-ADE8-0A04A43627BC}", ISamplingRelativeTolerance)
agcls.AgTypeNameMap["ISamplingRelativeTolerance"] = ISamplingRelativeTolerance

class ISatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    _uuid = "{84F129C1-1D47-4FE2-B87B-013BEF12269C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISatisfactionConditionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISatisfactionConditionFilter = agcom.GUID(ISatisfactionConditionFilter._uuid)
        vtable_offset_local = ISatisfactionConditionFilter._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ISatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ISatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ISatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ISatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ISatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ISatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISatisfactionConditionFilter.__dict__ and type(ISatisfactionConditionFilter.__dict__[attrname]) == property:
            return ISatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISatisfactionConditionFilter.")
    
    @property
    def Condition(self) -> "ICondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """A duration of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalDuration"](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{84F129C1-1D47-4FE2-B87B-013BEF12269C}", ISatisfactionConditionFilter)
agcls.AgTypeNameMap["ISatisfactionConditionFilter"] = ISatisfactionConditionFilter

class ISignalDelay(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = "{5ED53953-1C55-431D-88AF-1AF23B2FE424}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISignalDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISignalDelay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISignalDelay = agcom.GUID(ISignalDelay._uuid)
        vtable_offset_local = ISignalDelay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISignalDelay.__dict__ and type(ISignalDelay.__dict__[attrname]) == property:
            return ISignalDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISignalDelay.")
    

agcls.AgClassCatalog.add_catalog_entry("{5ED53953-1C55-431D-88AF-1AF23B2FE424}", ISignalDelay)
agcls.AgTypeNameMap["ISignalDelay"] = ISignalDelay

class ISignalDelayBasic(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = "{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSignalPathReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetSignalPathReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetSpeedOption"] = _raise_uninitialized_error
        self.__dict__["_SetSpeedOption"] = _raise_uninitialized_error
        self.__dict__["_GetTransferSpeed"] = _raise_uninitialized_error
        self.__dict__["_SetTransferSpeed"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISignalDelayBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISignalDelayBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISignalDelayBasic = agcom.GUID(ISignalDelayBasic._uuid)
        vtable_offset_local = ISignalDelayBasic._vtable_offset - 1
        self.__dict__["_GetSignalPathReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSignalPathReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSpeedOption"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSpeedOption"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetTransferSpeed"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTransferSpeed"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ISignalDelayBasic, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISignalDelayBasic.__dict__ and type(ISignalDelayBasic.__dict__[attrname]) == property:
            return ISignalDelayBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISignalDelayBasic.")
    
    @property
    def SignalPathReferenceSystem(self) -> "AgECrdnSignalPathReferenceSystem":
        """Get the type of signal path reference system which can be set to use STK Access default (see STK Help for further details), Solar system barycenter inertial reference, central body inertial reference or custom reference system..."""
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalPathReferenceSystem"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalPathReferenceSystem.setter
    def SignalPathReferenceSystem(self, signalPathReferenceSystem:"AgECrdnSignalPathReferenceSystem") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem, signalPathReferenceSystem) as arg_signalPathReferenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetSignalPathReferenceSystem"](arg_signalPathReferenceSystem.COM_val))

    @property
    def ReferenceSystem(self) -> "ISystem":
        """Get the custom reference system which is used as a reference for signal path if the signal path reference option is set to Custom."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def SpeedOption(self) -> "AgECrdnSpeedOptions":
        """Get the speed option which determines whether to use the speed of light or a custom speed value."""
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeedOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedOption.setter
    def SpeedOption(self, speedOption:"AgECrdnSpeedOptions") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions, speedOption) as arg_speedOption:
            agcls.evaluate_hresult(self.__dict__["_SetSpeedOption"](arg_speedOption.COM_val))

    @property
    def TransferSpeed(self) -> float:
        """Get the signal propagation speed value which is used if the speed option is set to Custom."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTransferSpeed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TransferSpeed.setter
    def TransferSpeed(self, transferSpeed:float) -> None:
        with agmarshall.DOUBLE_arg(transferSpeed) as arg_transferSpeed:
            agcls.evaluate_hresult(self.__dict__["_SetTransferSpeed"](arg_transferSpeed.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Get the time delay convergence which determines the accuracy of computed propagation time between the two locations."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergence"](arg_timeDelayConvergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}", ISignalDelayBasic)
agcls.AgTypeNameMap["ISignalDelayBasic"] = ISignalDelayBasic

class IVolumeCalcFactory(object):
    """The factory is used to create instances of volume calcs."""
    _uuid = "{42eb6d4a-5cff-471f-997d-3f624cb4a416}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcAltitude"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcAngleOffVector"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcFile"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcFromScalar"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcSolarIntensity"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcRange"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcDelayRange"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcFactory = agcom.GUID(IVolumeCalcFactory._uuid)
        vtable_offset_local = IVolumeCalcFactory._vtable_offset - 1
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcAltitude"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcAngleOffVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcFile"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcFromScalar"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcSolarIntensity"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcRange"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcDelayRange"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcFactory.__dict__ and type(IVolumeCalcFactory.__dict__[attrname]) == property:
            return IVolumeCalcFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcFactory.")
    
    def IsTypeSupported(self, eType:"AgECrdnVolumeCalcType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnVolumeCalcType") -> "IVolumeCalc":
        """Creates and registers a volume calc using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAltitude(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a altitude to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcAltitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAngleOffVector(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a angle to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcAngleOffVector"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFile(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a file volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcFile"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFromScalar(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a scalar to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcFromScalar"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcSolarIntensity(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a solar intensity volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcSolarIntensity"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcVolumeSatisfactionMetric(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a spatial condition satisfaction metric volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcRange(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcRange"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcDelayRange(self, name:str, description:str) -> "IVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcDelayRange"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{42eb6d4a-5cff-471f-997d-3f624cb4a416}", IVolumeCalcFactory)
agcls.AgTypeNameMap["IVolumeCalcFactory"] = IVolumeCalcFactory

class IVolumeFactory(object):
    """The factory is used to create instances of volumes."""
    _uuid = "{FE97990E-A152-417C-883E-64C42AB9B913}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCombined"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeLighting"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeOverTime"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromGrid"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromCalc"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromTimeSatisfaction"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromCondition"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeInview"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeFactory = agcom.GUID(IVolumeFactory._uuid)
        vtable_offset_local = IVolumeFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateVolumeCombined"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeLighting"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeOverTime"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromGrid"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromCalc"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeInview"] = IAGFUNCTYPE(pUnk, IID_IVolumeFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeFactory.__dict__ and type(IVolumeFactory.__dict__[attrname]) == property:
            return IVolumeFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeType") -> "IVolume":
        """Creates and registers a volume using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeCombined(self, name:str, description:str) -> "IVolume":
        """Creates a volume type combined."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCombined"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeLighting(self, name:str, description:str) -> "IVolume":
        """Creates a volume type lighting."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeLighting"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeOverTime(self, name:str, description:str) -> "IVolume":
        """Creates a volume type over time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeOverTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromGrid(self, name:str, description:str) -> "IVolume":
        """Creates a volume type from grid."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromGrid"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCalc(self, name:str, description:str) -> "IVolume":
        """Creates a volume type from calc."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromCalc"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromTimeSatisfaction(self, name:str, description:str) -> "IVolume":
        """Creates a volume type from time satisfaction."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromTimeSatisfaction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCondition(self, name:str, description:str) -> "IVolume":
        """Creates a volume type condition."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromCondition"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeInview(self, name:str, description:str) -> "IVolume":
        """Creates a volume type Inview."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeInview"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FE97990E-A152-417C-883E-64C42AB9B913}", IVolumeFactory)
agcls.AgTypeNameMap["IVolumeFactory"] = IVolumeFactory

class IVolumeGridFactory(object):
    """The factory is used to create instances of volume grids."""
    _uuid = "{4533DEA1-D754-4579-A79D-B5A639C2CD39}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridCartesian"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridCylindrical"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridSpherical"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridConstrained"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridLatLonAlt"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridBearingAlt"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridFactory = agcom.GUID(IVolumeGridFactory._uuid)
        vtable_offset_local = IVolumeGridFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridCartesian"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateVolumeGridCylindrical"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridSpherical"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridConstrained"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridLatLonAlt"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridBearingAlt"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridFactory.__dict__ and type(IVolumeGridFactory.__dict__[attrname]) == property:
            return IVolumeGridFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeGridType") -> "IVolumeGrid":
        """Creates and registers a volume grid using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeGridType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridCartesian(self, name:str, description:str) -> "IVolumeGrid":
        """Creates and registers a cartesian volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridCartesian"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeGridType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeGridType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeGridCylindrical(self, name:str, description:str) -> "IVolumeGrid":
        """Creates and registers a cylindrical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridCylindrical"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridSpherical(self, name:str, description:str) -> "IVolumeGrid":
        """Creates and registers a spherical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridSpherical"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridConstrained(self, name:str, description:str) -> "IVolumeGrid":
        """Creates and registers a volume grid of type that can be constrained by conditions using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridConstrained"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridLatLonAlt(self, name:str, description:str) -> "IVolumeGrid":
        """Creates and registers cartographic volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridLatLonAlt"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridBearingAlt(self, name:str, description:str) -> "IVolumeGrid":
        """Creates and registers a volume grid of type surface bearing using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridBearingAlt"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4533DEA1-D754-4579-A79D-B5A639C2CD39}", IVolumeGridFactory)
agcls.AgTypeNameMap["IVolumeGridFactory"] = IVolumeGridFactory

class IGridCoordinateDefinition(object):
    """Defines a set of coordinate values."""
    _uuid = "{96875D1C-9CBC-4732-A678-2CB17995C0E9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        self.__dict__["_GetGridValuesMethod"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesCustom"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedNumberOfStepsEx"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridCoordinateDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridCoordinateDefinition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridCoordinateDefinition = agcom.GUID(IGridCoordinateDefinition._uuid)
        vtable_offset_local = IGridCoordinateDefinition._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_IGridCoordinateDefinition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetGridValuesMethod"] = IAGFUNCTYPE(pUnk, IID_IGridCoordinateDefinition, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedStep"] = IAGFUNCTYPE(pUnk, IID_IGridCoordinateDefinition, vtable_offset_local+3, agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT_BOOL, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_IGridCoordinateDefinition, vtable_offset_local+4, agcom.DOUBLE, agcom.DOUBLE, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesCustom"] = IAGFUNCTYPE(pUnk, IID_IGridCoordinateDefinition, vtable_offset_local+5, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedNumberOfStepsEx"] = IAGFUNCTYPE(pUnk, IID_IGridCoordinateDefinition, vtable_offset_local+6, agcom.PVOID, agcom.PVOID, agcom.INT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridCoordinateDefinition.__dict__ and type(IGridCoordinateDefinition.__dict__[attrname]) == property:
            return IGridCoordinateDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridCoordinateDefinition.")
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def GridValuesMethod(self) -> "IGridValuesMethod":
        """Sets/Returns the grid values interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGridValuesMethod"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedStep(self, min:float, max:float, includeMinMax:bool, refValue:float, fixedStep:float) -> "IGridValuesFixedStep":
        """Sets grid values type to fixed step."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax, \
             agmarshall.DOUBLE_arg(refValue) as arg_refValue, \
             agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedStep"](arg_min.COM_val, arg_max.COM_val, arg_includeMinMax.COM_val, arg_refValue.COM_val, arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfSteps(self, min:float, max:float, numSteps:int) -> "IGridValuesFixedNumberOfSteps":
        """This method is deprecated. Use SetGridValuesFixedNumberOfStepsEx."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedNumberOfSteps"](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesCustom(self, values:list) -> "IGridValuesCustom":
        """Sets grid values type to custom values."""
        with agmarshall.SAFEARRAY_arg(values) as arg_values, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesCustom"](byref(arg_values.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfStepsEx(self, min:"IQuantity", max:"IQuantity", numSteps:int) -> "IGridValuesFixedNumberOfSteps":
        """Sets grid values type to fixed number of steps with min and max as IAgQuantity"""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedNumberOfStepsEx"](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{96875D1C-9CBC-4732-A678-2CB17995C0E9}", IGridCoordinateDefinition)
agcls.AgTypeNameMap["IGridCoordinateDefinition"] = IGridCoordinateDefinition

class IGridValuesCustom(object):
    """Fixed step grid values."""
    _uuid = "{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        self.__dict__["_SetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridValuesCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridValuesCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridValuesCustom = agcom.GUID(IGridValuesCustom._uuid)
        vtable_offset_local = IGridValuesCustom._vtable_offset - 1
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_IGridValuesCustom, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetValues"] = IAGFUNCTYPE(pUnk, IID_IGridValuesCustom, vtable_offset_local+2, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridValuesCustom.__dict__ and type(IGridValuesCustom.__dict__[attrname]) == property:
            return IGridValuesCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridValuesCustom.")
    
    @property
    def Values(self) -> list:
        """Custom set of coordinate values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Values.setter
    def Values(self, values:list) -> None:
        with agmarshall.SAFEARRAY_arg(values) as arg_values:
            agcls.evaluate_hresult(self.__dict__["_SetValues"](arg_values.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}", IGridValuesCustom)
agcls.AgTypeNameMap["IGridValuesCustom"] = IGridValuesCustom

class IGridValuesFixedNumberOfSteps(object):
    """Fixed step grid values."""
    _uuid = "{379ACEFA-1B1E-4753-BA9A-87939E5B8893}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMin"] = _raise_uninitialized_error
        self.__dict__["_SetMin"] = _raise_uninitialized_error
        self.__dict__["_GetMax"] = _raise_uninitialized_error
        self.__dict__["_SetMax"] = _raise_uninitialized_error
        self.__dict__["_GetNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_SetNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_GetMinEx"] = _raise_uninitialized_error
        self.__dict__["_SetMinEx"] = _raise_uninitialized_error
        self.__dict__["_GetMaxEx"] = _raise_uninitialized_error
        self.__dict__["_SetMaxEx"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridValuesFixedNumberOfSteps._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridValuesFixedNumberOfSteps from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridValuesFixedNumberOfSteps = agcom.GUID(IGridValuesFixedNumberOfSteps._uuid)
        vtable_offset_local = IGridValuesFixedNumberOfSteps._vtable_offset - 1
        self.__dict__["_GetMin"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMin"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMax"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMax"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+6, agcom.INT)
        self.__dict__["_GetMinEx"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMinEx"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetMaxEx"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetMaxEx"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedNumberOfSteps, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridValuesFixedNumberOfSteps.__dict__ and type(IGridValuesFixedNumberOfSteps.__dict__[attrname]) == property:
            return IGridValuesFixedNumberOfSteps.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridValuesFixedNumberOfSteps.")
    
    @property
    def Min(self) -> float:
        """This property is deprecated. Use MinEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__["_SetMin"](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """This property is deprecated. Use MaxEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetMax"](arg_max.COM_val))

    @property
    def NumberOfSteps(self) -> int:
        """The number of steps between coordinate values."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNumberOfSteps"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NumberOfSteps.setter
    def NumberOfSteps(self, numberOfSteps:int) -> None:
        with agmarshall.INT_arg(numberOfSteps) as arg_numberOfSteps:
            agcls.evaluate_hresult(self.__dict__["_SetNumberOfSteps"](arg_numberOfSteps.COM_val))

    @property
    def MinEx(self) -> "IQuantity":
        """Minimum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinEx"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MinEx.setter
    def MinEx(self, minEx:"IQuantity") -> None:
        with agmarshall.AgInterface_in_arg(minEx, IQuantity) as arg_minEx:
            agcls.evaluate_hresult(self.__dict__["_SetMinEx"](arg_minEx.COM_val))

    @property
    def MaxEx(self) -> "IQuantity":
        """Maximum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxEx"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MaxEx.setter
    def MaxEx(self, maxEx:"IQuantity") -> None:
        with agmarshall.AgInterface_in_arg(maxEx, IQuantity) as arg_maxEx:
            agcls.evaluate_hresult(self.__dict__["_SetMaxEx"](arg_maxEx.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{379ACEFA-1B1E-4753-BA9A-87939E5B8893}", IGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap["IGridValuesFixedNumberOfSteps"] = IGridValuesFixedNumberOfSteps

class IGridValuesFixedStep(object):
    """Fixed step grid values."""
    _uuid = "{7C18BF81-7E22-4A28-B462-37ED86EC3050}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMin"] = _raise_uninitialized_error
        self.__dict__["_SetMin"] = _raise_uninitialized_error
        self.__dict__["_GetMax"] = _raise_uninitialized_error
        self.__dict__["_SetMax"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeMinMax"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeMinMax"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceValue"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceValue"] = _raise_uninitialized_error
        self.__dict__["_GetStep"] = _raise_uninitialized_error
        self.__dict__["_SetStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridValuesFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridValuesFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridValuesFixedStep = agcom.GUID(IGridValuesFixedStep._uuid)
        vtable_offset_local = IGridValuesFixedStep._vtable_offset - 1
        self.__dict__["_GetMin"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMin"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMax"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMax"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIncludeMinMax"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeMinMax"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceValue"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetReferenceValue"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStep"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStep"] = IAGFUNCTYPE(pUnk, IID_IGridValuesFixedStep, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridValuesFixedStep.__dict__ and type(IGridValuesFixedStep.__dict__[attrname]) == property:
            return IGridValuesFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridValuesFixedStep.")
    
    @property
    def Min(self) -> float:
        """Minimum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__["_SetMin"](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """Maximum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetMax"](arg_max.COM_val))

    @property
    def IncludeMinMax(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeMinMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeMinMax.setter
    def IncludeMinMax(self, includeMinMax:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeMinMax"](arg_includeMinMax.COM_val))

    @property
    def ReferenceValue(self) -> float:
        """Reference coordinate value from which steps are taken."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceValue.setter
    def ReferenceValue(self, referenceValue:float) -> None:
        with agmarshall.DOUBLE_arg(referenceValue) as arg_referenceValue:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceValue"](arg_referenceValue.COM_val))

    @property
    def Step(self) -> float:
        """Step between subsequent coordinate values."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__["_SetStep"](arg_step.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7C18BF81-7E22-4A28-B462-37ED86EC3050}", IGridValuesFixedStep)
agcls.AgTypeNameMap["IGridValuesFixedStep"] = IGridValuesFixedStep

class IGridValuesMethod(object):
    """A grid values method."""
    _uuid = "{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridValuesMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridValuesMethod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridValuesMethod = agcom.GUID(IGridValuesMethod._uuid)
        vtable_offset_local = IGridValuesMethod._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_IGridValuesMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridValuesMethod.__dict__ and type(IGridValuesMethod.__dict__[attrname]) == property:
            return IGridValuesMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridValuesMethod.")
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}", IGridValuesMethod)
agcls.AgTypeNameMap["IGridValuesMethod"] = IGridValuesMethod

class ILightTimeDelay(object):
    """Manage Light Time Delay options.."""
    _uuid = "{82765B62-B9AB-4D52-900E-52ADAC0365D0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_SetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_GetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_SetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_GetClockHost"] = _raise_uninitialized_error
        self.__dict__["_SetClockHost"] = _raise_uninitialized_error
        self.__dict__["_GetTimeSense"] = _raise_uninitialized_error
        self.__dict__["_SetTimeSense"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILightTimeDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILightTimeDelay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILightTimeDelay = agcom.GUID(ILightTimeDelay._uuid)
        vtable_offset_local = ILightTimeDelay._vtable_offset - 1
        self.__dict__["_GetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAberrationType"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetAberrationType"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetClockHost"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetClockHost"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetTimeSense"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetTimeSense"] = IAGFUNCTYPE(pUnk, IID_ILightTimeDelay, vtable_offset_local+10, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILightTimeDelay.__dict__ and type(ILightTimeDelay.__dict__[attrname]) == property:
            return ILightTimeDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILightTimeDelay.")
    
    @property
    def UseLightTimeDelay(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseLightTimeDelay"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseLightTimeDelay.setter
    def UseLightTimeDelay(self, useLightTimeDelay:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useLightTimeDelay) as arg_useLightTimeDelay:
            agcls.evaluate_hresult(self.__dict__["_SetUseLightTimeDelay"](arg_useLightTimeDelay.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Set light Time Delay Convergence."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergence"](arg_timeDelayConvergence.COM_val))

    @property
    def AberrationType(self) -> "AgECrdnVolumeAberrationType":
        """Method used to Aberration Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAberrationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AberrationType.setter
    def AberrationType(self, aberrationType:"AgECrdnVolumeAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType, aberrationType) as arg_aberrationType:
            agcls.evaluate_hresult(self.__dict__["_SetAberrationType"](arg_aberrationType.COM_val))

    @property
    def ClockHost(self) -> "AgECrdnVolumeClockHostType":
        """Indicates whether object1 or object2 of an Access instance holds the clock for Access times."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockHost"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockHost.setter
    def ClockHost(self, clockHost:"AgECrdnVolumeClockHostType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType, clockHost) as arg_clockHost:
            agcls.evaluate_hresult(self.__dict__["_SetClockHost"](arg_clockHost.COM_val))

    @property
    def TimeSense(self) -> "AgECrdnVolumeTimeSenseType":
        """Indicates whether apparent position is computed in a transmit or receive sense"""
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeSense.setter
    def TimeSense(self, timeSense:"AgECrdnVolumeTimeSenseType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType, timeSense) as arg_timeSense:
            agcls.evaluate_hresult(self.__dict__["_SetTimeSense"](arg_timeSense.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{82765B62-B9AB-4D52-900E-52ADAC0365D0}", ILightTimeDelay)
agcls.AgTypeNameMap["ILightTimeDelay"] = ILightTimeDelay

class IVolume(object):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    _uuid = "{F85958EC-F470-432F-81B1-8517D3952F1E}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolume from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolume = agcom.GUID(IVolume._uuid)
        vtable_offset_local = IVolume._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolume.__dict__ and type(IVolume.__dict__[attrname]) == property:
            return IVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolume.")
    

agcls.AgClassCatalog.add_catalog_entry("{F85958EC-F470-432F-81B1-8517D3952F1E}", IVolume)
agcls.AgTypeNameMap["IVolume"] = IVolume

class IVolumeCalc(object):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    _uuid = "{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalc = agcom.GUID(IVolumeCalc._uuid)
        vtable_offset_local = IVolumeCalc._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalc.__dict__ and type(IVolumeCalc.__dict__[attrname]) == property:
            return IVolumeCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalc.")
    

agcls.AgClassCatalog.add_catalog_entry("{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}", IVolumeCalc)
agcls.AgTypeNameMap["IVolumeCalc"] = IVolumeCalc

class IVolumeCalcAltitude(object):
    """A volume calc altitude interface."""
    _uuid = "{6039868a-acea-4918-966b-c6f952fd94d3}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetShapeModel"] = _raise_uninitialized_error
        self.__dict__["_SetShapeModel"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomReference"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomReference"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcAltitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcAltitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcAltitude = agcom.GUID(IVolumeCalcAltitude._uuid)
        vtable_offset_local = IVolumeCalcAltitude._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetShapeModel"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShapeModel"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetUseCustomReference"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomReference"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAltitude, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcAltitude.__dict__ and type(IVolumeCalcAltitude.__dict__[attrname]) == property:
            return IVolumeCalcAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcAltitude.")
    
    @property
    def CentralBody(self) -> str:
        """Get the central body for the volume calc. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume calc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ShapeModel(self) -> "AgECrdnVolumeCalcAltitudeReferenceType":
        """The Volume Calc Altitude Reference Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetShapeModel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ShapeModel.setter
    def ShapeModel(self, shapeModel:"AgECrdnVolumeCalcAltitudeReferenceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType, shapeModel) as arg_shapeModel:
            agcls.evaluate_hresult(self.__dict__["_SetShapeModel"](arg_shapeModel.COM_val))

    @property
    def UseCustomReference(self) -> bool:
        """Whether to use custom reference."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomReference"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomReference.setter
    def UseCustomReference(self, useCustomReference:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomReference) as arg_useCustomReference:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomReference"](arg_useCustomReference.COM_val))

    @property
    def ReferencePoint(self) -> "IPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6039868a-acea-4918-966b-c6f952fd94d3}", IVolumeCalcAltitude)
agcls.AgTypeNameMap["IVolumeCalcAltitude"] = IVolumeCalcAltitude

class IVolumeCalcAngleOffVector(object):
    """A volume calc angle off vector interface."""
    _uuid = "{ad6880b4-afc1-47ba-b964-f38916955c7b}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_SetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAboutVector"] = _raise_uninitialized_error
        self.__dict__["_SetAboutVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcAngleOffVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcAngleOffVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcAngleOffVector = agcom.GUID(IVolumeCalcAngleOffVector._uuid)
        vtable_offset_local = IVolumeCalcAngleOffVector._vtable_offset - 1
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAngle"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetAboutVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetAboutVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcAngleOffVector, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcAngleOffVector.__dict__ and type(IVolumeCalcAngleOffVector.__dict__[attrname]) == property:
            return IVolumeCalcAngleOffVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcAngleOffVector.")
    
    @property
    def Angle(self) -> "AgECrdnVolumeCalcAngleOffVectorType":
        """The Volume Calc Angle Off Vector Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Angle.setter
    def Angle(self, angle:"AgECrdnVolumeCalcAngleOffVectorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType, angle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_SetAngle"](arg_angle.COM_val))

    @property
    def ReferencePlane(self) -> "IPlane":
        """The Volume Calc Angle Off Vector reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def ReferencePoint(self) -> "IPoint":
        """The Volume Calc Angle Off Vector reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferenceVector(self) -> "IVector":
        """The Volume Calc Angle Off Vector reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVector.setter
    def ReferenceVector(self, referenceVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(referenceVector, IVector) as arg_referenceVector:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceVector"](arg_referenceVector.COM_val))

    @property
    def AboutVector(self) -> "IVector":
        """The Volume Calc Angle Off Vector reference about vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAboutVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AboutVector.setter
    def AboutVector(self, aboutVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(aboutVector, IVector) as arg_aboutVector:
            agcls.evaluate_hresult(self.__dict__["_SetAboutVector"](arg_aboutVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ad6880b4-afc1-47ba-b964-f38916955c7b}", IVolumeCalcAngleOffVector)
agcls.AgTypeNameMap["IVolumeCalcAngleOffVector"] = IVolumeCalcAngleOffVector

class IVolumeCalcConditionSatMetric(object):
    """A volume calc condition satisfaction interface."""
    _uuid = "{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpatialCondition"] = _raise_uninitialized_error
        self.__dict__["_SetSpatialCondition"] = _raise_uninitialized_error
        self.__dict__["_GetSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_SetSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_GetAccumulationType"] = _raise_uninitialized_error
        self.__dict__["_SetAccumulationType"] = _raise_uninitialized_error
        self.__dict__["_GetDurationType"] = _raise_uninitialized_error
        self.__dict__["_SetDurationType"] = _raise_uninitialized_error
        self.__dict__["_GetFilter"] = _raise_uninitialized_error
        self.__dict__["_SetFilter"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinimumDuration"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinimumDuration"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaximumDuration"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaximumDuration"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumDurationTime"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcConditionSatMetric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcConditionSatMetric from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcConditionSatMetric = agcom.GUID(IVolumeCalcConditionSatMetric._uuid)
        vtable_offset_local = IVolumeCalcConditionSatMetric._vtable_offset - 1
        self.__dict__["_GetSpatialCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSpatialCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetAccumulationType"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetAccumulationType"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDurationType"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetDurationType"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetFilter"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetFilter"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+11, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+12, agcom.INT)
        self.__dict__["_GetUseMinimumDuration"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinimumDuration"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaximumDuration"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaximumDuration"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinimumDurationTime"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumDurationTime"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetMaximumDurationTime"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumDurationTime"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcConditionSatMetric, vtable_offset_local+20, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcConditionSatMetric.__dict__ and type(IVolumeCalcConditionSatMetric.__dict__[attrname]) == property:
            return IVolumeCalcConditionSatMetric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcConditionSatMetric.")
    
    @property
    def SpatialCondition(self) -> "IVolume":
        """A spatial condition for satisfaction metric."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpatialCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SpatialCondition.setter
    def SpatialCondition(self, spatialCondition:"IVolume") -> None:
        with agmarshall.AgInterface_in_arg(spatialCondition, IVolume) as arg_spatialCondition:
            agcls.evaluate_hresult(self.__dict__["_SetSpatialCondition"](arg_spatialCondition.COM_val))

    @property
    def SatisfactionMetric(self) -> "AgECrdnVolumeCalcVolumeSatisfactionMetricType":
        """Spatial condition satisfaction metric types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSatisfactionMetric"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionMetric.setter
    def SatisfactionMetric(self, satisfactionMetric:"AgECrdnVolumeCalcVolumeSatisfactionMetricType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType, satisfactionMetric) as arg_satisfactionMetric:
            agcls.evaluate_hresult(self.__dict__["_SetSatisfactionMetric"](arg_satisfactionMetric.COM_val))

    @property
    def AccumulationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType":
        """Spatial condition satisfaction accumulation types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAccumulationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AccumulationType.setter
    def AccumulationType(self, accumulationType:"AgECrdnVolumeCalcVolumeSatisfactionAccumulationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType, accumulationType) as arg_accumulationType:
            agcls.evaluate_hresult(self.__dict__["_SetAccumulationType"](arg_accumulationType.COM_val))

    @property
    def DurationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionDurationType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeCalcVolumeSatisfactionDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__["_SetDurationType"](arg_durationType.COM_val))

    @property
    def Filter(self) -> "AgECrdnVolumeCalcVolumeSatisfactionFilterType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"AgECrdnVolumeCalcVolumeSatisfactionFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType, filter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_SetFilter"](arg_filter.COM_val))

    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Spatial condition satisfaction Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))

    @property
    def UseMinimumDuration(self) -> bool:
        """Spatial condition satisfaction enable minimum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinimumDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumDuration.setter
    def UseMinimumDuration(self, useMinimumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumDuration) as arg_useMinimumDuration:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinimumDuration"](arg_useMinimumDuration.COM_val))

    @property
    def UseMaximumDuration(self) -> bool:
        """Spatial condition satisfaction enable maximum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaximumDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumDuration.setter
    def UseMaximumDuration(self, useMaximumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumDuration) as arg_useMaximumDuration:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaximumDuration"](arg_useMaximumDuration.COM_val))

    @property
    def MinimumDurationTime(self) -> float:
        """Spatial condition satisfaction minimum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumDurationTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumDurationTime.setter
    def MinimumDurationTime(self, minimumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDurationTime) as arg_minimumDurationTime:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumDurationTime"](arg_minimumDurationTime.COM_val))

    @property
    def MaximumDurationTime(self) -> float:
        """Spatial condition satisfaction maximum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumDurationTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumDurationTime.setter
    def MaximumDurationTime(self, maximumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDurationTime) as arg_maximumDurationTime:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumDurationTime"](arg_maximumDurationTime.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}", IVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap["IVolumeCalcConditionSatMetric"] = IVolumeCalcConditionSatMetric

class IVolumeCalcDelayRange(object):
    """A volume calc propagation delay to location interface."""
    _uuid = "{874bf6c9-20d7-486c-918a-a0094093879a}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_GetSpeedType"] = _raise_uninitialized_error
        self.__dict__["_SetSpeedType"] = _raise_uninitialized_error
        self.__dict__["_GetSpeed"] = _raise_uninitialized_error
        self.__dict__["_SetSpeed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcDelayRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcDelayRange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcDelayRange = agcom.GUID(IVolumeCalcDelayRange._uuid)
        vtable_offset_local = IVolumeCalcDelayRange._vtable_offset - 1
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSpeedType"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSpeedType"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSpeed"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSpeed"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcDelayRange, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcDelayRange.__dict__ and type(IVolumeCalcDelayRange.__dict__[attrname]) == property:
            return IVolumeCalcDelayRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcDelayRange.")
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "IPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "IPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "IVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))

    @property
    def SpeedType(self) -> "AgECrdnVolumeCalcRangeSpeedType":
        """The Volume Calc range speed types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeedType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedType.setter
    def SpeedType(self, speedType:"AgECrdnVolumeCalcRangeSpeedType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType, speedType) as arg_speedType:
            agcls.evaluate_hresult(self.__dict__["_SetSpeedType"](arg_speedType.COM_val))

    @property
    def Speed(self) -> float:
        """The Volume Calc range speed value"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Speed.setter
    def Speed(self, speed:float) -> None:
        with agmarshall.DOUBLE_arg(speed) as arg_speed:
            agcls.evaluate_hresult(self.__dict__["_SetSpeed"](arg_speed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{874bf6c9-20d7-486c-918a-a0094093879a}", IVolumeCalcDelayRange)
agcls.AgTypeNameMap["IVolumeCalcDelayRange"] = IVolumeCalcDelayRange

class IVolumeCalcFile(object):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    _uuid = "{362b7405-edf6-486c-8fcf-1f9a93b75000}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcFile = agcom.GUID(IVolumeCalcFile._uuid)
        vtable_offset_local = IVolumeCalcFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFile, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcFile.__dict__ and type(IVolumeCalcFile.__dict__[attrname]) == property:
            return IVolumeCalcFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcFile.")
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the volume calc data."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the volume calc file."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())


agcls.AgClassCatalog.add_catalog_entry("{362b7405-edf6-486c-8fcf-1f9a93b75000}", IVolumeCalcFile)
agcls.AgTypeNameMap["IVolumeCalcFile"] = IVolumeCalcFile

class IVolumeCalcFromScalar(object):
    """A volume calc scalar to location interface."""
    _uuid = "{6e537b27-ee55-44c5-89b2-f2c504a44bb6}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcFromScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcFromScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcFromScalar = agcom.GUID(IVolumeCalcFromScalar._uuid)
        vtable_offset_local = IVolumeCalcFromScalar._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFromScalar, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcFromScalar, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcFromScalar.__dict__ and type(IVolumeCalcFromScalar.__dict__[attrname]) == property:
            return IVolumeCalcFromScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcFromScalar.")
    
    @property
    def Scalar(self) -> "ICalcScalar":
        """The Volume calc scalar to location Type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6e537b27-ee55-44c5-89b2-f2c504a44bb6}", IVolumeCalcFromScalar)
agcls.AgTypeNameMap["IVolumeCalcFromScalar"] = IVolumeCalcFromScalar

class IVolumeCalcRange(object):
    """A volume calc distance to location interface."""
    _uuid = "{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcRange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcRange = agcom.GUID(IVolumeCalcRange._uuid)
        vtable_offset_local = IVolumeCalcRange._vtable_offset - 1
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcRange, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcRange.__dict__ and type(IVolumeCalcRange.__dict__[attrname]) == property:
            return IVolumeCalcRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcRange.")
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "IPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "IPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "IVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}", IVolumeCalcRange)
agcls.AgTypeNameMap["IVolumeCalcRange"] = IVolumeCalcRange

class IVolumeCalcSolarIntensity(object):
    """A volume calc solar intensityn interface."""
    _uuid = "{40e35f2b-9a83-449a-9a4e-35bdee832061}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCalcSolarIntensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCalcSolarIntensity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCalcSolarIntensity = agcom.GUID(IVolumeCalcSolarIntensity._uuid)
        vtable_offset_local = IVolumeCalcSolarIntensity._vtable_offset - 1
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcSolarIntensity, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcSolarIntensity, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcSolarIntensity, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeCalcSolarIntensity, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCalcSolarIntensity.__dict__ and type(IVolumeCalcSolarIntensity.__dict__[attrname]) == property:
            return IVolumeCalcSolarIntensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCalcSolarIntensity.")
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{40e35f2b-9a83-449a-9a4e-35bdee832061}", IVolumeCalcSolarIntensity)
agcls.AgTypeNameMap["IVolumeCalcSolarIntensity"] = IVolumeCalcSolarIntensity

class IVolumeCombined(object):
    """A combined volume interface."""
    _uuid = "{96684FB4-3839-44DB-AD80-B772BF58A39A}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_SetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_GetConditionCount"] = _raise_uninitialized_error
        self.__dict__["_GetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_RemoveCondition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeCombined from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeCombined = agcom.GUID(IVolumeCombined._uuid)
        vtable_offset_local = IVolumeCombined._vtable_offset - 1
        self.__dict__["_GetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetConditionCount"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetAllConditions"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetAllConditions"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+6, agcom.PVOID, agcom.INT)
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_RemoveCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeCombined, vtable_offset_local+8, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeCombined.__dict__ and type(IVolumeCombined.__dict__[attrname]) == property:
            return IVolumeCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeCombined.")
    
    @property
    def CombineOperation(self) -> "AgECrdnVolumeCombinedOperationType":
        """Sets/Returns volume combined operation."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCombineOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnVolumeCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__["_SetCombineOperation"](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Returns the spatial condition vector size."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all spatial conditions."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all spatial conditions."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__["_SetAllConditions"](byref(arg_conditions.COM_val)))

    def SetCondition(self, ref:"IVolume", pos:int) -> None:
        """Set spatial conditions at a position."""
        with agmarshall.AgInterface_in_arg(ref, IVolume) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_ref.COM_val, arg_pos.COM_val))

    def GetCondition(self, pos:int) -> "IVolume":
        """Get spatial conditions at a position."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def RemoveCondition(self, pos:int) -> None:
        """Remove spatial conditions at a position."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveCondition"](arg_pos.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{96684FB4-3839-44DB-AD80-B772BF58A39A}", IVolumeCombined)
agcls.AgTypeNameMap["IVolumeCombined"] = IVolumeCombined

class IVolumeFromCalc(object):
    """An volume from calc volume interface."""
    _uuid = "{018666E1-C0E6-46F6-A682-F91FBF3C74F3}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOperation"] = _raise_uninitialized_error
        self.__dict__["_SetOperation"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeCalc"] = _raise_uninitialized_error
        self.__dict__["_SetVolumeCalc"] = _raise_uninitialized_error
        self.__dict__["_GetMinimum"] = _raise_uninitialized_error
        self.__dict__["_SetMinimum"] = _raise_uninitialized_error
        self.__dict__["_GetMaximum"] = _raise_uninitialized_error
        self.__dict__["_SetMaximum"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeFromCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeFromCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeFromCalc = agcom.GUID(IVolumeFromCalc._uuid)
        vtable_offset_local = IVolumeFromCalc._vtable_offset - 1
        self.__dict__["_GetOperation"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetOperation"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetVolumeCalc"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetVolumeCalc"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetMinimum"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetMinimum"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetMaximum"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMaximum"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCalc, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeFromCalc.__dict__ and type(IVolumeFromCalc.__dict__[attrname]) == property:
            return IVolumeFromCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeFromCalc.")
    
    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__["_SetOperation"](arg_operation.COM_val))

    @property
    def VolumeCalc(self) -> "IVolumeCalc":
        """Get the volume calc from the bounds."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeCalc"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeCalc.setter
    def VolumeCalc(self, volumeCalc:"IVolumeCalc") -> None:
        with agmarshall.AgInterface_in_arg(volumeCalc, IVolumeCalc) as arg_volumeCalc:
            agcls.evaluate_hresult(self.__dict__["_SetVolumeCalc"](arg_volumeCalc.COM_val))

    def GetMinimum(self) -> "IQuantity":
        """Get the minimum bound value from the bounds. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the bounds."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimum"](arg_value.COM_val))

    def GetMaximum(self) -> "IQuantity":
        """Get the maximum bound value from the bounds. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximum"](arg_value.COM_val))

    def Set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{018666E1-C0E6-46F6-A682-F91FBF3C74F3}", IVolumeFromCalc)
agcls.AgTypeNameMap["IVolumeFromCalc"] = IVolumeFromCalc

class IVolumeFromCondition(object):
    """A volume from conditioninterface."""
    _uuid = "{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeFromCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeFromCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeFromCondition = agcom.GUID(IVolumeFromCondition._uuid)
        vtable_offset_local = IVolumeFromCondition._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromCondition, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeFromCondition.__dict__ and type(IVolumeFromCondition.__dict__[attrname]) == property:
            return IVolumeFromCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeFromCondition.")
    
    @property
    def Condition(self) -> "ICondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "IEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def Sampling(self) -> "ISampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ISampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ISampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}", IVolumeFromCondition)
agcls.AgTypeNameMap["IVolumeFromCondition"] = IVolumeFromCondition

class IVolumeFromGrid(object):
    """An over time volume interface."""
    _uuid = "{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEdgeType"] = _raise_uninitialized_error
        self.__dict__["_SetEdgeType"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeGrid"] = _raise_uninitialized_error
        self.__dict__["_SetVolumeGrid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeFromGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeFromGrid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeFromGrid = agcom.GUID(IVolumeFromGrid._uuid)
        vtable_offset_local = IVolumeFromGrid._vtable_offset - 1
        self.__dict__["_GetEdgeType"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromGrid, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetEdgeType"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromGrid, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetVolumeGrid"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromGrid, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetVolumeGrid"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromGrid, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeFromGrid.__dict__ and type(IVolumeFromGrid.__dict__[attrname]) == property:
            return IVolumeFromGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeFromGrid.")
    
    @property
    def EdgeType(self) -> "AgECrdnVolumeFromGridEdgeType":
        """Sets/Returns the edge type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEdgeType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EdgeType.setter
    def EdgeType(self, edgeType:"AgECrdnVolumeFromGridEdgeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType, edgeType) as arg_edgeType:
            agcls.evaluate_hresult(self.__dict__["_SetEdgeType"](arg_edgeType.COM_val))

    @property
    def VolumeGrid(self) -> "IVolumeGrid":
        """Sets/Returns the volume grid for bounding."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeGrid"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeGrid.setter
    def VolumeGrid(self, volumeGrid:"IVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(volumeGrid, IVolumeGrid) as arg_volumeGrid:
            agcls.evaluate_hresult(self.__dict__["_SetVolumeGrid"](arg_volumeGrid.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}", IVolumeFromGrid)
agcls.AgTypeNameMap["IVolumeFromGrid"] = IVolumeFromGrid

class IVolumeFromTimeSatisfaction(object):
    """An volume from time satisfaction volume interface."""
    _uuid = "{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeSatisfaction"] = _raise_uninitialized_error
        self.__dict__["_SetTimeSatisfaction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeFromTimeSatisfaction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeFromTimeSatisfaction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeFromTimeSatisfaction = agcom.GUID(IVolumeFromTimeSatisfaction._uuid)
        vtable_offset_local = IVolumeFromTimeSatisfaction._vtable_offset - 1
        self.__dict__["_GetTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromTimeSatisfaction, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_IVolumeFromTimeSatisfaction, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeFromTimeSatisfaction.__dict__ and type(IVolumeFromTimeSatisfaction.__dict__[attrname]) == property:
            return IVolumeFromTimeSatisfaction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeFromTimeSatisfaction.")
    
    @property
    def TimeSatisfaction(self) -> "IEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeSatisfaction"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeSatisfaction.setter
    def TimeSatisfaction(self, timeSatisfaction:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(timeSatisfaction, IEventIntervalList) as arg_timeSatisfaction:
            agcls.evaluate_hresult(self.__dict__["_SetTimeSatisfaction"](arg_timeSatisfaction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}", IVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap["IVolumeFromTimeSatisfaction"] = IVolumeFromTimeSatisfaction

class IVolumeGrid(object):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    _uuid = "{88BBE781-85C1-439D-A4F4-58006B9A35EC}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGrid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGrid = agcom.GUID(IVolumeGrid._uuid)
        vtable_offset_local = IVolumeGrid._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGrid.__dict__ and type(IVolumeGrid.__dict__[attrname]) == property:
            return IVolumeGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGrid.")
    

agcls.AgClassCatalog.add_catalog_entry("{88BBE781-85C1-439D-A4F4-58006B9A35EC}", IVolumeGrid)
agcls.AgTypeNameMap["IVolumeGrid"] = IVolumeGrid

class IVolumeGridBearingAlt(object):
    """A volume grid bearing alt (Surface Bearing) interface."""
    _uuid = "{2814A890-E858-41A6-B640-19F9D27E5ACB}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetAlongBearingCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetCrossBearingCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_SetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_GetBearingAngle"] = _raise_uninitialized_error
        self.__dict__["_SetBearingAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceLocation"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceLocation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridBearingAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridBearingAlt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridBearingAlt = agcom.GUID(IVolumeGridBearingAlt._uuid)
        vtable_offset_local = IVolumeGridBearingAlt._vtable_offset - 1
        self.__dict__["_GetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetAlongBearingCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCrossBearingCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_GetBearingAngle"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBearingAngle"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetReferenceLocation"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+10, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetReferenceLocation"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridBearingAlt, vtable_offset_local+11, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridBearingAlt.__dict__ and type(IVolumeGridBearingAlt.__dict__[attrname]) == property:
            return IVolumeGridBearingAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridBearingAlt.")
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceCentralBody"](arg_referenceCentralBody.COM_val))

    @property
    def AlongBearingCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns AlongBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongBearingCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CrossBearingCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns CrossBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCrossBearingCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns altitude Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAutoFitBounds"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__["_SetAutoFitBounds"](arg_autoFitBounds.COM_val))

    @property
    def BearingAngle(self) -> float:
        """Specify the Bearing Angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBearingAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @BearingAngle.setter
    def BearingAngle(self, bearingAngle:float) -> None:
        with agmarshall.DOUBLE_arg(bearingAngle) as arg_bearingAngle:
            agcls.evaluate_hresult(self.__dict__["_SetBearingAngle"](arg_bearingAngle.COM_val))

    @property
    def ReferenceLocation(self) -> list:
        """Get lat/lon for reference location"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceLocation.setter
    def ReferenceLocation(self, referenceLocation:list) -> None:
        with agmarshall.SAFEARRAY_arg(referenceLocation) as arg_referenceLocation:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceLocation"](arg_referenceLocation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2814A890-E858-41A6-B640-19F9D27E5ACB}", IVolumeGridBearingAlt)
agcls.AgTypeNameMap["IVolumeGridBearingAlt"] = IVolumeGridBearingAlt

class IVolumeGridCartesian(object):
    """A volume grid Cartesian interface."""
    _uuid = "{E959F851-165E-4201-8C13-81FA4C2D3E2D}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetXCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetYCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetZCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridCartesian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridCartesian = agcom.GUID(IVolumeGridCartesian._uuid)
        vtable_offset_local = IVolumeGridCartesian._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCartesian, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCartesian, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetXCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCartesian, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCartesian, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetZCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCartesian, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridCartesian.__dict__ and type(IVolumeGridCartesian.__dict__[attrname]) == property:
            return IVolumeGridCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridCartesian.")
    
    @property
    def ReferenceSystem(self) -> "ISystem":
        """Get the reference system in which Cartesian parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def XCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns X Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns Y Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ZCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns Z Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetZCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E959F851-165E-4201-8C13-81FA4C2D3E2D}", IVolumeGridCartesian)
agcls.AgTypeNameMap["IVolumeGridCartesian"] = IVolumeGridCartesian

class IVolumeGridConstrained(object):
    """A volume grid constrained interface."""
    _uuid = "{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceGrid"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceGrid"] = _raise_uninitialized_error
        self.__dict__["_GetConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetConstraint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridConstrained from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridConstrained = agcom.GUID(IVolumeGridConstrained._uuid)
        vtable_offset_local = IVolumeGridConstrained._vtable_offset - 1
        self.__dict__["_GetReferenceGrid"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceGrid"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridConstrained, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetConstraint"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetConstraint"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridConstrained, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridConstrained.__dict__ and type(IVolumeGridConstrained.__dict__[attrname]) == property:
            return IVolumeGridConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridConstrained.")
    
    @property
    def ReferenceGrid(self) -> "IVolumeGrid":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceGrid"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceGrid.setter
    def ReferenceGrid(self, referenceGrid:"IVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(referenceGrid, IVolumeGrid) as arg_referenceGrid:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceGrid"](arg_referenceGrid.COM_val))

    @property
    def Constraint(self) -> "IVolume":
        """Get the volume constraint on the grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"IVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, IVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__["_SetConstraint"](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}", IVolumeGridConstrained)
agcls.AgTypeNameMap["IVolumeGridConstrained"] = IVolumeGridConstrained

class IVolumeGridCylindrical(object):
    """A volume grid cylindrical interface."""
    _uuid = "{0CF87427-CC2B-4282-9B41-0A2D86395AD4}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetThetaCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetRadiusCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetHeightCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridCylindrical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridCylindrical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridCylindrical = agcom.GUID(IVolumeGridCylindrical._uuid)
        vtable_offset_local = IVolumeGridCylindrical._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCylindrical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCylindrical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetThetaCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCylindrical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRadiusCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCylindrical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetHeightCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridCylindrical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridCylindrical.__dict__ and type(IVolumeGridCylindrical.__dict__[attrname]) == property:
            return IVolumeGridCylindrical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridCylindrical.")
    
    @property
    def ReferenceSystem(self) -> "ISystem":
        """Get the reference system in which cylindrical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def ThetaCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns theta Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThetaCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RadiusCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns radius Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def HeightCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns height Coordinates parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetHeightCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0CF87427-CC2B-4282-9B41-0A2D86395AD4}", IVolumeGridCylindrical)
agcls.AgTypeNameMap["IVolumeGridCylindrical"] = IVolumeGridCylindrical

class IVolumeGridLatLonAlt(object):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    _uuid = "{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetLatitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetLongitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_SetAutoFitBounds"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridLatLonAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridLatLonAlt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridLatLonAlt = agcom.GUID(IVolumeGridLatLonAlt._uuid)
        vtable_offset_local = IVolumeGridLatLonAlt._vtable_offset - 1
        self.__dict__["_GetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridLatLonAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridLatLonAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetLatitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridLatLonAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetLongitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridLatLonAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridLatLonAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridLatLonAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridLatLonAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridLatLonAlt.__dict__ and type(IVolumeGridLatLonAlt.__dict__[attrname]) == property:
            return IVolumeGridLatLonAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridLatLonAlt.")
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceCentralBody"](arg_referenceCentralBody.COM_val))

    @property
    def LatitudeCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns latitude Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def LongitudeCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns longtitude Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns altitude parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAutoFitBounds"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__["_SetAutoFitBounds"](arg_autoFitBounds.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}", IVolumeGridLatLonAlt)
agcls.AgTypeNameMap["IVolumeGridLatLonAlt"] = IVolumeGridLatLonAlt

class IVolumeGridResult(object):
    """An interface that generates Volume Grid results."""
    _uuid = "{1C3B106C-011E-4C51-B321-20389C8EAF76}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSizeI"] = _raise_uninitialized_error
        self.__dict__["_GetSizeJ"] = _raise_uninitialized_error
        self.__dict__["_GetSizeK"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricDataVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricPositionVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricNativePositionVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricGradientVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridResult = agcom.GUID(IVolumeGridResult._uuid)
        vtable_offset_local = IVolumeGridResult._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetSizeI"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_GetSizeJ"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetSizeK"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+4, POINTER(agcom.INT))
        self.__dict__["_GetVolumeMetricDataVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricPositionVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+6, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricNativePositionVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricGradientVector"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridResult, vtable_offset_local+8, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridResult.__dict__ and type(IVolumeGridResult.__dict__[attrname]) == property:
            return IVolumeGridResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridResult.")
    
    @property
    def Epoch(self) -> typing.Any:
        """Epoch of returned volumetric data."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeI(self) -> int:
        """Number of grid point coordinates representing first dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeI"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeJ(self) -> int:
        """Number of grid point coordinates representing second dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeJ"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeK(self) -> int:
        """Number of grid point coordinates representing third dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeK"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VolumeMetricDataVector(self) -> list:
        """Vector of scalar values representing volumetric data."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricDataVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricPositionVector(self) -> list:
        """Vector of Cartesian coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricPositionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricNativePositionVector(self) -> list:
        """Vector of native coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricNativePositionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricGradientVector(self) -> list:
        """Vector of Cartesian coordinates representing gradient vectors at all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricGradientVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1C3B106C-011E-4C51-B321-20389C8EAF76}", IVolumeGridResult)
agcls.AgTypeNameMap["IVolumeGridResult"] = IVolumeGridResult

class IVolumeGridSpherical(object):
    """A volume grid spherical interface."""
    _uuid = "{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuthCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetElevationCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetRangeCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeGridSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeGridSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeGridSpherical = agcom.GUID(IVolumeGridSpherical._uuid)
        vtable_offset_local = IVolumeGridSpherical._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridSpherical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridSpherical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAzimuthCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridSpherical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetElevationCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridSpherical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetRangeCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVolumeGridSpherical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeGridSpherical.__dict__ and type(IVolumeGridSpherical.__dict__[attrname]) == property:
            return IVolumeGridSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeGridSpherical.")
    
    @property
    def ReferenceSystem(self) -> "ISystem":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def AzimuthCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns azimuth coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuthCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ElevationCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns elevation coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetElevationCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RangeCoordinates(self) -> "IGridCoordinateDefinition":
        """Returns range coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRangeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}", IVolumeGridSpherical)
agcls.AgTypeNameMap["IVolumeGridSpherical"] = IVolumeGridSpherical

class IVolumeInview(object):
    """An Inview volume interface."""
    _uuid = "{EF724630-CEB6-4818-A5BB-F74CF1B9D931}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetConstraintObject"] = _raise_uninitialized_error
        self.__dict__["_SetConstraintObject"] = _raise_uninitialized_error
        self.__dict__["_GetLightTimeDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeInview._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeInview from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeInview = agcom.GUID(IVolumeInview._uuid)
        vtable_offset_local = IVolumeInview._vtable_offset - 1
        self.__dict__["_GetConstraintObject"] = IAGFUNCTYPE(pUnk, IID_IVolumeInview, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetConstraintObject"] = IAGFUNCTYPE(pUnk, IID_IVolumeInview, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_IVolumeInview, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeInview.__dict__ and type(IVolumeInview.__dict__[attrname]) == property:
            return IVolumeInview.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeInview.")
    
    @property
    def ConstraintObject(self) -> typing.Any:
        """A constraint object of the access."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintObject"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ConstraintObject.setter
    def ConstraintObject(self, constraintObject:typing.Any) -> None:
        with agmarshall.VARIANT_arg(constraintObject) as arg_constraintObject:
            agcls.evaluate_hresult(self.__dict__["_SetConstraintObject"](arg_constraintObject.COM_val))

    @property
    def LightTimeDelay(self) -> "ILightTimeDelay":
        """Returns Light Time Delay options parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLightTimeDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF724630-CEB6-4818-A5BB-F74CF1B9D931}", IVolumeInview)
agcls.AgTypeNameMap["IVolumeInview"] = IVolumeInview

class IVolumeLighting(object):
    """A lighting volume interface."""
    _uuid = "{CE134C08-274E-4E29-9337-03E9C73AA8F9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetLightingConditions"] = _raise_uninitialized_error
        self.__dict__["_SetLightingConditions"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeLighting from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeLighting = agcom.GUID(IVolumeLighting._uuid)
        vtable_offset_local = IVolumeLighting._vtable_offset - 1
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeLighting, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeLighting, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeLighting, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVolumeLighting, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetLightingConditions"] = IAGFUNCTYPE(pUnk, IID_IVolumeLighting, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetLightingConditions"] = IAGFUNCTYPE(pUnk, IID_IVolumeLighting, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeLighting.__dict__ and type(IVolumeLighting.__dict__[attrname]) == property:
            return IVolumeLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeLighting.")
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))

    @property
    def LightingConditions(self) -> "AgECrdnVolumeLightingConditionsType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLightingConditions"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LightingConditions.setter
    def LightingConditions(self, lightingConditions:"AgECrdnVolumeLightingConditionsType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType, lightingConditions) as arg_lightingConditions:
            agcls.evaluate_hresult(self.__dict__["_SetLightingConditions"](arg_lightingConditions.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CE134C08-274E-4E29-9337-03E9C73AA8F9}", IVolumeLighting)
agcls.AgTypeNameMap["IVolumeLighting"] = IVolumeLighting

class IVolumeOverTime(object):
    """An over time volume interface."""
    _uuid = "{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationType"] = _raise_uninitialized_error
        self.__dict__["_SetDurationType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVolume"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceVolume"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVolumeOverTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVolumeOverTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVolumeOverTime = agcom.GUID(IVolumeOverTime._uuid)
        vtable_offset_local = IVolumeOverTime._vtable_offset - 1
        self.__dict__["_GetDurationType"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationType"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceVolume"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceVolume"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_IVolumeOverTime, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVolumeOverTime.__dict__ and type(IVolumeOverTime.__dict__[attrname]) == property:
            return IVolumeOverTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVolumeOverTime.")
    
    @property
    def DurationType(self) -> "AgECrdnVolumeOverTimeDurationType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeOverTimeDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__["_SetDurationType"](arg_durationType.COM_val))

    @property
    def ReferenceVolume(self) -> "IVolume":
        """Sets/Returns the reference volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVolume"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVolume.setter
    def ReferenceVolume(self, referenceVolume:"IVolume") -> None:
        with agmarshall.AgInterface_in_arg(referenceVolume, IVolume) as arg_referenceVolume:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceVolume"](arg_referenceVolume.COM_val))

    @property
    def ReferenceIntervals(self) -> "IEventIntervalList":
        """The reference interval list for the over time volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}", IVolumeOverTime)
agcls.AgTypeNameMap["IVolumeOverTime"] = IVolumeOverTime

class ITimeProperties(object):
    """Defines methods to compute time properties such as availability and special times."""
    _uuid = "{E95B72AA-F8DE-4122-AC60-54E46A208E19}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAvailability"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeProperties = agcom.GUID(ITimeProperties._uuid)
        vtable_offset_local = ITimeProperties._vtable_offset - 1
        self.__dict__["_GetAvailability"] = IAGFUNCTYPE(pUnk, IID_ITimeProperties, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeProperties.__dict__ and type(ITimeProperties.__dict__[attrname]) == property:
            return ITimeProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeProperties.")
    
    def GetAvailability(self) -> "IIntervalCollection":
        """Returns a collection of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailability"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E95B72AA-F8DE-4122-AC60-54E46A208E19}", ITimeProperties)
agcls.AgTypeNameMap["ITimeProperties"] = ITimeProperties

class ITypeInfo(object):
    """Provides information about the type of VGT components."""
    _uuid = "{67E20A46-9550-4A68-9276-697DC821A23A}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTypeDescription"] = _raise_uninitialized_error
        self.__dict__["_GetTypeName"] = _raise_uninitialized_error
        self.__dict__["_GetShortTypeDescription"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITypeInfo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITypeInfo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITypeInfo = agcom.GUID(ITypeInfo._uuid)
        vtable_offset_local = ITypeInfo._vtable_offset - 1
        self.__dict__["_GetTypeDescription"] = IAGFUNCTYPE(pUnk, IID_ITypeInfo, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetTypeName"] = IAGFUNCTYPE(pUnk, IID_ITypeInfo, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetShortTypeDescription"] = IAGFUNCTYPE(pUnk, IID_ITypeInfo, vtable_offset_local+3, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITypeInfo.__dict__ and type(ITypeInfo.__dict__[attrname]) == property:
            return ITypeInfo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITypeInfo.")
    
    @property
    def TypeDescription(self) -> str:
        """Return the type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def TypeName(self) -> str:
        """Return the type name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ShortTypeDescription(self) -> str:
        """Return the short type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetShortTypeDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{67E20A46-9550-4A68-9276-697DC821A23A}", ITypeInfo)
agcls.AgTypeNameMap["ITypeInfo"] = ITypeInfo

class IRefTo(object):
    """A base interface for all VGT component references."""
    _uuid = "{2F3A17A6-4304-4565-BC1C-7A064DCFE310}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPath"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRefTo = agcom.GUID(IRefTo._uuid)
        vtable_offset_local = IRefTo._vtable_offset - 1
        self.__dict__["_GetPath"] = IAGFUNCTYPE(pUnk, IID_IRefTo, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRefTo.__dict__ and type(IRefTo.__dict__[attrname]) == property:
            return IRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRefTo.")
    
    @property
    def Path(self) -> str:
        """Returns a path to the referenced VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2F3A17A6-4304-4565-BC1C-7A064DCFE310}", IRefTo)
agcls.AgTypeNameMap["IRefTo"] = IRefTo

class ITemplate(object):
    """The IAgCrdnTemplate interface enables to obtain information about the STK class that owns the VGT component."""
    _uuid = "{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetClassName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITemplate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITemplate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITemplate = agcom.GUID(ITemplate._uuid)
        vtable_offset_local = ITemplate._vtable_offset - 1
        self.__dict__["_GetClassName"] = IAGFUNCTYPE(pUnk, IID_ITemplate, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITemplate.__dict__ and type(ITemplate.__dict__[attrname]) == property:
            return ITemplate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITemplate.")
    
    @property
    def ClassName(self) -> str:
        """Returns a class name (i.e. 'Satellite', 'Facility', etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClassName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}", ITemplate)
agcls.AgTypeNameMap["ITemplate"] = ITemplate

class IInstance(object):
    """The IAgCrdnInstance interface enables to obtain information about the parent object that owns the VGT component."""
    _uuid = "{17633665-9601-4FFF-8227-4D5DF0AAEA06}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInstancePath"] = _raise_uninitialized_error
        self.__dict__["_GetTemplate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IInstance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IInstance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IInstance = agcom.GUID(IInstance._uuid)
        vtable_offset_local = IInstance._vtable_offset - 1
        self.__dict__["_GetInstancePath"] = IAGFUNCTYPE(pUnk, IID_IInstance, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetTemplate"] = IAGFUNCTYPE(pUnk, IID_IInstance, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IInstance.__dict__ and type(IInstance.__dict__[attrname]) == property:
            return IInstance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IInstance.")
    
    @property
    def InstancePath(self) -> str:
        """Returns a path to the parent object that owns the VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInstancePath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Template(self) -> "ICoordinate":
        """Returns a template object the VGT component was created from or null if the VGT component was not created from a template."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTemplate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{17633665-9601-4FFF-8227-4D5DF0AAEA06}", IInstance)
agcls.AgTypeNameMap["IInstance"] = IInstance

class IPointRefTo(object):
    """Represents a reference to a VGT point."""
    _uuid = "{B553DE32-05C9-4944-918A-90552E039DBE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointRefTo = agcom.GUID(IPointRefTo._uuid)
        vtable_offset_local = IPointRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IPointRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_IPointRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IPointRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IPointRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointRefTo.__dict__ and type(IPointRefTo.__dict__[attrname]) == property:
            return IPointRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new point."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetPoint(self, point:"IPoint") -> None:
        """Sets a new point."""
        with agmarshall.AgInterface_in_arg(point, IPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    def GetPoint(self) -> "IPoint":
        """Returns the actual point object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, point:"IPoint") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(point, IPoint) as arg_point, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_point.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B553DE32-05C9-4944-918A-90552E039DBE}", IPointRefTo)
agcls.AgTypeNameMap["IPointRefTo"] = IPointRefTo

class IVectorRefTo(object):
    """Represents a reference to a VGT vector."""
    _uuid = "{EDF2E070-340E-456C-BDA8-BE9B9B40E728}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorRefTo = agcom.GUID(IVectorRefTo._uuid)
        vtable_offset_local = IVectorRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IVectorRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IVectorRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorRefTo.__dict__ and type(IVectorRefTo.__dict__[attrname]) == property:
            return IVectorRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new vector."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetVector(self, vector:"IVector") -> None:
        """Sets a new vector."""
        with agmarshall.AgInterface_in_arg(vector, IVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__["_SetVector"](arg_vector.COM_val))

    def GetVector(self) -> "IVector":
        """Returns the actual vector object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, vector:"IVector") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(vector, IVector) as arg_vector, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_vector.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EDF2E070-340E-456C-BDA8-BE9B9B40E728}", IVectorRefTo)
agcls.AgTypeNameMap["IVectorRefTo"] = IVectorRefTo

class IAxesRefTo(object):
    """Represents a reference to a VGT axes."""
    _uuid = "{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesRefTo = agcom.GUID(IAxesRefTo._uuid)
        vtable_offset_local = IAxesRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IAxesRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IAxesRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesRefTo.__dict__ and type(IAxesRefTo.__dict__[attrname]) == property:
            return IAxesRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new axes."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetAxes(self, axes:"IAxes") -> None:
        """Sets a new axes."""
        with agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_SetAxes"](arg_axes.COM_val))

    def GetAxes(self) -> "IAxes":
        """Returns the actual axes object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, axes:"IAxes") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_axes.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}", IAxesRefTo)
agcls.AgTypeNameMap["IAxesRefTo"] = IAxesRefTo

class IAngleRefTo(object):
    """Represents a reference to a VGT angle."""
    _uuid = "{7A9D809F-D819-4458-9855-2DA8507F6E57}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleRefTo = agcom.GUID(IAngleRefTo._uuid)
        vtable_offset_local = IAngleRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IAngleRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IAngleRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleRefTo.__dict__ and type(IAngleRefTo.__dict__[attrname]) == property:
            return IAngleRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new angle."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetAngle(self, angle:"IAngle") -> None:
        """Sets a new angle."""
        with agmarshall.AgInterface_in_arg(angle, IAngle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_SetAngle"](arg_angle.COM_val))

    def GetAngle(self) -> "IAngle":
        """Returns the actual angle object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, angle:"IAngle") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(angle, IAngle) as arg_angle, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_angle.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7A9D809F-D819-4458-9855-2DA8507F6E57}", IAngleRefTo)
agcls.AgTypeNameMap["IAngleRefTo"] = IAngleRefTo

class ISystemRefTo(object):
    """Represents a reference to a VGT system."""
    _uuid = "{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetSystem"] = _raise_uninitialized_error
        self.__dict__["_GetSystem"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemRefTo = agcom.GUID(ISystemRefTo._uuid)
        vtable_offset_local = ISystemRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ISystemRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetSystem"] = IAGFUNCTYPE(pUnk, IID_ISystemRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSystem"] = IAGFUNCTYPE(pUnk, IID_ISystemRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_ISystemRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemRefTo.__dict__ and type(ISystemRefTo.__dict__[attrname]) == property:
            return ISystemRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new system."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetSystem(self, system:"ISystem") -> None:
        """Sets a new system."""
        with agmarshall.AgInterface_in_arg(system, ISystem) as arg_system:
            agcls.evaluate_hresult(self.__dict__["_SetSystem"](arg_system.COM_val))

    def GetSystem(self) -> "ISystem":
        """Returns the actual system object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, system:"ISystem") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(system, ISystem) as arg_system, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_system.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}", ISystemRefTo)
agcls.AgTypeNameMap["ISystemRefTo"] = ISystemRefTo

class IPlaneRefTo(object):
    """Represents a reference to a VGT plane."""
    _uuid = "{CE3D70F2-61E0-4A23-803F-A734005DC36D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetPlane"] = _raise_uninitialized_error
        self.__dict__["_GetPlane"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneRefTo = agcom.GUID(IPlaneRefTo._uuid)
        vtable_offset_local = IPlaneRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IPlaneRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetPlane"] = IAGFUNCTYPE(pUnk, IID_IPlaneRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPlane"] = IAGFUNCTYPE(pUnk, IID_IPlaneRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IPlaneRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneRefTo.__dict__ and type(IPlaneRefTo.__dict__[attrname]) == property:
            return IPlaneRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new plane using a specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetPlane(self, plane:"IPlane") -> None:
        """Sets a new plane."""
        with agmarshall.AgInterface_in_arg(plane, IPlane) as arg_plane:
            agcls.evaluate_hresult(self.__dict__["_SetPlane"](arg_plane.COM_val))

    def GetPlane(self) -> "IPlane":
        """Returns the actual plane object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, plane:"IPlane") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(plane, IPlane) as arg_plane, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_plane.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CE3D70F2-61E0-4A23-803F-A734005DC36D}", IPlaneRefTo)
agcls.AgTypeNameMap["IPlaneRefTo"] = IPlaneRefTo

class IAxesLabels(object):
    """Allows configuring the VGT axes labels."""
    _uuid = "{0CD79528-D932-4473-9CC4-0BF5C936A6CD}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLabelX"] = _raise_uninitialized_error
        self.__dict__["_SetLabelX"] = _raise_uninitialized_error
        self.__dict__["_GetLabelY"] = _raise_uninitialized_error
        self.__dict__["_SetLabelY"] = _raise_uninitialized_error
        self.__dict__["_GetLabelZ"] = _raise_uninitialized_error
        self.__dict__["_SetLabelZ"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesLabels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesLabels = agcom.GUID(IAxesLabels._uuid)
        vtable_offset_local = IAxesLabels._vtable_offset - 1
        self.__dict__["_GetLabelX"] = IAGFUNCTYPE(pUnk, IID_IAxesLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelX"] = IAGFUNCTYPE(pUnk, IID_IAxesLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetLabelY"] = IAGFUNCTYPE(pUnk, IID_IAxesLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelY"] = IAGFUNCTYPE(pUnk, IID_IAxesLabels, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetLabelZ"] = IAGFUNCTYPE(pUnk, IID_IAxesLabels, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelZ"] = IAGFUNCTYPE(pUnk, IID_IAxesLabels, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesLabels.__dict__ and type(IAxesLabels.__dict__[attrname]) == property:
            return IAxesLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesLabels.")
    
    @property
    def LabelX(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelX"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelX.setter
    def LabelX(self, labelX:str) -> None:
        with agmarshall.BSTR_arg(labelX) as arg_labelX:
            agcls.evaluate_hresult(self.__dict__["_SetLabelX"](arg_labelX.COM_val))

    @property
    def LabelY(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelY"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelY.setter
    def LabelY(self, labelY:str) -> None:
        with agmarshall.BSTR_arg(labelY) as arg_labelY:
            agcls.evaluate_hresult(self.__dict__["_SetLabelY"](arg_labelY.COM_val))

    @property
    def LabelZ(self) -> str:
        """Specify a Z axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelZ"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelZ.setter
    def LabelZ(self, labelZ:str) -> None:
        with agmarshall.BSTR_arg(labelZ) as arg_labelZ:
            agcls.evaluate_hresult(self.__dict__["_SetLabelZ"](arg_labelZ.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0CD79528-D932-4473-9CC4-0BF5C936A6CD}", IAxesLabels)
agcls.AgTypeNameMap["IAxesLabels"] = IAxesLabels

class IPlaneLabels(object):
    """Allows configuring the X and Y axes labels."""
    _uuid = "{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetXAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_SetXAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_SetYAxisLabel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneLabels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneLabels = agcom.GUID(IPlaneLabels._uuid)
        vtable_offset_local = IPlaneLabels._vtable_offset - 1
        self.__dict__["_GetXAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IPlaneLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetXAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IPlaneLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetYAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IPlaneLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetYAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IPlaneLabels, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneLabels.__dict__ and type(IPlaneLabels.__dict__[attrname]) == property:
            return IPlaneLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneLabels.")
    
    @property
    def XAxisLabel(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisLabel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @XAxisLabel.setter
    def XAxisLabel(self, xAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(xAxisLabel) as arg_xAxisLabel:
            agcls.evaluate_hresult(self.__dict__["_SetXAxisLabel"](arg_xAxisLabel.COM_val))

    @property
    def YAxisLabel(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisLabel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @YAxisLabel.setter
    def YAxisLabel(self, yAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(yAxisLabel) as arg_yAxisLabel:
            agcls.evaluate_hresult(self.__dict__["_SetYAxisLabel"](arg_yAxisLabel.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}", IPlaneLabels)
agcls.AgTypeNameMap["IPlaneLabels"] = IPlaneLabels

class IAxesAlignedAndConstrained(object):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    _uuid = "{19991E4F-F368-41CD-AE27-96CF11EC963F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAlignmentReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAlignmentDirection"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesAlignedAndConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesAlignedAndConstrained from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesAlignedAndConstrained = agcom.GUID(IAxesAlignedAndConstrained._uuid)
        vtable_offset_local = IAxesAlignedAndConstrained._vtable_offset - 1
        self.__dict__["_GetAlignmentReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IAxesAlignedAndConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetConstraintReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IAxesAlignedAndConstrained, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetAlignmentDirection"] = IAGFUNCTYPE(pUnk, IID_IAxesAlignedAndConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetConstraintDirection"] = IAGFUNCTYPE(pUnk, IID_IAxesAlignedAndConstrained, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesAlignedAndConstrained.__dict__ and type(IAxesAlignedAndConstrained.__dict__[attrname]) == property:
            return IAxesAlignedAndConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesAlignedAndConstrained.")
    
    @property
    def AlignmentReferenceVector(self) -> "IVectorRefTo":
        """Specify an alignment reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlignmentReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintReferenceVector(self) -> "IVectorRefTo":
        """Specify a constraint reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AlignmentDirection(self) -> "IDirection":
        """Specify a desired alignment direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlignmentDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintDirection(self) -> "IDirection":
        """Specify a desired constraint direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{19991E4F-F368-41CD-AE27-96CF11EC963F}", IAxesAlignedAndConstrained)
agcls.AgTypeNameMap["IAxesAlignedAndConstrained"] = IAxesAlignedAndConstrained

class IAxesAngularOffset(object):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    _uuid = "{0096F935-281A-4EC9-92A4-7400BD2DEF60}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpinVector"] = _raise_uninitialized_error
        self.__dict__["_GetRotationAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFixedOffsetAngle"] = _raise_uninitialized_error
        self.__dict__["_SetFixedOffsetAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesAngularOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesAngularOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesAngularOffset = agcom.GUID(IAxesAngularOffset._uuid)
        vtable_offset_local = IAxesAngularOffset._vtable_offset - 1
        self.__dict__["_GetSpinVector"] = IAGFUNCTYPE(pUnk, IID_IAxesAngularOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationAngle"] = IAGFUNCTYPE(pUnk, IID_IAxesAngularOffset, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesAngularOffset, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedOffsetAngle"] = IAGFUNCTYPE(pUnk, IID_IAxesAngularOffset, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFixedOffsetAngle"] = IAGFUNCTYPE(pUnk, IID_IAxesAngularOffset, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesAngularOffset.__dict__ and type(IAxesAngularOffset.__dict__[attrname]) == property:
            return IAxesAngularOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesAngularOffset.")
    
    @property
    def SpinVector(self) -> "IVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationAngle(self) -> "IAngleRefTo":
        """Specify a rotational angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOffsetAngle(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedOffsetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FixedOffsetAngle.setter
    def FixedOffsetAngle(self, fixedOffsetAngle:float) -> None:
        with agmarshall.DOUBLE_arg(fixedOffsetAngle) as arg_fixedOffsetAngle:
            agcls.evaluate_hresult(self.__dict__["_SetFixedOffsetAngle"](arg_fixedOffsetAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0096F935-281A-4EC9-92A4-7400BD2DEF60}", IAxesAngularOffset)
agcls.AgTypeNameMap["IAxesAngularOffset"] = IAxesAngularOffset

class IAxesFixedAtEpoch(object):
    """Axes based on another set fixed at a specified epoch."""
    _uuid = "{CEB9E066-A9F8-4B74-AF7A-0301BF611843}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesFixedAtEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesFixedAtEpoch = agcom.GUID(IAxesFixedAtEpoch._uuid)
        vtable_offset_local = IAxesFixedAtEpoch._vtable_offset - 1
        self.__dict__["_GetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesFixedAtEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IAxesFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IAxesFixedAtEpoch, vtable_offset_local+4, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesFixedAtEpoch.__dict__ and type(IAxesFixedAtEpoch.__dict__[attrname]) == property:
            return IAxesFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesFixedAtEpoch.")
    
    @property
    def SourceAxes(self) -> "IAxesRefTo":
        """Specify a source axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CEB9E066-A9F8-4B74-AF7A-0301BF611843}", IAxesFixedAtEpoch)
agcls.AgTypeNameMap["IAxesFixedAtEpoch"] = IAxesFixedAtEpoch

class IAxesBPlane(object):
    """B-Plane axes using the selected target body and reference vector."""
    _uuid = "{72FD97D1-AE64-45D2-973E-E4F491B474AC}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetTargetBody"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesBPlane = agcom.GUID(IAxesBPlane._uuid)
        vtable_offset_local = IAxesBPlane._vtable_offset - 1
        self.__dict__["_GetTrajectory"] = IAGFUNCTYPE(pUnk, IID_IAxesBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IAxesBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargetBody"] = IAGFUNCTYPE(pUnk, IID_IAxesBPlane, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IAxesBPlane, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_IAxesBPlane, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesBPlane.__dict__ and type(IAxesBPlane.__dict__[attrname]) == property:
            return IAxesBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesBPlane.")
    
    @property
    def Trajectory(self) -> "IPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetBody(self) -> "ICentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72FD97D1-AE64-45D2-973E-E4F491B474AC}", IAxesBPlane)
agcls.AgTypeNameMap["IAxesBPlane"] = IAxesBPlane

class IAxesCustomScript(object):
    """Customized axes offset with respect to a set of reference Axes."""
    _uuid = "{F5A690E6-0304-49E0-BAB5-229F848B0401}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesCustomScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesCustomScript = agcom.GUID(IAxesCustomScript._uuid)
        vtable_offset_local = IAxesCustomScript._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IAxesCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IAxesCustomScript, vtable_offset_local+3, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesCustomScript.__dict__ and type(IAxesCustomScript.__dict__[attrname]) == property:
            return IAxesCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesCustomScript.")
    
    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filename(self) -> str:
        """Can be MATLAB (.m or .dll), VB Script (.vbs) or Perl (.pl) script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F5A690E6-0304-49E0-BAB5-229F848B0401}", IAxesCustomScript)
agcls.AgTypeNameMap["IAxesCustomScript"] = IAxesCustomScript

class IAxesAttitudeFile(object):
    """Axes specified by data from a file."""
    _uuid = "{E4A194BD-44ED-498F-ACB2-9911C19F52E8}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesAttitudeFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesAttitudeFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesAttitudeFile = agcom.GUID(IAxesAttitudeFile._uuid)
        vtable_offset_local = IAxesAttitudeFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IAxesAttitudeFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IAxesAttitudeFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesAttitudeFile.__dict__ and type(IAxesAttitudeFile.__dict__[attrname]) == property:
            return IAxesAttitudeFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesAttitudeFile.")
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E4A194BD-44ED-498F-ACB2-9911C19F52E8}", IAxesAttitudeFile)
agcls.AgTypeNameMap["IAxesAttitudeFile"] = IAxesAttitudeFile

class IAxesFixed(object):
    """Axes fixed in reference axes."""
    _uuid = "{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFixedOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesFixed = agcom.GUID(IAxesFixed._uuid)
        vtable_offset_local = IAxesFixed._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesFixed, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedOrientation"] = IAGFUNCTYPE(pUnk, IID_IAxesFixed, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesFixed.__dict__ and type(IAxesFixed.__dict__[attrname]) == property:
            return IAxesFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesFixed.")
    
    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOrientation(self) -> "IOrientation":
        """Specify a desired orientation and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}", IAxesFixed)
agcls.AgTypeNameMap["IAxesFixed"] = IAxesFixed

class IAxesModelAttach(object):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    _uuid = "{3A20DEC4-2D89-416C-8B47-D76E859763B0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesModelAttach = agcom.GUID(IAxesModelAttach._uuid)
        vtable_offset_local = IAxesModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IAxesModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IAxesModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesModelAttach.__dict__ and type(IAxesModelAttach.__dict__[attrname]) == property:
            return IAxesModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3A20DEC4-2D89-416C-8B47-D76E859763B0}", IAxesModelAttach)
agcls.AgTypeNameMap["IAxesModelAttach"] = IAxesModelAttach

class IAxesSpinning(object):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    _uuid = "{ECB36015-B534-40C6-B50F-298217335C38}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpinVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetInitialOffset"] = _raise_uninitialized_error
        self.__dict__["_SetInitialOffset"] = _raise_uninitialized_error
        self.__dict__["_GetSpinRate"] = _raise_uninitialized_error
        self.__dict__["_SetSpinRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesSpinning._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesSpinning from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesSpinning = agcom.GUID(IAxesSpinning._uuid)
        vtable_offset_local = IAxesSpinning._vtable_offset - 1
        self.__dict__["_GetSpinVector"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetInitialOffset"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialOffset"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetSpinRate"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSpinRate"] = IAGFUNCTYPE(pUnk, IID_IAxesSpinning, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesSpinning.__dict__ and type(IAxesSpinning.__dict__[attrname]) == property:
            return IAxesSpinning.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesSpinning.")
    
    @property
    def SpinVector(self) -> "IVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch at which the axes are aligned with the reference axes."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))

    @property
    def InitialOffset(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitialOffset.setter
    def InitialOffset(self, initialOffset:float) -> None:
        with agmarshall.DOUBLE_arg(initialOffset) as arg_initialOffset:
            agcls.evaluate_hresult(self.__dict__["_SetInitialOffset"](arg_initialOffset.COM_val))

    @property
    def SpinRate(self) -> float:
        """Specify a spin rate the axes spins about the spin vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpinRate.setter
    def SpinRate(self, spinRate:float) -> None:
        with agmarshall.DOUBLE_arg(spinRate) as arg_spinRate:
            agcls.evaluate_hresult(self.__dict__["_SetSpinRate"](arg_spinRate.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ECB36015-B534-40C6-B50F-298217335C38}", IAxesSpinning)
agcls.AgTypeNameMap["IAxesSpinning"] = IAxesSpinning

class IAxesOnSurface(object):
    """Topocentric axes located at the reference point's projection on the central body."""
    _uuid = "{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_SetUseMSL"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesOnSurface = agcom.GUID(IAxesOnSurface._uuid)
        vtable_offset_local = IAxesOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IAxesOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IAxesOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetUseMSL"] = IAGFUNCTYPE(pUnk, IID_IAxesOnSurface, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMSL"] = IAGFUNCTYPE(pUnk, IID_IAxesOnSurface, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesOnSurface.__dict__ and type(IAxesOnSurface.__dict__[attrname]) == property:
            return IAxesOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesOnSurface.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseMSL(self) -> bool:
        """Specify whether the reference shape is at the Mean Sea Level."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMSL"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__["_SetUseMSL"](arg_useMSL.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}", IAxesOnSurface)
agcls.AgTypeNameMap["IAxesOnSurface"] = IAxesOnSurface

class IAxesTrajectory(object):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    _uuid = "{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTrajectoryPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetTrajectoryAxesType"] = _raise_uninitialized_error
        self.__dict__["_SetTrajectoryAxesType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesTrajectory = agcom.GUID(IAxesTrajectory._uuid)
        vtable_offset_local = IAxesTrajectory._vtable_offset - 1
        self.__dict__["_GetTrajectoryPoint"] = IAGFUNCTYPE(pUnk, IID_IAxesTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IAxesTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTrajectoryAxesType"] = IAGFUNCTYPE(pUnk, IID_IAxesTrajectory, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetTrajectoryAxesType"] = IAGFUNCTYPE(pUnk, IID_IAxesTrajectory, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesTrajectory.__dict__ and type(IAxesTrajectory.__dict__[attrname]) == property:
            return IAxesTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesTrajectory.")
    
    @property
    def TrajectoryPoint(self) -> "IPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectoryPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "ISystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TrajectoryAxesType(self) -> "AgECrdnTrajectoryAxesType":
        """Specify a type of the trajectory's coordinate frame."""
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectoryAxesType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TrajectoryAxesType.setter
    def TrajectoryAxesType(self, trajectoryAxesType:"AgECrdnTrajectoryAxesType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType, trajectoryAxesType) as arg_trajectoryAxesType:
            agcls.evaluate_hresult(self.__dict__["_SetTrajectoryAxesType"](arg_trajectoryAxesType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}", IAxesTrajectory)
agcls.AgTypeNameMap["IAxesTrajectory"] = IAxesTrajectory

class IAxesLagrangeLibration(object):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    _uuid = "{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPrimaryCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetSecondaryCentralBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesLagrangeLibration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesLagrangeLibration = agcom.GUID(IAxesLagrangeLibration._uuid)
        vtable_offset_local = IAxesLagrangeLibration._vtable_offset - 1
        self.__dict__["_GetPrimaryCentralBody"] = IAGFUNCTYPE(pUnk, IID_IAxesLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_IAxesLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_IAxesLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_GetSecondaryCentralBodies"] = IAGFUNCTYPE(pUnk, IID_IAxesLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesLagrangeLibration.__dict__ and type(IAxesLagrangeLibration.__dict__[attrname]) == property:
            return IAxesLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesLagrangeLibration.")
    
    @property
    def PrimaryCentralBody(self) -> "ICentralBodyRefTo":
        """Specify a primary central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPrimaryCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "ICentralBodyCollection":
        """Specify secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondaryCentralBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}", IAxesLagrangeLibration)
agcls.AgTypeNameMap["IAxesLagrangeLibration"] = IAxesLagrangeLibration

class IAxesCommonTasks(object):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateTopocentricAxesQuaternion"] = _raise_uninitialized_error
        self.__dict__["_CreateTopocentricAxesEulerAngles"] = _raise_uninitialized_error
        self.__dict__["_CreateFixed"] = _raise_uninitialized_error
        self.__dict__["_Sample"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesCommonTasks = agcom.GUID(IAxesCommonTasks._uuid)
        vtable_offset_local = IAxesCommonTasks._vtable_offset - 1
        self.__dict__["_CreateTopocentricAxesQuaternion"] = IAGFUNCTYPE(pUnk, IID_IAxesCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateTopocentricAxesEulerAngles"] = IAGFUNCTYPE(pUnk, IID_IAxesCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_CreateFixed"] = IAGFUNCTYPE(pUnk, IID_IAxesCommonTasks, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_Sample"] = IAGFUNCTYPE(pUnk, IID_IAxesCommonTasks, vtable_offset_local+4, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesCommonTasks.__dict__ and type(IAxesCommonTasks.__dict__[attrname]) == property:
            return IAxesCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesCommonTasks.")
    
    def CreateTopocentricAxesQuaternion(self, originPoint:"IPoint", qx:float, qy:float, qz:float, qs:float) -> "IAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The quaternion defines the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, IPoint) as arg_originPoint, \
             agmarshall.DOUBLE_arg(qx) as arg_qx, \
             agmarshall.DOUBLE_arg(qy) as arg_qy, \
             agmarshall.DOUBLE_arg(qz) as arg_qz, \
             agmarshall.DOUBLE_arg(qs) as arg_qs, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateTopocentricAxesQuaternion"](arg_originPoint.COM_val, arg_qx.COM_val, arg_qy.COM_val, arg_qz.COM_val, arg_qs.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateTopocentricAxesEulerAngles(self, originPoint:"IPoint", sequence:"AgEEulerOrientationSequence", a:typing.Any, b:typing.Any, c:typing.Any) -> "IAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The euler angles define the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, IPoint) as arg_originPoint, \
             agmarshall.AgEnum_arg(AgEEulerOrientationSequence, sequence) as arg_sequence, \
             agmarshall.VARIANT_arg(a) as arg_a, \
             agmarshall.VARIANT_arg(b) as arg_b, \
             agmarshall.VARIANT_arg(c) as arg_c, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateTopocentricAxesEulerAngles"](arg_originPoint.COM_val, arg_sequence.COM_val, arg_a.COM_val, arg_b.COM_val, arg_c.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixed(self, referenceAxes:"IAxes") -> "IAxesFixed":
        """Creates non-persistent fixed axes based on specified axes."""
        with agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixed"](arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, axes:"IAxes", referenceAxes:"IAxes", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "IAxesSamplingResult":
        """Computes and returns tabulated orientations and angular velocities of axes with respect to reference axes using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(axes, IAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Sample"](arg_axes.COM_val, arg_referenceAxes.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}", IAxesCommonTasks)
agcls.AgTypeNameMap["IAxesCommonTasks"] = IAxesCommonTasks

class IAxesAtTimeInstant(object):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    _uuid = "{193F4A55-5E79-43A1-8A2C-3C001F7608A5}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesAtTimeInstant = agcom.GUID(IAxesAtTimeInstant._uuid)
        vtable_offset_local = IAxesAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IAxesAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IAxesAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IAxesAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesAtTimeInstant.__dict__ and type(IAxesAtTimeInstant.__dict__[attrname]) == property:
            return IAxesAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourceAxes(self) -> "IAxes":
        """A base axes defining the orientation. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceAxes.setter
    def SourceAxes(self, sourceAxes:"IAxes") -> None:
        with agmarshall.AgInterface_in_arg(sourceAxes, IAxes) as arg_sourceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetSourceAxes"](arg_sourceAxes.COM_val))

    @property
    def ReferenceAxes(self) -> "IAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{193F4A55-5E79-43A1-8A2C-3C001F7608A5}", IAxesAtTimeInstant)
agcls.AgTypeNameMap["IAxesAtTimeInstant"] = IAxesAtTimeInstant

class IAxesPlugin(object):
    """A VGT axes plugin."""
    _uuid = "{E63FD5E1-B844-4893-9E4C-3F02210AE74C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesPlugin = agcom.GUID(IAxesPlugin._uuid)
        vtable_offset_local = IAxesPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_IAxesPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_IAxesPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_IAxesPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_IAxesPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_IAxesPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_IAxesPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesPlugin.__dict__ and type(IAxesPlugin.__dict__[attrname]) == property:
            return IAxesPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E63FD5E1-B844-4893-9E4C-3F02210AE74C}", IAxesPlugin)
agcls.AgTypeNameMap["IAxesPlugin"] = IAxesPlugin

class IAngleBetweenVectors(object):
    """An angle between two vectors."""
    _uuid = "{B3986E8E-A8CB-414F-8214-71C53ED00740}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromVector"] = _raise_uninitialized_error
        self.__dict__["_GetToVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleBetweenVectors._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleBetweenVectors from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleBetweenVectors = agcom.GUID(IAngleBetweenVectors._uuid)
        vtable_offset_local = IAngleBetweenVectors._vtable_offset - 1
        self.__dict__["_GetFromVector"] = IAGFUNCTYPE(pUnk, IID_IAngleBetweenVectors, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToVector"] = IAGFUNCTYPE(pUnk, IID_IAngleBetweenVectors, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleBetweenVectors.__dict__ and type(IAngleBetweenVectors.__dict__[attrname]) == property:
            return IAngleBetweenVectors.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleBetweenVectors.")
    
    @property
    def FromVector(self) -> "IVectorRefTo":
        """Specify the first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "IVectorRefTo":
        """Specify the second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B3986E8E-A8CB-414F-8214-71C53ED00740}", IAngleBetweenVectors)
agcls.AgTypeNameMap["IAngleBetweenVectors"] = IAngleBetweenVectors

class IAngleBetweenPlanes(object):
    """An angle between two planes."""
    _uuid = "{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromPlane"] = _raise_uninitialized_error
        self.__dict__["_GetToPlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleBetweenPlanes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleBetweenPlanes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleBetweenPlanes = agcom.GUID(IAngleBetweenPlanes._uuid)
        vtable_offset_local = IAngleBetweenPlanes._vtable_offset - 1
        self.__dict__["_GetFromPlane"] = IAGFUNCTYPE(pUnk, IID_IAngleBetweenPlanes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToPlane"] = IAGFUNCTYPE(pUnk, IID_IAngleBetweenPlanes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleBetweenPlanes.__dict__ and type(IAngleBetweenPlanes.__dict__[attrname]) == property:
            return IAngleBetweenPlanes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleBetweenPlanes.")
    
    @property
    def FromPlane(self) -> "IPlaneRefTo":
        """Specify the first of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToPlane(self) -> "IPlaneRefTo":
        """Specify the second of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}", IAngleBetweenPlanes)
agcls.AgTypeNameMap["IAngleBetweenPlanes"] = IAngleBetweenPlanes

class IAngleDihedral(object):
    """An angle between two vectors about an axis."""
    _uuid = "{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromVector"] = _raise_uninitialized_error
        self.__dict__["_GetToVector"] = _raise_uninitialized_error
        self.__dict__["_GetPoleAbout"] = _raise_uninitialized_error
        self.__dict__["_GetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_SetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_GetSignedAngle"] = _raise_uninitialized_error
        self.__dict__["_SetSignedAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleDihedral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleDihedral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleDihedral = agcom.GUID(IAngleDihedral._uuid)
        vtable_offset_local = IAngleDihedral._vtable_offset - 1
        self.__dict__["_GetFromVector"] = IAGFUNCTYPE(pUnk, IID_IAngleDihedral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToVector"] = IAGFUNCTYPE(pUnk, IID_IAngleDihedral, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetPoleAbout"] = IAGFUNCTYPE(pUnk, IID_IAngleDihedral, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IAngleDihedral, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IAngleDihedral, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetSignedAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleDihedral, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSignedAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleDihedral, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleDihedral.__dict__ and type(IAngleDihedral.__dict__[attrname]) == property:
            return IAngleDihedral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleDihedral.")
    
    @property
    def FromVector(self) -> "IVectorRefTo":
        """Specify a first vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "IVectorRefTo":
        """Specify a second vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PoleAbout(self) -> "IVectorRefTo":
        """Specify a vector about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoleAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CounterClockwiseRotation(self) -> bool:
        """Specify whether the rotation is counter-clockwise."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCounterClockwiseRotation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CounterClockwiseRotation.setter
    def CounterClockwiseRotation(self, counterClockwiseRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(counterClockwiseRotation) as arg_counterClockwiseRotation:
            agcls.evaluate_hresult(self.__dict__["_SetCounterClockwiseRotation"](arg_counterClockwiseRotation.COM_val))

    @property
    def SignedAngle(self) -> bool:
        """Specify whether the axis of rotation for the angle is aligned with Positive or Negative direction of the about vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignedAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignedAngle.setter
    def SignedAngle(self, signedAngle:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(signedAngle) as arg_signedAngle:
            agcls.evaluate_hresult(self.__dict__["_SetSignedAngle"](arg_signedAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}", IAngleDihedral)
agcls.AgTypeNameMap["IAngleDihedral"] = IAngleDihedral

class IAngleRotation(object):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    _uuid = "{9E842F77-B3A8-475C-96AA-E692B35E8E05}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromAxes"] = _raise_uninitialized_error
        self.__dict__["_GetToAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceDirection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleRotation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleRotation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleRotation = agcom.GUID(IAngleRotation._uuid)
        vtable_offset_local = IAngleRotation._vtable_offset - 1
        self.__dict__["_GetFromAxes"] = IAGFUNCTYPE(pUnk, IID_IAngleRotation, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToAxes"] = IAGFUNCTYPE(pUnk, IID_IAngleRotation, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IAngleRotation, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IAngleRotation, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleRotation.__dict__ and type(IAngleRotation.__dict__[attrname]) == property:
            return IAngleRotation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleRotation.")
    
    @property
    def FromAxes(self) -> "IAxesRefTo":
        """Specify an axes to rotate from."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToAxes(self) -> "IAxesRefTo":
        """Specify an axes to rotate to."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceDirection(self) -> "AgECrdnDisplayAxisSelector":
        """Specify a rotation direction."""
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceDirection.setter
    def ReferenceDirection(self, referenceDirection:"AgECrdnDisplayAxisSelector") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector, referenceDirection) as arg_referenceDirection:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceDirection"](arg_referenceDirection.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9E842F77-B3A8-475C-96AA-E692B35E8E05}", IAngleRotation)
agcls.AgTypeNameMap["IAngleRotation"] = IAngleRotation

class IAngleToPlane(object):
    """An angle between a vector and a plane."""
    _uuid = "{DDFA25AD-174D-407B-B90C-747B3E43F7C9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetSigned"] = _raise_uninitialized_error
        self.__dict__["_SetSigned"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleToPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleToPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleToPlane = agcom.GUID(IAngleToPlane._uuid)
        vtable_offset_local = IAngleToPlane._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IAngleToPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IAngleToPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetSigned"] = IAGFUNCTYPE(pUnk, IID_IAngleToPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSigned"] = IAGFUNCTYPE(pUnk, IID_IAngleToPlane, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleToPlane.__dict__ and type(IAngleToPlane.__dict__[attrname]) == property:
            return IAngleToPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleToPlane.")
    
    @property
    def ReferenceVector(self) -> "IVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Signed(self) -> "AgECrdnSignedAngleType":
        """Controls whether the angle is measured as either Positive or Negative when the reference Vector is directed toward the plane's normal, or always positive."""
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSigned"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Signed.setter
    def Signed(self, signed:"AgECrdnSignedAngleType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType, signed) as arg_signed:
            agcls.evaluate_hresult(self.__dict__["_SetSigned"](arg_signed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DDFA25AD-174D-407B-B90C-747B3E43F7C9}", IAngleToPlane)
agcls.AgTypeNameMap["IAngleToPlane"] = IAngleToPlane

class IPlaneNormal(object):
    """A plane normal to a vector at a given point."""
    _uuid = "{AAF66E5C-B310-4387-BDAE-D45F24F226BC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetNormalVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneNormal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneNormal = agcom.GUID(IPlaneNormal._uuid)
        vtable_offset_local = IPlaneNormal._vtable_offset - 1
        self.__dict__["_GetNormalVector"] = IAGFUNCTYPE(pUnk, IID_IPlaneNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IPlaneNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPlaneNormal, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneNormal.__dict__ and type(IPlaneNormal.__dict__[attrname]) == property:
            return IPlaneNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneNormal.")
    
    @property
    def NormalVector(self) -> "IVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{AAF66E5C-B310-4387-BDAE-D45F24F226BC}", IPlaneNormal)
agcls.AgTypeNameMap["IPlaneNormal"] = IPlaneNormal

class IPlaneQuadrant(object):
    """A plane based on a selected Quadrant of a reference system."""
    _uuid = "{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetQuadrant"] = _raise_uninitialized_error
        self.__dict__["_SetQuadrant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneQuadrant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneQuadrant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneQuadrant = agcom.GUID(IPlaneQuadrant._uuid)
        vtable_offset_local = IPlaneQuadrant._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IPlaneQuadrant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetQuadrant"] = IAGFUNCTYPE(pUnk, IID_IPlaneQuadrant, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetQuadrant"] = IAGFUNCTYPE(pUnk, IID_IPlaneQuadrant, vtable_offset_local+3, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneQuadrant.__dict__ and type(IPlaneQuadrant.__dict__[attrname]) == property:
            return IPlaneQuadrant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneQuadrant.")
    
    @property
    def ReferenceSystem(self) -> "ISystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quadrant(self) -> "AgECrdnQuadrantType":
        """Specify a quadrant."""
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQuadrant"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Quadrant.setter
    def Quadrant(self, quadrant:"AgECrdnQuadrantType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType, quadrant) as arg_quadrant:
            agcls.evaluate_hresult(self.__dict__["_SetQuadrant"](arg_quadrant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}", IPlaneQuadrant)
agcls.AgTypeNameMap["IPlaneQuadrant"] = IPlaneQuadrant

class IPlaneTrajectory(object):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    _uuid = "{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_SetRotationOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneTrajectory = agcom.GUID(IPlaneTrajectory._uuid)
        vtable_offset_local = IPlaneTrajectory._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IPlaneTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IPlaneTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IPlaneTrajectory, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IPlaneTrajectory, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneTrajectory.__dict__ and type(IPlaneTrajectory.__dict__[attrname]) == property:
            return IPlaneTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneTrajectory.")
    
    @property
    def Point(self) -> "IPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "ISystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__["_SetRotationOffset"](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}", IPlaneTrajectory)
agcls.AgTypeNameMap["IPlaneTrajectory"] = IPlaneTrajectory

class IPlaneTriad(object):
    """A Plane containing points A, B and ReferencePont with the first axis aligned with the direction from the ReferencePoint to point A and the second axis toward the direction from the ReferencePoint to point B."""
    _uuid = "{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointA"] = _raise_uninitialized_error
        self.__dict__["_GetPointB"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_SetRotationOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneTriad._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneTriad from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneTriad = agcom.GUID(IPlaneTriad._uuid)
        vtable_offset_local = IPlaneTriad._vtable_offset - 1
        self.__dict__["_GetPointA"] = IAGFUNCTYPE(pUnk, IID_IPlaneTriad, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointB"] = IAGFUNCTYPE(pUnk, IID_IPlaneTriad, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPlaneTriad, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IPlaneTriad, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IPlaneTriad, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneTriad.__dict__ and type(IPlaneTriad.__dict__[attrname]) == property:
            return IPlaneTriad.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneTriad.")
    
    @property
    def PointA(self) -> "IPointRefTo":
        """Specify a point A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointB(self) -> "IPointRefTo":
        """Specify a point B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__["_SetRotationOffset"](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}", IPlaneTriad)
agcls.AgTypeNameMap["IPlaneTriad"] = IPlaneTriad

class IPlaneTwoVector(object):
    """A plane passing through point and containing two given vectors."""
    _uuid = "{345761f0-0ace-494c-8d9c-0f3e3af9c2da}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetVector2"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneTwoVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneTwoVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneTwoVector = agcom.GUID(IPlaneTwoVector._uuid)
        vtable_offset_local = IPlaneTwoVector._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IPlaneTwoVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetVector2"] = IAGFUNCTYPE(pUnk, IID_IPlaneTwoVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPlaneTwoVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneTwoVector.__dict__ and type(IPlaneTwoVector.__dict__[attrname]) == property:
            return IPlaneTwoVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneTwoVector.")
    
    @property
    def ReferenceVector(self) -> "IVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Vector2(self) -> "IVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector2"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{345761f0-0ace-494c-8d9c-0f3e3af9c2da}", IPlaneTwoVector)
agcls.AgTypeNameMap["IPlaneTwoVector"] = IPlaneTwoVector

class IPointBPlane(object):
    """B-Plane point using the selected target body."""
    _uuid = "{CC3B797F-5327-4D04-911D-8ED499E056AF}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetBody"] = _raise_uninitialized_error
        self.__dict__["_GetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointBPlane = agcom.GUID(IPointBPlane._uuid)
        vtable_offset_local = IPointBPlane._vtable_offset - 1
        self.__dict__["_GetTargetBody"] = IAGFUNCTYPE(pUnk, IID_IPointBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTrajectory"] = IAGFUNCTYPE(pUnk, IID_IPointBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_IPointBPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_IPointBPlane, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IPointBPlane, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_IPointBPlane, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointBPlane.__dict__ and type(IPointBPlane.__dict__[attrname]) == property:
            return IPointBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointBPlane.")
    
    @property
    def TargetBody(self) -> "ICentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Trajectory(self) -> "IPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnPointBPlaneType":
        """Specify a point type."""
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnPointBPlaneType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CC3B797F-5327-4D04-911D-8ED499E056AF}", IPointBPlane)
agcls.AgTypeNameMap["IPointBPlane"] = IPointBPlane

class IPointFile(object):
    """Point specified by data from a file."""
    _uuid = "{9612277C-2238-42BD-89D7-E54D7701D8F2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointFile = agcom.GUID(IPointFile._uuid)
        vtable_offset_local = IPointFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IPointFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IPointFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointFile.__dict__ and type(IPointFile.__dict__[attrname]) == property:
            return IPointFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointFile.")
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9612277C-2238-42BD-89D7-E54D7701D8F2}", IPointFile)
agcls.AgTypeNameMap["IPointFile"] = IPointFile

class IPointFixedInSystem(object):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    _uuid = "{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetFixedPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointFixedInSystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointFixedInSystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointFixedInSystem = agcom.GUID(IPointFixedInSystem._uuid)
        vtable_offset_local = IPointFixedInSystem._vtable_offset - 1
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IPointFixedInSystem, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedPoint"] = IAGFUNCTYPE(pUnk, IID_IPointFixedInSystem, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointFixedInSystem.__dict__ and type(IPointFixedInSystem.__dict__[attrname]) == property:
            return IPointFixedInSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointFixedInSystem.")
    
    @property
    def Reference(self) -> "ISystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedPoint(self) -> "IPosition":
        """Specify the point's position. The position is relative with respect to the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}", IPointFixedInSystem)
agcls.AgTypeNameMap["IPointFixedInSystem"] = IPointFixedInSystem

class IPointGrazing(object):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    _uuid = "{7FDF037E-1367-4590-A330-660EF3442DE1}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointGrazing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointGrazing = agcom.GUID(IPointGrazing._uuid)
        vtable_offset_local = IPointGrazing._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPointGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IPointGrazing, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IPointGrazing, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IPointGrazing, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointGrazing.__dict__ and type(IPointGrazing.__dict__[attrname]) == property:
            return IPointGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointGrazing.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "IVectorRefTo":
        """Specify a direction vector to be used in conjunction with the position vector from the selected central body to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Altitude(self) -> float:
        """The point of closest approach to the central body surface occurs at the specified altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7FDF037E-1367-4590-A330-660EF3442DE1}", IPointGrazing)
agcls.AgTypeNameMap["IPointGrazing"] = IPointGrazing

class IPointGlint(object):
    """Point on central body surface that reflects from source to observer."""
    _uuid = "{C4168949-A6F2-42B7-8019-671FF808836D}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetObserverPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointGlint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointGlint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointGlint = agcom.GUID(IPointGlint._uuid)
        vtable_offset_local = IPointGlint._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointGlint, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IPointGlint, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetObserverPoint"] = IAGFUNCTYPE(pUnk, IID_IPointGlint, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointGlint.__dict__ and type(IPointGlint.__dict__[attrname]) == property:
            return IPointGlint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointGlint.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SourcePoint(self) -> "IPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ObserverPoint(self) -> "IPointRefTo":
        """Specify an observer point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetObserverPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4168949-A6F2-42B7-8019-671FF808836D}", IPointGlint)
agcls.AgTypeNameMap["IPointGlint"] = IPointGlint

class IPointCovarianceGrazing(object):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    _uuid = "{CC9E8B92-77D8-46A9-BD52-3DABB173913D}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetTargetName"] = _raise_uninitialized_error
        self.__dict__["_SetTargetName"] = _raise_uninitialized_error
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetProbability"] = _raise_uninitialized_error
        self.__dict__["_SetProbability"] = _raise_uninitialized_error
        self.__dict__["_GetScale"] = _raise_uninitialized_error
        self.__dict__["_SetScale"] = _raise_uninitialized_error
        self.__dict__["_GetUseProbability"] = _raise_uninitialized_error
        self.__dict__["_SetUseProbability"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointCovarianceGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointCovarianceGrazing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointCovarianceGrazing = agcom.GUID(IPointCovarianceGrazing._uuid)
        vtable_offset_local = IPointCovarianceGrazing._vtable_offset - 1
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargetName"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetTargetName"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetProbability"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetProbability"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetScale"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScale"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseProbability"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseProbability"] = IAGFUNCTYPE(pUnk, IID_IPointCovarianceGrazing, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointCovarianceGrazing.__dict__ and type(IPointCovarianceGrazing.__dict__[attrname]) == property:
            return IPointCovarianceGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointCovarianceGrazing.")
    
    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "IVectorRefTo":
        """Specify a direction vector to be used in conjunction with the displacement vector from the selected target object to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetName(self) -> str:
        """Specify a target object about which the covariance ellipsoid is centered."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TargetName.setter
    def TargetName(self, targetName:str) -> None:
        with agmarshall.BSTR_arg(targetName) as arg_targetName:
            agcls.evaluate_hresult(self.__dict__["_SetTargetName"](arg_targetName.COM_val))

    @property
    def Distance(self) -> float:
        """The point of closest approach to the covariance ellipsoid surface occurs at the specified distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:float) -> None:
        with agmarshall.DOUBLE_arg(distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def Probability(self) -> float:
        """Specify a probability that the true position is inside the ellipsoid boundary."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProbability"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Probability.setter
    def Probability(self, probability:float) -> None:
        with agmarshall.DOUBLE_arg(probability) as arg_probability:
            agcls.evaluate_hresult(self.__dict__["_SetProbability"](arg_probability.COM_val))

    @property
    def Scale(self) -> float:
        """Specify a scale factor which is applied to the one sigma ellipsoid."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_SetScale"](arg_scale.COM_val))

    @property
    def UseProbability(self) -> bool:
        """A flag controlling whether to use probability or scale factor."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseProbability"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseProbability.setter
    def UseProbability(self, useProbability:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useProbability) as arg_useProbability:
            agcls.evaluate_hresult(self.__dict__["_SetUseProbability"](arg_useProbability.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CC9E8B92-77D8-46A9-BD52-3DABB173913D}", IPointCovarianceGrazing)
agcls.AgTypeNameMap["IPointCovarianceGrazing"] = IPointCovarianceGrazing

class IPointPlaneIntersection(object):
    """Point on a plane located along a given direction looking from a given origin."""
    _uuid = "{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointPlaneIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointPlaneIntersection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointPlaneIntersection = agcom.GUID(IPointPlaneIntersection._uuid)
        vtable_offset_local = IPointPlaneIntersection._vtable_offset - 1
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IPointPlaneIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IPointPlaneIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_IPointPlaneIntersection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointPlaneIntersection.__dict__ and type(IPointPlaneIntersection.__dict__[attrname]) == property:
            return IPointPlaneIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointPlaneIntersection.")
    
    @property
    def DirectionVector(self) -> "IVectorRefTo":
        """Specify a direction vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginPoint(self) -> "IPointRefTo":
        """Specify the origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}", IPointPlaneIntersection)
agcls.AgTypeNameMap["IPointPlaneIntersection"] = IPointPlaneIntersection

class IPointOnSurface(object):
    """The detic subpoint of the reference point as projected onto the central body."""
    _uuid = "{AED0D41F-BB69-4672-A513-17A43B12873D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceType"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointOnSurface = agcom.GUID(IPointOnSurface._uuid)
        vtable_offset_local = IPointOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPointOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IPointOnSurface, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IPointOnSurface, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSurfaceType"] = IAGFUNCTYPE(pUnk, IID_IPointOnSurface, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSurfaceType"] = IAGFUNCTYPE(pUnk, IID_IPointOnSurface, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointOnSurface.__dict__ and type(IPointOnSurface.__dict__[attrname]) == property:
            return IPointOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointOnSurface.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Specify a reference shape."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceShape"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceShape"](arg_referenceShape.COM_val))

    @property
    def SurfaceType(self) -> "AgECrdnSurfaceType":
        """Specify a surface type."""
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceType.setter
    def SurfaceType(self, surfaceType:"AgECrdnSurfaceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType, surfaceType) as arg_surfaceType:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceType"](arg_surfaceType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AED0D41F-BB69-4672-A513-17A43B12873D}", IPointOnSurface)
agcls.AgTypeNameMap["IPointOnSurface"] = IPointOnSurface

class IPointModelAttach(object):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    _uuid = "{CFEB5448-9053-44F6-BCB5-35280361131F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_GetUseScale"] = _raise_uninitialized_error
        self.__dict__["_SetUseScale"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointModelAttach = agcom.GUID(IPointModelAttach._uuid)
        vtable_offset_local = IPointModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IPointModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IPointModelAttach, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetUseScale"] = IAGFUNCTYPE(pUnk, IID_IPointModelAttach, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScale"] = IAGFUNCTYPE(pUnk, IID_IPointModelAttach, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointModelAttach.__dict__ and type(IPointModelAttach.__dict__[attrname]) == property:
            return IPointModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a model attachment point."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))

    @property
    def UseScale(self) -> bool:
        """Specify whether to use the model scale."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScale.setter
    def UseScale(self, useScale:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScale) as arg_useScale:
            agcls.evaluate_hresult(self.__dict__["_SetUseScale"](arg_useScale.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFEB5448-9053-44F6-BCB5-35280361131F}", IPointModelAttach)
agcls.AgTypeNameMap["IPointModelAttach"] = IPointModelAttach

class IPointSatelliteCollectionEntry(object):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    _uuid = "{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEntryName"] = _raise_uninitialized_error
        self.__dict__["_SetEntryName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointSatelliteCollectionEntry._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointSatelliteCollectionEntry from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointSatelliteCollectionEntry = agcom.GUID(IPointSatelliteCollectionEntry._uuid)
        vtable_offset_local = IPointSatelliteCollectionEntry._vtable_offset - 1
        self.__dict__["_GetEntryName"] = IAGFUNCTYPE(pUnk, IID_IPointSatelliteCollectionEntry, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetEntryName"] = IAGFUNCTYPE(pUnk, IID_IPointSatelliteCollectionEntry, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointSatelliteCollectionEntry.__dict__ and type(IPointSatelliteCollectionEntry.__dict__[attrname]) == property:
            return IPointSatelliteCollectionEntry.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointSatelliteCollectionEntry.")
    
    @property
    def EntryName(self) -> str:
        """Specify a satellite collection entry name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEntryName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EntryName.setter
    def EntryName(self, entryName:str) -> None:
        with agmarshall.BSTR_arg(entryName) as arg_entryName:
            agcls.evaluate_hresult(self.__dict__["_SetEntryName"](arg_entryName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}", IPointSatelliteCollectionEntry)
agcls.AgTypeNameMap["IPointSatelliteCollectionEntry"] = IPointSatelliteCollectionEntry

class IPointPlaneProjection(object):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    _uuid = "{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointPlaneProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointPlaneProjection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointPlaneProjection = agcom.GUID(IPointPlaneProjection._uuid)
        vtable_offset_local = IPointPlaneProjection._vtable_offset - 1
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IPointPlaneProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IPointPlaneProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointPlaneProjection.__dict__ and type(IPointPlaneProjection.__dict__[attrname]) == property:
            return IPointPlaneProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointPlaneProjection.")
    
    @property
    def SourcePoint(self) -> "IPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}", IPointPlaneProjection)
agcls.AgTypeNameMap["IPointPlaneProjection"] = IPointPlaneProjection

class IPointLagrangeLibration(object):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    _uuid = "{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetSecondaryCentralBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointLagrangeLibration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointLagrangeLibration = agcom.GUID(IPointLagrangeLibration._uuid)
        vtable_offset_local = IPointLagrangeLibration._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_IPointLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_IPointLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_GetSecondaryCentralBodies"] = IAGFUNCTYPE(pUnk, IID_IPointLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointLagrangeLibration.__dict__ and type(IPointLagrangeLibration.__dict__[attrname]) == property:
            return IPointLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointLagrangeLibration.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "ICentralBodyCollection":
        """Specify multiple secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondaryCentralBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}", IPointLagrangeLibration)
agcls.AgTypeNameMap["IPointLagrangeLibration"] = IPointLagrangeLibration

class IPointCommonTasks(object):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{C357C0A5-3F2A-499C-83F3-6824532C969E}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateFixedInSystemCartographic"] = _raise_uninitialized_error
        self.__dict__["_CreateFixedInSystemCartesian"] = _raise_uninitialized_error
        self.__dict__["_Sample"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointCommonTasks = agcom.GUID(IPointCommonTasks._uuid)
        vtable_offset_local = IPointCommonTasks._vtable_offset - 1
        self.__dict__["_CreateFixedInSystemCartographic"] = IAGFUNCTYPE(pUnk, IID_IPointCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateFixedInSystemCartesian"] = IAGFUNCTYPE(pUnk, IID_IPointCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_Sample"] = IAGFUNCTYPE(pUnk, IID_IPointCommonTasks, vtable_offset_local+3, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointCommonTasks.__dict__ and type(IPointCommonTasks.__dict__[attrname]) == property:
            return IPointCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointCommonTasks.")
    
    def CreateFixedInSystemCartographic(self, referenceSystem:"ISystem", latitude:typing.Any, longitude:typing.Any, altitude:float) -> "IPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedInSystemCartographic"](arg_referenceSystem.COM_val, arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixedInSystemCartesian(self, referenceSystem:"ISystem", x:float, y:float, z:float) -> "IPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem, \
             agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.DOUBLE_arg(z) as arg_z, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedInSystemCartesian"](arg_referenceSystem.COM_val, arg_x.COM_val, arg_y.COM_val, arg_z.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, point:"IPoint", referenceSystem:"ISystem", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "IPointSamplingResult":
        """Computes and returns tabulated positions and velocities of a point with respect to reference system using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(point, IPoint) as arg_point, \
             agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Sample"](arg_point.COM_val, arg_referenceSystem.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C357C0A5-3F2A-499C-83F3-6824532C969E}", IPointCommonTasks)
agcls.AgTypeNameMap["IPointCommonTasks"] = IPointCommonTasks

class IPointCentBodyIntersect(object):
    """Point on central body surface along direction vector originating at source point."""
    _uuid = "{C0F5946B-9467-44AC-B16A-9276CE4EA141}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_SetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetIntersectionSurface"] = _raise_uninitialized_error
        self.__dict__["_SetIntersectionSurface"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetUseRangeConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetUseRangeConstraint"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetRange"] = _raise_uninitialized_error
        self.__dict__["_GetAllowIntersectionFromBelow"] = _raise_uninitialized_error
        self.__dict__["_SetAllowIntersectionFromBelow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointCentBodyIntersect._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointCentBodyIntersect from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointCentBodyIntersect = agcom.GUID(IPointCentBodyIntersect._uuid)
        vtable_offset_local = IPointCentBodyIntersect._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetIntersectionSurface"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetIntersectionSurface"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseRangeConstraint"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseRangeConstraint"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetUseMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_SetRange"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+21, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_GetAllowIntersectionFromBelow"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowIntersectionFromBelow"] = IAGFUNCTYPE(pUnk, IID_IPointCentBodyIntersect, vtable_offset_local+23, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointCentBodyIntersect.__dict__ and type(IPointCentBodyIntersect.__dict__[attrname]) == property:
            return IPointCentBodyIntersect.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointCentBodyIntersect.")
    
    @property
    def CentralBody(self) -> str:
        """Central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ReferencePoint(self) -> "IPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def DirectionVector(self) -> "IVector":
        """A direction vector. Can be any vector from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DirectionVector.setter
    def DirectionVector(self, directionVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(directionVector, IVector) as arg_directionVector:
            agcls.evaluate_hresult(self.__dict__["_SetDirectionVector"](arg_directionVector.COM_val))

    @property
    def IntersectionSurface(self) -> "AgECrdnIntersectionSurface":
        """An intersection surface."""
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntersectionSurface"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntersectionSurface.setter
    def IntersectionSurface(self, intersectionSurface:"AgECrdnIntersectionSurface") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface, intersectionSurface) as arg_intersectionSurface:
            agcls.evaluate_hresult(self.__dict__["_SetIntersectionSurface"](arg_intersectionSurface.COM_val))

    @property
    def Altitude(self) -> float:
        """An altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))

    @property
    def UseRangeConstraint(self) -> bool:
        """Whether to use range constraint."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseRangeConstraint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseRangeConstraint.setter
    def UseRangeConstraint(self, useRangeConstraint:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useRangeConstraint) as arg_useRangeConstraint:
            agcls.evaluate_hresult(self.__dict__["_SetUseRangeConstraint"](arg_useRangeConstraint.COM_val))

    @property
    def MinimumRange(self) -> float:
        """A minimum range. An exception is thrown if the value exceeds the MaximumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumRange.setter
    def MinimumRange(self, minimumRange:float) -> None:
        with agmarshall.DOUBLE_arg(minimumRange) as arg_minimumRange:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumRange"](arg_minimumRange.COM_val))

    @property
    def MaximumRange(self) -> float:
        """A maximum range. An exception is thrown if the value is less than the MinimumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumRange.setter
    def MaximumRange(self, maximumRange:float) -> None:
        with agmarshall.DOUBLE_arg(maximumRange) as arg_maximumRange:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumRange"](arg_maximumRange.COM_val))

    @property
    def UseMinimumRange(self) -> bool:
        """Whether the minimum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinimumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumRange.setter
    def UseMinimumRange(self, useMinimumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumRange) as arg_useMinimumRange:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinimumRange"](arg_useMinimumRange.COM_val))

    @property
    def UseMaximumRange(self) -> bool:
        """Whether the maximum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaximumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumRange.setter
    def UseMaximumRange(self, useMaximumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumRange) as arg_useMaximumRange:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaximumRange"](arg_useMaximumRange.COM_val))

    def SetRange(self, minimum:float, maximum:float) -> None:
        """Set minimum and maximum range. An exception is thrown if Minimum exceeds Maximum. An exception is thrown if UseRangeConstraint is set to true. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg(minimum) as arg_minimum, \
             agmarshall.DOUBLE_arg(maximum) as arg_maximum:
            agcls.evaluate_hresult(self.__dict__["_SetRange"](arg_minimum.COM_val, arg_maximum.COM_val))

    @property
    def AllowIntersectionFromBelow(self) -> bool:
        """Whether intersection is computed when reference point is inside the surface. Applicable when the surface is not defined by terrain."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowIntersectionFromBelow"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AllowIntersectionFromBelow.setter
    def AllowIntersectionFromBelow(self, allowIntersectionFromBelow:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowIntersectionFromBelow) as arg_allowIntersectionFromBelow:
            agcls.evaluate_hresult(self.__dict__["_SetAllowIntersectionFromBelow"](arg_allowIntersectionFromBelow.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C0F5946B-9467-44AC-B16A-9276CE4EA141}", IPointCentBodyIntersect)
agcls.AgTypeNameMap["IPointCentBodyIntersect"] = IPointCentBodyIntersect

class IPointAtTimeInstant(object):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    _uuid = "{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_SetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointAtTimeInstant = agcom.GUID(IPointAtTimeInstant._uuid)
        vtable_offset_local = IPointAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IPointAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IPointAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IPointAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IPointAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IPointAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IPointAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointAtTimeInstant.__dict__ and type(IPointAtTimeInstant.__dict__[attrname]) == property:
            return IPointAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourcePoint(self) -> "IPoint":
        """A source point. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourcePoint.setter
    def SourcePoint(self, sourcePoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(sourcePoint, IPoint) as arg_sourcePoint:
            agcls.evaluate_hresult(self.__dict__["_SetSourcePoint"](arg_sourcePoint.COM_val))

    @property
    def ReferenceSystem(self) -> "ISystem":
        """A reference system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}", IPointAtTimeInstant)
agcls.AgTypeNameMap["IPointAtTimeInstant"] = IPointAtTimeInstant

class IPointPlugin(object):
    """A VGT point plugin."""
    _uuid = "{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointPlugin = agcom.GUID(IPointPlugin._uuid)
        vtable_offset_local = IPointPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_IPointPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_IPointPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_IPointPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_IPointPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_IPointPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_IPointPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointPlugin.__dict__ and type(IPointPlugin.__dict__[attrname]) == property:
            return IPointPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}", IPointPlugin)
agcls.AgTypeNameMap["IPointPlugin"] = IPointPlugin

class IPointCBFixedOffset(object):
    """Point specified by fixed components with respect to central body."""
    _uuid = "{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointCBFixedOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointCBFixedOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointCBFixedOffset = agcom.GUID(IPointCBFixedOffset._uuid)
        vtable_offset_local = IPointCBFixedOffset._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointCBFixedOffset, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointCBFixedOffset, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IPointCBFixedOffset, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IPointCBFixedOffset, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IPointCBFixedOffset, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointCBFixedOffset.__dict__ and type(IPointCBFixedOffset.__dict__[attrname]) == property:
            return IPointCBFixedOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointCBFixedOffset.")
    
    @property
    def CentralBody(self) -> str:
        """Get the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Choose the point height's reference. Available options are central body ellipsoid (WSG84), terrain or Mean Sea Level."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceShape"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceShape"](arg_referenceShape.COM_val))

    @property
    def Position(self) -> "IPosition":
        """A position of the point fixed on the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}", IPointCBFixedOffset)
agcls.AgTypeNameMap["IPointCBFixedOffset"] = IPointCBFixedOffset

class ISystemAssembled(object):
    """A system assembled from an origin point and a set of reference axes."""
    _uuid = "{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemAssembled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemAssembled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemAssembled = agcom.GUID(ISystemAssembled._uuid)
        vtable_offset_local = ISystemAssembled._vtable_offset - 1
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_ISystemAssembled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ISystemAssembled, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemAssembled.__dict__ and type(ISystemAssembled.__dict__[attrname]) == property:
            return ISystemAssembled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemAssembled.")
    
    @property
    def OriginPoint(self) -> "IPointRefTo":
        """Specify a point of origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}", ISystemAssembled)
agcls.AgTypeNameMap["ISystemAssembled"] = ISystemAssembled

class ISystemOnSurface(object):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    _uuid = "{15798E36-1EC0-4A73-A910-FC28CC404082}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuthAngle"] = _raise_uninitialized_error
        self.__dict__["_SetAzimuthAngle"] = _raise_uninitialized_error
        self.__dict__["_GetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_SetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemOnSurface = agcom.GUID(ISystemOnSurface._uuid)
        vtable_offset_local = ISystemOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ISystemOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetAzimuthAngle"] = IAGFUNCTYPE(pUnk, IID_ISystemOnSurface, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAzimuthAngle"] = IAGFUNCTYPE(pUnk, IID_ISystemOnSurface, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_GetUseMSL"] = IAGFUNCTYPE(pUnk, IID_ISystemOnSurface, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMSL"] = IAGFUNCTYPE(pUnk, IID_ISystemOnSurface, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_ISystemOnSurface, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemOnSurface.__dict__ and type(ISystemOnSurface.__dict__[attrname]) == property:
            return ISystemOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemOnSurface.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AzimuthAngle(self) -> float:
        """An angle by which the topocentric axes is rotated."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuthAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AzimuthAngle.setter
    def AzimuthAngle(self, azimuthAngle:float) -> None:
        with agmarshall.DOUBLE_arg(azimuthAngle) as arg_azimuthAngle:
            agcls.evaluate_hresult(self.__dict__["_SetAzimuthAngle"](arg_azimuthAngle.COM_val))

    @property
    def UseMSL(self) -> bool:
        """Specify whether to use the Mean Sea Level as the reference shape."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMSL"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__["_SetUseMSL"](arg_useMSL.COM_val))

    @property
    def Position(self) -> "ILLAPosition":
        """Specify the position of the system's origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{15798E36-1EC0-4A73-A910-FC28CC404082}", ISystemOnSurface)
agcls.AgTypeNameMap["ISystemOnSurface"] = ISystemOnSurface

class ILLAPosition(object):
    """A position represented by the Latitude, longtitude and Latitude."""
    _uuid = "{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILLAPosition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILLAPosition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILLAPosition = agcom.GUID(ILLAPosition._uuid)
        vtable_offset_local = ILLAPosition._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_ILLAPosition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_ILLAPosition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_ILLAPosition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_ILLAPosition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_ILLAPosition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_ILLAPosition, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILLAPosition.__dict__ and type(ILLAPosition.__dict__[attrname]) == property:
            return ILLAPosition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILLAPosition.")
    
    @property
    def Latitude(self) -> float:
        """Specify a latitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Latitude.setter
    def Latitude(self, latitude:float) -> None:
        with agmarshall.DOUBLE_arg(latitude) as arg_latitude:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_latitude.COM_val))

    @property
    def Longitude(self) -> float:
        """Specify a longitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Longitude.setter
    def Longitude(self, longitude:float) -> None:
        with agmarshall.DOUBLE_arg(longitude) as arg_longitude:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_longitude.COM_val))

    @property
    def Altitude(self) -> float:
        """Specify an altitude value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}", ILLAPosition)
agcls.AgTypeNameMap["ILLAPosition"] = ILLAPosition

class ISystemCommonTasks(object):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateEastNorthUpCartographic"] = _raise_uninitialized_error
        self.__dict__["_CreateAssembled"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemCommonTasks = agcom.GUID(ISystemCommonTasks._uuid)
        vtable_offset_local = ISystemCommonTasks._vtable_offset - 1
        self.__dict__["_CreateEastNorthUpCartographic"] = IAGFUNCTYPE(pUnk, IID_ISystemCommonTasks, vtable_offset_local+1, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateAssembled"] = IAGFUNCTYPE(pUnk, IID_ISystemCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemCommonTasks.__dict__ and type(ISystemCommonTasks.__dict__[attrname]) == property:
            return ISystemCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemCommonTasks.")
    
    def CreateEastNorthUpCartographic(self, latitude:typing.Any, longitude:typing.Any, altitude:float) -> "ISystemAssembled":
        """Creates a non-persistent East-North-Up (ENU) reference frame with the origin at the specified geodetic location."""
        with agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEastNorthUpCartographic"](arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAssembled(self, originPoint:"IPoint", referenceAxes:"IAxes") -> "ISystemAssembled":
        """Creates a non-persistent system component assembled from an origin point and a set of reference axes."""
        with agmarshall.AgInterface_in_arg(originPoint, IPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateAssembled"](arg_originPoint.COM_val, arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}", ISystemCommonTasks)
agcls.AgTypeNameMap["ISystemCommonTasks"] = ISystemCommonTasks

class IVectorAngleRate(object):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    _uuid = "{CFC40EEB-A99F-4DAD-A366-1C7908C15128}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorAngleRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorAngleRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorAngleRate = agcom.GUID(IVectorAngleRate._uuid)
        vtable_offset_local = IVectorAngleRate._vtable_offset - 1
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorAngleRate, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorAngleRate, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorAngleRate, vtable_offset_local+3, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorAngleRate.__dict__ and type(IVectorAngleRate.__dict__[attrname]) == property:
            return IVectorAngleRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorAngleRate.")
    
    @property
    def Angle(self) -> "IAngleRefTo":
        """Specify an angle. The angle vector will be perpendicular to the plane in which the angle is defined."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFC40EEB-A99F-4DAD-A366-1C7908C15128}", IVectorAngleRate)
agcls.AgTypeNameMap["IVectorAngleRate"] = IVectorAngleRate

class IVectorApoapsis(object):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{A082FC52-1C33-4D63-B02E-1D163FC2F837}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorApoapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorApoapsis = agcom.GUID(IVectorApoapsis._uuid)
        vtable_offset_local = IVectorApoapsis._vtable_offset - 1
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorApoapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorApoapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorApoapsis.__dict__ and type(IVectorApoapsis.__dict__[attrname]) == property:
            return IVectorApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorApoapsis.")
    
    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A082FC52-1C33-4D63-B02E-1D163FC2F837}", IVectorApoapsis)
agcls.AgTypeNameMap["IVectorApoapsis"] = IVectorApoapsis

class IVectorFixedAtEpoch(object):
    """A vector based on another vector fixed at a specified epoch."""
    _uuid = "{7F816808-CF9D-434A-82CE-78F4A88BC75D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorFixedAtEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorFixedAtEpoch = agcom.GUID(IVectorFixedAtEpoch._uuid)
        vtable_offset_local = IVectorFixedAtEpoch._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtEpoch, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtEpoch, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorFixedAtEpoch.__dict__ and type(IVectorFixedAtEpoch.__dict__[attrname]) == property:
            return IVectorFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorFixedAtEpoch.")
    
    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))

    @property
    def SourceVector(self) -> "IVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7F816808-CF9D-434A-82CE-78F4A88BC75D}", IVectorFixedAtEpoch)
agcls.AgTypeNameMap["IVectorFixedAtEpoch"] = IVectorFixedAtEpoch

class IVectorAngularVelocity(object):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    _uuid = "{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorAngularVelocity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorAngularVelocity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorAngularVelocity = agcom.GUID(IVectorAngularVelocity._uuid)
        vtable_offset_local = IVectorAngularVelocity._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorAngularVelocity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorAngularVelocity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorAngularVelocity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorAngularVelocity, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorAngularVelocity.__dict__ and type(IVectorAngularVelocity.__dict__[attrname]) == property:
            return IVectorAngularVelocity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorAngularVelocity.")
    
    @property
    def Axes(self) -> "IAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}", IVectorAngularVelocity)
agcls.AgTypeNameMap["IVectorAngularVelocity"] = IVectorAngularVelocity

class IVectorConing(object):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    _uuid = "{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAboutVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetStartClockAngle"] = _raise_uninitialized_error
        self.__dict__["_SetStartClockAngle"] = _raise_uninitialized_error
        self.__dict__["_GetStopClockAngle"] = _raise_uninitialized_error
        self.__dict__["_SetStopClockAngle"] = _raise_uninitialized_error
        self.__dict__["_GetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetClockAngleRate"] = _raise_uninitialized_error
        self.__dict__["_SetClockAngleRate"] = _raise_uninitialized_error
        self.__dict__["_GetMode"] = _raise_uninitialized_error
        self.__dict__["_SetMode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorConing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorConing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorConing = agcom.GUID(IVectorConing._uuid)
        vtable_offset_local = IVectorConing._vtable_offset - 1
        self.__dict__["_GetAboutVector"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetStartClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStopClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetClockAngleRate"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetClockAngleRate"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMode"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetMode"] = IAGFUNCTYPE(pUnk, IID_IVectorConing, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorConing.__dict__ and type(IVectorConing.__dict__[attrname]) == property:
            return IVectorConing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorConing.")
    
    @property
    def AboutVector(self) -> "IVectorRefTo":
        """Specify a vector around which the the reference vector is revolved."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAboutVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def StartClockAngle(self) -> float:
        """Specify a start angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartClockAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartClockAngle.setter
    def StartClockAngle(self, startClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(startClockAngle) as arg_startClockAngle:
            agcls.evaluate_hresult(self.__dict__["_SetStartClockAngle"](arg_startClockAngle.COM_val))

    @property
    def StopClockAngle(self) -> float:
        """Specify a stop angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopClockAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopClockAngle.setter
    def StopClockAngle(self, stopClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(stopClockAngle) as arg_stopClockAngle:
            agcls.evaluate_hresult(self.__dict__["_SetStopClockAngle"](arg_stopClockAngle.COM_val))

    @property
    def StartEpoch(self) -> typing.Any:
        """Specify an epoch at which the coning vector is aligned with the reference vector."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartEpoch.setter
    def StartEpoch(self, startEpoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpoch"](arg_startEpoch.COM_val))

    @property
    def ClockAngleRate(self) -> float:
        """Specify a rotation rate."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockAngleRate.setter
    def ClockAngleRate(self, clockAngleRate:float) -> None:
        with agmarshall.DOUBLE_arg(clockAngleRate) as arg_clockAngleRate:
            agcls.evaluate_hresult(self.__dict__["_SetClockAngleRate"](arg_clockAngleRate.COM_val))

    @property
    def Mode(self) -> "AgECrdnSweepMode":
        """Specify either unidirectional or bidirectional mode."""
        with agmarshall.AgEnum_arg(AgECrdnSweepMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Mode.setter
    def Mode(self, mode:"AgECrdnSweepMode") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSweepMode, mode) as arg_mode:
            agcls.evaluate_hresult(self.__dict__["_SetMode"](arg_mode.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}", IVectorConing)
agcls.AgTypeNameMap["IVectorConing"] = IVectorConing

class IVectorCross(object):
    """The vector cross product of two vectors."""
    _uuid = "{F695FE24-7AE1-4935-837F-D7106A3C99A4}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFrom"] = _raise_uninitialized_error
        self.__dict__["_GetTo"] = _raise_uninitialized_error
        self.__dict__["_GetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_SetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorCross._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorCross from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorCross = agcom.GUID(IVectorCross._uuid)
        vtable_offset_local = IVectorCross._vtable_offset - 1
        self.__dict__["_GetFrom"] = IAGFUNCTYPE(pUnk, IID_IVectorCross, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTo"] = IAGFUNCTYPE(pUnk, IID_IVectorCross, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorCross, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorCross, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorCross, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorCross, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorCross.__dict__ and type(IVectorCross.__dict__[attrname]) == property:
            return IVectorCross.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorCross.")
    
    @property
    def From(self) -> "IVectorRefTo":
        """Specify one of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def To(self) -> "IVectorRefTo":
        """Specify the second of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IsNormalized(self) -> bool:
        """Whether to convert the cross product of two vectors to a unit vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsNormalized"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__["_SetIsNormalized"](arg_isNormalized.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F695FE24-7AE1-4935-837F-D7106A3C99A4}", IVectorCross)
agcls.AgTypeNameMap["IVectorCross"] = IVectorCross

class IVectorCustomScript(object):
    """Customized vector components defined with respect to reference axes."""
    _uuid = "{66756C64-795C-4E24-9D6A-E560851BBDE0}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetScriptFile"] = _raise_uninitialized_error
        self.__dict__["_SetScriptFile"] = _raise_uninitialized_error
        self.__dict__["_GetInitializationScriptFile"] = _raise_uninitialized_error
        self.__dict__["_SetInitializationScriptFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorCustomScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorCustomScript = agcom.GUID(IVectorCustomScript._uuid)
        vtable_offset_local = IVectorCustomScript._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorCustomScript, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetInitializationScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorCustomScript, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_SetInitializationScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorCustomScript, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorCustomScript.__dict__ and type(IVectorCustomScript.__dict__[attrname]) == property:
            return IVectorCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorCustomScript.")
    
    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptFile(self) -> str:
        """Specify a script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptFile"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScriptFile.setter
    def ScriptFile(self, scriptFile:str) -> None:
        with agmarshall.BSTR_arg(scriptFile) as arg_scriptFile:
            agcls.evaluate_hresult(self.__dict__["_SetScriptFile"](arg_scriptFile.COM_val))

    @property
    def InitializationScriptFile(self) -> str:
        """Specify an initialization script file (optional). The initialization script is run once, at the beginning of the calculation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitializationScriptFile"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitializationScriptFile.setter
    def InitializationScriptFile(self, initializationScriptFile:str) -> None:
        with agmarshall.BSTR_arg(initializationScriptFile) as arg_initializationScriptFile:
            agcls.evaluate_hresult(self.__dict__["_SetInitializationScriptFile"](arg_initializationScriptFile.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{66756C64-795C-4E24-9D6A-E560851BBDE0}", IVectorCustomScript)
agcls.AgTypeNameMap["IVectorCustomScript"] = IVectorCustomScript

class IVectorDerivative(object):
    """A vector derivative of a vector computed with respect to specified axes."""
    _uuid = "{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        self.__dict__["_SetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorDerivative = agcom.GUID(IVectorDerivative._uuid)
        vtable_offset_local = IVectorDerivative._vtable_offset - 1
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorDerivative, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_IVectorDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_IVectorDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorDerivative.__dict__ and type(IVectorDerivative.__dict__[attrname]) == property:
            return IVectorDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorDerivative.")
    
    @property
    def Vector(self) -> "IVectorRefTo":
        """Specify a base vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceUseOfNumericalDifferences"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__["_SetForceUseOfNumericalDifferences"](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}", IVectorDerivative)
agcls.AgTypeNameMap["IVectorDerivative"] = IVectorDerivative

class IVectorDisplacement(object):
    """Vector defined by its start and end points."""
    _uuid = "{457E8D69-0F1F-4C02-A9D6-F48F86F63853}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOrigin"] = _raise_uninitialized_error
        self.__dict__["_GetDestination"] = _raise_uninitialized_error
        self.__dict__["_GetApparent"] = _raise_uninitialized_error
        self.__dict__["_SetApparent"] = _raise_uninitialized_error
        self.__dict__["_GetIgnoreAberration"] = _raise_uninitialized_error
        self.__dict__["_SetIgnoreAberration"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorDisplacement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorDisplacement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorDisplacement = agcom.GUID(IVectorDisplacement._uuid)
        vtable_offset_local = IVectorDisplacement._vtable_offset - 1
        self.__dict__["_GetOrigin"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDestination"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetApparent"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetApparent"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetIgnoreAberration"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIgnoreAberration"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorDisplacement, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorDisplacement.__dict__ and type(IVectorDisplacement.__dict__[attrname]) == property:
            return IVectorDisplacement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorDisplacement.")
    
    @property
    def Origin(self) -> "IPointRefTo":
        """Specify the vector's origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrigin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Destination(self) -> "IPointRefTo":
        """Specify the vector's destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDestination"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Apparent(self) -> bool:
        """Controls whether to take a light speed delay into account."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetApparent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Apparent.setter
    def Apparent(self, apparent:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(apparent) as arg_apparent:
            agcls.evaluate_hresult(self.__dict__["_SetApparent"](arg_apparent.COM_val))

    @property
    def IgnoreAberration(self) -> bool:
        """Set to true if you do not want to calculate the aberration correction. This property is read-only if Apparent is set to false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIgnoreAberration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IgnoreAberration.setter
    def IgnoreAberration(self, ignoreAberration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(ignoreAberration) as arg_ignoreAberration:
            agcls.evaluate_hresult(self.__dict__["_SetIgnoreAberration"](arg_ignoreAberration.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """Specify a sense of signal transmission. This property is read-only if Apparent is set to false."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def ReferenceSystem(self) -> "ISystemRefTo":
        """Specify a frame in which the light time delay is computed. This property is read-only if Apparent is set to false."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{457E8D69-0F1F-4C02-A9D6-F48F86F63853}", IVectorDisplacement)
agcls.AgTypeNameMap["IVectorDisplacement"] = IVectorDisplacement

class IVectorTwoPlanesIntersection(object):
    """Defined along the intersection of two planes."""
    _uuid = "{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPlaneA"] = _raise_uninitialized_error
        self.__dict__["_GetPlaneB"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorTwoPlanesIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorTwoPlanesIntersection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorTwoPlanesIntersection = agcom.GUID(IVectorTwoPlanesIntersection._uuid)
        vtable_offset_local = IVectorTwoPlanesIntersection._vtable_offset - 1
        self.__dict__["_GetPlaneA"] = IAGFUNCTYPE(pUnk, IID_IVectorTwoPlanesIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPlaneB"] = IAGFUNCTYPE(pUnk, IID_IVectorTwoPlanesIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorTwoPlanesIntersection.__dict__ and type(IVectorTwoPlanesIntersection.__dict__[attrname]) == property:
            return IVectorTwoPlanesIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorTwoPlanesIntersection.")
    
    @property
    def PlaneA(self) -> "IPlaneRefTo":
        """Specify the first of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlaneA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PlaneB(self) -> "IPlaneRefTo":
        """Specify the second of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlaneB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}", IVectorTwoPlanesIntersection)
agcls.AgTypeNameMap["IVectorTwoPlanesIntersection"] = IVectorTwoPlanesIntersection

class IVectorModelAttach(object):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    _uuid = "{C4CCEE5C-B053-413F-8456-6A43720BD314}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorModelAttach = agcom.GUID(IVectorModelAttach._uuid)
        vtable_offset_local = IVectorModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorModelAttach.__dict__ and type(IVectorModelAttach.__dict__[attrname]) == property:
            return IVectorModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C4CCEE5C-B053-413F-8456-6A43720BD314}", IVectorModelAttach)
agcls.AgTypeNameMap["IVectorModelAttach"] = IVectorModelAttach

class IVectorProjection(object):
    """A projection of a vector computed with respect to a reference plane."""
    _uuid = "{2050D921-A98C-408C-8170-FDBB23FEA6E5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSource"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorProjection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorProjection = agcom.GUID(IVectorProjection._uuid)
        vtable_offset_local = IVectorProjection._vtable_offset - 1
        self.__dict__["_GetSource"] = IAGFUNCTYPE(pUnk, IID_IVectorProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVectorProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorProjection.__dict__ and type(IVectorProjection.__dict__[attrname]) == property:
            return IVectorProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorProjection.")
    
    @property
    def Source(self) -> "IVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSource"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2050D921-A98C-408C-8170-FDBB23FEA6E5}", IVectorProjection)
agcls.AgTypeNameMap["IVectorProjection"] = IVectorProjection

class IVectorScaled(object):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    _uuid = "{7D89412E-17A8-43D2-9153-58F45E7072F6}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetScale"] = _raise_uninitialized_error
        self.__dict__["_SetScale"] = _raise_uninitialized_error
        self.__dict__["_GetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_SetIsNormalized"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorScaled = agcom.GUID(IVectorScaled._uuid)
        vtable_offset_local = IVectorScaled._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScale"] = IAGFUNCTYPE(pUnk, IID_IVectorScaled, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScale"] = IAGFUNCTYPE(pUnk, IID_IVectorScaled, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_GetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorScaled, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorScaled, vtable_offset_local+5, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorScaled.__dict__ and type(IVectorScaled.__dict__[attrname]) == property:
            return IVectorScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorScaled.")
    
    @property
    def ReferenceVector(self) -> "IVectorRefTo":
        """A vector being scaled."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Scale(self) -> float:
        """A scaling multiple."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_SetScale"](arg_scale.COM_val))

    @property
    def IsNormalized(self) -> bool:
        """Controls whether to convert the reference vector to a unit vector before scalling."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsNormalized"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__["_SetIsNormalized"](arg_isNormalized.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D89412E-17A8-43D2-9153-58F45E7072F6}", IVectorScaled)
agcls.AgTypeNameMap["IVectorScaled"] = IVectorScaled

class IVectorEccentricity(object):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorEccentricity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorEccentricity = agcom.GUID(IVectorEccentricity._uuid)
        vtable_offset_local = IVectorEccentricity._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorEccentricity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorEccentricity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorEccentricity.__dict__ and type(IVectorEccentricity.__dict__[attrname]) == property:
            return IVectorEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorEccentricity.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}", IVectorEccentricity)
agcls.AgTypeNameMap["IVectorEccentricity"] = IVectorEccentricity

class IVectorFixedInAxes(object):
    """Vector fixed in the reference axes using the selected coordinate type."""
    _uuid = "{912ECDDB-B23C-4B7A-A173-AC22170DA343}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFixedInAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorFixedInAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorFixedInAxes = agcom.GUID(IVectorFixedInAxes._uuid)
        vtable_offset_local = IVectorFixedInAxes._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedInAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedInAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorFixedInAxes.__dict__ and type(IVectorFixedInAxes.__dict__[attrname]) == property:
            return IVectorFixedInAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorFixedInAxes.")
    
    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "IDirection":
        """Specify the vector direction."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{912ECDDB-B23C-4B7A-A173-AC22170DA343}", IVectorFixedInAxes)
agcls.AgTypeNameMap["IVectorFixedInAxes"] = IVectorFixedInAxes

class IVectorLineOfNodes(object):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    _uuid = "{DC23EB21-198C-4E01-9898-D565E937AFF1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorLineOfNodes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorLineOfNodes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorLineOfNodes = agcom.GUID(IVectorLineOfNodes._uuid)
        vtable_offset_local = IVectorLineOfNodes._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorLineOfNodes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorLineOfNodes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorLineOfNodes.__dict__ and type(IVectorLineOfNodes.__dict__[attrname]) == property:
            return IVectorLineOfNodes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorLineOfNodes.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{DC23EB21-198C-4E01-9898-D565E937AFF1}", IVectorLineOfNodes)
agcls.AgTypeNameMap["IVectorLineOfNodes"] = IVectorLineOfNodes

class IVectorOrbitAngularMomentum(object):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = "{22C8270A-7B36-40D7-9EC5-44FED3DEE541}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorOrbitAngularMomentum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorOrbitAngularMomentum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorOrbitAngularMomentum = agcom.GUID(IVectorOrbitAngularMomentum._uuid)
        vtable_offset_local = IVectorOrbitAngularMomentum._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitAngularMomentum, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitAngularMomentum, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitAngularMomentum, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitAngularMomentum, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorOrbitAngularMomentum.__dict__ and type(IVectorOrbitAngularMomentum.__dict__[attrname]) == property:
            return IVectorOrbitAngularMomentum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorOrbitAngularMomentum.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{22C8270A-7B36-40D7-9EC5-44FED3DEE541}", IVectorOrbitAngularMomentum)
agcls.AgTypeNameMap["IVectorOrbitAngularMomentum"] = IVectorOrbitAngularMomentum

class IVectorOrbitNormal(object):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = "{296D4695-53FE-40B7-BA3E-41A3C04A805F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorOrbitNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorOrbitNormal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorOrbitNormal = agcom.GUID(IVectorOrbitNormal._uuid)
        vtable_offset_local = IVectorOrbitNormal._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitNormal, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorOrbitNormal, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorOrbitNormal.__dict__ and type(IVectorOrbitNormal.__dict__[attrname]) == property:
            return IVectorOrbitNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorOrbitNormal.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{296D4695-53FE-40B7-BA3E-41A3C04A805F}", IVectorOrbitNormal)
agcls.AgTypeNameMap["IVectorOrbitNormal"] = IVectorOrbitNormal

class IVectorPeriapsis(object):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorPeriapsis = agcom.GUID(IVectorPeriapsis._uuid)
        vtable_offset_local = IVectorPeriapsis._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorPeriapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorPeriapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorPeriapsis.__dict__ and type(IVectorPeriapsis.__dict__[attrname]) == property:
            return IVectorPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorPeriapsis.")
    
    @property
    def CentralBody(self) -> "ICentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}", IVectorPeriapsis)
agcls.AgTypeNameMap["IVectorPeriapsis"] = IVectorPeriapsis

class IVectorReflection(object):
    """A vector (incident vector) reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    _uuid = "{AF054174-278A-41E6-B8FA-0FC48E19A8BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIncomingVector"] = _raise_uninitialized_error
        self.__dict__["_GetUseOppositeOfSelectedVector"] = _raise_uninitialized_error
        self.__dict__["_SetUseOppositeOfSelectedVector"] = _raise_uninitialized_error
        self.__dict__["_GetNormalVector"] = _raise_uninitialized_error
        self.__dict__["_GetAllowReflectionsOnBackside"] = _raise_uninitialized_error
        self.__dict__["_SetAllowReflectionsOnBackside"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorReflection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorReflection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorReflection = agcom.GUID(IVectorReflection._uuid)
        vtable_offset_local = IVectorReflection._vtable_offset - 1
        self.__dict__["_GetIncomingVector"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetUseOppositeOfSelectedVector"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseOppositeOfSelectedVector"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__["_GetNormalVector"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAllowReflectionsOnBackside"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowReflectionsOnBackside"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorReflection, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorReflection.__dict__ and type(IVectorReflection.__dict__[attrname]) == property:
            return IVectorReflection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorReflection.")
    
    @property
    def IncomingVector(self) -> "IVectorRefTo":
        """The reflecting vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncomingVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseOppositeOfSelectedVector(self) -> bool:
        """When set to false, resets the direction of the Incident Vector to default."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseOppositeOfSelectedVector"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseOppositeOfSelectedVector.setter
    def UseOppositeOfSelectedVector(self, useOppositeOfSelectedVector:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useOppositeOfSelectedVector) as arg_useOppositeOfSelectedVector:
            agcls.evaluate_hresult(self.__dict__["_SetUseOppositeOfSelectedVector"](arg_useOppositeOfSelectedVector.COM_val))

    @property
    def NormalVector(self) -> "IVectorRefTo":
        """The vector defines the reflection surface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AllowReflectionsOnBackside(self) -> bool:
        """Controls whether to reflect the indicent vector on both sides of the plane."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowReflectionsOnBackside"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AllowReflectionsOnBackside.setter
    def AllowReflectionsOnBackside(self, allowReflectionsOnBackside:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowReflectionsOnBackside) as arg_allowReflectionsOnBackside:
            agcls.evaluate_hresult(self.__dict__["_SetAllowReflectionsOnBackside"](arg_allowReflectionsOnBackside.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """The vector's scale factor."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactor"](arg_scaleFactor.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AF054174-278A-41E6-B8FA-0FC48E19A8BC}", IVectorReflection)
agcls.AgTypeNameMap["IVectorReflection"] = IVectorReflection

class IVectorRotationVector(object):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    _uuid = "{2dc152fa-f029-4bc6-bc47-f27d92219a32}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetForceMinimumRotation"] = _raise_uninitialized_error
        self.__dict__["_SetForceMinimumRotation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorRotationVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorRotationVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorRotationVector = agcom.GUID(IVectorRotationVector._uuid)
        vtable_offset_local = IVectorRotationVector._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorRotationVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorRotationVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetForceMinimumRotation"] = IAGFUNCTYPE(pUnk, IID_IVectorRotationVector, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceMinimumRotation"] = IAGFUNCTYPE(pUnk, IID_IVectorRotationVector, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorRotationVector.__dict__ and type(IVectorRotationVector.__dict__[attrname]) == property:
            return IVectorRotationVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorRotationVector.")
    
    @property
    def Axes(self) -> "IAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ForceMinimumRotation(self) -> bool:
        """Insures that the rotation angle will be between 0 and pi. If the angle is increasing at pi, then the axis direction will be negated to keep phi less than pi."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceMinimumRotation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceMinimumRotation.setter
    def ForceMinimumRotation(self, forceMinimumRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceMinimumRotation) as arg_forceMinimumRotation:
            agcls.evaluate_hresult(self.__dict__["_SetForceMinimumRotation"](arg_forceMinimumRotation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2dc152fa-f029-4bc6-bc47-f27d92219a32}", IVectorRotationVector)
agcls.AgTypeNameMap["IVectorRotationVector"] = IVectorRotationVector

class IVectorDirectionToStar(object):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    _uuid = "{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSelectedStar"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedStar"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorDirectionToStar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorDirectionToStar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorDirectionToStar = agcom.GUID(IVectorDirectionToStar._uuid)
        vtable_offset_local = IVectorDirectionToStar._vtable_offset - 1
        self.__dict__["_GetSelectedStar"] = IAGFUNCTYPE(pUnk, IID_IVectorDirectionToStar, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedStar"] = IAGFUNCTYPE(pUnk, IID_IVectorDirectionToStar, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorDirectionToStar.__dict__ and type(IVectorDirectionToStar.__dict__[attrname]) == property:
            return IVectorDirectionToStar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorDirectionToStar.")
    
    @property
    def SelectedStar(self) -> str:
        """A fully qualified path to a Star object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedStar"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedStar.setter
    def SelectedStar(self, selectedStar:str) -> None:
        with agmarshall.BSTR_arg(selectedStar) as arg_selectedStar:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedStar"](arg_selectedStar.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}", IVectorDirectionToStar)
agcls.AgTypeNameMap["IVectorDirectionToStar"] = IVectorDirectionToStar

class IVectorFixedAtTimeInstant(object):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    _uuid = "{B35CE60F-7CC5-4289-9052-2203B609087E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_SetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorFixedAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorFixedAtTimeInstant = agcom.GUID(IVectorFixedAtTimeInstant._uuid)
        vtable_offset_local = IVectorFixedAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorFixedAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorFixedAtTimeInstant.__dict__ and type(IVectorFixedAtTimeInstant.__dict__[attrname]) == property:
            return IVectorFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorFixedAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "IEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourceVector(self) -> "IVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, IVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__["_SetSourceVector"](arg_sourceVector.COM_val))

    @property
    def ReferenceAxes(self) -> "IAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B35CE60F-7CC5-4289-9052-2203B609087E}", IVectorFixedAtTimeInstant)
agcls.AgTypeNameMap["IVectorFixedAtTimeInstant"] = IVectorFixedAtTimeInstant

class IVectorLinearCombination(object):
    """Linear combination of two input vectors."""
    _uuid = "{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorLinearCombination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorLinearCombination = agcom.GUID(IVectorLinearCombination._uuid)
        vtable_offset_local = IVectorLinearCombination._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorLinearCombination, vtable_offset_local+16, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorLinearCombination.__dict__ and type(IVectorLinearCombination.__dict__[attrname]) == property:
            return IVectorLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorLinearCombination.")
    
    @property
    def VectorA(self) -> "IVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorA"](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "IVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorB"](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}", IVectorLinearCombination)
agcls.AgTypeNameMap["IVectorLinearCombination"] = IVectorLinearCombination

class IVectorProjectAlongVector(object):
    """A projection of a source vector in the direction of another vector."""
    _uuid = "{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_SetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorProjectAlongVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorProjectAlongVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorProjectAlongVector = agcom.GUID(IVectorProjectAlongVector._uuid)
        vtable_offset_local = IVectorProjectAlongVector._vtable_offset - 1
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorProjectAlongVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorProjectAlongVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVectorProjectAlongVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVectorProjectAlongVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorProjectAlongVector.__dict__ and type(IVectorProjectAlongVector.__dict__[attrname]) == property:
            return IVectorProjectAlongVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorProjectAlongVector.")
    
    @property
    def SourceVector(self) -> "IVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, IVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__["_SetSourceVector"](arg_sourceVector.COM_val))

    @property
    def AlongVector(self) -> "IVector":
        """A vector along which the source vector is projected. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}", IVectorProjectAlongVector)
agcls.AgTypeNameMap["IVectorProjectAlongVector"] = IVectorProjectAlongVector

class IVectorScalarLinearCombination(object):
    """Linear combination of two input vectors using scalars."""
    _uuid = "{0886A066-8650-4C8D-B234-14D28A175A78}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetUseScaleFromScalarA"] = _raise_uninitialized_error
        self.__dict__["_SetUseScaleFromScalarA"] = _raise_uninitialized_error
        self.__dict__["_GetUseScaleFromScalarB"] = _raise_uninitialized_error
        self.__dict__["_SetUseScaleFromScalarB"] = _raise_uninitialized_error
        self.__dict__["_GetScalarA"] = _raise_uninitialized_error
        self.__dict__["_SetScalarA"] = _raise_uninitialized_error
        self.__dict__["_GetScalarB"] = _raise_uninitialized_error
        self.__dict__["_SetScalarB"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorScalarLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorScalarLinearCombination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorScalarLinearCombination = agcom.GUID(IVectorScalarLinearCombination._uuid)
        vtable_offset_local = IVectorScalarLinearCombination._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseScaleFromScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScaleFromScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseScaleFromScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScaleFromScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+16, agcom.PVOID)
        self.__dict__["_GetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarLinearCombination, vtable_offset_local+24, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorScalarLinearCombination.__dict__ and type(IVectorScalarLinearCombination.__dict__[attrname]) == property:
            return IVectorScalarLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorScalarLinearCombination.")
    
    @property
    def VectorA(self) -> "IVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorA"](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def UseScaleFromScalarA(self) -> bool:
        """Whether to use a scale from scalar A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScaleFromScalarA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarA.setter
    def UseScaleFromScalarA(self, useScaleFromScalarA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarA) as arg_useScaleFromScalarA:
            agcls.evaluate_hresult(self.__dict__["_SetUseScaleFromScalarA"](arg_useScaleFromScalarA.COM_val))

    @property
    def UseScaleFromScalarB(self) -> bool:
        """Whether to use a scale from scalar B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScaleFromScalarB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarB.setter
    def UseScaleFromScalarB(self, useScaleFromScalarB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarB) as arg_useScaleFromScalarB:
            agcls.evaluate_hresult(self.__dict__["_SetUseScaleFromScalarB"](arg_useScaleFromScalarB.COM_val))

    @property
    def ScalarA(self) -> "ICalcScalar":
        """Scalar scale A. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarA.setter
    def ScalarA(self, scalarA:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarA, ICalcScalar) as arg_scalarA:
            agcls.evaluate_hresult(self.__dict__["_SetScalarA"](arg_scalarA.COM_val))

    @property
    def ScalarB(self) -> "ICalcScalar":
        """Scalar scale B. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarB.setter
    def ScalarB(self, scalarB:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarB, ICalcScalar) as arg_scalarB:
            agcls.evaluate_hresult(self.__dict__["_SetScalarB"](arg_scalarB.COM_val))

    @property
    def VectorB(self) -> "IVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorB"](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0886A066-8650-4C8D-B234-14D28A175A78}", IVectorScalarLinearCombination)
agcls.AgTypeNameMap["IVectorScalarLinearCombination"] = IVectorScalarLinearCombination

class IVectorScalarScaled(object):
    """Scaled version of the input vector using scalar."""
    _uuid = "{306C3852-C3E9-43EB-9371-1B9540B52097}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_GetNormalize"] = _raise_uninitialized_error
        self.__dict__["_SetNormalize"] = _raise_uninitialized_error
        self.__dict__["_GetDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorScalarScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorScalarScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorScalarScaled = agcom.GUID(IVectorScalarScaled._uuid)
        vtable_offset_local = IVectorScalarScaled._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorScalarScaled, vtable_offset_local+12, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorScalarScaled.__dict__ and type(IVectorScalarScaled.__dict__[attrname]) == property:
            return IVectorScalarScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorScalarScaled.")
    
    @property
    def InputVector(self) -> "IVector":
        """An input vector scaled by the scalar. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))

    @property
    def InputScalar(self) -> "ICalcScalar":
        """A variable scale applied to the input vector. Can be based on any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """A constant scale applied to the input vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactor"](arg_scaleFactor.COM_val))

    @property
    def Normalize(self) -> bool:
        """Whether to normalize the input vector before applying constant and variable scales."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalize"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Normalize.setter
    def Normalize(self, normalize:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalize) as arg_normalize:
            agcls.evaluate_hresult(self.__dict__["_SetNormalize"](arg_normalize.COM_val))

    @property
    def DimensionInheritance(self) -> "AgECrdnVectorScaledDimensionInheritance":
        """Whether or not to inherit dimension from the input vector or the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DimensionInheritance.setter
    def DimensionInheritance(self, dimensionInheritance:"AgECrdnVectorScaledDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance, dimensionInheritance) as arg_dimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetDimensionInheritance"](arg_dimensionInheritance.COM_val))

    @property
    def Dimension(self) -> str:
        """A dimension assigned to the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{306C3852-C3E9-43EB-9371-1B9540B52097}", IVectorScalarScaled)
agcls.AgTypeNameMap["IVectorScalarScaled"] = IVectorScalarScaled

class IVectorVelocityAcceleration(object):
    """Velocity vector of a point in a coordinate system."""
    _uuid = "{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorVelocityAcceleration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorVelocityAcceleration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorVelocityAcceleration = agcom.GUID(IVectorVelocityAcceleration._uuid)
        vtable_offset_local = IVectorVelocityAcceleration._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorVelocityAcceleration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorVelocityAcceleration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorVelocityAcceleration, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorVelocityAcceleration, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorVelocityAcceleration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorVelocityAcceleration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorVelocityAcceleration.__dict__ and type(IVectorVelocityAcceleration.__dict__[attrname]) == property:
            return IVectorVelocityAcceleration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorVelocityAcceleration.")
    
    @property
    def ReferenceSystem(self) -> "ISystem":
        """A reference (coordinate) system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ISystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ISystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def Point(self) -> "IPoint":
        """A point which velocity this vector represents. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}", IVectorVelocityAcceleration)
agcls.AgTypeNameMap["IVectorVelocityAcceleration"] = IVectorVelocityAcceleration

class IVectorPlugin(object):
    """A VGT vector plugin."""
    _uuid = "{F889F617-059E-4BC9-9000-206091889FEB}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorPlugin = agcom.GUID(IVectorPlugin._uuid)
        vtable_offset_local = IVectorPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_IVectorPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_IVectorPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_IVectorPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorPlugin.__dict__ and type(IVectorPlugin.__dict__[attrname]) == property:
            return IVectorPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F889F617-059E-4BC9-9000-206091889FEB}", IVectorPlugin)
agcls.AgTypeNameMap["IVectorPlugin"] = IVectorPlugin

class IVectorDispSurface(object):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    _uuid = "{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_SetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_GetDestinationPoint"] = _raise_uninitialized_error
        self.__dict__["_SetDestinationPoint"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorDispSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorDispSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorDispSurface = agcom.GUID(IVectorDispSurface._uuid)
        vtable_offset_local = IVectorDispSurface._vtable_offset - 1
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDestinationPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetDestinationPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorDispSurface, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorDispSurface.__dict__ and type(IVectorDispSurface.__dict__[attrname]) == property:
            return IVectorDispSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorDispSurface.")
    
    @property
    def OriginPoint(self) -> "IPoint":
        """An origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginPoint.setter
    def OriginPoint(self, originPoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(originPoint, IPoint) as arg_originPoint:
            agcls.evaluate_hresult(self.__dict__["_SetOriginPoint"](arg_originPoint.COM_val))

    @property
    def DestinationPoint(self) -> "IPoint":
        """Destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDestinationPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DestinationPoint.setter
    def DestinationPoint(self, destinationPoint:"IPoint") -> None:
        with agmarshall.AgInterface_in_arg(destinationPoint, IPoint) as arg_destinationPoint:
            agcls.evaluate_hresult(self.__dict__["_SetDestinationPoint"](arg_destinationPoint.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """surface central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceCentralBody"](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in displacement on surface vector. (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}", IVectorDispSurface)
agcls.AgTypeNameMap["IVectorDispSurface"] = IVectorDispSurface

class IVectorFactory(object):
    """A Factory object to create vectors."""
    _uuid = "{09F7F253-392A-44D9-9701-51CC0110C033}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateDisplacementVector"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableVectorPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreateVectorPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_CreateCrossProductVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorFactory = agcom.GUID(IVectorFactory._uuid)
        vtable_offset_local = IVectorFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVectorFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVectorFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateDisplacementVector"] = IAGFUNCTYPE(pUnk, IID_IVectorFactory, vtable_offset_local+3, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetAvailableVectorPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_IVectorFactory, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreateVectorPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCrossProductVector"] = IAGFUNCTYPE(pUnk, IID_IVectorFactory, vtable_offset_local+6, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorFactory.__dict__ and type(IVectorFactory.__dict__[attrname]) == property:
            return IVectorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorFactory.")
    
    def Create(self, vectorName:str, description:str, vectorType:"AgECrdnVectorType") -> "IVector":
        """Creates a VGT vector using specified name, description and type."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVectorType, vectorType) as arg_vectorType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_vectorName.COM_val, arg_description.COM_val, arg_vectorType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnVectorType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateDisplacementVector(self, vectorName:str, originPoint:"IPoint", destPoint:"IPoint") -> "IVectorDisplacement":
        """Creates a displacement vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(originPoint, IPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(destPoint, IPoint) as arg_destPoint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateDisplacementVector"](arg_vectorName.COM_val, arg_originPoint.COM_val, arg_destPoint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AvailableVectorPluginDisplayNames(self) -> list:
        """An array of display names associated with available vector plugins. The elements of the array are strings. Display names are used to create VGT vectors based on COM plugins using CreateVectorPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableVectorPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVectorPluginFromDisplayName(self, vectorName:str, description:str, displayName:str) -> "IVector":
        """Create a vector component based on a COM vector plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVectorPluginFromDisplayName"](arg_vectorName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCrossProductVector(self, vectorName:str, vectorA:"IVector", vectorB:"IVector") -> "IVectorCross":
        """Creates a cross product C = A x B."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(vectorA, IVector) as arg_vectorA, \
             agmarshall.AgInterface_in_arg(vectorB, IVector) as arg_vectorB, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCrossProductVector"](arg_vectorName.COM_val, arg_vectorA.COM_val, arg_vectorB.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{09F7F253-392A-44D9-9701-51CC0110C033}", IVectorFactory)
agcls.AgTypeNameMap["IVectorFactory"] = IVectorFactory

class IAxesFactory(object):
    """A Factory object to create axes."""
    _uuid = "{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableAxesPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreateAxesPluginFromDisplayName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesFactory = agcom.GUID(IAxesFactory._uuid)
        vtable_offset_local = IAxesFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IAxesFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IAxesFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAvailableAxesPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_IAxesFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreateAxesPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_IAxesFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesFactory.__dict__ and type(IAxesFactory.__dict__[attrname]) == property:
            return IAxesFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesFactory.")
    
    def Create(self, axesName:str, description:str, axesType:"AgECrdnAxesType") -> "IAxes":
        """Creates a VGT axes using specified name, description and type."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAxesType, axesType) as arg_axesType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_axesName.COM_val, arg_description.COM_val, arg_axesType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAxesType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableAxesPluginDisplayNames(self) -> list:
        """An array of display names associated with available axes plugins. The elements of the array are strings. Display names are used to create VGT axes based on COM plugins using CreateAxesPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableAxesPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAxesPluginFromDisplayName(self, axesName:str, description:str, displayName:str) -> "IAxes":
        """Create an axes component based on a COM axes plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateAxesPluginFromDisplayName"](arg_axesName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}", IAxesFactory)
agcls.AgTypeNameMap["IAxesFactory"] = IAxesFactory

class ISystemFactory(object):
    """A Factory interface to create VGT systems."""
    _uuid = "{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemFactory = agcom.GUID(ISystemFactory._uuid)
        vtable_offset_local = ISystemFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ISystemFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ISystemFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemFactory.__dict__ and type(ISystemFactory.__dict__[attrname]) == property:
            return ISystemFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemFactory.")
    
    def Create(self, systemName:str, description:str, systemType:"AgECrdnSystemType") -> "ISystem":
        """Creates a VGT system using the specified name, description and type."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnSystemType, systemType) as arg_systemType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_systemName.COM_val, arg_description.COM_val, arg_systemType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnSystemType") -> bool:
        """Returns true if the specified system type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}", ISystemFactory)
agcls.AgTypeNameMap["ISystemFactory"] = ISystemFactory

class IPointFactory(object):
    """A Factory object to create points."""
    _uuid = "{18FA11DA-BC93-4467-B53F-4D894739C3A3}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_GetAvailablePointPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreatePointPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_CreatePointFixedOnCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointFactory = agcom.GUID(IPointFactory._uuid)
        vtable_offset_local = IPointFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IPointFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IPointFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAvailablePointPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_IPointFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreatePointPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_IPointFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreatePointFixedOnCentralBody"] = IAGFUNCTYPE(pUnk, IID_IPointFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointFactory.__dict__ and type(IPointFactory.__dict__[attrname]) == property:
            return IPointFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointFactory.")
    
    def Create(self, pointName:str, description:str, pointType:"AgECrdnPointType") -> "IPoint":
        """Creates a VGT point using the specified name, description and type."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPointType, pointType) as arg_pointType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_pointName.COM_val, arg_description.COM_val, arg_pointType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPointType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPointType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailablePointPluginDisplayNames(self) -> list:
        """An array of display names associated with available point plugins. The elements of the array are strings. Display names are used to create VGT points based on COM plugins using CreatePointPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailablePointPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointPluginFromDisplayName(self, pointName:str, description:str, displayName:str) -> "IPoint":
        """Create a point component based on a COM point plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreatePointPluginFromDisplayName"](arg_pointName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointFixedOnCentralBody(self, pointName:str, description:str, longitude:typing.Any, latitude:typing.Any, altitude:float, referenceShape:"AgECrdnReferenceShapeType") -> "IPoint":
        """Creates a point fixed on a central body."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreatePointFixedOnCentralBody"](arg_pointName.COM_val, arg_description.COM_val, arg_longitude.COM_val, arg_latitude.COM_val, arg_altitude.COM_val, arg_referenceShape.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{18FA11DA-BC93-4467-B53F-4D894739C3A3}", IPointFactory)
agcls.AgTypeNameMap["IPointFactory"] = IPointFactory

class IPlaneFactory(object):
    """A Factory object to create VGT planes."""
    _uuid = "{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneFactory = agcom.GUID(IPlaneFactory._uuid)
        vtable_offset_local = IPlaneFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IPlaneFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IPlaneFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneFactory.__dict__ and type(IPlaneFactory.__dict__[attrname]) == property:
            return IPlaneFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneFactory.")
    
    def Create(self, planeName:str, description:str, planeType:"AgECrdnPlaneType") -> "IPlane":
        """Creates a VGT plane using the specified name, description and type."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPlaneType, planeType) as arg_planeType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_planeName.COM_val, arg_description.COM_val, arg_planeType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPlaneType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}", IPlaneFactory)
agcls.AgTypeNameMap["IPlaneFactory"] = IPlaneFactory

class IAngleFactory(object):
    """A Factory object to create angles."""
    _uuid = "{703883F3-9716-4D37-8930-184BECDE1461}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleFactory = agcom.GUID(IAngleFactory._uuid)
        vtable_offset_local = IAngleFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IAngleFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IAngleFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleFactory.__dict__ and type(IAngleFactory.__dict__[attrname]) == property:
            return IAngleFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleFactory.")
    
    def Create(self, angleName:str, description:str, angleType:"AgECrdnAngleType") -> "IAngle":
        """Creates a VGT angle using specified name, description and type."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAngleType, angleType) as arg_angleType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_angleName.COM_val, arg_description.COM_val, arg_angleType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAngleType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{703883F3-9716-4D37-8930-184BECDE1461}", IAngleFactory)
agcls.AgTypeNameMap["IAngleFactory"] = IAngleFactory

class IVectorGroup(object):
    """Access or create VGT vectors associated with an object or a central body."""
    _uuid = "{4412F0DD-2138-4653-8D20-9B4A0CA450D4}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGroup = agcom.GUID(IVectorGroup._uuid)
        vtable_offset_local = IVectorGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVectorGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGroup.__dict__ and type(IVectorGroup.__dict__[attrname]) == property:
            return IVectorGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVector":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, vectorName:str) -> None:
        """Removes a specified vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_vectorName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVectorFactory":
        """Returns a Factory object used to create custom vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVector":
        """Returns a vector by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVector":
        """Retrieves a vector from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVector":
        """Retrieves a vector from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{4412F0DD-2138-4653-8D20-9B4A0CA450D4}", IVectorGroup)
agcls.AgTypeNameMap["IVectorGroup"] = IVectorGroup

class IPointGroup(object):
    """Access or create VGT points associated with an object or a central body."""
    _uuid = "{6FB1415A-EC77-476F-B650-CC6813BE740C}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointGroup = agcom.GUID(IPointGroup._uuid)
        vtable_offset_local = IPointGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IPointGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointGroup.__dict__ and type(IPointGroup.__dict__[attrname]) == property:
            return IPointGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IPoint":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, pointName:str) -> None:
        """Removes a specified point by name."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_pointName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IPointFactory":
        """Returns a Factory object used to create custom points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IPoint":
        """Returns a point by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IPointCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known point types, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IPoint":
        """Retrieves a point from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IPoint":
        """Retrieves a point from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{6FB1415A-EC77-476F-B650-CC6813BE740C}", IPointGroup)
agcls.AgTypeNameMap["IPointGroup"] = IPointGroup

class IAngleGroup(object):
    """Access or create VGT angles associated with an object or a central body."""
    _uuid = "{C025A1BA-F856-4B26-9134-BBCC785B6C45}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleGroup = agcom.GUID(IAngleGroup._uuid)
        vtable_offset_local = IAngleGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IAngleGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleGroup.__dict__ and type(IAngleGroup.__dict__[attrname]) == property:
            return IAngleGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IAngle":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, angleName:str) -> None:
        """Removes a specified Angle."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_angleName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAngleFactory":
        """Returns a Factory object used to create custom angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAngle":
        """Returns an angle by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IAngle":
        """Retrieves an angle from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IAngle":
        """Retrieves an angle from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{C025A1BA-F856-4B26-9134-BBCC785B6C45}", IAngleGroup)
agcls.AgTypeNameMap["IAngleGroup"] = IAngleGroup

class IAxesGroup(object):
    """Access or create VGT axes associated with an object or a central body."""
    _uuid = "{21C67E72-992F-481F-B77F-1DFC43B4B705}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesGroup = agcom.GUID(IAxesGroup._uuid)
        vtable_offset_local = IAxesGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IAxesGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesGroup.__dict__ and type(IAxesGroup.__dict__[attrname]) == property:
            return IAxesGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IAxes":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, axesName:str) -> None:
        """Removes a specified Axes."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_axesName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAxesFactory":
        """Returns a Factory object used to create custom axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAxes":
        """Returns an axes by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IAxesCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known axes, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IAxes":
        """Retrieves an axes from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IAxes":
        """Retrieves an axes from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{21C67E72-992F-481F-B77F-1DFC43B4B705}", IAxesGroup)
agcls.AgTypeNameMap["IAxesGroup"] = IAxesGroup

class IPlaneGroup(object):
    """Represents a single entry point to manipulate VGT Planes associated with an object."""
    _uuid = "{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneGroup = agcom.GUID(IPlaneGroup._uuid)
        vtable_offset_local = IPlaneGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IPlaneGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneGroup.__dict__ and type(IPlaneGroup.__dict__[attrname]) == property:
            return IPlaneGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IPlane":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, planeName:str) -> None:
        """Removes a specified Plane."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_planeName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IPlaneFactory":
        """Returns a Factory object used to create custom planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IPlane":
        """Returns an Plane by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IPlane":
        """Retrieves a plane from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IPlane":
        """Retrieves a plane from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}", IPlaneGroup)
agcls.AgTypeNameMap["IPlaneGroup"] = IPlaneGroup

class ISystemGroup(object):
    """Access or create VGT systems associated with an object or a central body."""
    _uuid = "{05FF6322-1363-4B66-933E-03EA158B7523}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemGroup = agcom.GUID(ISystemGroup._uuid)
        vtable_offset_local = ISystemGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ISystemGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemGroup.__dict__ and type(ISystemGroup.__dict__[attrname]) == property:
            return ISystemGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISystem":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, systemName:str) -> None:
        """Removes a specified System."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_systemName.COM_val))

    @property
    def Context(self) -> "IContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ISystemFactory":
        """Returns a Factory object used to create custom VGT systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ISystem":
        """Returns a System by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "ISystemCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known systems, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ISystem":
        """Retrieves a system from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ISystem":
        """Retrieves a system from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{05FF6322-1363-4B66-933E-03EA158B7523}", ISystemGroup)
agcls.AgTypeNameMap["ISystemGroup"] = ISystemGroup

class IProvider(object):
    """Allows accessing existing Vector Geometry Tool components."""
    _uuid = "{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectors"] = _raise_uninitialized_error
        self.__dict__["_GetPoints"] = _raise_uninitialized_error
        self.__dict__["_GetAngles"] = _raise_uninitialized_error
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetPlanes"] = _raise_uninitialized_error
        self.__dict__["_GetSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEvents"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetCalcScalars"] = _raise_uninitialized_error
        self.__dict__["_GetEventArrays"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervalLists"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervalCollections"] = _raise_uninitialized_error
        self.__dict__["_GetParameterSets"] = _raise_uninitialized_error
        self.__dict__["_GetConditions"] = _raise_uninitialized_error
        self.__dict__["_Supports"] = _raise_uninitialized_error
        self.__dict__["_GetConditionSets"] = _raise_uninitialized_error
        self.__dict__["_Import"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeGrids"] = _raise_uninitialized_error
        self.__dict__["_GetVolumes"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeCalcs"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProvider._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProvider from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProvider = agcom.GUID(IProvider._uuid)
        vtable_offset_local = IProvider._vtable_offset - 1
        self.__dict__["_GetVectors"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPoints"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetAngles"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetPlanes"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetSystems"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownSystems"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownAxes"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetEvents"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervals"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_GetCalcScalars"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_GetEventArrays"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervalLists"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervalCollections"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_GetParameterSets"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetConditions"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+16, POINTER(agcom.PVOID))
        self.__dict__["_Supports"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+17, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetConditionSets"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_Import"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+19, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumeGrids"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+20, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumes"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumeCalcs"] = IAGFUNCTYPE(pUnk, IID_IProvider, vtable_offset_local+22, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProvider.__dict__ and type(IProvider.__dict__[attrname]) == property:
            return IProvider.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProvider.")
    
    @property
    def Vectors(self) -> "IVectorGroup":
        """Returns a group of vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectors"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Points(self) -> "IPointGroup":
        """Returns a group of points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Angles(self) -> "IAngleGroup":
        """Returns a group of angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngles"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Axes(self) -> "IAxesGroup":
        """Returns a group of axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Planes(self) -> "IPlaneGroup":
        """Returns a group of planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlanes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Systems(self) -> "ISystemGroup":
        """Returns a group of systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "IWellKnownSystems":
        """Returns well-known systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "IWellKnownAxes":
        """Returns well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Events(self) -> "IEventGroup":
        """Returns a group of events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEvents"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervals(self) -> "IEventIntervalGroup":
        """Returns a group of event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CalcScalars(self) -> "ICalcScalarGroup":
        """Returns a group of calc scalars."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcScalars"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventArrays(self) -> "IEventArrayGroup":
        """Returns a group of event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventArrays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalLists(self) -> "IEventIntervalListGroup":
        """Returns a group of event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervalLists"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalCollections(self) -> "IEventIntervalCollectionGroup":
        """Returns a group of event interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervalCollections"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ParameterSets(self) -> "IParameterSetGroup":
        """Access, add new or remove existing parameter set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetParameterSets"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Conditions(self) -> "IConditionGroup":
        """Returns a group of condition objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Supports(self, feature:"AgECrdnKind") -> bool:
        """Tests whether the specified VGT feature is supported."""
        with agmarshall.AgEnum_arg(AgECrdnKind, feature) as arg_feature, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Supports"](arg_feature.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ConditionSets(self) -> "IConditionSetGroup":
        """Returns a group of condition set objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionSets"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Import(self, filename:str) -> "ICollection":
        """Imports Analysis Workbench components from a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Import"](arg_filename.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeGrids(self) -> "IVolumeGridGroup":
        """Returns a group of volume grid objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeGrids"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Volumes(self) -> "IVolumeGroup":
        """Returns a group of volume objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeCalcs(self) -> "IVolumeCalcGroup":
        """Returns a group of volume calc objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeCalcs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}", IProvider)
agcls.AgTypeNameMap["IProvider"] = IProvider

class IRoot(object):
    """Represents a VGT root object."""
    _uuid = "{FEF8B20D-5EEB-4299-8775-038EE30AA30B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTemplateProvider"] = _raise_uninitialized_error
        self.__dict__["_GetProvider"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRoot._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRoot from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRoot = agcom.GUID(IRoot._uuid)
        vtable_offset_local = IRoot._vtable_offset - 1
        self.__dict__["_GetTemplateProvider"] = IAGFUNCTYPE(pUnk, IID_IRoot, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetProvider"] = IAGFUNCTYPE(pUnk, IID_IRoot, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownSystems"] = IAGFUNCTYPE(pUnk, IID_IRoot, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownAxes"] = IAGFUNCTYPE(pUnk, IID_IRoot, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRoot.__dict__ and type(IRoot.__dict__[attrname]) == property:
            return IRoot.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRoot.")
    
    def GetTemplateProvider(self, className:str) -> "IProvider":
        """Returns a template provider. The method takes a class name (i.e. \"Satellite\", \"Facility\", etc.)"""
        with agmarshall.BSTR_arg(className) as arg_className, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTemplateProvider"](arg_className.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetProvider(self, instPath:str) -> "IProvider":
        """Returns an instance provider. The method takes a short instance path to an STK object or a central body.(i.e. \"Satellite/Satellite1\", \"CentralBody/Earth\", etc.)"""
        with agmarshall.BSTR_arg(instPath) as arg_instPath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvider"](arg_instPath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "IWellKnownSystems":
        """Returns the most commonly used systems (e.g. Sun Fixed, Earth Fixed, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "IWellKnownAxes":
        """Returns the most commonly used axes (e.g. Sun ICRF, Earth Inertial, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FEF8B20D-5EEB-4299-8775-038EE30AA30B}", IRoot)
agcls.AgTypeNameMap["IRoot"] = IRoot

class IWellKnownEarthSystems(object):
    """Well-known Earth's coordinate systems."""
    _uuid = "{230A8949-FB8F-415E-A786-5EED50AEB11B}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWellKnownEarthSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWellKnownEarthSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWellKnownEarthSystems = agcom.GUID(IWellKnownEarthSystems._uuid)
        vtable_offset_local = IWellKnownEarthSystems._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IWellKnownEarthSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IWellKnownEarthSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IWellKnownEarthSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWellKnownEarthSystems.__dict__ and type(IWellKnownEarthSystems.__dict__[attrname]) == property:
            return IWellKnownEarthSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWellKnownEarthSystems.")
    
    @property
    def Fixed(self) -> "ISystem":
        """Earth's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "ISystem":
        """Earth's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "ISystem":
        """Earth's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{230A8949-FB8F-415E-A786-5EED50AEB11B}", IWellKnownEarthSystems)
agcls.AgTypeNameMap["IWellKnownEarthSystems"] = IWellKnownEarthSystems

class IWellKnownEarthAxes(object):
    """Well-known Earth's axes."""
    _uuid = "{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWellKnownEarthAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWellKnownEarthAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWellKnownEarthAxes = agcom.GUID(IWellKnownEarthAxes._uuid)
        vtable_offset_local = IWellKnownEarthAxes._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IWellKnownEarthAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IWellKnownEarthAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IWellKnownEarthAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_IWellKnownEarthAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWellKnownEarthAxes.__dict__ and type(IWellKnownEarthAxes.__dict__[attrname]) == property:
            return IWellKnownEarthAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWellKnownEarthAxes.")
    
    @property
    def Fixed(self) -> "IAxes":
        """Earth's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IAxes":
        """Earth's ICRF axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IAxes":
        """Earth's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IAxes":
        """The Earth's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}", IWellKnownEarthAxes)
agcls.AgTypeNameMap["IWellKnownEarthAxes"] = IWellKnownEarthAxes

class IWellKnownSunSystems(object):
    """The Sun's well-known coordinate reference systems."""
    _uuid = "{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        self.__dict__["_GetBarycenter"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWellKnownSunSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWellKnownSunSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWellKnownSunSystems = agcom.GUID(IWellKnownSunSystems._uuid)
        vtable_offset_local = IWellKnownSunSystems._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunSystems, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetBarycenter"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunSystems, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWellKnownSunSystems.__dict__ and type(IWellKnownSunSystems.__dict__[attrname]) == property:
            return IWellKnownSunSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWellKnownSunSystems.")
    
    @property
    def Fixed(self) -> "ISystem":
        """The Sun's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "ISystem":
        """The Sun's International Celestial Reference Frame (ICRF)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "ISystem":
        """The Sun's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "ISystem":
        """The Sun's J2000 coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Barycenter(self) -> "ISystem":
        """The Inertial system at the Sun's barycenter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBarycenter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}", IWellKnownSunSystems)
agcls.AgTypeNameMap["IWellKnownSunSystems"] = IWellKnownSunSystems

class IWellKnownSunAxes(object):
    """Well-known Sun's axes."""
    _uuid = "{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWellKnownSunAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWellKnownSunAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWellKnownSunAxes = agcom.GUID(IWellKnownSunAxes._uuid)
        vtable_offset_local = IWellKnownSunAxes._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSunAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWellKnownSunAxes.__dict__ and type(IWellKnownSunAxes.__dict__[attrname]) == property:
            return IWellKnownSunAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWellKnownSunAxes.")
    
    @property
    def Fixed(self) -> "IAxes":
        """Sun's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IAxes":
        """Sun's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IAxes":
        """Sun's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IAxes":
        """The Sun's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}", IWellKnownSunAxes)
agcls.AgTypeNameMap["IWellKnownSunAxes"] = IWellKnownSunAxes

class IWellKnownSystems(object):
    """Well-known coordinate reference systems."""
    _uuid = "{D93C6B6F-D457-4D20-BA7B-960773E3652B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEarth"] = _raise_uninitialized_error
        self.__dict__["_GetSun"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWellKnownSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWellKnownSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWellKnownSystems = agcom.GUID(IWellKnownSystems._uuid)
        vtable_offset_local = IWellKnownSystems._vtable_offset - 1
        self.__dict__["_GetEarth"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSun"] = IAGFUNCTYPE(pUnk, IID_IWellKnownSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWellKnownSystems.__dict__ and type(IWellKnownSystems.__dict__[attrname]) == property:
            return IWellKnownSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWellKnownSystems.")
    
    @property
    def Earth(self) -> "IWellKnownEarthSystems":
        """Earth's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEarth"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "IWellKnownSunSystems":
        """The Sun's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSun"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D93C6B6F-D457-4D20-BA7B-960773E3652B}", IWellKnownSystems)
agcls.AgTypeNameMap["IWellKnownSystems"] = IWellKnownSystems

class IWellKnownAxes(object):
    """Well-known Axes."""
    _uuid = "{B2546963-CC14-4F18-91DE-7091EBEA34C5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEarth"] = _raise_uninitialized_error
        self.__dict__["_GetSun"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWellKnownAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWellKnownAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWellKnownAxes = agcom.GUID(IWellKnownAxes._uuid)
        vtable_offset_local = IWellKnownAxes._vtable_offset - 1
        self.__dict__["_GetEarth"] = IAGFUNCTYPE(pUnk, IID_IWellKnownAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSun"] = IAGFUNCTYPE(pUnk, IID_IWellKnownAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWellKnownAxes.__dict__ and type(IWellKnownAxes.__dict__[attrname]) == property:
            return IWellKnownAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWellKnownAxes.")
    
    @property
    def Earth(self) -> "IWellKnownEarthAxes":
        """Earth's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEarth"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "IWellKnownSunAxes":
        """The Sun's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSun"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B2546963-CC14-4F18-91DE-7091EBEA34C5}", IWellKnownAxes)
agcls.AgTypeNameMap["IWellKnownAxes"] = IWellKnownAxes

class IAngleFindAngleResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngle method."""
    _uuid = "{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindAngleResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleFindAngleResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleFindAngleResult = agcom.GUID(IAngleFindAngleResult._uuid)
        vtable_offset_local = IAngleFindAngleResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAngleFindAngleResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleFindAngleResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleFindAngleResult.__dict__ and type(IAngleFindAngleResult.__dict__[attrname]) == property:
            return IAngleFindAngleResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleFindAngleResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}", IAngleFindAngleResult)
agcls.AgTypeNameMap["IAngleFindAngleResult"] = IAngleFindAngleResult

class IAngleFindAngleWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngleWithRate method."""
    _uuid = "{E46570BA-661C-4974-A780-32DFEAFB9630}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngleRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindAngleWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleFindAngleWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleFindAngleWithRateResult = agcom.GUID(IAngleFindAngleWithRateResult._uuid)
        vtable_offset_local = IAngleFindAngleWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAngleFindAngleWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleFindAngleWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetAngleRate"] = IAGFUNCTYPE(pUnk, IID_IAngleFindAngleWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleFindAngleWithRateResult.__dict__ and type(IAngleFindAngleWithRateResult.__dict__[attrname]) == property:
            return IAngleFindAngleWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleFindAngleWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in \"AngleRateUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E46570BA-661C-4974-A780-32DFEAFB9630}", IAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["IAngleFindAngleWithRateResult"] = IAngleFindAngleWithRateResult

class IAngleFindWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinatesWithRate method."""
    _uuid = "{C4E80CE7-2E38-4364-96D5-004EE425471D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngleRate"] = _raise_uninitialized_error
        self.__dict__["_GetVectorFrom"] = _raise_uninitialized_error
        self.__dict__["_GetVectorTo"] = _raise_uninitialized_error
        self.__dict__["_GetVectorAbout"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleFindWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleFindWithRateResult = agcom.GUID(IAngleFindWithRateResult._uuid)
        vtable_offset_local = IAngleFindWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAngleFindWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleFindWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetAngleRate"] = IAGFUNCTYPE(pUnk, IID_IAngleFindWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_GetVectorFrom"] = IAGFUNCTYPE(pUnk, IID_IAngleFindWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorTo"] = IAGFUNCTYPE(pUnk, IID_IAngleFindWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorAbout"] = IAGFUNCTYPE(pUnk, IID_IAngleFindWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleFindWithRateResult.__dict__ and type(IAngleFindWithRateResult.__dict__[attrname]) == property:
            return IAngleFindWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleFindWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in \"AngleRateUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4E80CE7-2E38-4364-96D5-004EE425471D}", IAngleFindWithRateResult)
agcls.AgTypeNameMap["IAngleFindWithRateResult"] = IAngleFindWithRateResult

class IAngleFindResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinates method."""
    _uuid = "{36DD880D-214E-4987-A70A-EA31E7E26B84}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetVectorFrom"] = _raise_uninitialized_error
        self.__dict__["_GetVectorTo"] = _raise_uninitialized_error
        self.__dict__["_GetVectorAbout"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAngleFindResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAngleFindResult = agcom.GUID(IAngleFindResult._uuid)
        vtable_offset_local = IAngleFindResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAngleFindResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IAngleFindResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetVectorFrom"] = IAGFUNCTYPE(pUnk, IID_IAngleFindResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorTo"] = IAGFUNCTYPE(pUnk, IID_IAngleFindResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorAbout"] = IAGFUNCTYPE(pUnk, IID_IAngleFindResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAngleFindResult.__dict__ and type(IAngleFindResult.__dict__[attrname]) == property:
            return IAngleFindResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAngleFindResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{36DD880D-214E-4987-A70A-EA31E7E26B84}", IAngleFindResult)
agcls.AgTypeNameMap["IAngleFindResult"] = IAngleFindResult

class IAxesTransformResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFrom method."""
    _uuid = "{D4EC98BE-0D20-4284-96D0-3C40A3100A06}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesTransformResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesTransformResult = agcom.GUID(IAxesTransformResult._uuid)
        vtable_offset_local = IAxesTransformResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAxesTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IAxesTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesTransformResult.__dict__ and type(IAxesTransformResult.__dict__[attrname]) == property:
            return IAxesTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesTransformResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D4EC98BE-0D20-4284-96D0-3C40A3100A06}", IAxesTransformResult)
agcls.AgTypeNameMap["IAxesTransformResult"] = IAxesTransformResult

class IAxesTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFromWithRate method."""
    _uuid = "{6434061B-3584-49FF-99C5-2C2D6B385CF1}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesTransformWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesTransformWithRateResult = agcom.GUID(IAxesTransformWithRateResult._uuid)
        vtable_offset_local = IAxesTransformWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAxesTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IAxesTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_IAxesTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesTransformWithRateResult.__dict__ and type(IAxesTransformWithRateResult.__dict__[attrname]) == property:
            return IAxesTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesTransformWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The vector velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6434061B-3584-49FF-99C5-2C2D6B385CF1}", IAxesTransformWithRateResult)
agcls.AgTypeNameMap["IAxesTransformWithRateResult"] = IAxesTransformWithRateResult

class IPlaneFindInAxesResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxes method."""
    _uuid = "{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneFindInAxesResult = agcom.GUID(IPlaneFindInAxesResult._uuid)
        vtable_offset_local = IPlaneFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneFindInAxesResult.__dict__ and type(IPlaneFindInAxesResult.__dict__[attrname]) == property:
            return IPlaneFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}", IPlaneFindInAxesResult)
agcls.AgTypeNameMap["IPlaneFindInAxesResult"] = IPlaneFindInAxesResult

class IPlaneFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxesWithRate method."""
    _uuid = "{CD4424A8-28CF-4AE5-8242-480B6625F0EB}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetXAxisRate"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneFindInAxesWithRateResult = agcom.GUID(IPlaneFindInAxesWithRateResult._uuid)
        vtable_offset_local = IPlaneFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxisRate"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxisRate"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInAxesWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneFindInAxesWithRateResult.__dict__ and type(IPlaneFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IPlaneFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "ICartesian3Vector":
        """The rate of change of X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "ICartesian3Vector":
        """The rate of change of Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CD4424A8-28CF-4AE5-8242-480B6625F0EB}", IPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["IPlaneFindInAxesWithRateResult"] = IPlaneFindInAxesWithRateResult

class IPlaneFindInSystemResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystem method."""
    _uuid = "{85D16885-3BEB-4590-963B-F1CC8D016097}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPosition"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneFindInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneFindInSystemResult = agcom.GUID(IPlaneFindInSystemResult._uuid)
        vtable_offset_local = IPlaneFindInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOriginPosition"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneFindInSystemResult.__dict__ and type(IPlaneFindInSystemResult.__dict__[attrname]) == property:
            return IPlaneFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneFindInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{85D16885-3BEB-4590-963B-F1CC8D016097}", IPlaneFindInSystemResult)
agcls.AgTypeNameMap["IPlaneFindInSystemResult"] = IPlaneFindInSystemResult

class IPlaneFindInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystemWithRate method."""
    _uuid = "{888499CB-4BF7-46A6-A11B-3FFC05EA6804}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPosition"] = _raise_uninitialized_error
        self.__dict__["_GetOriginVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetXAxisRate"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPlaneFindInSystemWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPlaneFindInSystemWithRateResult = agcom.GUID(IPlaneFindInSystemWithRateResult._uuid)
        vtable_offset_local = IPlaneFindInSystemWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOriginPosition"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOriginVelocity"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxisRate"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxisRate"] = IAGFUNCTYPE(pUnk, IID_IPlaneFindInSystemWithRateResult, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPlaneFindInSystemWithRateResult.__dict__ and type(IPlaneFindInSystemWithRateResult.__dict__[attrname]) == property:
            return IPlaneFindInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPlaneFindInSystemWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginVelocity(self) -> "ICartesian3Vector":
        """The rate of change of the position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "ICartesian3Vector":
        """A rate of change of the X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "ICartesian3Vector":
        """A rate of change of the Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{888499CB-4BF7-46A6-A11B-3FFC05EA6804}", IPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["IPlaneFindInSystemWithRateResult"] = IPlaneFindInSystemWithRateResult

class IAxesFindInAxesResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxes method."""
    _uuid = "{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesFindInAxesResult = agcom.GUID(IAxesFindInAxesResult._uuid)
        vtable_offset_local = IAxesFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAxesFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_IAxesFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesFindInAxesResult.__dict__ and type(IAxesFindInAxesResult.__dict__[attrname]) == property:
            return IAxesFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}", IAxesFindInAxesResult)
agcls.AgTypeNameMap["IAxesFindInAxesResult"] = IAxesFindInAxesResult

class IAxesFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxesWithRate method."""
    _uuid = "{72644DD0-D129-4D7A-8A81-586E86E639BD}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngularVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesFindInAxesWithRateResult = agcom.GUID(IAxesFindInAxesWithRateResult._uuid)
        vtable_offset_local = IAxesFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAxesFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngularVelocity"] = IAGFUNCTYPE(pUnk, IID_IAxesFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_IAxesFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesFindInAxesWithRateResult.__dict__ and type(IAxesFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IAxesFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngularVelocity(self) -> "ICartesian3Vector":
        """Axes' angular velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngularVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{72644DD0-D129-4D7A-8A81-586E86E639BD}", IAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["IAxesFindInAxesWithRateResult"] = IAxesFindInAxesWithRateResult

class IPointLocateInSystemResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystem method."""
    _uuid = "{84453DEC-5D01-4D47-A177-F8A737F0496D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointLocateInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointLocateInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointLocateInSystemResult = agcom.GUID(IPointLocateInSystemResult._uuid)
        vtable_offset_local = IPointLocateInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IPointLocateInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IPointLocateInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointLocateInSystemResult.__dict__ and type(IPointLocateInSystemResult.__dict__[attrname]) == property:
            return IPointLocateInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointLocateInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{84453DEC-5D01-4D47-A177-F8A737F0496D}", IPointLocateInSystemResult)
agcls.AgTypeNameMap["IPointLocateInSystemResult"] = IPointLocateInSystemResult

class IPointLocateInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystemWithRate method."""
    _uuid = "{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointLocateInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointLocateInSystemWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointLocateInSystemWithRateResult = agcom.GUID(IPointLocateInSystemWithRateResult._uuid)
        vtable_offset_local = IPointLocateInSystemWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IPointLocateInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IPointLocateInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_IPointLocateInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointLocateInSystemWithRateResult.__dict__ and type(IPointLocateInSystemWithRateResult.__dict__[attrname]) == property:
            return IPointLocateInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointLocateInSystemWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The point velocity in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}", IPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["IPointLocateInSystemWithRateResult"] = IPointLocateInSystemWithRateResult

class ISystemTransformResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFrom and IAgCrdnSystem.TransformTo methods."""
    _uuid = "{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemTransformResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemTransformResult = agcom.GUID(ISystemTransformResult._uuid)
        vtable_offset_local = ISystemTransformResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ISystemTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ISystemTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemTransformResult.__dict__ and type(ISystemTransformResult.__dict__[attrname]) == property:
            return ISystemTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemTransformResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}", ISystemTransformResult)
agcls.AgTypeNameMap["ISystemTransformResult"] = ISystemTransformResult

class ISystemTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFromWithRate and IAgCrdnSystem.TransformToWithRate methods."""
    _uuid = "{A9E92350-230F-45C7-A617-DB684FF89C78}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemTransformWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemTransformWithRateResult = agcom.GUID(ISystemTransformWithRateResult._uuid)
        vtable_offset_local = ISystemTransformWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ISystemTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ISystemTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_ISystemTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemTransformWithRateResult.__dict__ and type(ISystemTransformWithRateResult.__dict__[attrname]) == property:
            return ISystemTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemTransformWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The vector's velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A9E92350-230F-45C7-A617-DB684FF89C78}", ISystemTransformWithRateResult)
agcls.AgTypeNameMap["ISystemTransformWithRateResult"] = ISystemTransformWithRateResult

class ISystemFindInSystemResult(object):
    """Contains the results returned with IAgCrdnSystem.FindInSystem method."""
    _uuid = "{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISystemFindInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISystemFindInSystemResult = agcom.GUID(ISystemFindInSystemResult._uuid)
        vtable_offset_local = ISystemFindInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ISystemFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_ISystemFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_ISystemFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_ISystemFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_ISystemFindInSystemResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISystemFindInSystemResult.__dict__ and type(ISystemFindInSystemResult.__dict__[attrname]) == property:
            return ISystemFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISystemFindInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """A position vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """A velocity vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "ICartesian3Vector":
        """Rate of change."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """Orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}", ISystemFindInSystemResult)
agcls.AgTypeNameMap["ISystemFindInSystemResult"] = ISystemFindInSystemResult

class IVectorFindInAxesResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxes method."""
    _uuid = "{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorFindInAxesResult = agcom.GUID(IVectorFindInAxesResult._uuid)
        vtable_offset_local = IVectorFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorFindInAxesResult.__dict__ and type(IVectorFindInAxesResult.__dict__[attrname]) == property:
            return IVectorFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}", IVectorFindInAxesResult)
agcls.AgTypeNameMap["IVectorFindInAxesResult"] = IVectorFindInAxesResult

class IVectorFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxesWithRate method."""
    _uuid = "{A5EB9B7C-559C-4ABB-839E-47109CDC8446}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorFindInAxesWithRateResult = agcom.GUID(IVectorFindInAxesWithRateResult._uuid)
        vtable_offset_local = IVectorFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_IVectorFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorFindInAxesWithRateResult.__dict__ and type(IVectorFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IVectorFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "ICartesian3Vector":
        """The vector rate in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A5EB9B7C-559C-4ABB-839E-47109CDC8446}", IVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorFindInAxesWithRateResult"] = IVectorFindInAxesWithRateResult

class IMethodCallResult(object):
    """Instances of the interface are used to return the result of a computation."""
    _uuid = "{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMethodCallResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMethodCallResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMethodCallResult = agcom.GUID(IMethodCallResult._uuid)
        vtable_offset_local = IMethodCallResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IMethodCallResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMethodCallResult.__dict__ and type(IMethodCallResult.__dict__[attrname]) == property:
            return IMethodCallResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMethodCallResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}", IMethodCallResult)
agcls.AgTypeNameMap["IMethodCallResult"] = IMethodCallResult

class ICentralBody(object):
    """The interface represents a central body."""
    _uuid = "{8742150E-1663-4DCC-A442-278479FF93DC}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBody._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBody from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBody = agcom.GUID(ICentralBody._uuid)
        vtable_offset_local = ICentralBody._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_ICentralBody, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBody.__dict__ and type(ICentralBody.__dict__[attrname]) == property:
            return ICentralBody.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBody.")
    
    @property
    def Name(self) -> str:
        """A name of the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8742150E-1663-4DCC-A442-278479FF93DC}", ICentralBody)
agcls.AgTypeNameMap["ICentralBody"] = ICentralBody

class ICentralBodyRefTo(object):
    """Represents a reference to a VGT CentralBody."""
    _uuid = "{40596A74-4E5F-4406-85FF-70FA79893BFC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyRefTo = agcom.GUID(ICentralBodyRefTo._uuid)
        vtable_offset_local = ICentralBodyRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyRefTo.__dict__ and type(ICentralBodyRefTo.__dict__[attrname]) == property:
            return ICentralBodyRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new central body using specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetCentralBody(self, centralBody:"ICentralBody") -> None:
        """Sets a new central body."""
        with agmarshall.AgInterface_in_arg(centralBody, ICentralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    def GetCentralBody(self) -> "ICentralBody":
        """Returns a central body or null if the central body is invalid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{40596A74-4E5F-4406-85FF-70FA79893BFC}", ICentralBodyRefTo)
agcls.AgTypeNameMap["ICentralBodyRefTo"] = ICentralBodyRefTo

class ICentralBodyCollection(object):
    """A collection of central body names."""
    _uuid = "{FB32C9FA-327D-4AF9-9330-7DE8854F827E}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyCollection = agcom.GUID(ICentralBodyCollection._uuid)
        vtable_offset_local = ICentralBodyCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyCollection.__dict__ and type(ICentralBodyCollection.__dict__[attrname]) == property:
            return ICentralBodyCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> str:
        """Returns a central body name at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Add(self, centralBodyName:str) -> bool:
        """Adds a central body to the collection of central bodies. True indicates success."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_centralBodyName.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Remove(self, centralBodyName:str) -> None:
        """Removes a central body with the specified name from the collection of the central bodies."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_centralBodyName.COM_val))

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FB32C9FA-327D-4AF9-9330-7DE8854F827E}", ICentralBodyCollection)
agcls.AgTypeNameMap["ICentralBodyCollection"] = ICentralBodyCollection

class ICollection(object):
    """A collection of VGT objects."""
    _uuid = "{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}"
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICollection = agcom.GUID(ICollection._uuid)
        vtable_offset_local = ICollection._vtable_offset - 1
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICollection, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICollection, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICollection, vtable_offset_local+5, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICollection, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICollection.__dict__ and type(ICollection.__dict__[attrname]) == property:
            return ICollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICoordinate":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICoordinate":
        """Retrieves an element of the collection using the name of the element or a position in the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICoordinate":
        """Retrieves an item from the crdn collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICoordinate":
        """Retrieves an item from the crdn collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}", ICollection)
agcls.AgTypeNameMap["ICollection"] = ICollection

class IPointSamplingResult(object):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    _uuid = "{5131DB47-EFEA-4021-BEC5-DD13A73D9917}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointSamplingResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointSamplingResult = agcom.GUID(IPointSamplingResult._uuid)
        vtable_offset_local = IPointSamplingResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointSamplingResult.__dict__ and type(IPointSamplingResult.__dict__[attrname]) == property:
            return IPointSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointSamplingResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IPointSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5131DB47-EFEA-4021-BEC5-DD13A73D9917}", IPointSamplingResult)
agcls.AgTypeNameMap["IPointSamplingResult"] = IPointSamplingResult

class IPointSamplingInterval(object):
    """The interface represents an interval with the time, position and velocity arrays."""
    _uuid = "{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        self.__dict__["_GetPositions"] = _raise_uninitialized_error
        self.__dict__["_GetVelocities"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointSamplingInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointSamplingInterval = agcom.GUID(IPointSamplingInterval._uuid)
        vtable_offset_local = IPointSamplingInterval._vtable_offset - 1
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetPositions"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVelocities"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointSamplingInterval.__dict__ and type(IPointSamplingInterval.__dict__[attrname]) == property:
            return IPointSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointSamplingInterval.")
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Positions(self) -> list:
        """An array of 3-tuples each tuple representing the point's cartesian position (x,y,z)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPositions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocities"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}", IPointSamplingInterval)
agcls.AgTypeNameMap["IPointSamplingInterval"] = IPointSamplingInterval

class IPointSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    _uuid = "{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointSamplingIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointSamplingIntervalCollection = agcom.GUID(IPointSamplingIntervalCollection._uuid)
        vtable_offset_local = IPointSamplingIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPointSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointSamplingIntervalCollection.__dict__ and type(IPointSamplingIntervalCollection.__dict__[attrname]) == property:
            return IPointSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IPointSamplingInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IPointSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}", IPointSamplingIntervalCollection)
agcls.AgTypeNameMap["IPointSamplingIntervalCollection"] = IPointSamplingIntervalCollection

class IAxesSamplingResult(object):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    _uuid = "{F01C2A06-2998-406C-9898-CB60F5711EF1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesSamplingResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesSamplingResult = agcom.GUID(IAxesSamplingResult._uuid)
        vtable_offset_local = IAxesSamplingResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesSamplingResult.__dict__ and type(IAxesSamplingResult.__dict__[attrname]) == property:
            return IAxesSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesSamplingResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IAxesSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F01C2A06-2998-406C-9898-CB60F5711EF1}", IAxesSamplingResult)
agcls.AgTypeNameMap["IAxesSamplingResult"] = IAxesSamplingResult

class IAxesSamplingInterval(object):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    _uuid = "{5BF49282-A56A-48F1-85C9-92CF71C803D0}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        self.__dict__["_GetQuaternions"] = _raise_uninitialized_error
        self.__dict__["_GetVelocities"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesSamplingInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesSamplingInterval = agcom.GUID(IAxesSamplingInterval._uuid)
        vtable_offset_local = IAxesSamplingInterval._vtable_offset - 1
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetQuaternions"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVelocities"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesSamplingInterval.__dict__ and type(IAxesSamplingInterval.__dict__[attrname]) == property:
            return IAxesSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesSamplingInterval.")
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quaternions(self) -> list:
        """An array of 4-tuples each tuple representing the orientation of the axes as a quaternion (q1,q2,q3,q4)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQuaternions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of angular velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocities"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5BF49282-A56A-48F1-85C9-92CF71C803D0}", IAxesSamplingInterval)
agcls.AgTypeNameMap["IAxesSamplingInterval"] = IAxesSamplingInterval

class IAxesSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    _uuid = "{F593657B-35A4-4F40-B697-4D14E66195AC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAxesSamplingIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAxesSamplingIntervalCollection = agcom.GUID(IAxesSamplingIntervalCollection._uuid)
        vtable_offset_local = IAxesSamplingIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IAxesSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAxesSamplingIntervalCollection.__dict__ and type(IAxesSamplingIntervalCollection.__dict__[attrname]) == property:
            return IAxesSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAxesSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IAxesSamplingInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IAxesSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F593657B-35A4-4F40-B697-4D14E66195AC}", IAxesSamplingIntervalCollection)
agcls.AgTypeNameMap["IAxesSamplingIntervalCollection"] = IAxesSamplingIntervalCollection



class EvaluateResult(IEvaluateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        IEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEvaluateResult._get_property(self, attrname) is not None: found_prop = IEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EvaluateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{94FD0DFF-1DD0-4CA5-A7DB-1CB9CA3E3C93}", EvaluateResult)


class EvaluateWithRateResult(IEvaluateWithRateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        IEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = IEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EvaluateWithRateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{832CA139-8ECF-4E95-AB67-1BB7713CF9FC}", EvaluateWithRateResult)


class EventIntervalResult(IEventIntervalResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        IEventIntervalResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalResult._get_property(self, attrname) is not None: found_prop = IEventIntervalResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{ACE6C28C-4664-4B7F-8736-91F55C7962A6}", EventIntervalResult)


class EventFindOccurrenceResult(IEventFindOccurrenceResult):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    def __init__(self, sourceObject=None):
        IEventFindOccurrenceResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventFindOccurrenceResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventFindOccurrenceResult._get_property(self, attrname) is not None: found_prop = IEventFindOccurrenceResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventFindOccurrenceResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A432F58-4CAB-4448-8540-CBBAA9C2B9F0}", EventFindOccurrenceResult)


class FindTimesResult(IFindTimesResult):
    """Returns a collection of intervals and an array of times."""
    def __init__(self, sourceObject=None):
        IFindTimesResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFindTimesResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFindTimesResult._get_property(self, attrname) is not None: found_prop = IFindTimesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FindTimesResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF246FCF-7FA3-4CD6-878B-E9AC267F017A}", FindTimesResult)


class IntervalsVectorResult(IIntervalsVectorResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    def __init__(self, sourceObject=None):
        IIntervalsVectorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIntervalsVectorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIntervalsVectorResult._get_property(self, attrname) is not None: found_prop = IIntervalsVectorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IntervalsVectorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{233B8EB4-0B6A-485F-BACB-C678798FDA21}", IntervalsVectorResult)


class EventIntervalCollectionOccurredResult(IEventIntervalCollectionOccurredResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    def __init__(self, sourceObject=None):
        IEventIntervalCollectionOccurredResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalCollectionOccurredResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalCollectionOccurredResult._get_property(self, attrname) is not None: found_prop = IEventIntervalCollectionOccurredResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalCollectionOccurredResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D2BD8F6-406D-4BA0-B5CF-C81711C7C344}", EventIntervalCollectionOccurredResult)


class IntervalListResult(IIntervalListResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        IIntervalListResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIntervalListResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIntervalListResult._get_property(self, attrname) is not None: found_prop = IIntervalListResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IntervalListResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{C24C2EE4-3F75-41E8-BDC3-FE71E863921F}", IntervalListResult)


class IntervalVectorCollection(IIntervalVectorCollection):
    """A collection of interval collections."""
    def __init__(self, sourceObject=None):
        IIntervalVectorCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIntervalVectorCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIntervalVectorCollection._get_property(self, attrname) is not None: found_prop = IIntervalVectorCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IntervalVectorCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{99AAE1D2-3C5D-4836-A1BD-6EAD38FC9BC5}", IntervalVectorCollection)


class EventGroup(IEventGroup):
    """Access or create VGT events associated with an object."""
    def __init__(self, sourceObject=None):
        IEventGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventGroup._get_property(self, attrname) is not None: found_prop = IEventGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{D5D83181-A954-4FA9-886E-A917F135C974}", EventGroup)


class EventIntervalGroup(IEventIntervalGroup):
    """Access or create VGT event intervals associated with an object."""
    def __init__(self, sourceObject=None):
        IEventIntervalGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalGroup._get_property(self, attrname) is not None: found_prop = IEventIntervalGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{48C9D4D2-2713-4063-8BB1-D6F2E72E1025}", EventIntervalGroup)


class EventIntervalListGroup(IEventIntervalListGroup):
    """Access or create VGT event interval lists associated with an object."""
    def __init__(self, sourceObject=None):
        IEventIntervalListGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListGroup._get_property(self, attrname) is not None: found_prop = IEventIntervalListGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B2FDEBA-A2B9-4568-8F48-469F604DB966}", EventIntervalListGroup)


class EventArrayGroup(IEventArrayGroup):
    """Access or create VGT event arrays associated with an object."""
    def __init__(self, sourceObject=None):
        IEventArrayGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayGroup._get_property(self, attrname) is not None: found_prop = IEventArrayGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{365C4A6E-9C2B-4883-96C6-CF689BCC2943}", EventArrayGroup)


class CalcScalarGroup(ICalcScalarGroup):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICalcScalarGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarGroup._get_property(self, attrname) is not None: found_prop = ICalcScalarGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{DFAD8468-4480-460F-993D-74FFADB567B3}", CalcScalarGroup)


class EventIntervalCollectionGroup(IEventIntervalCollectionGroup):
    """Access or create VGT event interval collections associated with an object."""
    def __init__(self, sourceObject=None):
        IEventIntervalCollectionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalCollectionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalCollectionGroup._get_property(self, attrname) is not None: found_prop = IEventIntervalCollectionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalCollectionGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{16E277E2-E306-40E7-B698-B725BDED5739}", EventIntervalCollectionGroup)


class ParameterSetGroup(IParameterSetGroup):
    """Access or create VGT parameter sets associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IParameterSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSetGroup._get_property(self, attrname) is not None: found_prop = IParameterSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSetGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AF3C889-3805-40E2-94E2-3EA11AAFB0D7}", ParameterSetGroup)


class ConditionGroup(IConditionGroup):
    """Access or create VGT conditions associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IConditionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionGroup._get_property(self, attrname) is not None: found_prop = IConditionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{28BCB469-D32F-4FCE-9CC2-76216E3A37CA}", ConditionGroup)


class ConditionSetGroup(IConditionSetGroup):
    """Allows accessing and creating condition set components."""
    def __init__(self, sourceObject=None):
        IConditionSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionSetGroup._get_property(self, attrname) is not None: found_prop = IConditionSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionSetGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{D82D5C71-102E-4154-9FF6-153C4EDB5A94}", ConditionSetGroup)


class ConditionSetEvaluateResult(IConditionSetEvaluateResult):
    """Represents the results returned by ConditionSet.Evaluate."""
    def __init__(self, sourceObject=None):
        IConditionSetEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionSetEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionSetEvaluateResult._get_property(self, attrname) is not None: found_prop = IConditionSetEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionSetEvaluateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{13F4EB53-F5AB-487A-BC09-AA186C884744}", ConditionSetEvaluateResult)


class ConditionSetEvaluateWithRateResult(IConditionSetEvaluateWithRateResult):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    def __init__(self, sourceObject=None):
        IConditionSetEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionSetEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionSetEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = IConditionSetEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionSetEvaluateWithRateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{53051D77-87D0-432C-9044-A2AB1E2104BA}", ConditionSetEvaluateWithRateResult)


class VolumeGridGroup(IVolumeGridGroup):
    """Access or create VGT volume grids associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVolumeGridGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridGroup._get_property(self, attrname) is not None: found_prop = IVolumeGridGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E471C90-D0F2-4B6B-88AE-D529E9D16D03}", VolumeGridGroup)


class VolumeGroup(IVolumeGroup):
    """Access or create spatial conditions associated with a volume grid."""
    def __init__(self, sourceObject=None):
        IVolumeGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGroup._get_property(self, attrname) is not None: found_prop = IVolumeGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{0055B726-654F-446B-82D7-BCDD744F1D8F}", VolumeGroup)


class VolumeCalcGroup(IVolumeCalcGroup):
    """Access or create VGT volume calc associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVolumeCalcGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcGroup._get_property(self, attrname) is not None: found_prop = IVolumeCalcGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{b10331b7-f8c3-4a59-9e9b-b05dd6599167}", VolumeCalcGroup)


class CalcScalar(ICalcScalar, ICoordinate):
    """Any scalar calculation that is not constant by construction."""
    def __init__(self, sourceObject=None):
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{440E178B-1B34-4896-A25F-2A4F3AD4848E}", CalcScalar)


class CalcScalarAngle(ICalcScalarAngle, ICalcScalar, ICoordinate):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    def __init__(self, sourceObject=None):
        ICalcScalarAngle.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarAngle._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarAngle._get_property(self, attrname) is not None: found_prop = ICalcScalarAngle._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E2A940D-2656-4410-86B4-D7314B788E47}", CalcScalarAngle)


class CalcScalarConstant(ICalcScalarConstant, ICalcScalar, ICoordinate):
    """Constant scalar value of specified dimension."""
    def __init__(self, sourceObject=None):
        ICalcScalarConstant.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarConstant._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarConstant._get_property(self, attrname) is not None: found_prop = ICalcScalarConstant._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{0725A767-6788-4FF4-B848-EF3D526BD7B0}", CalcScalarConstant)


class CalcScalarCustom(ICalcScalarCustom, ICalcScalar, ICoordinate):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    def __init__(self, sourceObject=None):
        ICalcScalarCustom.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarCustom._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarCustom._get_property(self, attrname) is not None: found_prop = ICalcScalarCustom._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{80114DE9-EF5E-47DB-AC1B-91FD78FCA094}", CalcScalarCustom)


class CalcScalarDataElement(ICalcScalarDataElement, ICalcScalar, ICoordinate):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    def __init__(self, sourceObject=None):
        ICalcScalarDataElement.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarDataElement._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarDataElement._get_property(self, attrname) is not None: found_prop = ICalcScalarDataElement._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarDataElement.")
        
agcls.AgClassCatalog.add_catalog_entry("{260D686F-07E2-49DB-8E88-467EF79EFA54}", CalcScalarDataElement)


class CalcScalarDerivative(ICalcScalarDerivative, ICalcScalar, ICoordinate):
    """Derivative of an input scalar calculation."""
    def __init__(self, sourceObject=None):
        ICalcScalarDerivative.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarDerivative._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarDerivative._get_property(self, attrname) is not None: found_prop = ICalcScalarDerivative._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{865CE7A8-F7C3-4B25-AA1D-10CA305C7CF0}", CalcScalarDerivative)


class CalcScalarDotProduct(ICalcScalarDotProduct, ICalcScalar, ICoordinate):
    """Dot product between two vectors."""
    def __init__(self, sourceObject=None):
        ICalcScalarDotProduct.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarDotProduct._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarDotProduct._get_property(self, attrname) is not None: found_prop = ICalcScalarDotProduct._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarDotProduct.")
        
agcls.AgClassCatalog.add_catalog_entry("{703f009e-faab-4281-8d07-733b1344d42b}", CalcScalarDotProduct)


class CalcScalarElapsedTime(ICalcScalarElapsedTime, ICalcScalar, ICoordinate):
    """Time elapsed since the reference time instant. Negative if in the past."""
    def __init__(self, sourceObject=None):
        ICalcScalarElapsedTime.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarElapsedTime._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarElapsedTime._get_property(self, attrname) is not None: found_prop = ICalcScalarElapsedTime._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarElapsedTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D9FAF22-291A-4348-9EAD-1C8DF06D9C1C}", CalcScalarElapsedTime)


class CalcScalarFactory(ICalcScalarFactory):
    """The factory creates scalar calculation components."""
    def __init__(self, sourceObject=None):
        ICalcScalarFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarFactory._get_property(self, attrname) is not None: found_prop = ICalcScalarFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{47235112-821F-4DC2-9A70-57AB9F1F17E8}", CalcScalarFactory)


class CalcScalarFile(ICalcScalarFile, ICalcScalar, ICoordinate):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    def __init__(self, sourceObject=None):
        ICalcScalarFile.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarFile._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarFile._get_property(self, attrname) is not None: found_prop = ICalcScalarFile._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{75F0039F-B789-4771-BD50-9AEF30F6038E}", CalcScalarFile)


class CalcScalarFixedAtTimeInstant(ICalcScalarFixedAtTimeInstant, ICalcScalar, ICoordinate):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    def __init__(self, sourceObject=None):
        ICalcScalarFixedAtTimeInstant.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarFixedAtTimeInstant._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = ICalcScalarFixedAtTimeInstant._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarFixedAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{83E8DC6B-7821-4474-AA5B-29646ECD1EC1}", CalcScalarFixedAtTimeInstant)


class CalcScalarFunction(ICalcScalarFunction, ICalcScalar, ICoordinate):
    """Defined by performing the specified function on the input scalar or time instant."""
    def __init__(self, sourceObject=None):
        ICalcScalarFunction.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarFunction._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarFunction._get_property(self, attrname) is not None: found_prop = ICalcScalarFunction._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{40158F99-3146-4167-8BB0-A0046BB08EEB}", CalcScalarFunction)


class CalcScalarFunction2Var(ICalcScalarFunction2Var, ICalcScalar, ICoordinate):
    """Defined by performing a function(x,y) on two scalar arguments."""
    def __init__(self, sourceObject=None):
        ICalcScalarFunction2Var.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarFunction2Var._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarFunction2Var._get_property(self, attrname) is not None: found_prop = ICalcScalarFunction2Var._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarFunction2Var.")
        
agcls.AgClassCatalog.add_catalog_entry("{05CA07A4-A36F-44EF-99C4-5E0999E79200}", CalcScalarFunction2Var)


class CalcScalarIntegral(ICalcScalarIntegral, ICalcScalar, ICoordinate):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    def __init__(self, sourceObject=None):
        ICalcScalarIntegral.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarIntegral._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarIntegral._get_property(self, attrname) is not None: found_prop = ICalcScalarIntegral._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarIntegral.")
        
agcls.AgClassCatalog.add_catalog_entry("{C87C787A-BEDA-4AEC-9F88-3D6EE0936A03}", CalcScalarIntegral)


class CalcScalarPlugin(ICalcScalarPlugin, ICalcScalar, ICoordinate):
    """Use a scalar calculation plugin."""
    def __init__(self, sourceObject=None):
        ICalcScalarPlugin.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarPlugin._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarPlugin._get_property(self, attrname) is not None: found_prop = ICalcScalarPlugin._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{E435E30B-EA9B-4EFB-852A-C20427B71484}", CalcScalarPlugin)


class CalcScalarSurfaceDistanceBetweenPoints(ICalcScalarSurfaceDistanceBetweenPoints, ICalcScalar, ICoordinate):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    def __init__(self, sourceObject=None):
        ICalcScalarSurfaceDistanceBetweenPoints.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarSurfaceDistanceBetweenPoints._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname) is not None: found_prop = ICalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarSurfaceDistanceBetweenPoints.")
        
agcls.AgClassCatalog.add_catalog_entry("{DEDCB488-6C70-4BC0-A719-68832FB6D30E}", CalcScalarSurfaceDistanceBetweenPoints)


class CalcScalarVectorComponent(ICalcScalarVectorComponent, ICalcScalar, ICoordinate):
    """The specified component of a vector when resolved in the specified axes."""
    def __init__(self, sourceObject=None):
        ICalcScalarVectorComponent.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarVectorComponent._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarVectorComponent._get_property(self, attrname) is not None: found_prop = ICalcScalarVectorComponent._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarVectorComponent.")
        
agcls.AgClassCatalog.add_catalog_entry("{0b8e5c9f-de1b-4b6b-9e38-87b16db7bb71}", CalcScalarVectorComponent)


class CalcScalarVectorMagnitude(ICalcScalarVectorMagnitude, ICalcScalar, ICoordinate):
    """Scalar equal to the magnitude of a specified vector."""
    def __init__(self, sourceObject=None):
        ICalcScalarVectorMagnitude.__init__(self, sourceObject)
        ICalcScalar.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcScalarVectorMagnitude._private_init(self, pUnk)
        ICalcScalar._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcScalarVectorMagnitude._get_property(self, attrname) is not None: found_prop = ICalcScalarVectorMagnitude._get_property(self, attrname)
        if ICalcScalar._get_property(self, attrname) is not None: found_prop = ICalcScalar._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcScalarVectorMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7430CE8-D611-4F5C-B4B4-05531F1E0CC0}", CalcScalarVectorMagnitude)


class Condition(ICondition, ICoordinate):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    def __init__(self, sourceObject=None):
        ICondition.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICondition._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICondition._get_property(self, attrname) is not None: found_prop = ICondition._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Condition.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1BED244-FFB2-4038-AE76-A9B3194B2E49}", Condition)


class ConditionCombined(IConditionCombined, ICondition, ICoordinate):
    """Defines a condition which combines multiple conditions."""
    def __init__(self, sourceObject=None):
        IConditionCombined.__init__(self, sourceObject)
        ICondition.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionCombined._private_init(self, pUnk)
        ICondition._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionCombined._get_property(self, attrname) is not None: found_prop = IConditionCombined._get_property(self, attrname)
        if ICondition._get_property(self, attrname) is not None: found_prop = ICondition._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionCombined.")
        
agcls.AgClassCatalog.add_catalog_entry("{92F4488B-3543-4229-B1FB-447D282199B9}", ConditionCombined)


class ConditionFactory(IConditionFactory):
    """The factory creates condition components."""
    def __init__(self, sourceObject=None):
        IConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionFactory._get_property(self, attrname) is not None: found_prop = IConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{06C627F8-87EA-4552-86E8-7E5049914CDE}", ConditionFactory)


class ConditionPointInVolume(IConditionPointInVolume, ICondition, ICoordinate):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    def __init__(self, sourceObject=None):
        IConditionPointInVolume.__init__(self, sourceObject)
        ICondition.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionPointInVolume._private_init(self, pUnk)
        ICondition._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionPointInVolume._get_property(self, attrname) is not None: found_prop = IConditionPointInVolume._get_property(self, attrname)
        if ICondition._get_property(self, attrname) is not None: found_prop = ICondition._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionPointInVolume.")
        
agcls.AgClassCatalog.add_catalog_entry("{41532AD9-B30C-44AE-8581-CE74C24846A8}", ConditionPointInVolume)


class ConditionScalarBounds(IConditionScalarBounds, ICondition, ICoordinate):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    def __init__(self, sourceObject=None):
        IConditionScalarBounds.__init__(self, sourceObject)
        ICondition.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionScalarBounds._private_init(self, pUnk)
        ICondition._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionScalarBounds._get_property(self, attrname) is not None: found_prop = IConditionScalarBounds._get_property(self, attrname)
        if ICondition._get_property(self, attrname) is not None: found_prop = ICondition._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionScalarBounds.")
        
agcls.AgClassCatalog.add_catalog_entry("{452E2178-AFB0-4E61-8187-9C6CB4A704A0}", ConditionScalarBounds)


class ConditionSet(IConditionSet, ICoordinate):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    def __init__(self, sourceObject=None):
        IConditionSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionSet._get_property(self, attrname) is not None: found_prop = IConditionSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{B6407B1B-6858-49FC-845A-F8A6239162C2}", ConditionSet)


class ConditionSetFactory(IConditionSetFactory):
    """The factory creates condition set components."""
    def __init__(self, sourceObject=None):
        IConditionSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionSetFactory._get_property(self, attrname) is not None: found_prop = IConditionSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionSetFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D2445C98-9EA1-458F-9B6A-607249BF399A}", ConditionSetFactory)


class ConditionSetScalarThresholds(IConditionSetScalarThresholds, IConditionSet, ICoordinate):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    def __init__(self, sourceObject=None):
        IConditionSetScalarThresholds.__init__(self, sourceObject)
        IConditionSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConditionSetScalarThresholds._private_init(self, pUnk)
        IConditionSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConditionSetScalarThresholds._get_property(self, attrname) is not None: found_prop = IConditionSetScalarThresholds._get_property(self, attrname)
        if IConditionSet._get_property(self, attrname) is not None: found_prop = IConditionSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConditionSetScalarThresholds.")
        
agcls.AgClassCatalog.add_catalog_entry("{EED0BF6B-4D96-4D55-B988-0B962DCDBB4E}", ConditionSetScalarThresholds)


class Converge(IConverge, ICoordinate):
    """Represents a base class for convergence definitions."""
    def __init__(self, sourceObject=None):
        IConverge.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConverge._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConverge._get_property(self, attrname) is not None: found_prop = IConverge._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Converge.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A13D679-1970-43C2-8D4F-174B08AB04DC}", Converge)


class ConvergeBasic(IConvergeBasic, IConverge, ICoordinate):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    def __init__(self, sourceObject=None):
        IConvergeBasic.__init__(self, sourceObject)
        IConverge.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConvergeBasic._private_init(self, pUnk)
        IConverge._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConvergeBasic._get_property(self, attrname) is not None: found_prop = IConvergeBasic._get_property(self, attrname)
        if IConverge._get_property(self, attrname) is not None: found_prop = IConverge._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConvergeBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{808F19C3-0E31-4C89-94C8-BBE01E067DFF}", ConvergeBasic)


class Derivative(IDerivative, ICoordinate):
    """Represents a base class for derivative definitions."""
    def __init__(self, sourceObject=None):
        IDerivative.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDerivative._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDerivative._get_property(self, attrname) is not None: found_prop = IDerivative._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Derivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{2C7C1DA3-BD86-4D8B-9505-AC796FF1FD45}", Derivative)


class DerivativeBasic(IDerivativeBasic, IDerivative, ICoordinate):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    def __init__(self, sourceObject=None):
        IDerivativeBasic.__init__(self, sourceObject)
        IDerivative.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDerivativeBasic._private_init(self, pUnk)
        IDerivative._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDerivativeBasic._get_property(self, attrname) is not None: found_prop = IDerivativeBasic._get_property(self, attrname)
        if IDerivative._get_property(self, attrname) is not None: found_prop = IDerivative._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DerivativeBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{3CD084C3-0045-4452-9793-AE8DF4073433}", DerivativeBasic)


class Event(IEvent, ICoordinate):
    """Defines an event (time instant)."""
    def __init__(self, sourceObject=None):
        IEvent.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEvent._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEvent._get_property(self, attrname) is not None: found_prop = IEvent._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Event.")
        
agcls.AgClassCatalog.add_catalog_entry("{A4B75B25-5DAE-4AEC-86EF-512F5E031766}", Event)


class EventArray(IEventArray, ICoordinate):
    """An ordered array of times, which may or may not be evenly spaced."""
    def __init__(self, sourceObject=None):
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArray.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5C87B1A-D519-4A01-8649-AA7560CD503A}", EventArray)


class EventArrayConditionCrossings(IEventArrayConditionCrossings, IEventArray, ICoordinate):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IEventArrayConditionCrossings.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayConditionCrossings._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayConditionCrossings._get_property(self, attrname) is not None: found_prop = IEventArrayConditionCrossings._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayConditionCrossings.")
        
agcls.AgClassCatalog.add_catalog_entry("{B6FBC501-3521-4AE3-AFD8-4971F089D14F}", EventArrayConditionCrossings)


class EventArrayExtrema(IEventArrayExtrema, IEventArray, ICoordinate):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IEventArrayExtrema.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayExtrema._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayExtrema._get_property(self, attrname) is not None: found_prop = IEventArrayExtrema._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayExtrema.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FB3F78C-D9F6-43F0-BCAA-5A7DCD035592}", EventArrayExtrema)


class EventArrayFactory(IEventArrayFactory):
    """The factory creates event arrays."""
    def __init__(self, sourceObject=None):
        IEventArrayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayFactory._get_property(self, attrname) is not None: found_prop = IEventArrayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{A001EDFD-FAC8-4BBE-9FDC-0C7A5C4BB11C}", EventArrayFactory)


class EventArrayFiltered(IEventArrayFiltered, IEventArray, ICoordinate):
    """Defined by filtering times from original time array according to specified filtering method."""
    def __init__(self, sourceObject=None):
        IEventArrayFiltered.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayFiltered._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayFiltered._get_property(self, attrname) is not None: found_prop = IEventArrayFiltered._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayFiltered.")
        
agcls.AgClassCatalog.add_catalog_entry("{CA0D9FE7-E921-406E-8A1A-EE448A46C03C}", EventArrayFiltered)


class EventArrayFixedStep(IEventArrayFixedStep, IEventArray, ICoordinate):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    def __init__(self, sourceObject=None):
        IEventArrayFixedStep.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayFixedStep._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayFixedStep._get_property(self, attrname) is not None: found_prop = IEventArrayFixedStep._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{CDA379CC-7511-496E-874E-14E10F3E2B1A}", EventArrayFixedStep)


class EventArrayFixedTimes(IEventArrayFixedTimes, IEventArray, ICoordinate):
    """Array defined by time ordered instants each explicitly specified."""
    def __init__(self, sourceObject=None):
        IEventArrayFixedTimes.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayFixedTimes._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayFixedTimes._get_property(self, attrname) is not None: found_prop = IEventArrayFixedTimes._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayFixedTimes.")
        
agcls.AgClassCatalog.add_catalog_entry("{EA73AECA-23AB-4DA1-B297-E80E19C55C15}", EventArrayFixedTimes)


class EventArrayMerged(IEventArrayMerged, IEventArray, ICoordinate):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    def __init__(self, sourceObject=None):
        IEventArrayMerged.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayMerged._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayMerged._get_property(self, attrname) is not None: found_prop = IEventArrayMerged._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayMerged.")
        
agcls.AgClassCatalog.add_catalog_entry("{44FBC83E-D466-425F-ADF5-2003D754F935}", EventArrayMerged)


class EventArraySignaled(IEventArraySignaled, IEventArray, ICoordinate):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IEventArraySignaled.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArraySignaled._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArraySignaled._get_property(self, attrname) is not None: found_prop = IEventArraySignaled._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArraySignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{50E37652-E4D1-4B6F-BA12-2D9B17E5F1AA}", EventArraySignaled)


class EventArrayStartStopTimes(IEventArrayStartStopTimes, IEventArray, ICoordinate):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    def __init__(self, sourceObject=None):
        IEventArrayStartStopTimes.__init__(self, sourceObject)
        IEventArray.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventArrayStartStopTimes._private_init(self, pUnk)
        IEventArray._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventArrayStartStopTimes._get_property(self, attrname) is not None: found_prop = IEventArrayStartStopTimes._get_property(self, attrname)
        if IEventArray._get_property(self, attrname) is not None: found_prop = IEventArray._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventArrayStartStopTimes.")
        
agcls.AgClassCatalog.add_catalog_entry("{1AF5E1AC-97CB-4375-B0AE-AE8B6684432B}", EventArrayStartStopTimes)


class EventEpoch(IEventEpoch, IEvent, ICoordinate):
    """Event set at specified date/time."""
    def __init__(self, sourceObject=None):
        IEventEpoch.__init__(self, sourceObject)
        IEvent.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventEpoch._private_init(self, pUnk)
        IEvent._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventEpoch._get_property(self, attrname) is not None: found_prop = IEventEpoch._get_property(self, attrname)
        if IEvent._get_property(self, attrname) is not None: found_prop = IEvent._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{230426D4-438A-4B6E-A9D2-5393F7F87238}", EventEpoch)


class EventExtremum(IEventExtremum, IEvent, ICoordinate):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IEventExtremum.__init__(self, sourceObject)
        IEvent.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventExtremum._private_init(self, pUnk)
        IEvent._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventExtremum._get_property(self, attrname) is not None: found_prop = IEventExtremum._get_property(self, attrname)
        if IEvent._get_property(self, attrname) is not None: found_prop = IEvent._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventExtremum.")
        
agcls.AgClassCatalog.add_catalog_entry("{7D4AD095-F1A4-4ACA-8788-50DEF2F4B604}", EventExtremum)


class EventFactory(IEventFactory):
    """The factory creates events."""
    def __init__(self, sourceObject=None):
        IEventFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventFactory._get_property(self, attrname) is not None: found_prop = IEventFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{9DEB7422-F9AA-492A-9269-3BDB7B0AF7E4}", EventFactory)


class EventInterval(IEventInterval, ICoordinate):
    """A single time interval."""
    def __init__(self, sourceObject=None):
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{2CDA6DDC-7412-441A-8F94-0671FD57D16A}", EventInterval)


class EventIntervalBetweenTimeInstants(IEventIntervalBetweenTimeInstants, IEventInterval, ICoordinate):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    def __init__(self, sourceObject=None):
        IEventIntervalBetweenTimeInstants.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalBetweenTimeInstants._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalBetweenTimeInstants._get_property(self, attrname) is not None: found_prop = IEventIntervalBetweenTimeInstants._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalBetweenTimeInstants.")
        
agcls.AgClassCatalog.add_catalog_entry("{E84D9CAE-E919-4B84-99D7-553CCB97739C}", EventIntervalBetweenTimeInstants)


class EventIntervalCollection(IEventIntervalCollection, ICoordinate):
    """A collection of related interval lists."""
    def __init__(self, sourceObject=None):
        IEventIntervalCollection.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalCollection._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IEventIntervalCollection._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{892BFFEB-D366-49D5-8220-50AC5E4529A1}", EventIntervalCollection)


class EventIntervalCollectionCondition(IEventIntervalCollectionCondition, IEventIntervalCollection, ICoordinate):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IEventIntervalCollectionCondition.__init__(self, sourceObject)
        IEventIntervalCollection.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalCollectionCondition._private_init(self, pUnk)
        IEventIntervalCollection._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalCollectionCondition._get_property(self, attrname) is not None: found_prop = IEventIntervalCollectionCondition._get_property(self, attrname)
        if IEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IEventIntervalCollection._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalCollectionCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{05E4AFDD-2917-46BA-84C9-1EE7973F11D7}", EventIntervalCollectionCondition)


class EventIntervalCollectionFactory(IEventIntervalCollectionFactory):
    """The factory creates collections of event interval lists."""
    def __init__(self, sourceObject=None):
        IEventIntervalCollectionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalCollectionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalCollectionFactory._get_property(self, attrname) is not None: found_prop = IEventIntervalCollectionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalCollectionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C76F8390-6619-47D5-9D33-DD1FBBF19B63}", EventIntervalCollectionFactory)


class EventIntervalCollectionLighting(IEventIntervalCollectionLighting, IEventIntervalCollection, ICoordinate):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    def __init__(self, sourceObject=None):
        IEventIntervalCollectionLighting.__init__(self, sourceObject)
        IEventIntervalCollection.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalCollectionLighting._private_init(self, pUnk)
        IEventIntervalCollection._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalCollectionLighting._get_property(self, attrname) is not None: found_prop = IEventIntervalCollectionLighting._get_property(self, attrname)
        if IEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IEventIntervalCollection._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalCollectionLighting.")
        
agcls.AgClassCatalog.add_catalog_entry("{5457BFBA-3076-4250-B0E0-81FA79D58F19}", EventIntervalCollectionLighting)


class EventIntervalCollectionSignaled(IEventIntervalCollectionSignaled, IEventIntervalCollection, ICoordinate):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IEventIntervalCollectionSignaled.__init__(self, sourceObject)
        IEventIntervalCollection.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalCollectionSignaled._private_init(self, pUnk)
        IEventIntervalCollection._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalCollectionSignaled._get_property(self, attrname) is not None: found_prop = IEventIntervalCollectionSignaled._get_property(self, attrname)
        if IEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IEventIntervalCollection._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalCollectionSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1ED3869-B0E3-40F6-967A-C539C5D5D630}", EventIntervalCollectionSignaled)


class EventIntervalFactory(IEventIntervalFactory):
    """The factory creates event intervals."""
    def __init__(self, sourceObject=None):
        IEventIntervalFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalFactory._get_property(self, attrname) is not None: found_prop = IEventIntervalFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D5D195D8-DE6D-4926-B743-556B08A827C8}", EventIntervalFactory)


class EventIntervalFixed(IEventIntervalFixed, IEventInterval, ICoordinate):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    def __init__(self, sourceObject=None):
        IEventIntervalFixed.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalFixed._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalFixed._get_property(self, attrname) is not None: found_prop = IEventIntervalFixed._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{4408570B-CE46-4B6A-9A50-F8F6D56D76F1}", EventIntervalFixed)


class EventIntervalFixedDuration(IEventIntervalFixedDuration, IEventInterval, ICoordinate):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    def __init__(self, sourceObject=None):
        IEventIntervalFixedDuration.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalFixedDuration._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalFixedDuration._get_property(self, attrname) is not None: found_prop = IEventIntervalFixedDuration._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalFixedDuration.")
        
agcls.AgClassCatalog.add_catalog_entry("{84316F31-A3DB-4DF3-B8E3-352673D4E251}", EventIntervalFixedDuration)


class EventIntervalFromIntervalList(IEventIntervalFromIntervalList, IEventInterval, ICoordinate):
    """Interval created from specified interval list by using one of several selection methods."""
    def __init__(self, sourceObject=None):
        IEventIntervalFromIntervalList.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalFromIntervalList._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalFromIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalFromIntervalList._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalFromIntervalList.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E3B57D7-B236-4DCA-82DA-6C4835A6D0F1}", EventIntervalFromIntervalList)


class EventIntervalList(IEventIntervalList, ICoordinate):
    """An ordered list of time intervals."""
    def __init__(self, sourceObject=None):
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalList.")
        
agcls.AgClassCatalog.add_catalog_entry("{050E0A6D-9960-4470-9803-AF58B43FD747}", EventIntervalList)


class EventIntervalListCondition(IEventIntervalListCondition, IEventIntervalList, ICoordinate):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IEventIntervalListCondition.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListCondition._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListCondition._get_property(self, attrname) is not None: found_prop = IEventIntervalListCondition._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{4D1E24FE-BD49-4F09-9C30-523AFD58E02B}", EventIntervalListCondition)


class EventIntervalListFactory(IEventIntervalListFactory):
    """The factory creates event interval lists."""
    def __init__(self, sourceObject=None):
        IEventIntervalListFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListFactory._get_property(self, attrname) is not None: found_prop = IEventIntervalListFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC3FA659-172B-4C9D-9DCA-EF6AD6CC4A8A}", EventIntervalListFactory)


class EventIntervalListFile(IEventIntervalListFile, IEventIntervalList, ICoordinate):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    def __init__(self, sourceObject=None):
        IEventIntervalListFile.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListFile._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListFile._get_property(self, attrname) is not None: found_prop = IEventIntervalListFile._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{5A3BC6C1-559F-448D-946E-3D608C0C59B4}", EventIntervalListFile)


class EventIntervalListFiltered(IEventIntervalListFiltered, IEventIntervalList, ICoordinate):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    def __init__(self, sourceObject=None):
        IEventIntervalListFiltered.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListFiltered._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListFiltered._get_property(self, attrname) is not None: found_prop = IEventIntervalListFiltered._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListFiltered.")
        
agcls.AgClassCatalog.add_catalog_entry("{7123DA29-BECE-4032-9A81-77CDA69C5B13}", EventIntervalListFiltered)


class EventIntervalListFixed(IEventIntervalListFixed, IEventIntervalList, ICoordinate):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    def __init__(self, sourceObject=None):
        IEventIntervalListFixed.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListFixed._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListFixed._get_property(self, attrname) is not None: found_prop = IEventIntervalListFixed._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{60EF79E3-069B-45E3-A5A6-B49F9F9D618E}", EventIntervalListFixed)


class EventIntervalListMerged(IEventIntervalListMerged, IEventIntervalList, ICoordinate):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    def __init__(self, sourceObject=None):
        IEventIntervalListMerged.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListMerged._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListMerged._get_property(self, attrname) is not None: found_prop = IEventIntervalListMerged._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListMerged.")
        
agcls.AgClassCatalog.add_catalog_entry("{115C7064-1624-4928-B401-2C2B8DA2A2DC}", EventIntervalListMerged)


class EventIntervalListScaled(IEventIntervalListScaled, IEventIntervalList, ICoordinate):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    def __init__(self, sourceObject=None):
        IEventIntervalListScaled.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListScaled._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListScaled._get_property(self, attrname) is not None: found_prop = IEventIntervalListScaled._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{3A5FDAFA-95C5-4743-A675-B9598AAAA1B9}", EventIntervalListScaled)


class EventIntervalListSignaled(IEventIntervalListSignaled, IEventIntervalList, ICoordinate):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IEventIntervalListSignaled.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListSignaled._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListSignaled._get_property(self, attrname) is not None: found_prop = IEventIntervalListSignaled._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{0C2159AF-FCE5-46AA-A06B-30E49A5B6704}", EventIntervalListSignaled)


class EventIntervalListTimeOffset(IEventIntervalListTimeOffset, IEventIntervalList, ICoordinate):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    def __init__(self, sourceObject=None):
        IEventIntervalListTimeOffset.__init__(self, sourceObject)
        IEventIntervalList.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalListTimeOffset._private_init(self, pUnk)
        IEventIntervalList._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalListTimeOffset._get_property(self, attrname) is not None: found_prop = IEventIntervalListTimeOffset._get_property(self, attrname)
        if IEventIntervalList._get_property(self, attrname) is not None: found_prop = IEventIntervalList._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalListTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{BA2C1495-B20E-477A-A995-8B5B879DE84C}", EventIntervalListTimeOffset)


class EventIntervalScaled(IEventIntervalScaled, IEventInterval, ICoordinate):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    def __init__(self, sourceObject=None):
        IEventIntervalScaled.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalScaled._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalScaled._get_property(self, attrname) is not None: found_prop = IEventIntervalScaled._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{8BCF947C-8E52-4B0C-9416-520C7CCEAB3E}", EventIntervalScaled)


class EventIntervalSignaled(IEventIntervalSignaled, IEventInterval, ICoordinate):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    def __init__(self, sourceObject=None):
        IEventIntervalSignaled.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalSignaled._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalSignaled._get_property(self, attrname) is not None: found_prop = IEventIntervalSignaled._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E2D6BF4-81D9-476D-A4F2-F1882E24B56E}", EventIntervalSignaled)


class EventIntervalSmartInterval(IEventIntervalSmartInterval, IEventInterval, ICoordinate):
    """A smart interval."""
    def __init__(self, sourceObject=None):
        IEventIntervalSmartInterval.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalSmartInterval._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalSmartInterval._get_property(self, attrname) is not None: found_prop = IEventIntervalSmartInterval._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalSmartInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{F3D4E2AC-3845-4719-AD57-EE0C715A584D}", EventIntervalSmartInterval)


class EventIntervalTimeOffset(IEventIntervalTimeOffset, IEventInterval, ICoordinate):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    def __init__(self, sourceObject=None):
        IEventIntervalTimeOffset.__init__(self, sourceObject)
        IEventInterval.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventIntervalTimeOffset._private_init(self, pUnk)
        IEventInterval._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventIntervalTimeOffset._get_property(self, attrname) is not None: found_prop = IEventIntervalTimeOffset._get_property(self, attrname)
        if IEventInterval._get_property(self, attrname) is not None: found_prop = IEventInterval._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventIntervalTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{DE89BB00-5A89-4DA4-8730-CA2C3495A867}", EventIntervalTimeOffset)


class EventSignaled(IEventSignaled, IEvent, ICoordinate):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    def __init__(self, sourceObject=None):
        IEventSignaled.__init__(self, sourceObject)
        IEvent.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventSignaled._private_init(self, pUnk)
        IEvent._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventSignaled._get_property(self, attrname) is not None: found_prop = IEventSignaled._get_property(self, attrname)
        if IEvent._get_property(self, attrname) is not None: found_prop = IEvent._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{3951EF3D-DAEA-4F04-B78C-22537BD84A2D}", EventSignaled)


class EventSmartEpoch(IEventSmartEpoch, IEvent, ICoordinate):
    """A smart epoch."""
    def __init__(self, sourceObject=None):
        IEventSmartEpoch.__init__(self, sourceObject)
        IEvent.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventSmartEpoch._private_init(self, pUnk)
        IEvent._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventSmartEpoch._get_property(self, attrname) is not None: found_prop = IEventSmartEpoch._get_property(self, attrname)
        if IEvent._get_property(self, attrname) is not None: found_prop = IEvent._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventSmartEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{F722C253-92DA-4956-983B-B80AB469F192}", EventSmartEpoch)


class EventStartStopTime(IEventStartStopTime, IEvent, ICoordinate):
    """Event is either start or stop time selected from a reference interval."""
    def __init__(self, sourceObject=None):
        IEventStartStopTime.__init__(self, sourceObject)
        IEvent.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventStartStopTime._private_init(self, pUnk)
        IEvent._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventStartStopTime._get_property(self, attrname) is not None: found_prop = IEventStartStopTime._get_property(self, attrname)
        if IEvent._get_property(self, attrname) is not None: found_prop = IEvent._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventStartStopTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{F0429607-A51C-495C-9902-585429D40D10}", EventStartStopTime)


class EventTimeOffset(IEventTimeOffset, IEvent, ICoordinate):
    """Event at fixed offset from specified reference event."""
    def __init__(self, sourceObject=None):
        IEventTimeOffset.__init__(self, sourceObject)
        IEvent.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEventTimeOffset._private_init(self, pUnk)
        IEvent._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEventTimeOffset._get_property(self, attrname) is not None: found_prop = IEventTimeOffset._get_property(self, attrname)
        if IEvent._get_property(self, attrname) is not None: found_prop = IEvent._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EventTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{EE2C89C8-C148-4044-B0BE-BF137D4B876B}", EventTimeOffset)


class FirstIntervalsFilter(IFirstIntervalsFilter, IPruneFilter):
    """The filter selects a portion of first intervals."""
    def __init__(self, sourceObject=None):
        IFirstIntervalsFilter.__init__(self, sourceObject)
        IPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFirstIntervalsFilter._private_init(self, pUnk)
        IPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFirstIntervalsFilter._get_property(self, attrname) is not None: found_prop = IFirstIntervalsFilter._get_property(self, attrname)
        if IPruneFilter._get_property(self, attrname) is not None: found_prop = IPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FirstIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A044590-5063-4331-9FC2-621221CF7EA9}", FirstIntervalsFilter)


class GapsFilter(IGapsFilter, IPruneFilter):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IGapsFilter.__init__(self, sourceObject)
        IPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGapsFilter._private_init(self, pUnk)
        IPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGapsFilter._get_property(self, attrname) is not None: found_prop = IGapsFilter._get_property(self, attrname)
        if IPruneFilter._get_property(self, attrname) is not None: found_prop = IPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GapsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{C54D3817-6B48-4436-8E1D-323A38DC2BC0}", GapsFilter)


class Integral(IIntegral, ICoordinate):
    """Represents a base class for integral definitions."""
    def __init__(self, sourceObject=None):
        IIntegral.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIntegral._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIntegral._get_property(self, attrname) is not None: found_prop = IIntegral._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Integral.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C6B1D39-FC48-475A-A888-DA9D459C1906}", Integral)


class IntegralBasic(IIntegralBasic, IIntegral, ICoordinate):
    """Integral definition determines how scalar calculation is numerically integrated."""
    def __init__(self, sourceObject=None):
        IIntegralBasic.__init__(self, sourceObject)
        IIntegral.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIntegralBasic._private_init(self, pUnk)
        IIntegral._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIntegralBasic._get_property(self, attrname) is not None: found_prop = IIntegralBasic._get_property(self, attrname)
        if IIntegral._get_property(self, attrname) is not None: found_prop = IIntegral._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IntegralBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{7FCEE0EE-218C-419E-B5DB-8381B18FAE8A}", IntegralBasic)


class Interp(IInterp, ICoordinate):
    """Represents a base class for interpolation definitions."""
    def __init__(self, sourceObject=None):
        IInterp.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IInterp._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IInterp._get_property(self, attrname) is not None: found_prop = IInterp._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Interp.")
        
agcls.AgClassCatalog.add_catalog_entry("{F73B3675-6FD4-4050-9566-797DCD695107}", Interp)


class InterpBasic(IInterpBasic, IInterp, ICoordinate):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    def __init__(self, sourceObject=None):
        IInterpBasic.__init__(self, sourceObject)
        IInterp.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IInterpBasic._private_init(self, pUnk)
        IInterp._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IInterpBasic._get_property(self, attrname) is not None: found_prop = IInterpBasic._get_property(self, attrname)
        if IInterp._get_property(self, attrname) is not None: found_prop = IInterp._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in InterpBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{AB05143F-6997-4F40-BE86-DCF4D723F31E}", InterpBasic)


class IntervalsFilter(IIntervalsFilter, IPruneFilter):
    """The filter selects intervals of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IIntervalsFilter.__init__(self, sourceObject)
        IPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIntervalsFilter._private_init(self, pUnk)
        IPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIntervalsFilter._get_property(self, attrname) is not None: found_prop = IIntervalsFilter._get_property(self, attrname)
        if IPruneFilter._get_property(self, attrname) is not None: found_prop = IPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA31C4A7-B07C-4DEC-B479-BBEB07234B44}", IntervalsFilter)


class LastIntervalsFilter(ILastIntervalsFilter, IPruneFilter):
    """The filter selects a portion of last intervals."""
    def __init__(self, sourceObject=None):
        ILastIntervalsFilter.__init__(self, sourceObject)
        IPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILastIntervalsFilter._private_init(self, pUnk)
        IPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILastIntervalsFilter._get_property(self, attrname) is not None: found_prop = ILastIntervalsFilter._get_property(self, attrname)
        if IPruneFilter._get_property(self, attrname) is not None: found_prop = IPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LastIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{1FAF4A1D-B0BA-4A86-A0AC-049670C66302}", LastIntervalsFilter)


class ParameterSet(IParameterSet, ICoordinate):
    """Parameter set contains various sets of scalar computations."""
    def __init__(self, sourceObject=None):
        IParameterSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSet._get_property(self, attrname) is not None: found_prop = IParameterSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{CD1D82FC-08BF-4854-9295-F90AC87FAE68}", ParameterSet)


class ParameterSetAttitude(IParameterSetAttitude, IParameterSet, ICoordinate):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    def __init__(self, sourceObject=None):
        IParameterSetAttitude.__init__(self, sourceObject)
        IParameterSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSetAttitude._private_init(self, pUnk)
        IParameterSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSetAttitude._get_property(self, attrname) is not None: found_prop = IParameterSetAttitude._get_property(self, attrname)
        if IParameterSet._get_property(self, attrname) is not None: found_prop = IParameterSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSetAttitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{7082CB04-052B-46A2-A051-4FF52D0260B0}", ParameterSetAttitude)


class ParameterSetFactory(IParameterSetFactory):
    """The factory is used to create instances of available parameter set types."""
    def __init__(self, sourceObject=None):
        IParameterSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSetFactory._get_property(self, attrname) is not None: found_prop = IParameterSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSetFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{FF399336-197C-480B-98AC-3F07E76FF3BC}", ParameterSetFactory)


class ParameterSetGroundTrajectory(IParameterSetGroundTrajectory, IParameterSet, ICoordinate):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    def __init__(self, sourceObject=None):
        IParameterSetGroundTrajectory.__init__(self, sourceObject)
        IParameterSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSetGroundTrajectory._private_init(self, pUnk)
        IParameterSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSetGroundTrajectory._get_property(self, attrname) is not None: found_prop = IParameterSetGroundTrajectory._get_property(self, attrname)
        if IParameterSet._get_property(self, attrname) is not None: found_prop = IParameterSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSetGroundTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1972E17-F000-4BFF-80A3-216A91D0E2B1}", ParameterSetGroundTrajectory)


class ParameterSetOrbit(IParameterSetOrbit, IParameterSet, ICoordinate):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    def __init__(self, sourceObject=None):
        IParameterSetOrbit.__init__(self, sourceObject)
        IParameterSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSetOrbit._private_init(self, pUnk)
        IParameterSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSetOrbit._get_property(self, attrname) is not None: found_prop = IParameterSetOrbit._get_property(self, attrname)
        if IParameterSet._get_property(self, attrname) is not None: found_prop = IParameterSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSetOrbit.")
        
agcls.AgClassCatalog.add_catalog_entry("{BF4A60A0-68E5-4000-8843-DD7FD76813A9}", ParameterSetOrbit)


class ParameterSetTrajectory(IParameterSetTrajectory, IParameterSet, ICoordinate):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    def __init__(self, sourceObject=None):
        IParameterSetTrajectory.__init__(self, sourceObject)
        IParameterSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSetTrajectory._private_init(self, pUnk)
        IParameterSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSetTrajectory._get_property(self, attrname) is not None: found_prop = IParameterSetTrajectory._get_property(self, attrname)
        if IParameterSet._get_property(self, attrname) is not None: found_prop = IParameterSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSetTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{542072ED-4073-4F91-8EC8-45F7CC401ED7}", ParameterSetTrajectory)


class ParameterSetVector(IParameterSetVector, IParameterSet, ICoordinate):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    def __init__(self, sourceObject=None):
        IParameterSetVector.__init__(self, sourceObject)
        IParameterSet.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IParameterSetVector._private_init(self, pUnk)
        IParameterSet._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IParameterSetVector._get_property(self, attrname) is not None: found_prop = IParameterSetVector._get_property(self, attrname)
        if IParameterSet._get_property(self, attrname) is not None: found_prop = IParameterSet._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ParameterSetVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC7B40D5-7091-4A24-A698-436D2A274DC8}", ParameterSetVector)


class PruneFilter(IPruneFilter):
    """A filter used with event interval list pruned class to prune interval lists..."""
    def __init__(self, sourceObject=None):
        IPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPruneFilter._get_property(self, attrname) is not None: found_prop = IPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PruneFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{E08D63E9-CC8E-41F8-B3C5-0D062425C025}", PruneFilter)


class PruneFilterFactory(IPruneFilterFactory):
    """The factory creates pruning filters."""
    def __init__(self, sourceObject=None):
        IPruneFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPruneFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPruneFilterFactory._get_property(self, attrname) is not None: found_prop = IPruneFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PruneFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{954284C2-3544-4888-9A56-759AA8C7E1F7}", PruneFilterFactory)


class RelativeSatisfactionConditionFilter(IRelativeSatisfactionConditionFilter, IPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    def __init__(self, sourceObject=None):
        IRelativeSatisfactionConditionFilter.__init__(self, sourceObject)
        IPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRelativeSatisfactionConditionFilter._private_init(self, pUnk)
        IPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRelativeSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = IRelativeSatisfactionConditionFilter._get_property(self, attrname)
        if IPruneFilter._get_property(self, attrname) is not None: found_prop = IPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RelativeSatisfactionConditionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{93A5C2C0-AABA-4DB3-9359-100604D0BA02}", RelativeSatisfactionConditionFilter)


class Sampling(ISampling, ICoordinate):
    """Base sampling interface."""
    def __init__(self, sourceObject=None):
        ISampling.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISampling._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISampling._get_property(self, attrname) is not None: found_prop = ISampling._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Sampling.")
        
agcls.AgClassCatalog.add_catalog_entry("{17FC40E9-EF68-4FFD-8A16-071054486F6A}", Sampling)


class SamplingBasic(ISamplingBasic, ISampling, ICoordinate):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    def __init__(self, sourceObject=None):
        ISamplingBasic.__init__(self, sourceObject)
        ISampling.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISamplingBasic._private_init(self, pUnk)
        ISampling._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISamplingBasic._get_property(self, attrname) is not None: found_prop = ISamplingBasic._get_property(self, attrname)
        if ISampling._get_property(self, attrname) is not None: found_prop = ISampling._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SamplingBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{CB786C50-8D9C-4333-A985-FFD2ADD20206}", SamplingBasic)


class SamplingCurvatureTolerance(ISamplingCurvatureTolerance, ISamplingMethod):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    def __init__(self, sourceObject=None):
        ISamplingCurvatureTolerance.__init__(self, sourceObject)
        ISamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISamplingCurvatureTolerance._private_init(self, pUnk)
        ISamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISamplingCurvatureTolerance._get_property(self, attrname) is not None: found_prop = ISamplingCurvatureTolerance._get_property(self, attrname)
        if ISamplingMethod._get_property(self, attrname) is not None: found_prop = ISamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SamplingCurvatureTolerance.")
        
agcls.AgClassCatalog.add_catalog_entry("{EF49B404-27D2-4AC5-BB5E-EA223A237922}", SamplingCurvatureTolerance)


class SamplingFixedStep(ISamplingFixedStep, ISamplingMethod):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    def __init__(self, sourceObject=None):
        ISamplingFixedStep.__init__(self, sourceObject)
        ISamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISamplingFixedStep._private_init(self, pUnk)
        ISamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISamplingFixedStep._get_property(self, attrname) is not None: found_prop = ISamplingFixedStep._get_property(self, attrname)
        if ISamplingMethod._get_property(self, attrname) is not None: found_prop = ISamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SamplingFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B7D520F-7835-4E84-BCA4-D748C73CB609}", SamplingFixedStep)


class SamplingMethod(ISamplingMethod):
    """A sampling method."""
    def __init__(self, sourceObject=None):
        ISamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISamplingMethod._get_property(self, attrname) is not None: found_prop = ISamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SamplingMethod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D77F1444-C9BC-4C9C-91A2-A5F9DE172AB8}", SamplingMethod)


class SamplingMethodFactory(ISamplingMethodFactory):
    """The factory creates sampling method components."""
    def __init__(self, sourceObject=None):
        ISamplingMethodFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISamplingMethodFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISamplingMethodFactory._get_property(self, attrname) is not None: found_prop = ISamplingMethodFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SamplingMethodFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{E55B6BC9-25B5-46E6-A29A-4E32F9EF3080}", SamplingMethodFactory)


class SamplingRelativeTolerance(ISamplingRelativeTolerance, ISamplingMethod):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    def __init__(self, sourceObject=None):
        ISamplingRelativeTolerance.__init__(self, sourceObject)
        ISamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISamplingRelativeTolerance._private_init(self, pUnk)
        ISamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISamplingRelativeTolerance._get_property(self, attrname) is not None: found_prop = ISamplingRelativeTolerance._get_property(self, attrname)
        if ISamplingMethod._get_property(self, attrname) is not None: found_prop = ISamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SamplingRelativeTolerance.")
        
agcls.AgClassCatalog.add_catalog_entry("{5FBC3E6B-8097-4482-A1BA-DAA0083FE904}", SamplingRelativeTolerance)


class SatisfactionConditionFilter(ISatisfactionConditionFilter, IPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    def __init__(self, sourceObject=None):
        ISatisfactionConditionFilter.__init__(self, sourceObject)
        IPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISatisfactionConditionFilter._private_init(self, pUnk)
        IPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = ISatisfactionConditionFilter._get_property(self, attrname)
        if IPruneFilter._get_property(self, attrname) is not None: found_prop = IPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SatisfactionConditionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{3DD67B2F-2C0A-4355-A154-08E47A93AFCF}", SatisfactionConditionFilter)


class SignalDelay(ISignalDelay, ICoordinate):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        ISignalDelay.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISignalDelay._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISignalDelay._get_property(self, attrname) is not None: found_prop = ISignalDelay._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SignalDelay.")
        
agcls.AgClassCatalog.add_catalog_entry("{71744841-D938-44BE-8336-2B54F06CF443}", SignalDelay)


class SignalDelayBasic(ISignalDelayBasic, ISignalDelay, ICoordinate):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        ISignalDelayBasic.__init__(self, sourceObject)
        ISignalDelay.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISignalDelayBasic._private_init(self, pUnk)
        ISignalDelay._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISignalDelayBasic._get_property(self, attrname) is not None: found_prop = ISignalDelayBasic._get_property(self, attrname)
        if ISignalDelay._get_property(self, attrname) is not None: found_prop = ISignalDelay._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SignalDelayBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{0763A330-475A-4E4E-AB26-8943A8CC1C92}", SignalDelayBasic)


class VolumeCalcFactory(IVolumeCalcFactory):
    """The factory is used to create instances of volume calcs."""
    def __init__(self, sourceObject=None):
        IVolumeCalcFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcFactory._get_property(self, attrname) is not None: found_prop = IVolumeCalcFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{80956ae5-fb8c-4ce4-930f-56b362d07cec}", VolumeCalcFactory)


class VolumeFactory(IVolumeFactory):
    """The factory is used to create instances of volumes."""
    def __init__(self, sourceObject=None):
        IVolumeFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeFactory._get_property(self, attrname) is not None: found_prop = IVolumeFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F9497BD8-A985-4054-8ADE-9042DE66125F}", VolumeFactory)


class VolumeGridFactory(IVolumeGridFactory):
    """The factory is used to create instances of volume grids."""
    def __init__(self, sourceObject=None):
        IVolumeGridFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridFactory._get_property(self, attrname) is not None: found_prop = IVolumeGridFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F6359611-FB48-4B00-9017-01A4BE2B76E5}", VolumeGridFactory)


class GridCoordinateDefinition(IGridCoordinateDefinition):
    """Defines a set of coordinate values."""
    def __init__(self, sourceObject=None):
        IGridCoordinateDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridCoordinateDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridCoordinateDefinition._get_property(self, attrname) is not None: found_prop = IGridCoordinateDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridCoordinateDefinition.")
        
agcls.AgClassCatalog.add_catalog_entry("{CCE5BC10-615F-441F-95AE-CB4CC0A7C62A}", GridCoordinateDefinition)


class GridValuesCustom(IGridValuesCustom, IGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IGridValuesCustom.__init__(self, sourceObject)
        IGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridValuesCustom._private_init(self, pUnk)
        IGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridValuesCustom._get_property(self, attrname) is not None: found_prop = IGridValuesCustom._get_property(self, attrname)
        if IGridValuesMethod._get_property(self, attrname) is not None: found_prop = IGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridValuesCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{B50CCBA5-A969-40E1-86B3-96DAE5D2A3E3}", GridValuesCustom)


class GridValuesFixedNumberOfSteps(IGridValuesFixedNumberOfSteps, IGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IGridValuesFixedNumberOfSteps.__init__(self, sourceObject)
        IGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridValuesFixedNumberOfSteps._private_init(self, pUnk)
        IGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridValuesFixedNumberOfSteps._get_property(self, attrname) is not None: found_prop = IGridValuesFixedNumberOfSteps._get_property(self, attrname)
        if IGridValuesMethod._get_property(self, attrname) is not None: found_prop = IGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridValuesFixedNumberOfSteps.")
        
agcls.AgClassCatalog.add_catalog_entry("{DDD7F78E-13DC-4417-8AE5-B43BB1511AFC}", GridValuesFixedNumberOfSteps)


class GridValuesFixedStep(IGridValuesFixedStep, IGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IGridValuesFixedStep.__init__(self, sourceObject)
        IGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridValuesFixedStep._private_init(self, pUnk)
        IGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridValuesFixedStep._get_property(self, attrname) is not None: found_prop = IGridValuesFixedStep._get_property(self, attrname)
        if IGridValuesMethod._get_property(self, attrname) is not None: found_prop = IGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridValuesFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{0942EA2D-33DE-41B5-98BE-E53E659EC81D}", GridValuesFixedStep)


class GridValuesMethod(IGridValuesMethod):
    """A grid values method."""
    def __init__(self, sourceObject=None):
        IGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridValuesMethod._get_property(self, attrname) is not None: found_prop = IGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridValuesMethod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1D242BF-73F3-443A-AB46-64EAA02C5F37}", GridValuesMethod)


class LightTimeDelay(ILightTimeDelay):
    """Manage Light Time Delay options.."""
    def __init__(self, sourceObject=None):
        ILightTimeDelay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILightTimeDelay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILightTimeDelay._get_property(self, attrname) is not None: found_prop = ILightTimeDelay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LightTimeDelay.")
        
agcls.AgClassCatalog.add_catalog_entry("{085E2242-4392-4F35-857E-A46A72EADE70}", LightTimeDelay)


class Volume(IVolume, ICoordinate):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    def __init__(self, sourceObject=None):
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Volume.")
        
agcls.AgClassCatalog.add_catalog_entry("{299D5D3F-7E12-4747-BFD3-2B5CADBAD8EE}", Volume)


class VolumeCalc(IVolumeCalc, ICoordinate):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    def __init__(self, sourceObject=None):
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{d014bfd1-130d-4dc4-a841-76c75bc08f9c}", VolumeCalc)


class VolumeCalcAltitude(IVolumeCalcAltitude, IVolumeCalc, ICoordinate):
    """A volume calc altitude interface."""
    def __init__(self, sourceObject=None):
        IVolumeCalcAltitude.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcAltitude._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcAltitude._get_property(self, attrname) is not None: found_prop = IVolumeCalcAltitude._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcAltitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{4e3c369c-c189-48ce-8e93-f0c6478f0abe}", VolumeCalcAltitude)


class VolumeCalcAngleOffVector(IVolumeCalcAngleOffVector, IVolumeCalc, ICoordinate):
    """A volume calc angle off vector interface."""
    def __init__(self, sourceObject=None):
        IVolumeCalcAngleOffVector.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcAngleOffVector._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcAngleOffVector._get_property(self, attrname) is not None: found_prop = IVolumeCalcAngleOffVector._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcAngleOffVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{e37c954b-d3d5-4d2e-91b6-0ae4f8380620}", VolumeCalcAngleOffVector)


class VolumeCalcConditionSatMetric(IVolumeCalcConditionSatMetric, IVolumeCalc, ICoordinate):
    """A volume calc condition satisfaction interface."""
    def __init__(self, sourceObject=None):
        IVolumeCalcConditionSatMetric.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcConditionSatMetric._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcConditionSatMetric._get_property(self, attrname) is not None: found_prop = IVolumeCalcConditionSatMetric._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcConditionSatMetric.")
        
agcls.AgClassCatalog.add_catalog_entry("{589b39d3-7b75-4fe8-8fb2-1c7e5e247fea}", VolumeCalcConditionSatMetric)


class VolumeCalcDelayRange(IVolumeCalcDelayRange, IVolumeCalc, ICoordinate):
    """A volume calc propagation delay to location interface."""
    def __init__(self, sourceObject=None):
        IVolumeCalcDelayRange.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcDelayRange._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcDelayRange._get_property(self, attrname) is not None: found_prop = IVolumeCalcDelayRange._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcDelayRange.")
        
agcls.AgClassCatalog.add_catalog_entry("{bd9388e8-e5f8-4ba9-9371-4ff8fc1ed33c}", VolumeCalcDelayRange)


class VolumeCalcFile(IVolumeCalcFile, IVolumeCalc, ICoordinate):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    def __init__(self, sourceObject=None):
        IVolumeCalcFile.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcFile._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcFile._get_property(self, attrname) is not None: found_prop = IVolumeCalcFile._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{188f96c6-9568-4609-9944-dfc5fb7247c5}", VolumeCalcFile)


class VolumeCalcFromScalar(IVolumeCalcFromScalar, IVolumeCalc, ICoordinate):
    """A volume calc scalar to location interface."""
    def __init__(self, sourceObject=None):
        IVolumeCalcFromScalar.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcFromScalar._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcFromScalar._get_property(self, attrname) is not None: found_prop = IVolumeCalcFromScalar._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcFromScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{73219623-93c0-4c6e-961a-7fae5dfe9234}", VolumeCalcFromScalar)


class VolumeCalcRange(IVolumeCalcRange, IVolumeCalc, ICoordinate):
    """A volume calc distance to location interface."""
    def __init__(self, sourceObject=None):
        IVolumeCalcRange.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcRange._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcRange._get_property(self, attrname) is not None: found_prop = IVolumeCalcRange._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcRange.")
        
agcls.AgClassCatalog.add_catalog_entry("{7f1aa95f-e8d6-4faf-925b-98785243ba67}", VolumeCalcRange)


class VolumeCalcSolarIntensity(IVolumeCalcSolarIntensity, IVolumeCalc, ICoordinate):
    """A volume calc solar intensityn interface."""
    def __init__(self, sourceObject=None):
        IVolumeCalcSolarIntensity.__init__(self, sourceObject)
        IVolumeCalc.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCalcSolarIntensity._private_init(self, pUnk)
        IVolumeCalc._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCalcSolarIntensity._get_property(self, attrname) is not None: found_prop = IVolumeCalcSolarIntensity._get_property(self, attrname)
        if IVolumeCalc._get_property(self, attrname) is not None: found_prop = IVolumeCalc._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCalcSolarIntensity.")
        
agcls.AgClassCatalog.add_catalog_entry("{7796e871-d645-4f65-a3dc-de687b6fbcd5}", VolumeCalcSolarIntensity)


class VolumeCombined(IVolumeCombined, IVolume, ICoordinate):
    """A combined volume interface."""
    def __init__(self, sourceObject=None):
        IVolumeCombined.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeCombined._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeCombined._get_property(self, attrname) is not None: found_prop = IVolumeCombined._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeCombined.")
        
agcls.AgClassCatalog.add_catalog_entry("{7ECD2E89-B432-47C3-A80F-AF6429E66746}", VolumeCombined)


class VolumeFromCalc(IVolumeFromCalc, IVolume, ICoordinate):
    """An volume from calc volume interface."""
    def __init__(self, sourceObject=None):
        IVolumeFromCalc.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeFromCalc._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeFromCalc._get_property(self, attrname) is not None: found_prop = IVolumeFromCalc._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeFromCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F2AC0BF-4645-4C7F-9660-A894E267FD59}", VolumeFromCalc)


class VolumeFromCondition(IVolumeFromCondition, IVolume, ICoordinate):
    """A volume from conditioninterface."""
    def __init__(self, sourceObject=None):
        IVolumeFromCondition.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeFromCondition._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeFromCondition._get_property(self, attrname) is not None: found_prop = IVolumeFromCondition._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeFromCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{A2546B12-78BF-4F8F-87C2-31BC73DA265B}", VolumeFromCondition)


class VolumeFromGrid(IVolumeFromGrid, IVolume, ICoordinate):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        IVolumeFromGrid.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeFromGrid._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeFromGrid._get_property(self, attrname) is not None: found_prop = IVolumeFromGrid._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeFromGrid.")
        
agcls.AgClassCatalog.add_catalog_entry("{D49FE282-4C05-4097-970C-1282997378E9}", VolumeFromGrid)


class VolumeFromTimeSatisfaction(IVolumeFromTimeSatisfaction, IVolume, ICoordinate):
    """An volume from time satisfaction volume interface."""
    def __init__(self, sourceObject=None):
        IVolumeFromTimeSatisfaction.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeFromTimeSatisfaction._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeFromTimeSatisfaction._get_property(self, attrname) is not None: found_prop = IVolumeFromTimeSatisfaction._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeFromTimeSatisfaction.")
        
agcls.AgClassCatalog.add_catalog_entry("{29ECFCF5-9E5E-4E17-99AA-0B312227CFBF}", VolumeFromTimeSatisfaction)


class VolumeGrid(IVolumeGrid, ICoordinate):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    def __init__(self, sourceObject=None):
        IVolumeGrid.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGrid._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGrid._get_property(self, attrname) is not None: found_prop = IVolumeGrid._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGrid.")
        
agcls.AgClassCatalog.add_catalog_entry("{B7068C38-74D7-4F22-B0C4-A0DBA06DF373}", VolumeGrid)


class VolumeGridBearingAlt(IVolumeGridBearingAlt, IVolumeGrid, ICoordinate):
    """A volume grid bearing alt (Surface Bearing) interface."""
    def __init__(self, sourceObject=None):
        IVolumeGridBearingAlt.__init__(self, sourceObject)
        IVolumeGrid.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridBearingAlt._private_init(self, pUnk)
        IVolumeGrid._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridBearingAlt._get_property(self, attrname) is not None: found_prop = IVolumeGridBearingAlt._get_property(self, attrname)
        if IVolumeGrid._get_property(self, attrname) is not None: found_prop = IVolumeGrid._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridBearingAlt.")
        
agcls.AgClassCatalog.add_catalog_entry("{ED60A16E-82F8-4E0A-9F07-CF8DF05C985A}", VolumeGridBearingAlt)


class VolumeGridCartesian(IVolumeGridCartesian, IVolumeGrid, ICoordinate):
    """A volume grid Cartesian interface."""
    def __init__(self, sourceObject=None):
        IVolumeGridCartesian.__init__(self, sourceObject)
        IVolumeGrid.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridCartesian._private_init(self, pUnk)
        IVolumeGrid._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridCartesian._get_property(self, attrname) is not None: found_prop = IVolumeGridCartesian._get_property(self, attrname)
        if IVolumeGrid._get_property(self, attrname) is not None: found_prop = IVolumeGrid._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridCartesian.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF15D0A4-BB42-4762-A761-9BD11DC948D0}", VolumeGridCartesian)


class VolumeGridConstrained(IVolumeGridConstrained, IVolumeGrid, ICoordinate):
    """A volume grid constrained interface."""
    def __init__(self, sourceObject=None):
        IVolumeGridConstrained.__init__(self, sourceObject)
        IVolumeGrid.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridConstrained._private_init(self, pUnk)
        IVolumeGrid._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridConstrained._get_property(self, attrname) is not None: found_prop = IVolumeGridConstrained._get_property(self, attrname)
        if IVolumeGrid._get_property(self, attrname) is not None: found_prop = IVolumeGrid._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridConstrained.")
        
agcls.AgClassCatalog.add_catalog_entry("{253FC52C-5554-4A53-AE3D-624316ECFFFD}", VolumeGridConstrained)


class VolumeGridCylindrical(IVolumeGridCylindrical, IVolumeGrid, ICoordinate):
    """A volume grid cylindrical interface."""
    def __init__(self, sourceObject=None):
        IVolumeGridCylindrical.__init__(self, sourceObject)
        IVolumeGrid.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridCylindrical._private_init(self, pUnk)
        IVolumeGrid._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridCylindrical._get_property(self, attrname) is not None: found_prop = IVolumeGridCylindrical._get_property(self, attrname)
        if IVolumeGrid._get_property(self, attrname) is not None: found_prop = IVolumeGrid._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridCylindrical.")
        
agcls.AgClassCatalog.add_catalog_entry("{55C6A7AA-5354-4DF1-9A0E-F62CB01115C8}", VolumeGridCylindrical)


class VolumeGridLatLonAlt(IVolumeGridLatLonAlt, IVolumeGrid, ICoordinate):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    def __init__(self, sourceObject=None):
        IVolumeGridLatLonAlt.__init__(self, sourceObject)
        IVolumeGrid.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridLatLonAlt._private_init(self, pUnk)
        IVolumeGrid._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridLatLonAlt._get_property(self, attrname) is not None: found_prop = IVolumeGridLatLonAlt._get_property(self, attrname)
        if IVolumeGrid._get_property(self, attrname) is not None: found_prop = IVolumeGrid._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridLatLonAlt.")
        
agcls.AgClassCatalog.add_catalog_entry("{89C10FC4-4031-4B63-9C55-E092DDF3839D}", VolumeGridLatLonAlt)


class VolumeGridResult(IVolumeGridResult):
    """An interface that generates Volume Grid results."""
    def __init__(self, sourceObject=None):
        IVolumeGridResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridResult._get_property(self, attrname) is not None: found_prop = IVolumeGridResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{43B95CA7-5CCA-4477-9F37-63A86CD9DEBB}", VolumeGridResult)


class VolumeGridSpherical(IVolumeGridSpherical, IVolumeGrid, ICoordinate):
    """A volume grid spherical interface."""
    def __init__(self, sourceObject=None):
        IVolumeGridSpherical.__init__(self, sourceObject)
        IVolumeGrid.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeGridSpherical._private_init(self, pUnk)
        IVolumeGrid._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeGridSpherical._get_property(self, attrname) is not None: found_prop = IVolumeGridSpherical._get_property(self, attrname)
        if IVolumeGrid._get_property(self, attrname) is not None: found_prop = IVolumeGrid._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeGridSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{0DFD2937-3181-4895-AB05-A45FFD744964}", VolumeGridSpherical)


class VolumeInview(IVolumeInview, IVolume, ICoordinate):
    """An Inview volume interface."""
    def __init__(self, sourceObject=None):
        IVolumeInview.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeInview._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeInview._get_property(self, attrname) is not None: found_prop = IVolumeInview._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeInview.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC8CB747-2714-4F73-8BD6-ED974F0B03AB}", VolumeInview)


class VolumeLighting(IVolumeLighting, IVolume, ICoordinate):
    """A lighting volume interface."""
    def __init__(self, sourceObject=None):
        IVolumeLighting.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeLighting._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeLighting._get_property(self, attrname) is not None: found_prop = IVolumeLighting._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeLighting.")
        
agcls.AgClassCatalog.add_catalog_entry("{B9ACC019-A8DD-4342-ADE9-1335215F0FAF}", VolumeLighting)


class VolumeOverTime(IVolumeOverTime, IVolume, ICoordinate):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        IVolumeOverTime.__init__(self, sourceObject)
        IVolume.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVolumeOverTime._private_init(self, pUnk)
        IVolume._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVolumeOverTime._get_property(self, attrname) is not None: found_prop = IVolumeOverTime._get_property(self, attrname)
        if IVolume._get_property(self, attrname) is not None: found_prop = IVolume._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VolumeOverTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5AB68EE-DCC1-435F-A0C3-133095B01D2D}", VolumeOverTime)


class Generic(ICoordinate):
    """Generic VGT component."""
    def __init__(self, sourceObject=None):
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Generic.")
        
agcls.AgClassCatalog.add_catalog_entry("{2909EDFB-9BE2-4BD2-A678-186C9D136937}", Generic)


class TypeInfo(ITypeInfo):
    """VGT component info."""
    def __init__(self, sourceObject=None):
        ITypeInfo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITypeInfo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITypeInfo._get_property(self, attrname) is not None: found_prop = ITypeInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TypeInfo.")
        
agcls.AgClassCatalog.add_catalog_entry("{BA26887C-6DFE-4F18-96D8-5694296568D2}", TypeInfo)


class Instance(IContext, IInstance):
    """Enables to obtain information about the parent object that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IContext.__init__(self, sourceObject)
        IInstance.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IContext._private_init(self, pUnk)
        IInstance._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IContext._get_property(self, attrname) is not None: found_prop = IContext._get_property(self, attrname)
        if IInstance._get_property(self, attrname) is not None: found_prop = IInstance._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Instance.")
        
agcls.AgClassCatalog.add_catalog_entry("{28241775-2044-4AD1-BC1D-D5B345437415}", Instance)


class Template(IContext, ITemplate):
    """Enables to obtain information about the STK class that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IContext.__init__(self, sourceObject)
        ITemplate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IContext._private_init(self, pUnk)
        ITemplate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IContext._get_property(self, attrname) is not None: found_prop = IContext._get_property(self, attrname)
        if ITemplate._get_property(self, attrname) is not None: found_prop = ITemplate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Template.")
        
agcls.AgClassCatalog.add_catalog_entry("{DB2ABC0D-53EC-43C9-AB85-3ADBDC10CFE3}", Template)


class PointRefTo(IPointRefTo, IRefTo):
    """Represents a reference to a VGT point."""
    def __init__(self, sourceObject=None):
        IPointRefTo.__init__(self, sourceObject)
        IRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointRefTo._private_init(self, pUnk)
        IRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointRefTo._get_property(self, attrname) is not None: found_prop = IPointRefTo._get_property(self, attrname)
        if IRefTo._get_property(self, attrname) is not None: found_prop = IRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{33A043CD-6D36-414A-B73C-9DA3ABDE4C6F}", PointRefTo)


class VectorRefTo(IVectorRefTo, IRefTo):
    """Represents a vector reference."""
    def __init__(self, sourceObject=None):
        IVectorRefTo.__init__(self, sourceObject)
        IRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorRefTo._private_init(self, pUnk)
        IRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorRefTo._get_property(self, attrname) is not None: found_prop = IVectorRefTo._get_property(self, attrname)
        if IRefTo._get_property(self, attrname) is not None: found_prop = IRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{76ABF2B5-C60E-4B80-84BA-3F2345E357A6}", VectorRefTo)


class AxesRefTo(IAxesRefTo, IRefTo):
    """Represents a reference to a VGT axes."""
    def __init__(self, sourceObject=None):
        IAxesRefTo.__init__(self, sourceObject)
        IRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesRefTo._private_init(self, pUnk)
        IRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesRefTo._get_property(self, attrname) is not None: found_prop = IAxesRefTo._get_property(self, attrname)
        if IRefTo._get_property(self, attrname) is not None: found_prop = IRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{ABAD0C95-5570-461A-9DA0-FD800B10DB20}", AxesRefTo)


class AngleRefTo(IAngleRefTo, IRefTo):
    """Represents a reference to a VGT angle."""
    def __init__(self, sourceObject=None):
        IAngleRefTo.__init__(self, sourceObject)
        IRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleRefTo._private_init(self, pUnk)
        IRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleRefTo._get_property(self, attrname) is not None: found_prop = IAngleRefTo._get_property(self, attrname)
        if IRefTo._get_property(self, attrname) is not None: found_prop = IRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1C8DFF6-65AA-4A6B-B160-7315BD795133}", AngleRefTo)


class SystemRefTo(ISystemRefTo, IRefTo):
    """Represents a System reference."""
    def __init__(self, sourceObject=None):
        ISystemRefTo.__init__(self, sourceObject)
        IRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISystemRefTo._private_init(self, pUnk)
        IRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISystemRefTo._get_property(self, attrname) is not None: found_prop = ISystemRefTo._get_property(self, attrname)
        if IRefTo._get_property(self, attrname) is not None: found_prop = IRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SystemRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{4C6DEAA3-3DD0-439F-A58F-A2BC329384A8}", SystemRefTo)


class PlaneRefTo(IPlaneRefTo, IRefTo):
    """Represents a Plane reference."""
    def __init__(self, sourceObject=None):
        IPlaneRefTo.__init__(self, sourceObject)
        IRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneRefTo._private_init(self, pUnk)
        IRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneRefTo._get_property(self, attrname) is not None: found_prop = IPlaneRefTo._get_property(self, attrname)
        if IRefTo._get_property(self, attrname) is not None: found_prop = IRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{C24A1C1D-EEF3-43DB-83BF-04F12E85B155}", PlaneRefTo)


class Vector(IVector, ITimeProperties, ICoordinate):
    """A generic vector class."""
    def __init__(self, sourceObject=None):
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Vector.")
        
agcls.AgClassCatalog.add_catalog_entry("{64392436-52D5-4274-9483-E10C56BBD037}", Vector)


class AxesLabels(IAxesLabels):
    """Allows configuring the VGT axes labels."""
    def __init__(self, sourceObject=None):
        IAxesLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesLabels._get_property(self, attrname) is not None: found_prop = IAxesLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesLabels.")
        
agcls.AgClassCatalog.add_catalog_entry("{AC9F13AD-1E42-4695-AC74-6259D2013E4F}", AxesLabels)


class Axes(IAxes, ITimeProperties, ICoordinate):
    """A generic axes class."""
    def __init__(self, sourceObject=None):
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Axes.")
        
agcls.AgClassCatalog.add_catalog_entry("{50F5DD10-4D83-4603-94ED-BF7514C26282}", Axes)


class Point(IPoint, ITimeProperties, ICoordinate):
    """A generic VGT point class."""
    def __init__(self, sourceObject=None):
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Point.")
        
agcls.AgClassCatalog.add_catalog_entry("{0092C129-467E-4B36-B971-C53F65481DA9}", Point)


class System(ISystem, ITimeProperties, ICoordinate):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        ISystem.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISystem._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISystem._get_property(self, attrname) is not None: found_prop = ISystem._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in System.")
        
agcls.AgClassCatalog.add_catalog_entry("{20F29E1B-F72A-4B9C-B13B-04E8F1CCAEA6}", System)


class Angle(IAngle, ITimeProperties, ICoordinate):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IAngle.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngle._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngle._get_property(self, attrname) is not None: found_prop = IAngle._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Angle.")
        
agcls.AgClassCatalog.add_catalog_entry("{C3F96DA3-00EC-4E20-A66C-B3506100496B}", Angle)


class PlaneLabels(IPlaneLabels):
    """Allows configuring the X and Y axes labels."""
    def __init__(self, sourceObject=None):
        IPlaneLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneLabels._get_property(self, attrname) is not None: found_prop = IPlaneLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneLabels.")
        
agcls.AgClassCatalog.add_catalog_entry("{E40312E9-2D04-4F38-8E35-0C1F5CC66B79}", PlaneLabels)


class Plane(IPlane, ITimeProperties, ICoordinate):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IPlane.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlane._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlane._get_property(self, attrname) is not None: found_prop = IPlane._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Plane.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E6EAA85-8440-4C4E-97FE-76491E05098A}", Plane)


class AxesAlignedAndConstrained(IAxesAlignedAndConstrained, IAxes, ITimeProperties, ICoordinate):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    def __init__(self, sourceObject=None):
        IAxesAlignedAndConstrained.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesAlignedAndConstrained._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesAlignedAndConstrained._get_property(self, attrname) is not None: found_prop = IAxesAlignedAndConstrained._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesAlignedAndConstrained.")
        
agcls.AgClassCatalog.add_catalog_entry("{46BB7D5B-6593-434F-B288-BF1445920A2C}", AxesAlignedAndConstrained)


class AxesAngularOffset(IAxesAngularOffset, IAxes, ITimeProperties, ICoordinate):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IAxesAngularOffset.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesAngularOffset._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesAngularOffset._get_property(self, attrname) is not None: found_prop = IAxesAngularOffset._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesAngularOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{64503F8B-96E7-455B-B589-2578ADE1214B}", AxesAngularOffset)


class AxesFixedAtEpoch(IAxesFixedAtEpoch, IAxes, ITimeProperties, ICoordinate):
    """Axes based on another set fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IAxesFixedAtEpoch.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesFixedAtEpoch._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IAxesFixedAtEpoch._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesFixedAtEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{BEEE1271-F9F7-4C9E-A6C9-4337AA4F86AC}", AxesFixedAtEpoch)


class AxesBPlane(IAxesBPlane, IAxes, ITimeProperties, ICoordinate):
    """B-Plane axes using the selected target body and reference vector."""
    def __init__(self, sourceObject=None):
        IAxesBPlane.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesBPlane._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesBPlane._get_property(self, attrname) is not None: found_prop = IAxesBPlane._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{E0F714EA-31E4-4F92-876F-BDD3183C29B5}", AxesBPlane)


class AxesCustomScript(IAxesCustomScript, IAxes, ITimeProperties, ICoordinate):
    """Customized axes offset with respect to a set of reference Axes."""
    def __init__(self, sourceObject=None):
        IAxesCustomScript.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesCustomScript._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesCustomScript._get_property(self, attrname) is not None: found_prop = IAxesCustomScript._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesCustomScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC7A87DC-118E-46ED-8657-90DF42B7B101}", AxesCustomScript)


class AxesAttitudeFile(IAxesAttitudeFile, IAxes, ITimeProperties, ICoordinate):
    """Axes specified by data from a file."""
    def __init__(self, sourceObject=None):
        IAxesAttitudeFile.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesAttitudeFile._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesAttitudeFile._get_property(self, attrname) is not None: found_prop = IAxesAttitudeFile._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesAttitudeFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{3505D063-9E1B-4964-9865-FFE41F64C8CF}", AxesAttitudeFile)


class AxesFixed(IAxesFixed, IAxes, ITimeProperties, ICoordinate):
    """Axes fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IAxesFixed.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesFixed._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesFixed._get_property(self, attrname) is not None: found_prop = IAxesFixed._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AE41C73-3C82-405B-B7D2-A6D1BE7EE2EE}", AxesFixed)


class AxesModelAttach(IAxesModelAttach, IAxes, ITimeProperties, ICoordinate):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IAxesModelAttach.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesModelAttach._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesModelAttach._get_property(self, attrname) is not None: found_prop = IAxesModelAttach._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{816C612A-13DD-4812-BFDE-E3861F8C39FD}", AxesModelAttach)


class AxesSpinning(IAxesSpinning, IAxes, ITimeProperties, ICoordinate):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IAxesSpinning.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesSpinning._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesSpinning._get_property(self, attrname) is not None: found_prop = IAxesSpinning._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesSpinning.")
        
agcls.AgClassCatalog.add_catalog_entry("{C0FB8B6D-84CC-4553-ADA9-2F7D91A83AB6}", AxesSpinning)


class AxesOnSurface(IAxesOnSurface, IAxes, ITimeProperties, ICoordinate):
    """Topocentric axes located at the reference point's projection on the central body."""
    def __init__(self, sourceObject=None):
        IAxesOnSurface.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesOnSurface._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesOnSurface._get_property(self, attrname) is not None: found_prop = IAxesOnSurface._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE8C301A-A846-44FD-8871-5AB4CAACEF11}", AxesOnSurface)


class AxesTrajectory(IAxesTrajectory, IAxes, ITimeProperties, ICoordinate):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    def __init__(self, sourceObject=None):
        IAxesTrajectory.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesTrajectory._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesTrajectory._get_property(self, attrname) is not None: found_prop = IAxesTrajectory._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{4038771E-73C1-4989-A9AB-4DC37025FACC}", AxesTrajectory)


class AxesLagrangeLibration(IAxesLagrangeLibration, IAxes, ITimeProperties, ICoordinate):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    def __init__(self, sourceObject=None):
        IAxesLagrangeLibration.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesLagrangeLibration._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesLagrangeLibration._get_property(self, attrname) is not None: found_prop = IAxesLagrangeLibration._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesLagrangeLibration.")
        
agcls.AgClassCatalog.add_catalog_entry("{16315085-7C87-4A20-865C-0F419A5CDA2F}", AxesLagrangeLibration)


class AxesCommonTasks(IAxesCommonTasks):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IAxesCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesCommonTasks._get_property(self, attrname) is not None: found_prop = IAxesCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{07D4865C-78F1-4B3A-9756-D70050613D4A}", AxesCommonTasks)


class AxesAtTimeInstant(IAxesAtTimeInstant, ICoordinate, ITimeProperties, IAxes):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IAxesAtTimeInstant.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesAtTimeInstant._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAxesAtTimeInstant._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{3845C20A-A6E2-45A0-A748-10E9B565C48D}", AxesAtTimeInstant)


class AxesPlugin(IAxesPlugin, ICoordinate, ITimeProperties, IAxes):
    """A VGT axes plugin."""
    def __init__(self, sourceObject=None):
        IAxesPlugin.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesPlugin._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesPlugin._get_property(self, attrname) is not None: found_prop = IAxesPlugin._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IAxes._get_property(self, attrname) is not None: found_prop = IAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{C494C46D-EBC6-45B9-B2E7-C9FF7E75467D}", AxesPlugin)


class AngleBetweenVectors(IAngleBetweenVectors, IAngle, ITimeProperties, ICoordinate):
    """An angle between two vectors."""
    def __init__(self, sourceObject=None):
        IAngleBetweenVectors.__init__(self, sourceObject)
        IAngle.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleBetweenVectors._private_init(self, pUnk)
        IAngle._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleBetweenVectors._get_property(self, attrname) is not None: found_prop = IAngleBetweenVectors._get_property(self, attrname)
        if IAngle._get_property(self, attrname) is not None: found_prop = IAngle._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleBetweenVectors.")
        
agcls.AgClassCatalog.add_catalog_entry("{2F0AA430-85D0-4479-9540-B1B64EB3B530}", AngleBetweenVectors)


class AngleBetweenPlanes(IAngleBetweenPlanes, IAngle, ITimeProperties, ICoordinate):
    """An angle between two planes."""
    def __init__(self, sourceObject=None):
        IAngleBetweenPlanes.__init__(self, sourceObject)
        IAngle.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleBetweenPlanes._private_init(self, pUnk)
        IAngle._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleBetweenPlanes._get_property(self, attrname) is not None: found_prop = IAngleBetweenPlanes._get_property(self, attrname)
        if IAngle._get_property(self, attrname) is not None: found_prop = IAngle._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleBetweenPlanes.")
        
agcls.AgClassCatalog.add_catalog_entry("{30C2886F-8792-475D-9E42-975308B1B94E}", AngleBetweenPlanes)


class AngleDihedral(IAngleDihedral, IAngle, ITimeProperties, ICoordinate):
    """An angle between two vectors about an axis."""
    def __init__(self, sourceObject=None):
        IAngleDihedral.__init__(self, sourceObject)
        IAngle.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleDihedral._private_init(self, pUnk)
        IAngle._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleDihedral._get_property(self, attrname) is not None: found_prop = IAngleDihedral._get_property(self, attrname)
        if IAngle._get_property(self, attrname) is not None: found_prop = IAngle._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleDihedral.")
        
agcls.AgClassCatalog.add_catalog_entry("{550855BB-E8F1-440B-BA5C-024ACE2E2A17}", AngleDihedral)


class AngleRotation(IAngleRotation, IAngle, ITimeProperties, ICoordinate):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    def __init__(self, sourceObject=None):
        IAngleRotation.__init__(self, sourceObject)
        IAngle.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleRotation._private_init(self, pUnk)
        IAngle._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleRotation._get_property(self, attrname) is not None: found_prop = IAngleRotation._get_property(self, attrname)
        if IAngle._get_property(self, attrname) is not None: found_prop = IAngle._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleRotation.")
        
agcls.AgClassCatalog.add_catalog_entry("{AD8B87A3-8407-42AB-B6CA-8E83450C32C1}", AngleRotation)


class AngleToPlane(IAngleToPlane, IAngle, ITimeProperties, ICoordinate):
    """An angle between a vector and a plane."""
    def __init__(self, sourceObject=None):
        IAngleToPlane.__init__(self, sourceObject)
        IAngle.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleToPlane._private_init(self, pUnk)
        IAngle._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleToPlane._get_property(self, attrname) is not None: found_prop = IAngleToPlane._get_property(self, attrname)
        if IAngle._get_property(self, attrname) is not None: found_prop = IAngle._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleToPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{8CE8877B-1078-41CD-AEE6-B9DDD92F8201}", AngleToPlane)


class PlaneNormal(IPlaneNormal, IPlane, ITimeProperties, ICoordinate):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IPlaneNormal.__init__(self, sourceObject)
        IPlane.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneNormal._private_init(self, pUnk)
        IPlane._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneNormal._get_property(self, attrname) is not None: found_prop = IPlaneNormal._get_property(self, attrname)
        if IPlane._get_property(self, attrname) is not None: found_prop = IPlane._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneNormal.")
        
agcls.AgClassCatalog.add_catalog_entry("{0AED319D-7B6C-462B-882B-D363F7A2A86C}", PlaneNormal)


class PlaneQuadrant(IPlaneQuadrant, IPlane, ITimeProperties, ICoordinate):
    """A plane based on a selected Quadrant of a reference system."""
    def __init__(self, sourceObject=None):
        IPlaneQuadrant.__init__(self, sourceObject)
        IPlane.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneQuadrant._private_init(self, pUnk)
        IPlane._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneQuadrant._get_property(self, attrname) is not None: found_prop = IPlaneQuadrant._get_property(self, attrname)
        if IPlane._get_property(self, attrname) is not None: found_prop = IPlane._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneQuadrant.")
        
agcls.AgClassCatalog.add_catalog_entry("{8330CE61-25F6-4F92-AE2E-BDB566BA42F3}", PlaneQuadrant)


class PlaneTrajectory(IPlaneTrajectory, IPlane, ITimeProperties, ICoordinate):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    def __init__(self, sourceObject=None):
        IPlaneTrajectory.__init__(self, sourceObject)
        IPlane.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneTrajectory._private_init(self, pUnk)
        IPlane._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneTrajectory._get_property(self, attrname) is not None: found_prop = IPlaneTrajectory._get_property(self, attrname)
        if IPlane._get_property(self, attrname) is not None: found_prop = IPlane._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7BD18F79-6788-48B1-AFB5-243D62C01177}", PlaneTrajectory)


class PlaneTriad(IPlaneTriad, IPlane, ITimeProperties, ICoordinate):
    """A Plane containing points PointA, PointB and ReferencePont with the first axis aligned with the direction from the ReferencePoint to PointA and the second axis toward the direction from the ReferencePoint to PointB."""
    def __init__(self, sourceObject=None):
        IPlaneTriad.__init__(self, sourceObject)
        IPlane.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneTriad._private_init(self, pUnk)
        IPlane._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneTriad._get_property(self, attrname) is not None: found_prop = IPlaneTriad._get_property(self, attrname)
        if IPlane._get_property(self, attrname) is not None: found_prop = IPlane._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneTriad.")
        
agcls.AgClassCatalog.add_catalog_entry("{8A4D3940-BD08-4D5C-A171-E0AC90DEB5F4}", PlaneTriad)


class PlaneTwoVector(IPlaneTwoVector, IPlane, ITimeProperties, ICoordinate):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IPlaneTwoVector.__init__(self, sourceObject)
        IPlane.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneTwoVector._private_init(self, pUnk)
        IPlane._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneTwoVector._get_property(self, attrname) is not None: found_prop = IPlaneTwoVector._get_property(self, attrname)
        if IPlane._get_property(self, attrname) is not None: found_prop = IPlane._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneTwoVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{49a61e7a-baba-48fd-9d9d-61f91c520291}", PlaneTwoVector)


class PointBPlane(IPointBPlane, IPoint, ITimeProperties, ICoordinate):
    """B-Plane point using the selected target body."""
    def __init__(self, sourceObject=None):
        IPointBPlane.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointBPlane._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointBPlane._get_property(self, attrname) is not None: found_prop = IPointBPlane._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{E62329EB-83D1-47CE-8B5B-B795995A2270}", PointBPlane)


class PointFile(IPointFile, IPoint, ITimeProperties, ICoordinate):
    """Point specified by data from a file."""
    def __init__(self, sourceObject=None):
        IPointFile.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointFile._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointFile._get_property(self, attrname) is not None: found_prop = IPointFile._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E71C927-09CA-4A90-95F0-CB87E244CE72}", PointFile)


class PointFixedInSystem(IPointFixedInSystem, IPoint, ITimeProperties, ICoordinate):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    def __init__(self, sourceObject=None):
        IPointFixedInSystem.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointFixedInSystem._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointFixedInSystem._get_property(self, attrname) is not None: found_prop = IPointFixedInSystem._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointFixedInSystem.")
        
agcls.AgClassCatalog.add_catalog_entry("{9FA10E06-094A-446C-BE9A-5BA397776778}", PointFixedInSystem)


class PointGrazing(IPointGrazing, IPoint, ITimeProperties, ICoordinate):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    def __init__(self, sourceObject=None):
        IPointGrazing.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointGrazing._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointGrazing._get_property(self, attrname) is not None: found_prop = IPointGrazing._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointGrazing.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7D8A954-B6ED-43A0-8B2C-C58B06DCDFF7}", PointGrazing)


class PointGlint(IPointGlint, IPoint, ITimeProperties, ICoordinate):
    """Point on central body surface that reflects from source to observer."""
    def __init__(self, sourceObject=None):
        IPointGlint.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointGlint._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointGlint._get_property(self, attrname) is not None: found_prop = IPointGlint._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointGlint.")
        
agcls.AgClassCatalog.add_catalog_entry("{68F85553-0FA2-459D-93AC-BD4D68A01F6F}", PointGlint)


class PointCovarianceGrazing(IPointCovarianceGrazing, IPoint, ITimeProperties, ICoordinate):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    def __init__(self, sourceObject=None):
        IPointCovarianceGrazing.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointCovarianceGrazing._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointCovarianceGrazing._get_property(self, attrname) is not None: found_prop = IPointCovarianceGrazing._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointCovarianceGrazing.")
        
agcls.AgClassCatalog.add_catalog_entry("{84D91807-716E-46F4-AB70-53C73FA21C20}", PointCovarianceGrazing)


class PointPlaneIntersection(IPointPlaneIntersection, IPoint, ITimeProperties, ICoordinate):
    """Point on a plane located along a given direction looking from a given origin."""
    def __init__(self, sourceObject=None):
        IPointPlaneIntersection.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointPlaneIntersection._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointPlaneIntersection._get_property(self, attrname) is not None: found_prop = IPointPlaneIntersection._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointPlaneIntersection.")
        
agcls.AgClassCatalog.add_catalog_entry("{63F785C4-EC8E-4BCA-AF05-D57BD357D06C}", PointPlaneIntersection)


class PointOnSurface(IPointOnSurface, IPoint, ITimeProperties, ICoordinate):
    """The detic subpoint of the reference point as projected onto the central body."""
    def __init__(self, sourceObject=None):
        IPointOnSurface.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointOnSurface._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointOnSurface._get_property(self, attrname) is not None: found_prop = IPointOnSurface._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{03ECCFD1-B058-4817-826F-EDE2A6880757}", PointOnSurface)


class PointModelAttach(IPointModelAttach, IPoint, ITimeProperties, ICoordinate):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    def __init__(self, sourceObject=None):
        IPointModelAttach.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointModelAttach._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointModelAttach._get_property(self, attrname) is not None: found_prop = IPointModelAttach._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{15958616-F779-4772-9E54-9B134B69BE89}", PointModelAttach)


class PointSatelliteCollectionEntry(IPointSatelliteCollectionEntry, IPoint, ITimeProperties, ICoordinate):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    def __init__(self, sourceObject=None):
        IPointSatelliteCollectionEntry.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointSatelliteCollectionEntry._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointSatelliteCollectionEntry._get_property(self, attrname) is not None: found_prop = IPointSatelliteCollectionEntry._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointSatelliteCollectionEntry.")
        
agcls.AgClassCatalog.add_catalog_entry("{d0dacbed-0c16-4de5-b32a-9c7624297014}", PointSatelliteCollectionEntry)


class PointPlaneProjection(IPointPlaneProjection, IPoint, ITimeProperties, ICoordinate):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    def __init__(self, sourceObject=None):
        IPointPlaneProjection.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointPlaneProjection._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointPlaneProjection._get_property(self, attrname) is not None: found_prop = IPointPlaneProjection._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointPlaneProjection.")
        
agcls.AgClassCatalog.add_catalog_entry("{C750AD99-2498-42F6-BBBD-CEB1835E8F3A}", PointPlaneProjection)


class PointLagrangeLibration(IPointLagrangeLibration, IPoint, ITimeProperties, ICoordinate):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    def __init__(self, sourceObject=None):
        IPointLagrangeLibration.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointLagrangeLibration._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointLagrangeLibration._get_property(self, attrname) is not None: found_prop = IPointLagrangeLibration._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointLagrangeLibration.")
        
agcls.AgClassCatalog.add_catalog_entry("{6BF6D976-775A-445D-AD2B-899892F3127E}", PointLagrangeLibration)


class PointCommonTasks(IPointCommonTasks):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IPointCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointCommonTasks._get_property(self, attrname) is not None: found_prop = IPointCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{9866644C-E731-465E-A7AA-3F4667C1729E}", PointCommonTasks)


class PointCentBodyIntersect(IPointCentBodyIntersect, ICoordinate, ITimeProperties, IPoint):
    """Point on central body surface along direction vector originating at source point."""
    def __init__(self, sourceObject=None):
        IPointCentBodyIntersect.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointCentBodyIntersect._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointCentBodyIntersect._get_property(self, attrname) is not None: found_prop = IPointCentBodyIntersect._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointCentBodyIntersect.")
        
agcls.AgClassCatalog.add_catalog_entry("{882047E8-7CB3-489B-B029-33163CBBA583}", PointCentBodyIntersect)


class PointAtTimeInstant(IPointAtTimeInstant, ICoordinate, ITimeProperties, IPoint):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IPointAtTimeInstant.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointAtTimeInstant._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointAtTimeInstant._get_property(self, attrname) is not None: found_prop = IPointAtTimeInstant._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{8BFB46DF-C6BC-45DA-BAA7-9C996710CFDA}", PointAtTimeInstant)


class PointPlugin(IPointPlugin, ICoordinate, ITimeProperties, IPoint):
    """A VGT point plugin."""
    def __init__(self, sourceObject=None):
        IPointPlugin.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointPlugin._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointPlugin._get_property(self, attrname) is not None: found_prop = IPointPlugin._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{8297DC34-1755-4FE7-BA23-2D9CDE487EF1}", PointPlugin)


class PointCBFixedOffset(IPointCBFixedOffset, ICoordinate, ITimeProperties, IPoint):
    """Point specified by fixed components with respect to central body."""
    def __init__(self, sourceObject=None):
        IPointCBFixedOffset.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointCBFixedOffset._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointCBFixedOffset._get_property(self, attrname) is not None: found_prop = IPointCBFixedOffset._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IPoint._get_property(self, attrname) is not None: found_prop = IPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointCBFixedOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{0C76BDAE-992E-4D61-8D09-E6B2B6923A5B}", PointCBFixedOffset)


class SystemAssembled(ISystemAssembled, ISystem, ITimeProperties, ICoordinate):
    """A system assembled from an origin point and a set of reference axes."""
    def __init__(self, sourceObject=None):
        ISystemAssembled.__init__(self, sourceObject)
        ISystem.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISystemAssembled._private_init(self, pUnk)
        ISystem._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISystemAssembled._get_property(self, attrname) is not None: found_prop = ISystemAssembled._get_property(self, attrname)
        if ISystem._get_property(self, attrname) is not None: found_prop = ISystem._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SystemAssembled.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE4E84B1-8CCF-467A-A3ED-274D0943407F}", SystemAssembled)


class SystemOnSurface(ISystemOnSurface, ISystem, ITimeProperties, ICoordinate):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    def __init__(self, sourceObject=None):
        ISystemOnSurface.__init__(self, sourceObject)
        ISystem.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISystemOnSurface._private_init(self, pUnk)
        ISystem._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISystemOnSurface._get_property(self, attrname) is not None: found_prop = ISystemOnSurface._get_property(self, attrname)
        if ISystem._get_property(self, attrname) is not None: found_prop = ISystem._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SystemOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{073423F9-A59D-4313-B499-C86A45C63513}", SystemOnSurface)


class LLAPosition(ILLAPosition):
    """A position represented by the Latitude, longtitude and Latitude."""
    def __init__(self, sourceObject=None):
        ILLAPosition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILLAPosition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILLAPosition._get_property(self, attrname) is not None: found_prop = ILLAPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LLAPosition.")
        
agcls.AgClassCatalog.add_catalog_entry("{CB962F51-978A-43F9-A88B-AAB62117F93C}", LLAPosition)


class SystemCommonTasks(ISystemCommonTasks):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        ISystemCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISystemCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISystemCommonTasks._get_property(self, attrname) is not None: found_prop = ISystemCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SystemCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{EBE7AF41-FC7E-4D82-B522-72B4AA551B41}", SystemCommonTasks)


class VectorAngleRate(IVectorAngleRate, IVector, ITimeProperties, ICoordinate):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    def __init__(self, sourceObject=None):
        IVectorAngleRate.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorAngleRate._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorAngleRate._get_property(self, attrname) is not None: found_prop = IVectorAngleRate._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorAngleRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{5769E079-8E9B-40B2-B2EF-14F202AF5666}", VectorAngleRate)


class VectorApoapsis(IVectorApoapsis, IVector, ITimeProperties, ICoordinate):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IVectorApoapsis.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorApoapsis._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorApoapsis._get_property(self, attrname) is not None: found_prop = IVectorApoapsis._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorApoapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{22E4138C-29C6-4401-91E0-DF0C00422302}", VectorApoapsis)


class VectorFixedAtEpoch(IVectorFixedAtEpoch, IVector, ITimeProperties, ICoordinate):
    """Based on another vector fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IVectorFixedAtEpoch.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorFixedAtEpoch._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IVectorFixedAtEpoch._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorFixedAtEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{FA8DB5F5-1F28-40E6-9B86-489E06D61523}", VectorFixedAtEpoch)


class VectorAngularVelocity(IVectorAngularVelocity, IVector, ITimeProperties, ICoordinate):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    def __init__(self, sourceObject=None):
        IVectorAngularVelocity.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorAngularVelocity._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorAngularVelocity._get_property(self, attrname) is not None: found_prop = IVectorAngularVelocity._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorAngularVelocity.")
        
agcls.AgClassCatalog.add_catalog_entry("{2ABC83DB-6F6C-4A91-8597-21BD2715D411}", VectorAngularVelocity)


class VectorConing(IVectorConing, IVector, ITimeProperties, ICoordinate):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    def __init__(self, sourceObject=None):
        IVectorConing.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorConing._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorConing._get_property(self, attrname) is not None: found_prop = IVectorConing._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorConing.")
        
agcls.AgClassCatalog.add_catalog_entry("{74E6F986-E292-4115-84E4-9E9953C163B8}", VectorConing)


class VectorCross(IVectorCross, IVector, ITimeProperties, ICoordinate):
    """The vector cross product of two vectors."""
    def __init__(self, sourceObject=None):
        IVectorCross.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorCross._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorCross._get_property(self, attrname) is not None: found_prop = IVectorCross._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorCross.")
        
agcls.AgClassCatalog.add_catalog_entry("{88B6E3B7-51CD-45DE-97C0-DCFE834C0111}", VectorCross)


class VectorCustomScript(IVectorCustomScript, IVector, ITimeProperties, ICoordinate):
    """Customized vector components defined with respect to reference axes."""
    def __init__(self, sourceObject=None):
        IVectorCustomScript.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorCustomScript._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorCustomScript._get_property(self, attrname) is not None: found_prop = IVectorCustomScript._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorCustomScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{D65CDDC6-21DA-419F-BF72-79C2376648E8}", VectorCustomScript)


class VectorDerivative(IVectorDerivative, IVector, ITimeProperties, ICoordinate):
    """A vector derivative of a vector computed with respect to specified axes."""
    def __init__(self, sourceObject=None):
        IVectorDerivative.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorDerivative._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorDerivative._get_property(self, attrname) is not None: found_prop = IVectorDerivative._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{B81ECB39-CF3E-49AE-8622-F454CD0EA7B2}", VectorDerivative)


class VectorDisplacement(IVectorDisplacement, IVector, ITimeProperties, ICoordinate):
    """Vector defined by its start and end points."""
    def __init__(self, sourceObject=None):
        IVectorDisplacement.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorDisplacement._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorDisplacement._get_property(self, attrname) is not None: found_prop = IVectorDisplacement._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorDisplacement.")
        
agcls.AgClassCatalog.add_catalog_entry("{6CAADA67-7238-4705-9F74-95596344DED0}", VectorDisplacement)


class VectorTwoPlanesIntersection(IVectorTwoPlanesIntersection, IVector, ITimeProperties, ICoordinate):
    """Defined along the intersection of two planes."""
    def __init__(self, sourceObject=None):
        IVectorTwoPlanesIntersection.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorTwoPlanesIntersection._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorTwoPlanesIntersection._get_property(self, attrname) is not None: found_prop = IVectorTwoPlanesIntersection._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorTwoPlanesIntersection.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1145553-76CD-4C1E-AE08-E63E29CF4E46}", VectorTwoPlanesIntersection)


class VectorModelAttach(IVectorModelAttach, IVector, ITimeProperties, ICoordinate):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IVectorModelAttach.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorModelAttach._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorModelAttach._get_property(self, attrname) is not None: found_prop = IVectorModelAttach._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{E95BEEB8-C544-4852-9C82-20080343E585}", VectorModelAttach)


class VectorProjection(IVectorProjection, IVector, ITimeProperties, ICoordinate):
    """A projection of a vector computed with respect to a reference plane."""
    def __init__(self, sourceObject=None):
        IVectorProjection.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorProjection._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorProjection._get_property(self, attrname) is not None: found_prop = IVectorProjection._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorProjection.")
        
agcls.AgClassCatalog.add_catalog_entry("{7306544A-A8B0-477B-B89D-BA711C9ED600}", VectorProjection)


class VectorScaled(IVectorScaled, IVector, ITimeProperties, ICoordinate):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    def __init__(self, sourceObject=None):
        IVectorScaled.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorScaled._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorScaled._get_property(self, attrname) is not None: found_prop = IVectorScaled._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{92D80C29-251B-436B-9DA0-D5BA4B262185}", VectorScaled)


class VectorEccentricity(IVectorEccentricity, IVector, ITimeProperties, ICoordinate):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IVectorEccentricity.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorEccentricity._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorEccentricity._get_property(self, attrname) is not None: found_prop = IVectorEccentricity._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorEccentricity.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7F157D7-11EB-4779-955F-98530B9C2608}", VectorEccentricity)


class VectorFixedInAxes(IVectorFixedInAxes, IVector, ITimeProperties, ICoordinate):
    """Vector fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IVectorFixedInAxes.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorFixedInAxes._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorFixedInAxes._get_property(self, attrname) is not None: found_prop = IVectorFixedInAxes._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorFixedInAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{61E9F963-8CFC-4B24-B583-716A64BAE54C}", VectorFixedInAxes)


class VectorLineOfNodes(IVectorLineOfNodes, IVector, ITimeProperties, ICoordinate):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    def __init__(self, sourceObject=None):
        IVectorLineOfNodes.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorLineOfNodes._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorLineOfNodes._get_property(self, attrname) is not None: found_prop = IVectorLineOfNodes._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorLineOfNodes.")
        
agcls.AgClassCatalog.add_catalog_entry("{3D6B3FD1-93C2-4F11-AB10-B749DF633C29}", VectorLineOfNodes)


class VectorOrbitAngularMomentum(IVectorOrbitAngularMomentum, IVector, ITimeProperties, ICoordinate):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IVectorOrbitAngularMomentum.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorOrbitAngularMomentum._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorOrbitAngularMomentum._get_property(self, attrname) is not None: found_prop = IVectorOrbitAngularMomentum._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorOrbitAngularMomentum.")
        
agcls.AgClassCatalog.add_catalog_entry("{2B38A283-7EDA-43E2-9C04-E9964FCA7D91}", VectorOrbitAngularMomentum)


class VectorOrbitNormal(IVectorOrbitNormal, IVector, ITimeProperties, ICoordinate):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IVectorOrbitNormal.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorOrbitNormal._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorOrbitNormal._get_property(self, attrname) is not None: found_prop = IVectorOrbitNormal._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorOrbitNormal.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFBAED88-891B-4EF7-98BD-DEBAF630C0E1}", VectorOrbitNormal)


class VectorPeriapsis(IVectorPeriapsis, IVector, ITimeProperties, ICoordinate):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IVectorPeriapsis.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorPeriapsis._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorPeriapsis._get_property(self, attrname) is not None: found_prop = IVectorPeriapsis._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA81B380-6D7C-48F4-8E7F-472035958B44}", VectorPeriapsis)


class VectorReflection(IVectorReflection, IVector, ITimeProperties, ICoordinate):
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    def __init__(self, sourceObject=None):
        IVectorReflection.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorReflection._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorReflection._get_property(self, attrname) is not None: found_prop = IVectorReflection._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorReflection.")
        
agcls.AgClassCatalog.add_catalog_entry("{C35F8BF0-ED12-48BF-8770-EE63DAF4A9B1}", VectorReflection)


class VectorRotationVector(IVectorRotationVector, IVector, ITimeProperties, ICoordinate):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    def __init__(self, sourceObject=None):
        IVectorRotationVector.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorRotationVector._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorRotationVector._get_property(self, attrname) is not None: found_prop = IVectorRotationVector._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorRotationVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{c599beae-b6c1-495e-8957-a4b9ffc5cb8e}", VectorRotationVector)


class VectorDirectionToStar(IVectorDirectionToStar, IVector, ITimeProperties, ICoordinate):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    def __init__(self, sourceObject=None):
        IVectorDirectionToStar.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorDirectionToStar._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorDirectionToStar._get_property(self, attrname) is not None: found_prop = IVectorDirectionToStar._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorDirectionToStar.")
        
agcls.AgClassCatalog.add_catalog_entry("{147FDFCC-767A-460C-9833-02A582AFCA9C}", VectorDirectionToStar)


class VectorFixedAtTimeInstant(IVectorFixedAtTimeInstant, ICoordinate, ITimeProperties, IVector):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IVectorFixedAtTimeInstant.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorFixedAtTimeInstant._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = IVectorFixedAtTimeInstant._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorFixedAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC8737B3-A94E-4B68-857F-81E780C874FD}", VectorFixedAtTimeInstant)


class VectorLinearCombination(IVectorLinearCombination, ICoordinate, ITimeProperties, IVector):
    """Linear combination of two input vectors."""
    def __init__(self, sourceObject=None):
        IVectorLinearCombination.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorLinearCombination._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorLinearCombination._get_property(self, attrname) is not None: found_prop = IVectorLinearCombination._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorLinearCombination.")
        
agcls.AgClassCatalog.add_catalog_entry("{59E2764C-7920-4CDC-B5FF-2590154E1ABE}", VectorLinearCombination)


class VectorProjectAlongVector(IVectorProjectAlongVector, ICoordinate, ITimeProperties, IVector):
    """A projection of a source vector in the direction of another vector."""
    def __init__(self, sourceObject=None):
        IVectorProjectAlongVector.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorProjectAlongVector._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorProjectAlongVector._get_property(self, attrname) is not None: found_prop = IVectorProjectAlongVector._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorProjectAlongVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{7B76B999-135B-4AAF-ADEA-444FD759417D}", VectorProjectAlongVector)


class VectorScalarLinearCombination(IVectorScalarLinearCombination, ICoordinate, ITimeProperties, IVector):
    """Linear combination of two input vectors using scalars."""
    def __init__(self, sourceObject=None):
        IVectorScalarLinearCombination.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorScalarLinearCombination._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorScalarLinearCombination._get_property(self, attrname) is not None: found_prop = IVectorScalarLinearCombination._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorScalarLinearCombination.")
        
agcls.AgClassCatalog.add_catalog_entry("{0FB78FA5-9E5F-4A0F-AD73-FB89A0E523F8}", VectorScalarLinearCombination)


class VectorScalarScaled(IVectorScalarScaled, ICoordinate, ITimeProperties, IVector):
    """Scaled version of the input vector using scalar."""
    def __init__(self, sourceObject=None):
        IVectorScalarScaled.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorScalarScaled._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorScalarScaled._get_property(self, attrname) is not None: found_prop = IVectorScalarScaled._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorScalarScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C93B992-687F-4311-B339-DE0DA38409AE}", VectorScalarScaled)


class VectorVelocityAcceleration(IVectorVelocityAcceleration, ICoordinate, ITimeProperties, IVector):
    """Velocity vector of a point in a coordinate system."""
    def __init__(self, sourceObject=None):
        IVectorVelocityAcceleration.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorVelocityAcceleration._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorVelocityAcceleration._get_property(self, attrname) is not None: found_prop = IVectorVelocityAcceleration._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorVelocityAcceleration.")
        
agcls.AgClassCatalog.add_catalog_entry("{75A62225-C09F-4F08-B7FE-9216B02DECF2}", VectorVelocityAcceleration)


class VectorPlugin(IVectorPlugin, ICoordinate, ITimeProperties, IVector):
    """A VGT vector plugin."""
    def __init__(self, sourceObject=None):
        IVectorPlugin.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorPlugin._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorPlugin._get_property(self, attrname) is not None: found_prop = IVectorPlugin._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{E105429A-489E-47F6-B827-8E5819FCE917}", VectorPlugin)


class VectorDispSurface(IVectorDispSurface, ICoordinate, ITimeProperties, IVector):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    def __init__(self, sourceObject=None):
        IVectorDispSurface.__init__(self, sourceObject)
        ICoordinate.__init__(self, sourceObject)
        ITimeProperties.__init__(self, sourceObject)
        IVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorDispSurface._private_init(self, pUnk)
        ICoordinate._private_init(self, pUnk)
        ITimeProperties._private_init(self, pUnk)
        IVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorDispSurface._get_property(self, attrname) is not None: found_prop = IVectorDispSurface._get_property(self, attrname)
        if ICoordinate._get_property(self, attrname) is not None: found_prop = ICoordinate._get_property(self, attrname)
        if ITimeProperties._get_property(self, attrname) is not None: found_prop = ITimeProperties._get_property(self, attrname)
        if IVector._get_property(self, attrname) is not None: found_prop = IVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorDispSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{ccd4af03-78af-47ae-902a-90860a17daa4}", VectorDispSurface)


class VectorFactory(IVectorFactory):
    """A Factory object to create vectors."""
    def __init__(self, sourceObject=None):
        IVectorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorFactory._get_property(self, attrname) is not None: found_prop = IVectorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{084C11E1-D35D-4F42-83D6-3EF43FEC1E23}", VectorFactory)


class AxesFactory(IAxesFactory):
    """A Factory object to create axes."""
    def __init__(self, sourceObject=None):
        IAxesFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesFactory._get_property(self, attrname) is not None: found_prop = IAxesFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7B3E2402-1E15-43DC-BB48-6E98D377B107}", AxesFactory)


class SystemFactory(ISystemFactory):
    """A Factory class to create VGT systems."""
    def __init__(self, sourceObject=None):
        ISystemFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISystemFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISystemFactory._get_property(self, attrname) is not None: found_prop = ISystemFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SystemFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{01A37414-BA74-4DF3-A007-6A3395C8A859}", SystemFactory)


class PointFactory(IPointFactory):
    """A Factory object to create points."""
    def __init__(self, sourceObject=None):
        IPointFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointFactory._get_property(self, attrname) is not None: found_prop = IPointFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{6C79F3B2-8AE5-468A-940F-F0988752B309}", PointFactory)


class PlaneFactory(IPlaneFactory):
    """A Factory object to create VGT planes."""
    def __init__(self, sourceObject=None):
        IPlaneFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneFactory._get_property(self, attrname) is not None: found_prop = IPlaneFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{6F83DB0C-0AFB-4831-BED0-63AE2F8FEFFB}", PlaneFactory)


class AngleFactory(IAngleFactory):
    """A Factory object to create angles."""
    def __init__(self, sourceObject=None):
        IAngleFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleFactory._get_property(self, attrname) is not None: found_prop = IAngleFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{0888F89F-9D77-4FCE-9A08-67FCBE870187}", AngleFactory)


class VectorGroup(IVectorGroup):
    """Access or create VGT vectors associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVectorGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGroup._get_property(self, attrname) is not None: found_prop = IVectorGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{69ABE9EE-BAA4-40A7-8097-06DBE70D71D5}", VectorGroup)


class PointGroup(IPointGroup):
    """Access or create VGT points associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IPointGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointGroup._get_property(self, attrname) is not None: found_prop = IPointGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{0793BE73-C894-4AF7-BFDB-5D61F5C3B6FD}", PointGroup)


class AngleGroup(IAngleGroup):
    """Access or create VGT angles associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAngleGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAngleGroup._get_property(self, attrname) is not None: found_prop = IAngleGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AngleGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{CF6C41CC-A02E-424C-8E7E-B5BA05F1FAF3}", AngleGroup)


class AxesGroup(IAxesGroup):
    """Access or create VGT axes associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAxesGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesGroup._get_property(self, attrname) is not None: found_prop = IAxesGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{2D792657-9D6E-4B1E-AEAB-B964839C6F94}", AxesGroup)


class PlaneGroup(IPlaneGroup):
    """Represents a VGT Plane component."""
    def __init__(self, sourceObject=None):
        IPlaneGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPlaneGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPlaneGroup._get_property(self, attrname) is not None: found_prop = IPlaneGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PlaneGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{15117A82-3EE6-483E-A65E-2A44F60DB355}", PlaneGroup)


class SystemGroup(ISystemGroup):
    """Access or create VGT systems associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ISystemGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISystemGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISystemGroup._get_property(self, attrname) is not None: found_prop = ISystemGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SystemGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{65E8F1CC-E68C-4EF6-9A68-443DD01C55E2}", SystemGroup)


class Provider(IProvider):
    """Allows accessing existing Vector Geometry Tool components."""
    def __init__(self, sourceObject=None):
        IProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProvider._get_property(self, attrname) is not None: found_prop = IProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Provider.")
        
agcls.AgClassCatalog.add_catalog_entry("{D9031FE1-81E1-4818-944D-5F00FC3EC97D}", Provider)


class Root(IRoot):
    """Represents a VGT root."""
    def __init__(self, sourceObject=None):
        IRoot.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRoot._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRoot._get_property(self, attrname) is not None: found_prop = IRoot._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Root.")
        
agcls.AgClassCatalog.add_catalog_entry("{26E18B6F-19CA-4537-B6B3-D307DAADCDBB}", Root)


class WellKnownEarthSystems(IWellKnownEarthSystems):
    """Well-known Earth's coordinate systems."""
    def __init__(self, sourceObject=None):
        IWellKnownEarthSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWellKnownEarthSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWellKnownEarthSystems._get_property(self, attrname) is not None: found_prop = IWellKnownEarthSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WellKnownEarthSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CE3EA8C-78D7-4C9E-9D35-4E34DBA9FD19}", WellKnownEarthSystems)


class WellKnownEarthAxes(IWellKnownEarthAxes):
    """Well-known Earth's axes."""
    def __init__(self, sourceObject=None):
        IWellKnownEarthAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWellKnownEarthAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWellKnownEarthAxes._get_property(self, attrname) is not None: found_prop = IWellKnownEarthAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WellKnownEarthAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{B79CA8BC-D4BA-4F76-9278-AB7C9C537859}", WellKnownEarthAxes)


class WellKnownSunSystems(IWellKnownSunSystems):
    """The Sun's well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IWellKnownSunSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWellKnownSunSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWellKnownSunSystems._get_property(self, attrname) is not None: found_prop = IWellKnownSunSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WellKnownSunSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{855EB036-E71F-47F9-B27B-57247345282A}", WellKnownSunSystems)


class WellKnownSunAxes(IWellKnownSunAxes):
    """Well-known Sun's axes."""
    def __init__(self, sourceObject=None):
        IWellKnownSunAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWellKnownSunAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWellKnownSunAxes._get_property(self, attrname) is not None: found_prop = IWellKnownSunAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WellKnownSunAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{7F786A33-8851-4FA4-A0CA-DC353170143E}", WellKnownSunAxes)


class WellKnownSystems(IWellKnownSystems):
    """Well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IWellKnownSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWellKnownSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWellKnownSystems._get_property(self, attrname) is not None: found_prop = IWellKnownSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WellKnownSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{8C5101B3-3FDD-443D-A59F-B1E801873E0A}", WellKnownSystems)


class WellKnownAxes(IWellKnownAxes):
    """Represents well-known VGT Axes."""
    def __init__(self, sourceObject=None):
        IWellKnownAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWellKnownAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWellKnownAxes._get_property(self, attrname) is not None: found_prop = IWellKnownAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WellKnownAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E24B44A-B46D-4B9B-A22C-615EFAA73A6C}", WellKnownAxes)


class MethodCallResult(IAngleFindResult, IAngleFindWithRateResult, IAxesTransformResult, IAxesTransformWithRateResult, IAxesFindInAxesResult, IAxesFindInAxesWithRateResult, IPlaneFindInAxesResult, IPlaneFindInAxesWithRateResult, IPlaneFindInSystemResult, IPlaneFindInSystemWithRateResult, IPointLocateInSystemResult, IPointLocateInSystemWithRateResult, ISystemTransformResult, ISystemTransformWithRateResult, ISystemFindInSystemResult, IVectorFindInAxesResult, IVectorFindInAxesWithRateResult, IAngleFindAngleWithRateResult, IAngleFindAngleResult, IMethodCallResult):
    """
    Represents a result of a call to a VGT method.
    Some of the inherited interfaces for this class may be disabled at runtime.
    """
    def __init__(self, sourceObject=None):
        IAngleFindResult.__init__(self, sourceObject)
        IAngleFindWithRateResult.__init__(self, sourceObject)
        IAxesTransformResult.__init__(self, sourceObject)
        IAxesTransformWithRateResult.__init__(self, sourceObject)
        IAxesFindInAxesResult.__init__(self, sourceObject)
        IAxesFindInAxesWithRateResult.__init__(self, sourceObject)
        IPlaneFindInAxesResult.__init__(self, sourceObject)
        IPlaneFindInAxesWithRateResult.__init__(self, sourceObject)
        IPlaneFindInSystemResult.__init__(self, sourceObject)
        IPlaneFindInSystemWithRateResult.__init__(self, sourceObject)
        IPointLocateInSystemResult.__init__(self, sourceObject)
        IPointLocateInSystemWithRateResult.__init__(self, sourceObject)
        ISystemTransformResult.__init__(self, sourceObject)
        ISystemTransformWithRateResult.__init__(self, sourceObject)
        ISystemFindInSystemResult.__init__(self, sourceObject)
        IVectorFindInAxesResult.__init__(self, sourceObject)
        IVectorFindInAxesWithRateResult.__init__(self, sourceObject)
        IAngleFindAngleWithRateResult.__init__(self, sourceObject)
        IAngleFindAngleResult.__init__(self, sourceObject)
        IMethodCallResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAngleFindResult._private_init(self, pUnk)
        IAngleFindWithRateResult._private_init(self, pUnk)
        IAxesTransformResult._private_init(self, pUnk)
        IAxesTransformWithRateResult._private_init(self, pUnk)
        IAxesFindInAxesResult._private_init(self, pUnk)
        IAxesFindInAxesWithRateResult._private_init(self, pUnk)
        IPlaneFindInAxesResult._private_init(self, pUnk)
        IPlaneFindInAxesWithRateResult._private_init(self, pUnk)
        IPlaneFindInSystemResult._private_init(self, pUnk)
        IPlaneFindInSystemWithRateResult._private_init(self, pUnk)
        IPointLocateInSystemResult._private_init(self, pUnk)
        IPointLocateInSystemWithRateResult._private_init(self, pUnk)
        ISystemTransformResult._private_init(self, pUnk)
        ISystemTransformWithRateResult._private_init(self, pUnk)
        ISystemFindInSystemResult._private_init(self, pUnk)
        IVectorFindInAxesResult._private_init(self, pUnk)
        IVectorFindInAxesWithRateResult._private_init(self, pUnk)
        IAngleFindAngleWithRateResult._private_init(self, pUnk)
        IAngleFindAngleResult._private_init(self, pUnk)
        IMethodCallResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindResult._uuid))
        if pUnkTest is not None:
            if attrname in IAngleFindResult.__dict__ and type(IAngleFindResult.__dict__[attrname]) == property: found_prop = IAngleFindResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAngleFindWithRateResult.__dict__ and type(IAngleFindWithRateResult.__dict__[attrname]) == property: found_prop = IAngleFindWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in IAxesTransformResult.__dict__ and type(IAxesTransformResult.__dict__[attrname]) == property: found_prop = IAxesTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAxesTransformWithRateResult.__dict__ and type(IAxesTransformWithRateResult.__dict__[attrname]) == property: found_prop = IAxesTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IAxesFindInAxesResult.__dict__ and type(IAxesFindInAxesResult.__dict__[attrname]) == property: found_prop = IAxesFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAxesFindInAxesWithRateResult.__dict__ and type(IAxesFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IAxesFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IPlaneFindInAxesResult.__dict__ and type(IPlaneFindInAxesResult.__dict__[attrname]) == property: found_prop = IPlaneFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IPlaneFindInAxesWithRateResult.__dict__ and type(IPlaneFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IPlaneFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IPlaneFindInSystemResult.__dict__ and type(IPlaneFindInSystemResult.__dict__[attrname]) == property: found_prop = IPlaneFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IPlaneFindInSystemWithRateResult.__dict__ and type(IPlaneFindInSystemWithRateResult.__dict__[attrname]) == property: found_prop = IPlaneFindInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointLocateInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IPointLocateInSystemResult.__dict__ and type(IPointLocateInSystemResult.__dict__[attrname]) == property: found_prop = IPointLocateInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointLocateInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IPointLocateInSystemWithRateResult.__dict__ and type(IPointLocateInSystemWithRateResult.__dict__[attrname]) == property: found_prop = IPointLocateInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in ISystemTransformResult.__dict__ and type(ISystemTransformResult.__dict__[attrname]) == property: found_prop = ISystemTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ISystemTransformWithRateResult.__dict__ and type(ISystemTransformWithRateResult.__dict__[attrname]) == property: found_prop = ISystemTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in ISystemFindInSystemResult.__dict__ and type(ISystemFindInSystemResult.__dict__[attrname]) == property: found_prop = ISystemFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorFindInAxesResult.__dict__ and type(IVectorFindInAxesResult.__dict__[attrname]) == property: found_prop = IVectorFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorFindInAxesWithRateResult.__dict__ and type(IVectorFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IVectorFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindAngleWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAngleFindAngleWithRateResult.__dict__ and type(IAngleFindAngleWithRateResult.__dict__[attrname]) == property: found_prop = IAngleFindAngleWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindAngleResult._uuid))
        if pUnkTest is not None:
            if attrname in IAngleFindAngleResult.__dict__ and type(IAngleFindAngleResult.__dict__[attrname]) == property: found_prop = IAngleFindAngleResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMethodCallResult._uuid))
        if pUnkTest is not None:
            if attrname in IMethodCallResult.__dict__ and type(IMethodCallResult.__dict__[attrname]) == property: found_prop = IMethodCallResult.__dict__[attrname]
            del(pUnkTest)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MethodCallResult.")
    def __getattr__(self, attrname):
        found_attr = None
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindResult._uuid))
        if pUnk is not None:
            intf = IAngleFindResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindWithRateResult._uuid))
        if pUnk is not None:
            intf = IAngleFindWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesTransformResult._uuid))
        if pUnk is not None:
            intf = IAxesTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = IAxesTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IAxesFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAxesFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IAxesFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IPlaneFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IPlaneFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInSystemResult._uuid))
        if pUnk is not None:
            intf = IPlaneFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPlaneFindInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = IPlaneFindInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointLocateInSystemResult._uuid))
        if pUnk is not None:
            intf = IPointLocateInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointLocateInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = IPointLocateInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemTransformResult._uuid))
        if pUnk is not None:
            intf = ISystemTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = ISystemTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISystemFindInSystemResult._uuid))
        if pUnk is not None:
            intf = ISystemFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IVectorFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindAngleWithRateResult._uuid))
        if pUnk is not None:
            intf = IAngleFindAngleWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAngleFindAngleResult._uuid))
        if pUnk is not None:
            intf = IAngleFindAngleResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMethodCallResult._uuid))
        if pUnk is not None:
            intf = IMethodCallResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        if found_attr is not None:
            return found_attr
        else:
            raise STKAttributeError(attrname + " is not a valid attribute in this instance of MethodCallResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{03665183-03A3-4ABE-9954-476CD71C8BB3}", MethodCallResult)


class Interval(IInterval):
    """Represents an interval."""
    def __init__(self, sourceObject=None):
        IInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IInterval._get_property(self, attrname) is not None: found_prop = IInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Interval.")
        
agcls.AgClassCatalog.add_catalog_entry("{7825007C-4D30-46EC-A047-EAF6683C4187}", Interval)


class IntervalCollection(IIntervalCollection):
    """Represents a collection of intervals."""
    def __init__(self, sourceObject=None):
        IIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIntervalCollection._get_property(self, attrname) is not None: found_prop = IIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{908714CE-1D69-4F68-875A-9B584CF8F2A7}", IntervalCollection)


class CentralBody(ICentralBody):
    """Represents an central body."""
    def __init__(self, sourceObject=None):
        ICentralBody.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBody._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBody._get_property(self, attrname) is not None: found_prop = ICentralBody._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBody.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A0248DF-B126-4448-A653-CD5C28DC9229}", CentralBody)


class CentralBodyRefTo(ICentralBodyRefTo, IRefTo):
    """Represents a central body reference."""
    def __init__(self, sourceObject=None):
        ICentralBodyRefTo.__init__(self, sourceObject)
        IRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyRefTo._private_init(self, pUnk)
        IRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyRefTo._get_property(self, attrname) is not None: found_prop = ICentralBodyRefTo._get_property(self, attrname)
        if IRefTo._get_property(self, attrname) is not None: found_prop = IRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFB22A58-DB60-4A1B-B0D4-44916CACC759}", CentralBodyRefTo)


class CentralBodyCollection(ICentralBodyCollection):
    """A collection of central body names."""
    def __init__(self, sourceObject=None):
        ICentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyCollection._get_property(self, attrname) is not None: found_prop = ICentralBodyCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E8951B8F-E457-4289-9125-5381515552C4}", CentralBodyCollection)


class Collection(ICollection):
    """A collection of VGT objects."""
    def __init__(self, sourceObject=None):
        ICollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICollection._get_property(self, attrname) is not None: found_prop = ICollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Collection.")
        
agcls.AgClassCatalog.add_catalog_entry("{24B18D3A-675E-467D-A97C-5CD42EB6DC8D}", Collection)


class PointSamplingResult(IPointSamplingResult):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    def __init__(self, sourceObject=None):
        IPointSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointSamplingResult._get_property(self, attrname) is not None: found_prop = IPointSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointSamplingResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{A3132149-15ED-4D7E-85A6-FD1B2BB80B1E}", PointSamplingResult)


class PointSamplingInterval(IPointSamplingInterval):
    """The interface represents an interval with the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        IPointSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointSamplingInterval._get_property(self, attrname) is not None: found_prop = IPointSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointSamplingInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{8B7546E8-0228-4269-92D1-B3C186AF18EF}", PointSamplingInterval)


class PointSamplingIntervalCollection(IPointSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        IPointSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = IPointSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointSamplingIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F6CF6B1-7192-4960-927D-1FC328122E59}", PointSamplingIntervalCollection)


class AxesSamplingResult(IAxesSamplingResult):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    def __init__(self, sourceObject=None):
        IAxesSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesSamplingResult._get_property(self, attrname) is not None: found_prop = IAxesSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesSamplingResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{54622168-5440-4C86-9539-A0CA336E554B}", AxesSamplingResult)


class AxesSamplingInterval(IAxesSamplingInterval):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAxesSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesSamplingInterval._get_property(self, attrname) is not None: found_prop = IAxesSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesSamplingInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{069BCA07-B5AB-4A46-A508-AFE218E21B2F}", AxesSamplingInterval)


class AxesSamplingIntervalCollection(IAxesSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAxesSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAxesSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAxesSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = IAxesSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AxesSamplingIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AD4C296-E643-4CB6-A34A-D33748117EEF}", AxesSamplingIntervalCollection)



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
