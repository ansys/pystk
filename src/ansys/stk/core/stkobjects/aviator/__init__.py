################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = ["ADDSMessage", "ADDSMessageCollection", "ARINC424Airport", "ARINC424Helipad", "ARINC424Navaid", "ARINC424Runway", 
"ARINC424Source", "ARINC424Waypoint", "AVTR_ACCELERATION_ADV_ACCEL_MODE", "AVTR_ACCEL_MANEUVER_AERO_PROP_MODE", "AVTR_ACCEL_MANEUVER_MODE", 
"AVTR_ACCEL_MODE", "AVTR_ACCEL_PERF_MODEL_OVERRIDE", "AVTR_ADDS_FORECAST_TYPE", "AVTR_ADDS_MISSING_MSG_TYPE", "AVTR_ADDS_MSG_EXTRAP_TYPE", 
"AVTR_ADDS_MSG_INTERP_TYPE", "AVTR_ADV_FIXED_WING_AERO_STRATEGY", "AVTR_ADV_FIXED_WING_GEOMETRY", "AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY", 
"AVTR_AERO_PROP_FLIGHT_MODE", "AVTR_AERO_PROP_SIMPLE_MODE", "AVTR_AFPROP_FUEL_TYPE", "AVTR_AGLMSL", "AVTR_AILERON_ROLL_FLIGHT_PATH", 
"AVTR_AILERON_ROLL_MODE", "AVTR_AIRCRAFT_AERO_STRATEGY", "AVTR_AIRCRAFT_PROP_STRATEGY", "AVTR_AIRSPEED_TYPE", "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE", 
"AVTR_ALTITUDE_REF", "AVTR_AND_OR", "AVTR_ANGLE_MODE", "AVTR_APPROACH_MODE", "AVTR_ATMOSPHERE_MODEL", "AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE", 
"AVTR_AUTOPILOT_ALTITUDE_MODE", "AVTR_AUTOPILOT_HORIZ_PLANE_MODE", "AVTR_BALLISTIC3_D_CONTROL_MODE", "AVTR_BASIC_FIXED_WING_PROP_MODE", 
"AVTR_BASIC_MANEUVER_AIRSPEED_MODE", "AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT", "AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE", "AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE", 
"AVTR_BASIC_MANEUVER_REF_FRAME", "AVTR_BASIC_MANEUVER_STRATEGY", "AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS", "AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", 
"AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE", "AVTR_CEA_FUEL_TYPE", "AVTR_CLIMB_SPEED_TYPE", "AVTR_CLOSURE_MODE", 
"AVTR_CLOSURE_VALUE", "AVTR_CRUISE_MAX_PERF_SPEED_TYPE", "AVTR_CRUISE_SPEED", "AVTR_DELAY_ALT_MODE", "AVTR_DELAY_TURN_DIR", 
"AVTR_DEPARTURE_SPEED_MODE", "AVTR_DESCENT_SPEED_TYPE", "AVTR_ERROR_CODES", "AVTR_EXT_EPHEM_FLIGHT_MODE", "AVTR_FLIGHT_LINE_PROC_TYPE", 
"AVTR_FLY_AOA_LEFT_RIGHT", "AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE", "AVTR_FORMATION_FLYER_STOP_CONDITION", "AVTR_FUEL_FLOW_TYPE", 
"AVTR_HOLDING_DIRECTION", "AVTR_HOLDING_ENTRY_MANEUVER", "AVTR_HOLDING_PROFILE_MODE", "AVTR_HOLD_REFUEL_DUMP_MODE", "AVTR_HOVER_ALTITUDE_MODE", 
"AVTR_HOVER_HEADING_MODE", "AVTR_HOVER_MODE", "AVTR_INTERCEPT_MODE", "AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE", "AVTR_JET_ENGINE_INTAKE_TYPE", 
"AVTR_JET_ENGINE_TECHNOLOGY_LEVEL", "AVTR_JET_ENGINE_TURBINE_TYPE", "AVTR_JET_FUEL_TYPE", "AVTR_JOIN_EXIT_ARC_METHOD", "AVTR_LANDING_APPROACH_FIX_RANGE_MODE", 
"AVTR_LAUNCH_ATTITUDE_MODE", "AVTR_LAUNCH_DYN_STATE_BEARING_REF", "AVTR_LAUNCH_DYN_STATE_COORD_FRAME", "AVTR_LINE_ORIENTATION", 
"AVTR_MINIMIZE_SITE_PROC_TIME_DIFF", "AVTR_MISSILE_AERO_STRATEGY", "AVTR_MISSILE_PROP_STRATEGY", "AVTR_NAVIGATOR_TURN_DIR", 
"AVTR_NUMERICAL_INTEGRATOR", "AVTR_PERF_MODEL_OVERRIDE", "AVTR_PHASE_OF_FLIGHT", "AVTR_PITCH3_D_CONTROL_MODE", "AVTR_POINT_TO_POINT_MODE", 
"AVTR_PROCEDURE_TYPE", "AVTR_PROFILE_CONTROL_LIMIT", "AVTR_PULL_MODE", "AVTR_PUSH_PULL", "AVTR_RAMJET_MODE", "AVTR_REFUEL_DUMP_MODE", 
"AVTR_REF_STATE_ATTITUDE_MODE", "AVTR_REF_STATE_LATERAL_ACCEL_MODE", "AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE", "AVTR_REF_STATE_PERF_MODE", 
"AVTR_RELATIVE_ALTITUDE_MODE", "AVTR_REL_ABS_BEARING", "AVTR_REL_SPEED_ALT_STOP_CONDITION", "AVTR_RENDEZVOUS_STOP_CONDITION", 
"AVTR_ROLLING_PULL_MODE", "AVTR_ROLL_LEFT_RIGHT", "AVTR_ROLL_UPRIGHT_INVERTED", "AVTR_ROTORCRAFT_POWERPLANT_TYPE", "AVTR_RUNWAY_HIGH_LOW_END", 
"AVTR_SCRAMJET_MODE", "AVTR_SEARCH_PATTERN_COURSE_MODE", "AVTR_SITE_TYPE", "AVTR_SMOOTH_ACCEL_LEFT_RIGHT", "AVTR_SMOOTH_ACCEL_STOP_CONDITIONS", 
"AVTR_SMOOTH_TURN_FPA_MODE", "AVTR_SMOOTH_TURN_MODE", "AVTR_STATIONKEEPING_STOP_CONDITION", "AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE", 
"AVTR_STRAIGHT_AHEAD_REF_FRAME", "AVTR_TAKEOFF_LANDING_SPEED_MODE", "AVTR_TAKEOFF_MODE", "AVTR_TRAJECTORY_BLEND_MODE", "AVTR_TRANSITION_TO_HOVER_MODE", 
"AVTR_TURBINE_MODE", "AVTR_TURN_DIRECTION", "AVTR_TURN_MODE", "AVTR_VERT_LANDING_MODE", "AVTR_VTOL_FINAL_HEADING_MODE", 
"AVTR_VTOL_HEADING_MODE", "AVTR_VTOL_RATE_MODE", "AVTR_VTOL_TRANSITION_MODE", "AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE", 
"AVTR_VTOL_TRANSLATION_MODE", "AVTR_WIND_ATMOS_MODEL_SOURCE", "AVTR_WIND_MODEL_TYPE", "AdvFixedWingElectricPowerplant", 
"AdvFixedWingEmpiricalJetEngine", "AdvFixedWingExternalAero", "AdvFixedWingExternalProp", "AdvFixedWingGeometryBasic", "AdvFixedWingGeometryVariable", 
"AdvFixedWingPistonPowerplant", "AdvFixedWingRamjetBasic", "AdvFixedWingScramjetBasic", "AdvFixedWingSubSuperHypersonicAero", 
"AdvFixedWingSubSuperHypersonicProp", "AdvFixedWingSubsonicAero", "AdvFixedWingSupersonicAero", "AdvFixedWingTool", "AdvFixedWingTurbofanBasicABPowerplant", 
"AdvFixedWingTurbofanBasicABProp", "AdvFixedWingTurbojetBasicABPowerplant", "AdvFixedWingTurbojetBasicABProp", "AdvFixedWingTurbopropPowerplant", 
"AeroPropManeuverModeHelper", "AircraftAcceleration", "AircraftAccelerationMode", "AircraftAdvAccelerationModel", "AircraftAdvClimbModel", 
"AircraftAdvCruiseModel", "AircraftAdvDescentModel", "AircraftAdvLandingModel", "AircraftAdvTakeoffModel", "AircraftAero", 
"AircraftBasicAccelerationModel", "AircraftBasicClimbModel", "AircraftBasicCruiseModel", "AircraftBasicDescentModel", "AircraftBasicFixedWingAero", 
"AircraftBasicFixedWingProp", "AircraftBasicLandingModel", "AircraftBasicTakeoffModel", "AircraftCategory", "AircraftClimb", 
"AircraftCruise", "AircraftDescent", "AircraftExternalAero", "AircraftExternalProp", "AircraftLanding", "AircraftModel", 
"AircraftModels", "AircraftProp", "AircraftSimpleAero", "AircraftSimpleProp", "AircraftTakeoff", "AircraftTerrainFollow", 
"AircraftTerrainFollowModel", "AircraftVTOL", "AircraftVTOLModel", "AirportCategory", "AltitudeMSLAndLevelOffOptions", "AltitudeMSLOptions", 
"AltitudeOptions", "ArcAltitudeAndDelayOptions", "ArcAltitudeOptions", "ArcOptions", "ArcVerticalPlaneOptions", "AtmosphereModel", 
"AtmosphereModelBasic", "AttitudeTransitions", "AviatorPropagator", "BasicFixedWingFwdFlightLiftHelper", "BasicManeuverAirspeedOptions", 
"BasicManeuverStrategyAileronRoll", "BasicManeuverStrategyAutopilotNav", "BasicManeuverStrategyAutopilotProf", "BasicManeuverStrategyBallistic3D", 
"BasicManeuverStrategyBarrelRoll", "BasicManeuverStrategyBezier", "BasicManeuverStrategyCruiseProfile", "BasicManeuverStrategyFlyAOA", 
"BasicManeuverStrategyGlideProfile", "BasicManeuverStrategyIntercept", "BasicManeuverStrategyLTAHover", "BasicManeuverStrategyLoop", 
"BasicManeuverStrategyPitch3D", "BasicManeuverStrategyPull", "BasicManeuverStrategyPushPull", "BasicManeuverStrategyRelSpeedAltitude", 
"BasicManeuverStrategyRelativeBearing", "BasicManeuverStrategyRelativeCourse", "BasicManeuverStrategyRelativeFPA", "BasicManeuverStrategyRendezvous", 
"BasicManeuverStrategyRollingPull", "BasicManeuverStrategySimpleTurn", "BasicManeuverStrategySmoothAccel", "BasicManeuverStrategySmoothTurn", 
"BasicManeuverStrategyStationkeeping", "BasicManeuverStrategyStraightAhead", "BasicManeuverStrategyWeave", "CalculationOptions", 
"Catalog", "ClimbAndDescentTransitions", "Configuration", "CruiseAirspeedAndProfileOptions", "CruiseAirspeedOptions", "CruiseAirspeedProfile", 
"DAFIFHelipad", "DAFIFRunway", "DAFIFSource", "DAFIFWaypoint", "EnrouteAndDelayOptions", "EnrouteOptions", "EnrouteTurnDirectionOptions", 
"FuelModelKeroseneAFPROP", "FuelModelKeroseneCEA", "FuelTankExternal", "FuelTankInternal", "HoverAltitudeOptions", "IADDSMessage", 
"IADDSMessageCollection", "IARINC424Airport", "IARINC424Item", "IARINC424Runway", "IARINC424Source", "IAdvFixedWingElectricPowerplant", 
"IAdvFixedWingEmpiricalJetEngine", "IAdvFixedWingExternalAero", "IAdvFixedWingExternalProp", "IAdvFixedWingGeometry", "IAdvFixedWingGeometryBasic", 
"IAdvFixedWingGeometryVariable", "IAdvFixedWingPistonPowerplant", "IAdvFixedWingPowerplant", "IAdvFixedWingRamjetBasic", 
"IAdvFixedWingScramjetBasic", "IAdvFixedWingSubSuperHypersonicAero", "IAdvFixedWingSubSuperHypersonicProp", "IAdvFixedWingSubsonicAero", 
"IAdvFixedWingSupersonicAero", "IAdvFixedWingTool", "IAdvFixedWingTurbofanBasicABPowerplant", "IAdvFixedWingTurbofanBasicABProp", 
"IAdvFixedWingTurbojetBasicABPowerplant", "IAdvFixedWingTurbojetBasicABProp", "IAdvFixedWingTurbopropPowerplant", "IAeroPropManeuverModeHelper", 
"IAircraftAcceleration", "IAircraftAccelerationMode", "IAircraftAdvAccelerationModel", "IAircraftAdvClimbModel", "IAircraftAdvCruiseModel", 
"IAircraftAdvDescentModel", "IAircraftAdvLandingModel", "IAircraftAdvTakeoffModel", "IAircraftAero", "IAircraftBasicAccelerationModel", 
"IAircraftBasicClimbModel", "IAircraftBasicCruiseModel", "IAircraftBasicDescentModel", "IAircraftBasicFixedWingAero", "IAircraftBasicFixedWingProp", 
"IAircraftBasicLandingModel", "IAircraftBasicTakeoffModel", "IAircraftCategory", "IAircraftClimb", "IAircraftCruise", "IAircraftDescent", 
"IAircraftExternalAero", "IAircraftExternalProp", "IAircraftLanding", "IAircraftModel", "IAircraftModels", "IAircraftProp", 
"IAircraftSimpleAero", "IAircraftSimpleProp", "IAircraftTakeoff", "IAircraftTerrainFollow", "IAircraftTerrainFollowModel", 
"IAircraftVTOL", "IAircraftVTOLModel", "IAirportCategory", "IAltitudeMSLAndLevelOffOptions", "IAltitudeMSLOptions", "IAltitudeOptions", 
"IArcAltitudeAndDelayOptions", "IArcAltitudeOptions", "IArcOptions", "IArcVerticalPlaneOptions", "IAtmosphereModel", "IAtmosphereModelBasic", 
"IAttitudeTransitions", "IAutomationStrategyFactory", "IAviatorPropagator", "IAviatorVehicle", "IBasicFixedWingLiftHelper", 
"IBasicManeuverAirspeedOptions", "IBasicManeuverStrategy", "IBasicManeuverStrategyAileronRoll", "IBasicManeuverStrategyAutopilotNav", 
"IBasicManeuverStrategyAutopilotProf", "IBasicManeuverStrategyBallistic3D", "IBasicManeuverStrategyBarrelRoll", "IBasicManeuverStrategyBezier", 
"IBasicManeuverStrategyCruiseProfile", "IBasicManeuverStrategyFlyAOA", "IBasicManeuverStrategyGlideProfile", "IBasicManeuverStrategyIntercept", 
"IBasicManeuverStrategyLTAHover", "IBasicManeuverStrategyLoop", "IBasicManeuverStrategyPitch3D", "IBasicManeuverStrategyPull", 
"IBasicManeuverStrategyPushPull", "IBasicManeuverStrategyRelSpeedAltitude", "IBasicManeuverStrategyRelativeBearing", "IBasicManeuverStrategyRelativeCourse", 
"IBasicManeuverStrategyRelativeFPA", "IBasicManeuverStrategyRendezvous", "IBasicManeuverStrategyRollingPull", "IBasicManeuverStrategySimpleTurn", 
"IBasicManeuverStrategySmoothAccel", "IBasicManeuverStrategySmoothTurn", "IBasicManeuverStrategyStationkeeping", "IBasicManeuverStrategyStraightAhead", 
"IBasicManeuverStrategyWeave", "ICalculationOptions", "ICatalog", "ICatalogAirport", "ICatalogItem", "ICatalogNavaid", "ICatalogRunway", 
"ICatalogSource", "ICatalogVTOLPoint", "ICatalogWaypoint", "IClimbAndDescentTransitions", "IConfiguration", "IConnect", 
"ICruiseAirspeedAndProfileOptions", "ICruiseAirspeedOptions", "ICruiseAirspeedProfile", "IDAFIFItem", "IDAFIFSource", "IEnrouteAndDelayOptions", 
"IEnrouteOptions", "IEnrouteTurnDirectionOptions", "IFuelModelKeroseneAFPROP", "IFuelModelKeroseneCEA", "IFuelTankExternal", 
"IFuelTankInternal", "IHoverAltitudeOptions", "ILandingEnterDownwindPattern", "ILandingInterceptGlideslope", "ILandingStandardInstrumentApproach", 
"ILevelTurns", "IMissileAdvancedAero", "IMissileAero", "IMissileExternalAero", "IMissileExternalProp", "IMissileModel", 
"IMissileModels", "IMissileProp", "IMissileRamjetProp", "IMissileRocketProp", "IMissileSimpleAero", "IMissileSimpleProp", 
"IMissileTurbojetProp", "IMission", "INavaidCategory", "INavigationOptions", "IPayloadStation", "IPerformanceModel", "IPerformanceModelOptions", 
"IPhase", "IPhaseCollection", "IProcedure", "IProcedureAirway", "IProcedureAirwayRouter", "IProcedureArcEnroute", "IProcedureArcPointToPoint", 
"IProcedureAreaTargetSearch", "IProcedureBasicManeuver", "IProcedureBasicPointToPoint", "IProcedureCollection", "IProcedureDelay", 
"IProcedureEnroute", "IProcedureExtEphem", "IProcedureFastTimeOptions", "IProcedureFlightLine", "IProcedureFormationFlyer", 
"IProcedureFormationRecover", "IProcedureHoldingCircular", "IProcedureHoldingFigure8", "IProcedureHoldingRacetrack", "IProcedureHover", 
"IProcedureHoverTranslate", "IProcedureInFormation", "IProcedureLanding", "IProcedureLaunch", "IProcedureLaunchDynState", 
"IProcedureLaunchWaypoint", "IProcedureParallelFlightLine", "IProcedureReferenceState", "IProcedureSuperProcedure", "IProcedureTakeoff", 
"IProcedureTerrainFollow", "IProcedureTimeOptions", "IProcedureTransitionToForwardFlight", "IProcedureTransitionToHover", 
"IProcedureVGTPoint", "IProcedureVerticalLanding", "IProcedureVerticalTakeoff", "IPropulsionEfficiencies", "IPropulsionThrust", 
"IReferenceStateForwardFlightOptions", "IReferenceStateHoverOptions", "IReferenceStateTakeoffLandingOptions", "IReferenceStateWeightOnWheelsOptions", 
"IRefuelDumpProperties", "IRotorcraftAero", "IRotorcraftModel", "IRotorcraftModels", "IRotorcraftProp", "IRunwayCategory", 
"IRunwayHeadingOptions", "ISite", "ISiteAirportFromCatalog", "ISiteDynState", "ISiteEndOfPrevProcedure", "ISiteNavaidFromCatalog", 
"ISiteReferenceState", "ISiteRelToPrevProcedure", "ISiteRelToSTKObject", "ISiteRunway", "ISiteRunwayFromCatalog", "ISiteSTKAreaTarget", 
"ISiteSTKObjectWaypoint", "ISiteSTKStaticObject", "ISiteSTKVehicle", "ISiteSuperProcedure", "ISiteUnknown", "ISiteVTOLPoint", 
"ISiteVTOLPointFromCatalog", "ISiteWaypoint", "ISiteWaypointFromCatalog", "IStation", "IStationCollection", "ITakeoffDeparturePoint", 
"ITakeoffLowTransition", "ITakeoffNormal", "IUserRunway", "IUserRunwaySource", "IUserVTOLPoint", "IUserVTOLPointSource", 
"IUserWaypoint", "IUserWaypointSource", "IVTOLPointCategory", "IVerticalPlaneAndFlightPathOptions", "IVerticalPlaneOptions", 
"IWaypointCategory", "IWindModel", "IWindModelADDS", "IWindModelConstant", "LandingCruiseAirspeedAndProfileOptions", "LandingEnrouteOptions", 
"LandingEnterDownwindPattern", "LandingInterceptGlideslope", "LandingStandardInstrumentApproach", "LandingVerticalPlaneOptions", 
"LevelTurns", "MissileAdvancedAero", "MissileAero", "MissileExternalAero", "MissileExternalProp", "MissileModel", "MissileModels", 
"MissileProp", "MissileRamjetProp", "MissileRocketProp", "MissileSimpleAero", "MissileSimpleProp", "MissileTurbojetProp", 
"Mission", "NavaidCategory", "NavigationOptions", "PayloadStation", "PerformanceModel", "PerformanceModelOptions", "Phase", 
"PhaseCollection", "Procedure", "ProcedureAirway", "ProcedureAirwayRouter", "ProcedureArcEnroute", "ProcedureArcPointToPoint", 
"ProcedureAreaTargetSearch", "ProcedureBasicManeuver", "ProcedureBasicPointToPoint", "ProcedureCollection", "ProcedureDelay", 
"ProcedureEnroute", "ProcedureExtEphem", "ProcedureFastTimeOptions", "ProcedureFlightLine", "ProcedureFormationFlyer", "ProcedureFormationRecover", 
"ProcedureHoldingCircular", "ProcedureHoldingFigure8", "ProcedureHoldingRacetrack", "ProcedureHover", "ProcedureHoverTranslate", 
"ProcedureInFormation", "ProcedureLanding", "ProcedureLaunch", "ProcedureLaunchDynState", "ProcedureLaunchWaypoint", "ProcedureParallelFlightLine", 
"ProcedureReferenceState", "ProcedureSuperProcedure", "ProcedureTakeoff", "ProcedureTerrainFollow", "ProcedureTimeOptions", 
"ProcedureTransitionToForwardFlight", "ProcedureTransitionToHover", "ProcedureVGTPoint", "ProcedureVerticalLanding", "ProcedureVerticalTakeoff", 
"PropulsionEfficiencies", "PropulsionThrust", "ReferenceStateForwardFlightOptions", "ReferenceStateHoverOptions", "ReferenceStateTakeoffLandingOptions", 
"ReferenceStateWeightOnWheelsOptions", "RefuelDumpProperties", "RotorcraftAero", "RotorcraftModel", "RotorcraftModels", 
"RotorcraftProp", "RunwayCategory", "RunwayHeadingOptions", "Site", "SiteAirportFromCatalog", "SiteDynState", "SiteEndOfPrevProcedure", 
"SiteNavaidFromCatalog", "SiteReferenceState", "SiteRelToPrevProcedure", "SiteRelToSTKObject", "SiteRunway", "SiteRunwayFromCatalog", 
"SiteSTKAreaTarget", "SiteSTKObjectWaypoint", "SiteSTKStaticObject", "SiteSTKVehicle", "SiteSuperProcedure", "SiteVTOLPoint", 
"SiteVTOLPointFromCatalog", "SiteWaypoint", "SiteWaypointFromCatalog", "StationCollection", "TakeoffDeparturePoint", "TakeoffLowTransition", 
"TakeoffNormal", "UserRunway", "UserRunwaySource", "UserVTOLPoint", "UserVTOLPointSource", "UserWaypoint", "UserWaypointSource", 
"VTOLPointCategory", "VerticalPlaneAndFlightPathOptions", "VerticalPlaneOptions", "WaypointCategory", "WindModel", "WindModelADDS", 
"WindModelConstant"]

import typing

from ctypes   import byref, POINTER
from enum     import IntEnum

try:
    from numpy import ndarray 
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame 
except ModuleNotFoundError:
    pass

from ...internal  import comutil          as agcom
from ...internal  import coclassutil      as agcls
from ...internal  import marshall         as agmarshall
from ...internal.comutil     import IUnknown, IDispatch, IAGFUNCTYPE, IEnumVARIANT
from ...internal.eventutil   import *
from ...utilities.exceptions import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AVTR_ERROR_CODES(IntEnum):
    """Error Codes."""
    # Object not found.
    OBJECT_NOT_FOUND = (((1 << 31) | (4 << 16)) | (0x200 + 1))
    # Index out of range.
    INDEX_OUT_OF_RANGE = (((1 << 31) | (4 << 16)) | (0x200 + 2))
    # The attribute is invalid.
    INVALID_ATTRIBUTE = (((1 << 31) | (4 << 16)) | (0x200 + 3))
    # The command failed.
    COMMAND_FAILED = (((1 << 31) | (4 << 16)) | (0x200 + 4))
    # Invalid argument.
    AVTR_ERROR_INVALID_ARG = (((1 << 31) | (4 << 16)) | (0x200 + 5))
    # Empty argument.
    EMPTY_ARG = (((1 << 31) | (4 << 16)) | (0x200 + 6))
    # Object was not removed.
    OBJECT_NOT_REMOVED = (((1 << 31) | (4 << 16)) | (0x200 + 7))
    # Error renaming object.
    FAILED_TO_RENAME_OBJECT = (((1 << 31) | (4 << 16)) | (0x200 + 8))
    # Unknown class type.
    UNKNOWN_CLASS_TYPE = (((1 << 31) | (4 << 16)) | (0x200 + 9))
    # Failed to create the object.
    FAILED_TO_CREATE_OBJECT = (((1 << 31) | (4 << 16)) | (0x200 + 10))
    # Invalid choice for object link.
    OBJECT_LINK_INVALID_CHOICE = (((1 << 31) | (4 << 16)) | (0x200 + 11))
    # No choices available.
    OBJECT_LINK_NO_CHOICES = (((1 << 31) | (4 << 16)) | (0x200 + 12))
    # Read only attribute.
    READ_ONLY_ATTRIBUTE = (((1 << 31) | (4 << 16)) | (0x200 + 13))
    # Invalid constraint list.
    CSTR_INVALID_CSTR_LIST = (((1 << 31) | (4 << 16)) | (0x200 + 14))
    # InvalidConstraint.
    CSTR_INVALID_CONSTRAINT = (((1 << 31) | (4 << 16)) | (0x200 + 15))
    # List if read only.
    LIST_READ_ONLY = (((1 << 31) | (4 << 16)) | (0x200 + 16))
    # Failed to insert the item into the list.
    LIST_INSERT_FAILED = (((1 << 31) | (4 << 16)) | (0x200 + 17))
    # Length is invalid.
    INVALID_LENGTH = (((1 << 31) | (4 << 16)) | (0x200 + 18))
    # Error loading a file.
    FAILED_TO_LOAD_FILE = (((1 << 31) | (4 << 16)) | (0x200 + 19))
    # Invalid operation.
    INVALID_OPERATION = (((1 << 31) | (4 << 16)) | (0x200 + 20))
    # Method failed.
    METHOD_INVOKE_FAILED = (((1 << 31) | (4 << 16)) | (0x200 + 21))
    # Deprecated property or method.
    DEPRECATED = (((1 << 31) | (4 << 16)) | (0x200 + 22))

AVTR_ERROR_CODES.OBJECT_NOT_FOUND.__doc__ = "Object not found."
AVTR_ERROR_CODES.INDEX_OUT_OF_RANGE.__doc__ = "Index out of range."
AVTR_ERROR_CODES.INVALID_ATTRIBUTE.__doc__ = "The attribute is invalid."
AVTR_ERROR_CODES.COMMAND_FAILED.__doc__ = "The command failed."
AVTR_ERROR_CODES.AVTR_ERROR_INVALID_ARG.__doc__ = "Invalid argument."
AVTR_ERROR_CODES.EMPTY_ARG.__doc__ = "Empty argument."
AVTR_ERROR_CODES.OBJECT_NOT_REMOVED.__doc__ = "Object was not removed."
AVTR_ERROR_CODES.FAILED_TO_RENAME_OBJECT.__doc__ = "Error renaming object."
AVTR_ERROR_CODES.UNKNOWN_CLASS_TYPE.__doc__ = "Unknown class type."
AVTR_ERROR_CODES.FAILED_TO_CREATE_OBJECT.__doc__ = "Failed to create the object."
AVTR_ERROR_CODES.OBJECT_LINK_INVALID_CHOICE.__doc__ = "Invalid choice for object link."
AVTR_ERROR_CODES.OBJECT_LINK_NO_CHOICES.__doc__ = "No choices available."
AVTR_ERROR_CODES.READ_ONLY_ATTRIBUTE.__doc__ = "Read only attribute."
AVTR_ERROR_CODES.CSTR_INVALID_CSTR_LIST.__doc__ = "Invalid constraint list."
AVTR_ERROR_CODES.CSTR_INVALID_CONSTRAINT.__doc__ = "InvalidConstraint."
AVTR_ERROR_CODES.LIST_READ_ONLY.__doc__ = "List if read only."
AVTR_ERROR_CODES.LIST_INSERT_FAILED.__doc__ = "Failed to insert the item into the list."
AVTR_ERROR_CODES.INVALID_LENGTH.__doc__ = "Length is invalid."
AVTR_ERROR_CODES.FAILED_TO_LOAD_FILE.__doc__ = "Error loading a file."
AVTR_ERROR_CODES.INVALID_OPERATION.__doc__ = "Invalid operation."
AVTR_ERROR_CODES.METHOD_INVOKE_FAILED.__doc__ = "Method failed."
AVTR_ERROR_CODES.DEPRECATED.__doc__ = "Deprecated property or method."

agcls.AgTypeNameMap["AVTR_ERROR_CODES"] = AVTR_ERROR_CODES

class AVTR_CLOSURE_VALUE(IntEnum):
    """The closure value."""
    # The closure mode
    CLOSURE_MODE = 0
    # The HOBS max angle offset
    MAX_ANGLE = 1
    # The HOBS angle tolerance
    ANGLE_TOL = 2

AVTR_CLOSURE_VALUE.CLOSURE_MODE.__doc__ = "The closure mode"
AVTR_CLOSURE_VALUE.MAX_ANGLE.__doc__ = "The HOBS max angle offset"
AVTR_CLOSURE_VALUE.ANGLE_TOL.__doc__ = "The HOBS angle tolerance"

agcls.AgTypeNameMap["AVTR_CLOSURE_VALUE"] = AVTR_CLOSURE_VALUE

class AVTR_PROCEDURE_TYPE(IntEnum):
    """Aviator procedure types."""
    # Airway procedure.
    PROC_AIRWAY = 0
    # Airway Router procedure.
    PROC_AIRWAY_ROUTER = 1
    # ArcEnroute procedure.
    PROC_ARC_ENROUTE = 2
    # ArcPointToPoint procedure.
    PROC_ARC_POINT_TO_POINT = 3
    # Area Target Search procedure.
    PROC_AREA_TARGET_SEARCH = 4
    # Basic Maneuver procedure.
    PROC_BASIC_MANEUVER = 5
    # Basic Point to Point procedure.
    PROC_BASIC_POINT_TO_POINT = 6
    # Delay procedure.
    PROC_DELAY = 7
    # Enroute procedure.
    PROC_ENROUTE = 8
    # Flight Line procedure.
    PROC_FLIGHT_LINE = 9
    # Formation Recover procedure.
    PROC_FORMATION_RECOVER = 10
    # Holding Circular procedure.
    PROC_HOLDING_CIRCULAR = 11
    # Holding Figure 8 procedure.
    PROC_HOLDING_FIGURE8 = 12
    # Holding Racetrack procedure.
    PROC_HOLDING_RACETRACK = 13
    # Hover procedure.
    PROC_HOVER = 14
    # Hover Translate procedure.
    PROC_HOVER_TRANSLATE = 15
    # In Formation procedure.
    PROC_IN_FORMATION = 16
    # Landing procedure.
    PROC_LANDING = 17
    # Launch procedure.
    PROC_LAUNCH = 18
    # Parallel Flight Line procedure.
    PROC_PARALLEL_FLIGHT_LINE = 19
    # Reference State procedure.
    PROC_REFERENCE_STATE = 20
    # Super Procedure procedure.
    PROC_SUPER_PROCEDURE = 21
    # Takeoff procedure.
    PROC_TAKEOFF = 22
    # Terrain Following procedure.
    PROC_TERRAIN_FOLLOWING = 23
    # Transition to Forward Flight procedure.
    PROC_TRANSITION_TO_FORWARD_FLIGHT = 24
    # Transition To Hover procedure.
    PROC_TRANSITION_TO_HOVER = 25
    # Vertical Landing procedure.
    PROC_VERTICAL_LANDING = 26
    # Vertical Takeoff procedure.
    PROC_VERTICAL_TAKEOFF = 27
    # VGT Point procedure.
    PROC_VGT_POINT = 28
    # LaunchDynState procedure.
    PROC_LAUNCH_DYN_STATE = 29
    # LaunchWaypoint procedure.
    PROC_LAUNCH_WAYPOINT = 30
    # FormationFlyer procedure.
    PROC_FORMATION_FLYER = 31
    # ExtEphem procedure.
    PROC_EXT_EPHEM = 32

AVTR_PROCEDURE_TYPE.PROC_AIRWAY.__doc__ = "Airway procedure."
AVTR_PROCEDURE_TYPE.PROC_AIRWAY_ROUTER.__doc__ = "Airway Router procedure."
AVTR_PROCEDURE_TYPE.PROC_ARC_ENROUTE.__doc__ = "ArcEnroute procedure."
AVTR_PROCEDURE_TYPE.PROC_ARC_POINT_TO_POINT.__doc__ = "ArcPointToPoint procedure."
AVTR_PROCEDURE_TYPE.PROC_AREA_TARGET_SEARCH.__doc__ = "Area Target Search procedure."
AVTR_PROCEDURE_TYPE.PROC_BASIC_MANEUVER.__doc__ = "Basic Maneuver procedure."
AVTR_PROCEDURE_TYPE.PROC_BASIC_POINT_TO_POINT.__doc__ = "Basic Point to Point procedure."
AVTR_PROCEDURE_TYPE.PROC_DELAY.__doc__ = "Delay procedure."
AVTR_PROCEDURE_TYPE.PROC_ENROUTE.__doc__ = "Enroute procedure."
AVTR_PROCEDURE_TYPE.PROC_FLIGHT_LINE.__doc__ = "Flight Line procedure."
AVTR_PROCEDURE_TYPE.PROC_FORMATION_RECOVER.__doc__ = "Formation Recover procedure."
AVTR_PROCEDURE_TYPE.PROC_HOLDING_CIRCULAR.__doc__ = "Holding Circular procedure."
AVTR_PROCEDURE_TYPE.PROC_HOLDING_FIGURE8.__doc__ = "Holding Figure 8 procedure."
AVTR_PROCEDURE_TYPE.PROC_HOLDING_RACETRACK.__doc__ = "Holding Racetrack procedure."
AVTR_PROCEDURE_TYPE.PROC_HOVER.__doc__ = "Hover procedure."
AVTR_PROCEDURE_TYPE.PROC_HOVER_TRANSLATE.__doc__ = "Hover Translate procedure."
AVTR_PROCEDURE_TYPE.PROC_IN_FORMATION.__doc__ = "In Formation procedure."
AVTR_PROCEDURE_TYPE.PROC_LANDING.__doc__ = "Landing procedure."
AVTR_PROCEDURE_TYPE.PROC_LAUNCH.__doc__ = "Launch procedure."
AVTR_PROCEDURE_TYPE.PROC_PARALLEL_FLIGHT_LINE.__doc__ = "Parallel Flight Line procedure."
AVTR_PROCEDURE_TYPE.PROC_REFERENCE_STATE.__doc__ = "Reference State procedure."
AVTR_PROCEDURE_TYPE.PROC_SUPER_PROCEDURE.__doc__ = "Super Procedure procedure."
AVTR_PROCEDURE_TYPE.PROC_TAKEOFF.__doc__ = "Takeoff procedure."
AVTR_PROCEDURE_TYPE.PROC_TERRAIN_FOLLOWING.__doc__ = "Terrain Following procedure."
AVTR_PROCEDURE_TYPE.PROC_TRANSITION_TO_FORWARD_FLIGHT.__doc__ = "Transition to Forward Flight procedure."
AVTR_PROCEDURE_TYPE.PROC_TRANSITION_TO_HOVER.__doc__ = "Transition To Hover procedure."
AVTR_PROCEDURE_TYPE.PROC_VERTICAL_LANDING.__doc__ = "Vertical Landing procedure."
AVTR_PROCEDURE_TYPE.PROC_VERTICAL_TAKEOFF.__doc__ = "Vertical Takeoff procedure."
AVTR_PROCEDURE_TYPE.PROC_VGT_POINT.__doc__ = "VGT Point procedure."
AVTR_PROCEDURE_TYPE.PROC_LAUNCH_DYN_STATE.__doc__ = "LaunchDynState procedure."
AVTR_PROCEDURE_TYPE.PROC_LAUNCH_WAYPOINT.__doc__ = "LaunchWaypoint procedure."
AVTR_PROCEDURE_TYPE.PROC_FORMATION_FLYER.__doc__ = "FormationFlyer procedure."
AVTR_PROCEDURE_TYPE.PROC_EXT_EPHEM.__doc__ = "ExtEphem procedure."

agcls.AgTypeNameMap["AVTR_PROCEDURE_TYPE"] = AVTR_PROCEDURE_TYPE

class AVTR_SITE_TYPE(IntEnum):
    """Aviator site types."""
    # Airport from Catalog site.
    SITE_AIRPORT_FROM_CATALOG = 0
    # End of Previous Procedure site.
    SITE_END_OF_PREV_PROCEDURE = 1
    # Navaid from Catalog site.
    SITE_NAVAID_FROM_CATALOG = 2
    # Reference State site.
    SITE_REFERENCE_STATE = 3
    # Relative to Previous Procedure site.
    SITE_RELATIVE_TO_PREV_PROCEDURE = 4
    # Relative to Stationary STK Object site.
    SITE_RELATIVE_TO_STATIONARY_STK_OBJECT = 5
    # Runway site.
    SITE_RUNWAY = 6
    # Runway from Catalog site.
    SITE_RUNWAY_FROM_CATALOG = 7
    # STK Area Target site.
    SITE_STK_AREA_TARGET = 8
    # STK Object Waypoint site.
    SITE_STK_OBJECT_WAYPOINT = 9
    # STK STatic Object site.
    SITE_STK_STATIC_OBJECT = 10
    # STK Vehicle site.
    SITE_STK_VEHICLE = 11
    # Super Procedure site.
    SITE_SUPER_PROCEDURE = 12
    # VTOL Point site.
    SITE_VTOL_POINT = 13
    # VTOL Point from Catalog site.
    SITE_VTOL_POINT_FROM_CATALOG = 14
    # Waypoint site.
    SITE_WAYPOINT = 15
    # Waypoint from Catalog site.
    SITE_WAYPOINT_FROM_CATALOG = 16
    # DynState site.
    SITE_DYN_STATE = 17

AVTR_SITE_TYPE.SITE_AIRPORT_FROM_CATALOG.__doc__ = "Airport from Catalog site."
AVTR_SITE_TYPE.SITE_END_OF_PREV_PROCEDURE.__doc__ = "End of Previous Procedure site."
AVTR_SITE_TYPE.SITE_NAVAID_FROM_CATALOG.__doc__ = "Navaid from Catalog site."
AVTR_SITE_TYPE.SITE_REFERENCE_STATE.__doc__ = "Reference State site."
AVTR_SITE_TYPE.SITE_RELATIVE_TO_PREV_PROCEDURE.__doc__ = "Relative to Previous Procedure site."
AVTR_SITE_TYPE.SITE_RELATIVE_TO_STATIONARY_STK_OBJECT.__doc__ = "Relative to Stationary STK Object site."
AVTR_SITE_TYPE.SITE_RUNWAY.__doc__ = "Runway site."
AVTR_SITE_TYPE.SITE_RUNWAY_FROM_CATALOG.__doc__ = "Runway from Catalog site."
AVTR_SITE_TYPE.SITE_STK_AREA_TARGET.__doc__ = "STK Area Target site."
AVTR_SITE_TYPE.SITE_STK_OBJECT_WAYPOINT.__doc__ = "STK Object Waypoint site."
AVTR_SITE_TYPE.SITE_STK_STATIC_OBJECT.__doc__ = "STK STatic Object site."
AVTR_SITE_TYPE.SITE_STK_VEHICLE.__doc__ = "STK Vehicle site."
AVTR_SITE_TYPE.SITE_SUPER_PROCEDURE.__doc__ = "Super Procedure site."
AVTR_SITE_TYPE.SITE_VTOL_POINT.__doc__ = "VTOL Point site."
AVTR_SITE_TYPE.SITE_VTOL_POINT_FROM_CATALOG.__doc__ = "VTOL Point from Catalog site."
AVTR_SITE_TYPE.SITE_WAYPOINT.__doc__ = "Waypoint site."
AVTR_SITE_TYPE.SITE_WAYPOINT_FROM_CATALOG.__doc__ = "Waypoint from Catalog site."
AVTR_SITE_TYPE.SITE_DYN_STATE.__doc__ = "DynState site."

agcls.AgTypeNameMap["AVTR_SITE_TYPE"] = AVTR_SITE_TYPE

class AVTR_BASIC_MANEUVER_STRATEGY(IntEnum):
    """Basic maneuver strategy types."""
    # Straight Ahead strategy.
    STRAIGHT_AHEAD = 0
    # Weave strategy.
    WEAVE = 1

AVTR_BASIC_MANEUVER_STRATEGY.STRAIGHT_AHEAD.__doc__ = "Straight Ahead strategy."
AVTR_BASIC_MANEUVER_STRATEGY.WEAVE.__doc__ = "Weave strategy."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_STRATEGY"] = AVTR_BASIC_MANEUVER_STRATEGY

class AVTR_STRAIGHT_AHEAD_REF_FRAME(IntEnum):
    """Straight Ahead basic maneuver Reference Frame."""
    # Maintain Course.
    MAINTAIN_COURSE = 0
    # Maintain Heading.
    MAINTAIN_HEADING = 1
    # No Lateral Accelerations.
    NO_LATERAL_ACC = 2
    # Compensate For Coriolis
    COMPENSATE_CORIOLIS = 3

AVTR_STRAIGHT_AHEAD_REF_FRAME.MAINTAIN_COURSE.__doc__ = "Maintain Course."
AVTR_STRAIGHT_AHEAD_REF_FRAME.MAINTAIN_HEADING.__doc__ = "Maintain Heading."
AVTR_STRAIGHT_AHEAD_REF_FRAME.NO_LATERAL_ACC.__doc__ = "No Lateral Accelerations."
AVTR_STRAIGHT_AHEAD_REF_FRAME.COMPENSATE_CORIOLIS.__doc__ = "Compensate For Coriolis"

agcls.AgTypeNameMap["AVTR_STRAIGHT_AHEAD_REF_FRAME"] = AVTR_STRAIGHT_AHEAD_REF_FRAME

class AVTR_AIRSPEED_TYPE(IntEnum):
    """Airspeed types."""
    # Mach number.
    MACH = 0
    # Equivalent airspeed.
    EAS = 1
    # Calibrated airspeed.
    CAS = 2
    # True airspeed.
    TAS = 3

AVTR_AIRSPEED_TYPE.MACH.__doc__ = "Mach number."
AVTR_AIRSPEED_TYPE.EAS.__doc__ = "Equivalent airspeed."
AVTR_AIRSPEED_TYPE.CAS.__doc__ = "Calibrated airspeed."
AVTR_AIRSPEED_TYPE.TAS.__doc__ = "True airspeed."

agcls.AgTypeNameMap["AVTR_AIRSPEED_TYPE"] = AVTR_AIRSPEED_TYPE

class AVTR_AERO_PROP_SIMPLE_MODE(IntEnum):
    """Aircraft operating mode for basic acceleration models with aerodynamics set to Simple."""
    # Fixed wing operatiog mode.
    FIXED_WING = 0
    # Helicopter operating mode.
    HELICOPTER = 1

AVTR_AERO_PROP_SIMPLE_MODE.FIXED_WING.__doc__ = "Fixed wing operatiog mode."
AVTR_AERO_PROP_SIMPLE_MODE.HELICOPTER.__doc__ = "Helicopter operating mode."

agcls.AgTypeNameMap["AVTR_AERO_PROP_SIMPLE_MODE"] = AVTR_AERO_PROP_SIMPLE_MODE

class AVTR_AERO_PROP_FLIGHT_MODE(IntEnum):
    """Flight mode for the Aero/Prop maneuver mode helper in aircraft acceleration models."""
    # Forward Flight mode.
    FLIGHT_PERF_FORWARD_FLIGHT = 0
    # Hover mode.
    FLIGHT_PERF_HOVER = 1
    # Takeoff mode.
    FLIGHT_PERF_TAKEOFF = 2
    # Landing mode.
    FLIGHT_PERF_LANDING = 3
    # Weight on wheels mode.
    FLIGHT_PERF_WEIGHT_ON_WHEELS = 4

AVTR_AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_FORWARD_FLIGHT.__doc__ = "Forward Flight mode."
AVTR_AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_HOVER.__doc__ = "Hover mode."
AVTR_AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_TAKEOFF.__doc__ = "Takeoff mode."
AVTR_AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_LANDING.__doc__ = "Landing mode."
AVTR_AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_WEIGHT_ON_WHEELS.__doc__ = "Weight on wheels mode."

agcls.AgTypeNameMap["AVTR_AERO_PROP_FLIGHT_MODE"] = AVTR_AERO_PROP_FLIGHT_MODE

class AVTR_PHASE_OF_FLIGHT(IntEnum):
    """Flight mode for basic maneuver procedures."""
    # Takeoff flight mode.
    FLIGHT_PHASE_TAKEOFF = 1
    # Forward flight climb flight mode.
    FLIGHT_PHASE_CLIMB = 2
    # Forward flight - cruise flight mode.
    FLIGHT_PHASE_CRUISE = 3
    # Forward flight descend flight mode.
    FLIGHT_PHASE_DESCEND = 4
    # Landing flight mode.
    FLIGHT_PHASE_LANDING = 5
    # Rotary wing / hover flight mode
    FLIGHT_PHASE_VTOL = 6

AVTR_PHASE_OF_FLIGHT.FLIGHT_PHASE_TAKEOFF.__doc__ = "Takeoff flight mode."
AVTR_PHASE_OF_FLIGHT.FLIGHT_PHASE_CLIMB.__doc__ = "Forward flight climb flight mode."
AVTR_PHASE_OF_FLIGHT.FLIGHT_PHASE_CRUISE.__doc__ = "Forward flight - cruise flight mode."
AVTR_PHASE_OF_FLIGHT.FLIGHT_PHASE_DESCEND.__doc__ = "Forward flight descend flight mode."
AVTR_PHASE_OF_FLIGHT.FLIGHT_PHASE_LANDING.__doc__ = "Landing flight mode."
AVTR_PHASE_OF_FLIGHT.FLIGHT_PHASE_VTOL.__doc__ = "Rotary wing / hover flight mode"

agcls.AgTypeNameMap["AVTR_PHASE_OF_FLIGHT"] = AVTR_PHASE_OF_FLIGHT

class AVTR_CRUISE_SPEED(IntEnum):
    """Cruise airspeed type for the procedure."""
    # Minimum airspeed.
    MIN_AIRSPEED = 0
    # Maximum endurance airspeed.
    MAX_ENDURANCE_AIRSPEED = 1
    # Maximum range airspeed.
    MAX_RANGE_AIRSPEED = 2
    # Other airspeed.
    OTHER_AIRSPEED = 3
    # Maximum airspeed.
    MAX_AIRSPEED = 4
    # Maximum performance airspeed.
    MAX_PERF_AIRSPEED = 6

AVTR_CRUISE_SPEED.MIN_AIRSPEED.__doc__ = "Minimum airspeed."
AVTR_CRUISE_SPEED.MAX_ENDURANCE_AIRSPEED.__doc__ = "Maximum endurance airspeed."
AVTR_CRUISE_SPEED.MAX_RANGE_AIRSPEED.__doc__ = "Maximum range airspeed."
AVTR_CRUISE_SPEED.OTHER_AIRSPEED.__doc__ = "Other airspeed."
AVTR_CRUISE_SPEED.MAX_AIRSPEED.__doc__ = "Maximum airspeed."
AVTR_CRUISE_SPEED.MAX_PERF_AIRSPEED.__doc__ = "Maximum performance airspeed."

agcls.AgTypeNameMap["AVTR_CRUISE_SPEED"] = AVTR_CRUISE_SPEED

class AVTR_TAKEOFF_MODE(IntEnum):
    """Takeoff procedure mode."""
    # Normal takeoff mode.
    TAKEOFF_NORMAL = 0
    # Fly to departure point takeoff mode.
    TAKEOFF_FLY_TO_DEPARTURE_POINT = 1
    # Low transition takeoff.
    TAKEOFF_LOW_TRANSITION = 2

AVTR_TAKEOFF_MODE.TAKEOFF_NORMAL.__doc__ = "Normal takeoff mode."
AVTR_TAKEOFF_MODE.TAKEOFF_FLY_TO_DEPARTURE_POINT.__doc__ = "Fly to departure point takeoff mode."
AVTR_TAKEOFF_MODE.TAKEOFF_LOW_TRANSITION.__doc__ = "Low transition takeoff."

agcls.AgTypeNameMap["AVTR_TAKEOFF_MODE"] = AVTR_TAKEOFF_MODE

class AVTR_APPROACH_MODE(IntEnum):
    """Landing procedure approach mode."""
    # Standard instrument approach mode.
    STANDARD_INSTRUMENT_APPROACH = 0
    # Intercept Glideslope approach mode.
    INTERCEPT_GLIDESLOPE = 1
    # Enter downwind pattern approach mode.
    ENTER_DOWNWIND_PATTERN = 2

AVTR_APPROACH_MODE.STANDARD_INSTRUMENT_APPROACH.__doc__ = "Standard instrument approach mode."
AVTR_APPROACH_MODE.INTERCEPT_GLIDESLOPE.__doc__ = "Intercept Glideslope approach mode."
AVTR_APPROACH_MODE.ENTER_DOWNWIND_PATTERN.__doc__ = "Enter downwind pattern approach mode."

agcls.AgTypeNameMap["AVTR_APPROACH_MODE"] = AVTR_APPROACH_MODE

class AVTR_NAVIGATOR_TURN_DIR(IntEnum):
    """Turn mode for procedures with Enroute Turn Direction options."""
    # Automatic turn. Aviator will determine the direction of the turn.
    NAVIGATOR_TURN_AUTO = 0
    # Left turn.
    NAVIGATOR_TURN_LEFT = 1
    # Right turn.
    NAVIGATOR_TURN_RIGHT = 2

AVTR_NAVIGATOR_TURN_DIR.NAVIGATOR_TURN_AUTO.__doc__ = "Automatic turn. Aviator will determine the direction of the turn."
AVTR_NAVIGATOR_TURN_DIR.NAVIGATOR_TURN_LEFT.__doc__ = "Left turn."
AVTR_NAVIGATOR_TURN_DIR.NAVIGATOR_TURN_RIGHT.__doc__ = "Right turn."

agcls.AgTypeNameMap["AVTR_NAVIGATOR_TURN_DIR"] = AVTR_NAVIGATOR_TURN_DIR

class AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE(IntEnum):
    """Fuel flow type for basic maneuver procedures."""
    # Fuel flow defined for the current Takeoff performance model.
    BASIC_MANEUVER_FUEL_FLOW_TAKEOFF = 0
    # Fuel flow defined for the current Cruise performance model.
    BASIC_MANEUVER_FUEL_FLOW_CRUISE = 1
    # Fuel flow defined for the current Landing performance model.
    BASIC_MANEUVER_FUEL_FLOW_LANDING = 2
    # Fuel flow defined for the current VTOL performance model.
    BASIC_MANEUVER_FUEL_FLOW_VTOL = 3
    # Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model.
    BASIC_MANEUVER_FUEL_FLOW_AERO_PROP = 4
    # Fuel flow defined manually.
    BASIC_MANEUVER_FUEL_FLOW_OVERRIDE = 5
    # Fuel flow defined using the thrust model for this maneuver.
    BASIC_MANEUVER_FUEL_FLOW_THRUST_MODEL = 6

AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_TAKEOFF.__doc__ = "Fuel flow defined for the current Takeoff performance model."
AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_CRUISE.__doc__ = "Fuel flow defined for the current Cruise performance model."
AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_LANDING.__doc__ = "Fuel flow defined for the current Landing performance model."
AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_VTOL.__doc__ = "Fuel flow defined for the current VTOL performance model."
AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_AERO_PROP.__doc__ = "Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model."
AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_OVERRIDE.__doc__ = "Fuel flow defined manually."
AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_THRUST_MODEL.__doc__ = "Fuel flow defined using the thrust model for this maneuver."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE"] = AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE

class AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT(IntEnum):
    """The type of response Aviator will have if the maneuver attempts to exceed the altitude limit."""
    # Error when altitude limit exceeded.
    BASIC_MANEUVER_ALT_LIMIT_ERROR = 0
    # Stop when altitude limit exceeded.
    BASIC_MANEUVER_ALT_LIMIT_STOP = 1
    # Continue when altitude limit exceeded.
    BASIC_MANEUVER_ALT_LIMIT_CONTINUE = 2

AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT.BASIC_MANEUVER_ALT_LIMIT_ERROR.__doc__ = "Error when altitude limit exceeded."
AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT.BASIC_MANEUVER_ALT_LIMIT_STOP.__doc__ = "Stop when altitude limit exceeded."
AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT.BASIC_MANEUVER_ALT_LIMIT_CONTINUE.__doc__ = "Continue when altitude limit exceeded."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT"] = AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT

class AVTR_RUNWAY_HIGH_LOW_END(IntEnum):
    """Runway heading that the aircraft will use."""
    # High end.
    HIGH_END = 0
    # Low end.
    LOW_END = 1
    # Headwind.
    HEADWIND = 2

AVTR_RUNWAY_HIGH_LOW_END.HIGH_END.__doc__ = "High end."
AVTR_RUNWAY_HIGH_LOW_END.LOW_END.__doc__ = "Low end."
AVTR_RUNWAY_HIGH_LOW_END.HEADWIND.__doc__ = "Headwind."

agcls.AgTypeNameMap["AVTR_RUNWAY_HIGH_LOW_END"] = AVTR_RUNWAY_HIGH_LOW_END

class AVTR_BASIC_MANEUVER_REF_FRAME(IntEnum):
    """Reference frame for the basic maneuver strategy."""
    # Earth frame.
    EARTH_FRAME = 0
    # Wind frame.
    WIND_FRAME = 1

AVTR_BASIC_MANEUVER_REF_FRAME.EARTH_FRAME.__doc__ = "Earth frame."
AVTR_BASIC_MANEUVER_REF_FRAME.WIND_FRAME.__doc__ = "Wind frame."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_REF_FRAME"] = AVTR_BASIC_MANEUVER_REF_FRAME

class AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT(IntEnum):
    """Method to define the control limits for the aircraft during the maneuver."""
    # Use Accel Perf Model.
    NAV_USE_ACCEL_PERF_MODEL = 0
    # Specify min turn radius.
    NAV_MIN_TURN_RADIUS = 1
    # Specify max turn rate.
    NAV_MAX_TURN_RATE = 2
    # Specify max horiz accel.
    NAV_MAX_HORIZ_ACCEL = 3

AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_USE_ACCEL_PERF_MODEL.__doc__ = "Use Accel Perf Model."
AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_MIN_TURN_RADIUS.__doc__ = "Specify min turn radius."
AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_MAX_TURN_RATE.__doc__ = "Specify max turn rate."
AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_MAX_HORIZ_ACCEL.__doc__ = "Specify max horiz accel."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT"] = AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT

class AVTR_ACCEL_MANEUVER_MODE(IntEnum):
    """The mode that the aircraft will adhere to the specified acceleration parameters."""
    # Constant value (default).
    ACCEL_MANEUVER_MODE_NORMAL = 0
    # Scale by amtmospheric density. The aircraft will consider dynamic pressure when calculating turn radius.
    ACCEL_MANEUVER_MODE_DENSITY_SCALE = 1
    # Aero/Prop maneuver mode.
    ACCEL_MANEUVER_MODE_AERO_PROP = 2

AVTR_ACCEL_MANEUVER_MODE.ACCEL_MANEUVER_MODE_NORMAL.__doc__ = "Constant value (default)."
AVTR_ACCEL_MANEUVER_MODE.ACCEL_MANEUVER_MODE_DENSITY_SCALE.__doc__ = "Scale by amtmospheric density. The aircraft will consider dynamic pressure when calculating turn radius."
AVTR_ACCEL_MANEUVER_MODE.ACCEL_MANEUVER_MODE_AERO_PROP.__doc__ = "Aero/Prop maneuver mode."

agcls.AgTypeNameMap["AVTR_ACCEL_MANEUVER_MODE"] = AVTR_ACCEL_MANEUVER_MODE

class AVTR_AIRCRAFT_AERO_STRATEGY(IntEnum):
    """The aerodynamic strategy used to compute lift, drag, angle of attack, sideslip and intermediate / derived values."""
    # Simple aerodynamics.
    AIRCRAFT_AERO_SIMPLE = 0
    # External file aerodynamics.
    AIRCRAFT_AERO_EXTERNAL_FILE = 1
    # Basic fixed wing aerodynamics.
    AIRCRAFT_AERO_BASIC_FIXED_WING = 2
    # Advanced missile aerodynamics.
    AIRCRAFT_AERO_ADVANCED_MISSILE = 3

AVTR_AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_SIMPLE.__doc__ = "Simple aerodynamics."
AVTR_AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_EXTERNAL_FILE.__doc__ = "External file aerodynamics."
AVTR_AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_BASIC_FIXED_WING.__doc__ = "Basic fixed wing aerodynamics."
AVTR_AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_ADVANCED_MISSILE.__doc__ = "Advanced missile aerodynamics."

agcls.AgTypeNameMap["AVTR_AIRCRAFT_AERO_STRATEGY"] = AVTR_AIRCRAFT_AERO_STRATEGY

class AVTR_AIRCRAFT_PROP_STRATEGY(IntEnum):
    """The propulsion strategy used to compute thrust and throttle setting."""
    # Simple propulsion.
    AIRCRAFT_PROP_SIMPLE = 0
    # External file propulsion.
    AIRCRAFT_PROP_EXTERNAL_FILE = 1
    # Basic fixed wing propulsion.
    AIRCRAFT_PROP_BASIC_FIXED_WING = 2
    # Missile - Ramjet propulsion.
    AIRCRAFT_PROP_MISSILE_RAMJET = 3
    # Missile - Rocket propulsion.
    AIRCRAFT_PROP_MISSILE_ROCKET = 4
    # Missile - Turbojet propulsion.
    AIRCRAFT_PROP_MISSILE_TURBOJET = 5

AVTR_AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_SIMPLE.__doc__ = "Simple propulsion."
AVTR_AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_EXTERNAL_FILE.__doc__ = "External file propulsion."
AVTR_AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_BASIC_FIXED_WING.__doc__ = "Basic fixed wing propulsion."
AVTR_AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_MISSILE_RAMJET.__doc__ = "Missile - Ramjet propulsion."
AVTR_AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_MISSILE_ROCKET.__doc__ = "Missile - Rocket propulsion."
AVTR_AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_MISSILE_TURBOJET.__doc__ = "Missile - Turbojet propulsion."

agcls.AgTypeNameMap["AVTR_AIRCRAFT_PROP_STRATEGY"] = AVTR_AIRCRAFT_PROP_STRATEGY

class AVTR_AGLMSL(IntEnum):
    """The altitude mode."""
    # AGl altitude. ALtitude above local terrain
    ALT_AGL = 0
    # MSL altitude. Altitude above sea level.
    ALT_MSL = 1

AVTR_AGLMSL.ALT_AGL.__doc__ = "AGl altitude. ALtitude above local terrain"
AVTR_AGLMSL.ALT_MSL.__doc__ = "MSL altitude. Altitude above sea level."

agcls.AgTypeNameMap["AVTR_AGLMSL"] = AVTR_AGLMSL

class AVTR_LANDING_APPROACH_FIX_RANGE_MODE(IntEnum):
    """The reference point on the runway for the Approach Fix Range."""
    # Runway center.
    REL_TO_RUNWAY_CENTER = 0
    # Runway end.
    REL_TO_RUNWAY_END = 1

AVTR_LANDING_APPROACH_FIX_RANGE_MODE.REL_TO_RUNWAY_CENTER.__doc__ = "Runway center."
AVTR_LANDING_APPROACH_FIX_RANGE_MODE.REL_TO_RUNWAY_END.__doc__ = "Runway end."

agcls.AgTypeNameMap["AVTR_LANDING_APPROACH_FIX_RANGE_MODE"] = AVTR_LANDING_APPROACH_FIX_RANGE_MODE

class AVTR_ACCELERATION_ADV_ACCEL_MODE(IntEnum):
    """Acceleration mode for aircraft advanced acceleration models."""
    # Max acceleration.
    ACCEL_MODE_MAX_ACCEL = 0
    # Manually override the acceleration.
    ACCEL_MODE_OVERRIDE_ACCEL = 1

AVTR_ACCELERATION_ADV_ACCEL_MODE.ACCEL_MODE_MAX_ACCEL.__doc__ = "Max acceleration."
AVTR_ACCELERATION_ADV_ACCEL_MODE.ACCEL_MODE_OVERRIDE_ACCEL.__doc__ = "Manually override the acceleration."

agcls.AgTypeNameMap["AVTR_ACCELERATION_ADV_ACCEL_MODE"] = AVTR_ACCELERATION_ADV_ACCEL_MODE

class AVTR_ACCEL_MANEUVER_AERO_PROP_MODE(IntEnum):
    """The mode used for the Aero/Prop maneuver mode helper for aircraft basic acceleration models."""
    # Use Thrust and Lift Coefficient
    USE_THRUST_AND_LIFT_COEFFICIENT = 0
    # Use Lift Coefficient only.
    USE_LIFT_COEFFICIENT_ONLY = 1

AVTR_ACCEL_MANEUVER_AERO_PROP_MODE.USE_THRUST_AND_LIFT_COEFFICIENT.__doc__ = "Use Thrust and Lift Coefficient"
AVTR_ACCEL_MANEUVER_AERO_PROP_MODE.USE_LIFT_COEFFICIENT_ONLY.__doc__ = "Use Lift Coefficient only."

agcls.AgTypeNameMap["AVTR_ACCEL_MANEUVER_AERO_PROP_MODE"] = AVTR_ACCEL_MANEUVER_AERO_PROP_MODE

class AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS(IntEnum):
    """The type of response Aviator will have if the basic maneuver attempts to exceed the airspeed limit."""
    # Constrain the aircraft to not exceed the airspeed limit.
    CONSTRAIN_IF_VIOLATED = 0
    # Stop when airspeed limit exceeded..
    STOP_IF_VIOLATED = 1
    # Error when airspeed limit exceeded.
    ERROR_IF_VIOLATED = 2
    # Ignore when airspeed limit exceeded.
    IGNORE_IF_VIOLATED = 3

AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.CONSTRAIN_IF_VIOLATED.__doc__ = "Constrain the aircraft to not exceed the airspeed limit."
AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.STOP_IF_VIOLATED.__doc__ = "Stop when airspeed limit exceeded.."
AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.ERROR_IF_VIOLATED.__doc__ = "Error when airspeed limit exceeded."
AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.IGNORE_IF_VIOLATED.__doc__ = "Ignore when airspeed limit exceeded."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS"] = AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS

class AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE(IntEnum):
    """Powered Cruise Options."""
    # The mode selected is unpowered options.
    GLIDE_SPECIFY_UN_POWERED_CRUISE = 0
    # The mode selected is specifiy throttle.
    GLIDE_SPECIFY_THROTTLE = 1
    # The mode selected is thrust model.
    GLIDE_SPECIFY_THRUST_MODEL = 2

AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE.GLIDE_SPECIFY_UN_POWERED_CRUISE.__doc__ = "The mode selected is unpowered options."
AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE.GLIDE_SPECIFY_THROTTLE.__doc__ = "The mode selected is specifiy throttle."
AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE.GLIDE_SPECIFY_THRUST_MODEL.__doc__ = "The mode selected is thrust model."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE"] = AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE

class AVTR_TURN_MODE(IntEnum):
    """The mode to specify an aircraft's level turn performance for acceleration performance models."""
    # Turn G. The standard G force of the aircraft in a turn.
    TURN_MODE_TURN_G = 0
    # Bank angle.
    TURN_MODE_BANK_ANGLE = 1
    # Turn acceleration.
    TURN_MODE_ACCEL = 2
    # Turn radius.
    TURN_MODE_RADIUS = 3
    # Turn rate.
    TURN_MODE_RATE = 4

AVTR_TURN_MODE.TURN_MODE_TURN_G.__doc__ = "Turn G. The standard G force of the aircraft in a turn."
AVTR_TURN_MODE.TURN_MODE_BANK_ANGLE.__doc__ = "Bank angle."
AVTR_TURN_MODE.TURN_MODE_ACCEL.__doc__ = "Turn acceleration."
AVTR_TURN_MODE.TURN_MODE_RADIUS.__doc__ = "Turn radius."
AVTR_TURN_MODE.TURN_MODE_RATE.__doc__ = "Turn rate."

agcls.AgTypeNameMap["AVTR_TURN_MODE"] = AVTR_TURN_MODE

class AVTR_POINT_TO_POINT_MODE(IntEnum):
    """The heading or course of the aircraft at the beginning of the procedure."""
    # Fly direct.
    FLY_DIRECT = 0
    # Arrive on course for next procedure.
    ARRIVE_ON_COURSE_FOR_NEXT = 1
    # Arrive on course.
    ARRIVE_ON_COURSE = 2
    # Inscribed turn.
    INSCRIBED_TURN = 3
    # Arrive on heading into wind.
    ARRIVE_ON_HDG_INTO_WIND = 4

AVTR_POINT_TO_POINT_MODE.FLY_DIRECT.__doc__ = "Fly direct."
AVTR_POINT_TO_POINT_MODE.ARRIVE_ON_COURSE_FOR_NEXT.__doc__ = "Arrive on course for next procedure."
AVTR_POINT_TO_POINT_MODE.ARRIVE_ON_COURSE.__doc__ = "Arrive on course."
AVTR_POINT_TO_POINT_MODE.INSCRIBED_TURN.__doc__ = "Inscribed turn."
AVTR_POINT_TO_POINT_MODE.ARRIVE_ON_HDG_INTO_WIND.__doc__ = "Arrive on heading into wind."

agcls.AgTypeNameMap["AVTR_POINT_TO_POINT_MODE"] = AVTR_POINT_TO_POINT_MODE

class AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE(IntEnum):
    """Turn mode for procedures that may require a level off maneuver."""
    # Automatic turn.Aviator will determine the direction of the turn.
    LEVEL_OFF_AUTOMATIC_MANEUVER = 0
    # Left turn.
    LEVEL_OFF_LEFT_TURN_MANEUVER = 1
    # Right turn.
    LEVEL_OFF_RIGHT_TURN_MANEUVER = 2
    # No turn. A level off maneuver will not be performed.
    LEVEL_OFF_NO_MANEUVER = 3

AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_AUTOMATIC_MANEUVER.__doc__ = "Automatic turn.Aviator will determine the direction of the turn."
AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_LEFT_TURN_MANEUVER.__doc__ = "Left turn."
AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_RIGHT_TURN_MANEUVER.__doc__ = "Right turn."
AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_NO_MANEUVER.__doc__ = "No turn. A level off maneuver will not be performed."

agcls.AgTypeNameMap["AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE"] = AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE

class AVTR_WIND_MODEL_TYPE(IntEnum):
    """The wind model type."""
    # Constant Wind/Speed.
    CONSTANT_WIND = 0
    # NOAA ADDS Service.
    ADDS = 1
    # Disabled wind model.
    DISABLED = 2

AVTR_WIND_MODEL_TYPE.CONSTANT_WIND.__doc__ = "Constant Wind/Speed."
AVTR_WIND_MODEL_TYPE.ADDS.__doc__ = "NOAA ADDS Service."
AVTR_WIND_MODEL_TYPE.DISABLED.__doc__ = "Disabled wind model."

agcls.AgTypeNameMap["AVTR_WIND_MODEL_TYPE"] = AVTR_WIND_MODEL_TYPE

class AVTR_WIND_ATMOS_MODEL_SOURCE(IntEnum):
    """The source for the wind or atmosphere model."""
    # Scenario Model.
    SCENARIO_MODEL = 0
    # Mission Model.
    MISSION_MODEL = 1
    # Procedure Model.
    PROCEDURE_MODEL = 2

AVTR_WIND_ATMOS_MODEL_SOURCE.SCENARIO_MODEL.__doc__ = "Scenario Model."
AVTR_WIND_ATMOS_MODEL_SOURCE.MISSION_MODEL.__doc__ = "Mission Model."
AVTR_WIND_ATMOS_MODEL_SOURCE.PROCEDURE_MODEL.__doc__ = "Procedure Model."

agcls.AgTypeNameMap["AVTR_WIND_ATMOS_MODEL_SOURCE"] = AVTR_WIND_ATMOS_MODEL_SOURCE

class AVTR_ADDS_MSG_INTERP_TYPE(IntEnum):
    """The interpolation method for the wind conditions."""
    # One Point Interpolation.
    INTERP_ONE_POINT = 0
    # Two Point Interpolation.
    INTERP_TWO_POINT = 1

AVTR_ADDS_MSG_INTERP_TYPE.INTERP_ONE_POINT.__doc__ = "One Point Interpolation."
AVTR_ADDS_MSG_INTERP_TYPE.INTERP_TWO_POINT.__doc__ = "Two Point Interpolation."

agcls.AgTypeNameMap["AVTR_ADDS_MSG_INTERP_TYPE"] = AVTR_ADDS_MSG_INTERP_TYPE

class AVTR_ADDS_MISSING_MSG_TYPE(IntEnum):
    """The wind effect to apply if there is an interval gap between messages."""
    # Zero Wind.
    MISSING_MSG_ZERO_WIND = 0
    # Interpolate End Points.
    MISSING_MSG_INTERP_END_POINTS = 1

AVTR_ADDS_MISSING_MSG_TYPE.MISSING_MSG_ZERO_WIND.__doc__ = "Zero Wind."
AVTR_ADDS_MISSING_MSG_TYPE.MISSING_MSG_INTERP_END_POINTS.__doc__ = "Interpolate End Points."

agcls.AgTypeNameMap["AVTR_ADDS_MISSING_MSG_TYPE"] = AVTR_ADDS_MISSING_MSG_TYPE

class AVTR_ADDS_MSG_EXTRAP_TYPE(IntEnum):
    """The wind effect to apply if the procedure(s) extend beyond the intervals of any available messages."""
    # Zero Wind.
    EXTRAP_MSG_ZERO_WIND = 0
    # Hold End Point Wind.
    EXTRAP_MSG_HOLD_END_POINTS = 1

AVTR_ADDS_MSG_EXTRAP_TYPE.EXTRAP_MSG_ZERO_WIND.__doc__ = "Zero Wind."
AVTR_ADDS_MSG_EXTRAP_TYPE.EXTRAP_MSG_HOLD_END_POINTS.__doc__ = "Hold End Point Wind."

agcls.AgTypeNameMap["AVTR_ADDS_MSG_EXTRAP_TYPE"] = AVTR_ADDS_MSG_EXTRAP_TYPE

class AVTR_ADDS_FORECAST_TYPE(IntEnum):
    """The forecast type for the NOAA ADDS message."""
    # 6 hour forecast
    HOUR_6 = 0
    # 12 hour forecast
    HOUR_12 = 1
    # 24 hour forecast
    HOUR_24 = 2

AVTR_ADDS_FORECAST_TYPE.HOUR_6.__doc__ = "6 hour forecast"
AVTR_ADDS_FORECAST_TYPE.HOUR_12.__doc__ = "12 hour forecast"
AVTR_ADDS_FORECAST_TYPE.HOUR_24.__doc__ = "24 hour forecast"

agcls.AgTypeNameMap["AVTR_ADDS_FORECAST_TYPE"] = AVTR_ADDS_FORECAST_TYPE

class AVTR_ATMOSPHERE_MODEL(IntEnum):
    """The basic atmosphere model type."""
    # 1976 U.S. Standard Atmosphere
    STANDARD1976 = 0
    # U.S. MIL HDBK 310 - Hot
    MIL_HOT = 1
    # U.S. MIL HDBK 310 - Cold
    MIL_COLD = 2
    # U.S. MIL HDBK 310 - Low Density
    MIL_LOW_DENSITY = 3
    # U.S. MIL HDBK 310 - High Density
    MIL_HIGH_DENSITY = 4
    # Interpolate MIL HDBK 310 Data
    MIL_INTERPOLATE = 5

AVTR_ATMOSPHERE_MODEL.STANDARD1976.__doc__ = "1976 U.S. Standard Atmosphere"
AVTR_ATMOSPHERE_MODEL.MIL_HOT.__doc__ = "U.S. MIL HDBK 310 - Hot"
AVTR_ATMOSPHERE_MODEL.MIL_COLD.__doc__ = "U.S. MIL HDBK 310 - Cold"
AVTR_ATMOSPHERE_MODEL.MIL_LOW_DENSITY.__doc__ = "U.S. MIL HDBK 310 - Low Density"
AVTR_ATMOSPHERE_MODEL.MIL_HIGH_DENSITY.__doc__ = "U.S. MIL HDBK 310 - High Density"
AVTR_ATMOSPHERE_MODEL.MIL_INTERPOLATE.__doc__ = "Interpolate MIL HDBK 310 Data"

agcls.AgTypeNameMap["AVTR_ATMOSPHERE_MODEL"] = AVTR_ATMOSPHERE_MODEL

class AVTR_SMOOTH_TURN_MODE(IntEnum):
    """The basic maneuver smooth turn mode."""
    # Specify the load factor of the smooth turn
    SMOOTH_TURN_LOAD_FACTOR = 0
    # Specify the roll angle of the smooth turn
    SMOOTH_TURN_ROLL_ANGLE = 1

AVTR_SMOOTH_TURN_MODE.SMOOTH_TURN_LOAD_FACTOR.__doc__ = "Specify the load factor of the smooth turn"
AVTR_SMOOTH_TURN_MODE.SMOOTH_TURN_ROLL_ANGLE.__doc__ = "Specify the roll angle of the smooth turn"

agcls.AgTypeNameMap["AVTR_SMOOTH_TURN_MODE"] = AVTR_SMOOTH_TURN_MODE

class AVTR_PERF_MODEL_OVERRIDE(IntEnum):
    """The performance model override mode."""
    # Use the performance model value
    PERF_MODEL_VALUE = 0
    # Override the performance model value
    OVERRIDE = 1

AVTR_PERF_MODEL_OVERRIDE.PERF_MODEL_VALUE.__doc__ = "Use the performance model value"
AVTR_PERF_MODEL_OVERRIDE.OVERRIDE.__doc__ = "Override the performance model value"

agcls.AgTypeNameMap["AVTR_PERF_MODEL_OVERRIDE"] = AVTR_PERF_MODEL_OVERRIDE

class AVTR_BASIC_MANEUVER_AIRSPEED_MODE(IntEnum):
    """The basic maneuver airspeed mode."""
    # Maintain the current airspeed
    MAINTAIN_CURRENT_AIRSPEED = 0
    # Maintain the specified airspeed
    MAINTAIN_SPECIFIED_AIRSPEED = 1
    # Maintain the minimum airspeed for the aircraft
    MAINTAIN_MIN_AIRSPEED = 2
    # Maintain the maximum endurance airspeed for the aircraft
    MAINTAIN_MAX_ENDURANCE_AIRSPEED = 3
    # Maintain the maximum range airspeed for the aircraft
    MAINTAIN_MAX_RANGE_AIRSPEED = 4
    # Maintain the maximum airspeed for the aircraft
    MAINTAIN_MAX_AIRSPEED = 5
    # Maintain the maximum performance airspeed for the aircraft
    MAINTAIN_MAX_PERFORMANCE_AIRSPEED = 6
    # Accelerate at the specified rate
    ACCEL_AT_G = 7
    # Decelerate at the specified rate
    DECEL_AT_G = 8
    # Accel/Decel at the force of gravity (no drag, no thrust)
    ACCEL_DECEL_UNDER_GRAVITY = 9
    # Accel/Decel using Aero/Propulsion with throttle setting
    ACCEL_DECEL_AERO_PROP = 10
    # Specify thrust (using drag from Aerodynamics model)
    THRUST = 11
    # Interpolate Accelerate/Decelerate over interval
    INTERPOLATE_ACCEL_DECEL = 12

AVTR_BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_CURRENT_AIRSPEED.__doc__ = "Maintain the current airspeed"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_SPECIFIED_AIRSPEED.__doc__ = "Maintain the specified airspeed"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MIN_AIRSPEED.__doc__ = "Maintain the minimum airspeed for the aircraft"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_ENDURANCE_AIRSPEED.__doc__ = "Maintain the maximum endurance airspeed for the aircraft"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_RANGE_AIRSPEED.__doc__ = "Maintain the maximum range airspeed for the aircraft"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_AIRSPEED.__doc__ = "Maintain the maximum airspeed for the aircraft"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_PERFORMANCE_AIRSPEED.__doc__ = "Maintain the maximum performance airspeed for the aircraft"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.ACCEL_AT_G.__doc__ = "Accelerate at the specified rate"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.DECEL_AT_G.__doc__ = "Decelerate at the specified rate"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.ACCEL_DECEL_UNDER_GRAVITY.__doc__ = "Accel/Decel at the force of gravity (no drag, no thrust)"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.ACCEL_DECEL_AERO_PROP.__doc__ = "Accel/Decel using Aero/Propulsion with throttle setting"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.THRUST.__doc__ = "Specify thrust (using drag from Aerodynamics model)"
AVTR_BASIC_MANEUVER_AIRSPEED_MODE.INTERPOLATE_ACCEL_DECEL.__doc__ = "Interpolate Accelerate/Decelerate over interval"

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_AIRSPEED_MODE"] = AVTR_BASIC_MANEUVER_AIRSPEED_MODE

class AVTR_AILERON_ROLL_FLIGHT_PATH(IntEnum):
    """The flight path option for an aileron roll strategy for a basic maneuver procedure."""
    # Fly a straight line flight path
    STRAIGHT_LINE_FLIGHT_PATH = 0
    # Fly a zero G flight path
    ZERO_G_FLIGHT_PATH = 1

AVTR_AILERON_ROLL_FLIGHT_PATH.STRAIGHT_LINE_FLIGHT_PATH.__doc__ = "Fly a straight line flight path"
AVTR_AILERON_ROLL_FLIGHT_PATH.ZERO_G_FLIGHT_PATH.__doc__ = "Fly a zero G flight path"

agcls.AgTypeNameMap["AVTR_AILERON_ROLL_FLIGHT_PATH"] = AVTR_AILERON_ROLL_FLIGHT_PATH

class AVTR_ROLL_LEFT_RIGHT(IntEnum):
    """The roll direction for an aileron roll strategy for a basic maneuver procedure."""
    # Roll left
    ROLL_LEFT = 0
    # Roll right
    ROLL_RIGHT = 1

AVTR_ROLL_LEFT_RIGHT.ROLL_LEFT.__doc__ = "Roll left"
AVTR_ROLL_LEFT_RIGHT.ROLL_RIGHT.__doc__ = "Roll right"

agcls.AgTypeNameMap["AVTR_ROLL_LEFT_RIGHT"] = AVTR_ROLL_LEFT_RIGHT

class AVTR_ROLL_UPRIGHT_INVERTED(IntEnum):
    """The orientation for an aileron roll strategy for a basic maneuver procedure."""
    # Upright roll
    ROLL_UPRIGHT = 0
    # Inverted roll
    ROLL_INVERTED = 1

AVTR_ROLL_UPRIGHT_INVERTED.ROLL_UPRIGHT.__doc__ = "Upright roll"
AVTR_ROLL_UPRIGHT_INVERTED.ROLL_INVERTED.__doc__ = "Inverted roll"

agcls.AgTypeNameMap["AVTR_ROLL_UPRIGHT_INVERTED"] = AVTR_ROLL_UPRIGHT_INVERTED

class AVTR_AILERON_ROLL_MODE(IntEnum):
    """The roll mode aileron roll strategy for a basic maneuver procedure."""
    # Specify the angle to roll
    ROLL_TO_ANGLE = 0
    # Specify the orientation to roll to
    ROLL_TO_ORIENTATION = 1

AVTR_AILERON_ROLL_MODE.ROLL_TO_ANGLE.__doc__ = "Specify the angle to roll"
AVTR_AILERON_ROLL_MODE.ROLL_TO_ORIENTATION.__doc__ = "Specify the orientation to roll to"

agcls.AgTypeNameMap["AVTR_AILERON_ROLL_MODE"] = AVTR_AILERON_ROLL_MODE

class AVTR_FLY_AOA_LEFT_RIGHT(IntEnum):
    """The roll direction for a Fly AOA strategy for a basic maneuver procedure."""
    # Roll left
    FLY_AOA_LEFT = 0
    # Roll right
    FLY_AOA_RIGHT = 1
    # No roll
    FLY_AOA_NO_ROLL = 2

AVTR_FLY_AOA_LEFT_RIGHT.FLY_AOA_LEFT.__doc__ = "Roll left"
AVTR_FLY_AOA_LEFT_RIGHT.FLY_AOA_RIGHT.__doc__ = "Roll right"
AVTR_FLY_AOA_LEFT_RIGHT.FLY_AOA_NO_ROLL.__doc__ = "No roll"

agcls.AgTypeNameMap["AVTR_FLY_AOA_LEFT_RIGHT"] = AVTR_FLY_AOA_LEFT_RIGHT

class AVTR_SMOOTH_ACCEL_LEFT_RIGHT(IntEnum):
    """The roll direction for a smooth acceleration strategy for a basic maneuver procedure."""
    # Roll left
    SMOOTH_ACCEL_LEFT = 0
    # Roll right
    SMOOTH_ACCEL_RIGHT = 1
    # No roll
    SMOOTH_ACCEL_NO_ROLL = 2

AVTR_SMOOTH_ACCEL_LEFT_RIGHT.SMOOTH_ACCEL_LEFT.__doc__ = "Roll left"
AVTR_SMOOTH_ACCEL_LEFT_RIGHT.SMOOTH_ACCEL_RIGHT.__doc__ = "Roll right"
AVTR_SMOOTH_ACCEL_LEFT_RIGHT.SMOOTH_ACCEL_NO_ROLL.__doc__ = "No roll"

agcls.AgTypeNameMap["AVTR_SMOOTH_ACCEL_LEFT_RIGHT"] = AVTR_SMOOTH_ACCEL_LEFT_RIGHT

class AVTR_PULL_MODE(IntEnum):
    """The pull mode for a pull strategy of a basic maneuver procedure."""
    # Pull to the specified angle
    PULL_TO_ANGLE = 0
    # Pull to the horizon plus the additional angle
    PULL_TO_HORIZON = 1

AVTR_PULL_MODE.PULL_TO_ANGLE.__doc__ = "Pull to the specified angle"
AVTR_PULL_MODE.PULL_TO_HORIZON.__doc__ = "Pull to the horizon plus the additional angle"

agcls.AgTypeNameMap["AVTR_PULL_MODE"] = AVTR_PULL_MODE

class AVTR_ROLLING_PULL_MODE(IntEnum):
    """The rolling pull mode for a rolling pull strategy of a basic maneuver procedure."""
    # Roll to the specified angle
    ROLL_TO_ANGLE_MODE = 0
    # Roll to the specified orientaiton plus additional angle
    ROLL_TO_ORIENTATION_MODE = 1
    # Pull to the specified angle
    PULL_TO_ANGLE_MODE = 2
    # Pull to the horizon plus the additional angle
    PULL_TO_HORIZON_MODE = 3

AVTR_ROLLING_PULL_MODE.ROLL_TO_ANGLE_MODE.__doc__ = "Roll to the specified angle"
AVTR_ROLLING_PULL_MODE.ROLL_TO_ORIENTATION_MODE.__doc__ = "Roll to the specified orientaiton plus additional angle"
AVTR_ROLLING_PULL_MODE.PULL_TO_ANGLE_MODE.__doc__ = "Pull to the specified angle"
AVTR_ROLLING_PULL_MODE.PULL_TO_HORIZON_MODE.__doc__ = "Pull to the horizon plus the additional angle"

agcls.AgTypeNameMap["AVTR_ROLLING_PULL_MODE"] = AVTR_ROLLING_PULL_MODE

class AVTR_SMOOTH_ACCEL_STOP_CONDITIONS(IntEnum):
    """The rolling pull mode for a rolling pull strategy of a basic maneuver procedure."""
    # Roll rate and load factor rate achieved
    ROLL_RATE_AND_LOAD_FACTOR = 0
    # Roll rate or load factor rate achieved
    ROLL_RATE_OR_LOAD_FACTOR = 1
    # Basic stop conditions
    SMOOTH_ACCEL_NORMAL_STOP_CONDITIONS = 2

AVTR_SMOOTH_ACCEL_STOP_CONDITIONS.ROLL_RATE_AND_LOAD_FACTOR.__doc__ = "Roll rate and load factor rate achieved"
AVTR_SMOOTH_ACCEL_STOP_CONDITIONS.ROLL_RATE_OR_LOAD_FACTOR.__doc__ = "Roll rate or load factor rate achieved"
AVTR_SMOOTH_ACCEL_STOP_CONDITIONS.SMOOTH_ACCEL_NORMAL_STOP_CONDITIONS.__doc__ = "Basic stop conditions"

agcls.AgTypeNameMap["AVTR_SMOOTH_ACCEL_STOP_CONDITIONS"] = AVTR_SMOOTH_ACCEL_STOP_CONDITIONS

class AVTR_AUTOPILOT_HORIZ_PLANE_MODE(IntEnum):
    """The autopilot mode for an autopilot - horizontal plane strategy of a basic maneuver procedure."""
    # The absolute heading mode
    AUTOPILOT_ABSOLUTE_HEADING = 0
    # The absolute course mode
    AUTOPILOT_ABSOLUTE_COURSE = 1
    # The relative heading change mode
    AUTOPILOT_RELATIVE_HEADING = 2
    # The relative course change mode
    AUTOPILOT_RELATIVE_COURSE = 3
    # The set heading rate mode
    AUTOPILOT_HEADING_RATE = 4
    # The set heading rate  mode
    AUTOPILOT_COURSE_RATE = 5

AVTR_AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_ABSOLUTE_HEADING.__doc__ = "The absolute heading mode"
AVTR_AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_ABSOLUTE_COURSE.__doc__ = "The absolute course mode"
AVTR_AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_RELATIVE_HEADING.__doc__ = "The relative heading change mode"
AVTR_AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_RELATIVE_COURSE.__doc__ = "The relative course change mode"
AVTR_AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_HEADING_RATE.__doc__ = "The set heading rate mode"
AVTR_AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_COURSE_RATE.__doc__ = "The set heading rate  mode"

agcls.AgTypeNameMap["AVTR_AUTOPILOT_HORIZ_PLANE_MODE"] = AVTR_AUTOPILOT_HORIZ_PLANE_MODE

class AVTR_ANGLE_MODE(IntEnum):
    """The angle mode for a barrel roll strategy of a basic maneuver procedure."""
    # The absolute angle option
    RELATIVE_ANGLE = 0
    # The relative angle option
    ABSOLUTE_ANGLE = 1

AVTR_ANGLE_MODE.RELATIVE_ANGLE.__doc__ = "The absolute angle option"
AVTR_ANGLE_MODE.ABSOLUTE_ANGLE.__doc__ = "The relative angle option"

agcls.AgTypeNameMap["AVTR_ANGLE_MODE"] = AVTR_ANGLE_MODE

class AVTR_HOVER_ALTITUDE_MODE(IntEnum):
    """The altitude mode for the lighter than air hover strategy of a basic maneuver procedure."""
    # The hold initial altitude mode
    HOVER_HOLD_INIT_ALTITUDE = 0
    # The specify altitude mode
    HOVER_SPECIFY_ALTITUDE = 1
    # The specify altitude change mode
    HOVER_SPECIFY_ALTITUDE_CHANGE = 2
    # The specify altitude rate mode
    HOVER_SPECIFY_ALTITUDE_RATE = 3
    # The hold initial altitude rate mode
    HOVER_HOLD_INIT_ALTITUDE_RATE = 4
    # The parachute mode
    HOVER_PARACHUTE = 5

AVTR_HOVER_ALTITUDE_MODE.HOVER_HOLD_INIT_ALTITUDE.__doc__ = "The hold initial altitude mode"
AVTR_HOVER_ALTITUDE_MODE.HOVER_SPECIFY_ALTITUDE.__doc__ = "The specify altitude mode"
AVTR_HOVER_ALTITUDE_MODE.HOVER_SPECIFY_ALTITUDE_CHANGE.__doc__ = "The specify altitude change mode"
AVTR_HOVER_ALTITUDE_MODE.HOVER_SPECIFY_ALTITUDE_RATE.__doc__ = "The specify altitude rate mode"
AVTR_HOVER_ALTITUDE_MODE.HOVER_HOLD_INIT_ALTITUDE_RATE.__doc__ = "The hold initial altitude rate mode"
AVTR_HOVER_ALTITUDE_MODE.HOVER_PARACHUTE.__doc__ = "The parachute mode"

agcls.AgTypeNameMap["AVTR_HOVER_ALTITUDE_MODE"] = AVTR_HOVER_ALTITUDE_MODE

class AVTR_HOVER_HEADING_MODE(IntEnum):
    """The heading mode for the lighter than air hover strategy of a basic maneuver procedure."""
    # The relative to start heading mode
    HOVER_RELATIVE = 0
    # The absolute heading mode
    HOVER_ABSOLUTE = 1
    # The align into wind heading mode
    HOVER_INTO_WIND = 2
    # The align opposite wind heading mode
    HOVER_OPPOSITE_WIND = 3

AVTR_HOVER_HEADING_MODE.HOVER_RELATIVE.__doc__ = "The relative to start heading mode"
AVTR_HOVER_HEADING_MODE.HOVER_ABSOLUTE.__doc__ = "The absolute heading mode"
AVTR_HOVER_HEADING_MODE.HOVER_INTO_WIND.__doc__ = "The align into wind heading mode"
AVTR_HOVER_HEADING_MODE.HOVER_OPPOSITE_WIND.__doc__ = "The align opposite wind heading mode"

agcls.AgTypeNameMap["AVTR_HOVER_HEADING_MODE"] = AVTR_HOVER_HEADING_MODE

class AVTR_AUTOPILOT_ALTITUDE_MODE(IntEnum):
    """The altitude mode for the autopilot - vertical plane strategy of a basic maneuver procedure."""
    # The hold initial altitude mode
    AUTOPILOT_HOLD_INIT_ALTITUDE = 0
    # The specify altitude mode
    AUTOPILOT_SPECIFY_ALTITUDE = 1
    # The specify altitude change mode
    AUTOPILOT_SPECIFY_ALTITUDE_CHANGE = 2
    # The specify altitude rate mode
    AUTOPILOT_SPECIFY_ALTITUDE_RATE = 3
    # The hold initial altitude rate mode
    AUTOPILOT_HOLD_INIT_ALTITUDE_RATE = 4
    # The specify wind fram eflight path angle mode
    AUTOPILOT_SPECIFY_FPA = 5
    # The hold initial wind frame flight path angle mode
    AUTOPILOT_HOLD_INIT_FPA = 6
    # The ballistic flight path mode
    AUTOPILOT_BALLISTIC = 7

AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_HOLD_INIT_ALTITUDE.__doc__ = "The hold initial altitude mode"
AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_ALTITUDE.__doc__ = "The specify altitude mode"
AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_ALTITUDE_CHANGE.__doc__ = "The specify altitude change mode"
AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_ALTITUDE_RATE.__doc__ = "The specify altitude rate mode"
AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_HOLD_INIT_ALTITUDE_RATE.__doc__ = "The hold initial altitude rate mode"
AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_FPA.__doc__ = "The specify wind fram eflight path angle mode"
AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_HOLD_INIT_FPA.__doc__ = "The hold initial wind frame flight path angle mode"
AVTR_AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_BALLISTIC.__doc__ = "The ballistic flight path mode"

agcls.AgTypeNameMap["AVTR_AUTOPILOT_ALTITUDE_MODE"] = AVTR_AUTOPILOT_ALTITUDE_MODE

class AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE(IntEnum):
    """The altitude control mode for the autopilot - vertical plane strategy of a basic maneuver procedure."""
    # The control altitude rate mode
    AUTOPILOT_ALTITUDE_RATE = 0
    # The control flight path angle mode
    AUTOPILOT_FPA = 1
    # The climb/descent performance models mode
    AUTOPILOT_PERF_MODELS = 2

AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE.AUTOPILOT_ALTITUDE_RATE.__doc__ = "The control altitude rate mode"
AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE.AUTOPILOT_FPA.__doc__ = "The control flight path angle mode"
AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE.AUTOPILOT_PERF_MODELS.__doc__ = "The climb/descent performance models mode"

agcls.AgTypeNameMap["AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE"] = AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE

class AVTR_CLOSURE_MODE(IntEnum):
    """The closure mode for guidance strategies of the basic maneuver procedure."""
    # The closure is not set. The maneuver will continue whether or not the aircraft is closing with the target
    CLOSURE_NOT_SET = 0
    # The closure is required
    CLOSURE_REQUIRED = 1
    # The high off boresight mode
    HOBS = 2

AVTR_CLOSURE_MODE.CLOSURE_NOT_SET.__doc__ = "The closure is not set. The maneuver will continue whether or not the aircraft is closing with the target"
AVTR_CLOSURE_MODE.CLOSURE_REQUIRED.__doc__ = "The closure is required"
AVTR_CLOSURE_MODE.HOBS.__doc__ = "The high off boresight mode"

agcls.AgTypeNameMap["AVTR_CLOSURE_MODE"] = AVTR_CLOSURE_MODE

class AVTR_INTERCEPT_MODE(IntEnum):
    """The intercept mode for the intercept strategy of the basic maneuver procedure."""
    # The target aspect mode. The aircraft will maintain an approach angle with the target.
    TARGET_ASPECT = 0
    # The lateral separation mode. The aircraft will guide to a specific distance from the target
    LATERAL_SEPARATION = 1

AVTR_INTERCEPT_MODE.TARGET_ASPECT.__doc__ = "The target aspect mode. The aircraft will maintain an approach angle with the target."
AVTR_INTERCEPT_MODE.LATERAL_SEPARATION.__doc__ = "The lateral separation mode. The aircraft will guide to a specific distance from the target"

agcls.AgTypeNameMap["AVTR_INTERCEPT_MODE"] = AVTR_INTERCEPT_MODE

class AVTR_RENDEZVOUS_STOP_CONDITION(IntEnum):
    """The stop condition options for a rendezvous formation strategy of the basic maneuver procedure."""
    # The basic stopping conditions will be used.
    STOP_NORMAL = 0
    # Stop after the target completes the current procedure.
    STOP_AFTER_TARGET_CURRENT_PROCEDURE = 1
    # Stop after the target completes the current phase.
    STOP_AFTER_TARGET_CURRENT_PHASE = 2
    # Stop when the target enters a new mode of flight.
    STOP_WHEN_TARGET_PERF_MODE_CHANGES = 3
    # Stop when the target enters a new performance phase.
    STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES = 4

AVTR_RENDEZVOUS_STOP_CONDITION.STOP_NORMAL.__doc__ = "The basic stopping conditions will be used."
AVTR_RENDEZVOUS_STOP_CONDITION.STOP_AFTER_TARGET_CURRENT_PROCEDURE.__doc__ = "Stop after the target completes the current procedure."
AVTR_RENDEZVOUS_STOP_CONDITION.STOP_AFTER_TARGET_CURRENT_PHASE.__doc__ = "Stop after the target completes the current phase."
AVTR_RENDEZVOUS_STOP_CONDITION.STOP_WHEN_TARGET_PERF_MODE_CHANGES.__doc__ = "Stop when the target enters a new mode of flight."
AVTR_RENDEZVOUS_STOP_CONDITION.STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES.__doc__ = "Stop when the target enters a new performance phase."

agcls.AgTypeNameMap["AVTR_RENDEZVOUS_STOP_CONDITION"] = AVTR_RENDEZVOUS_STOP_CONDITION

class AVTR_FORMATION_FLYER_STOP_CONDITION(IntEnum):
    """The stop condition options for a Formation Flyer procedure."""
    # Stop After FullMission.
    FORMATION_FLYER_STOP_AFTER_FULL_MISSION = 0
    # Stop After Time.
    FORMATION_FLYER_STOP_AFTER_TIME = 1
    # Stop After FuelState.
    FORMATION_FLYER_STOP_AFTER_FUEL_STATE = 2
    # Stop After DownRange.
    FORMATION_FLYER_STOP_AFTER_DOWN_RANGE = 3
    # Stop When TargetProcedure Changes.
    FORMATION_FLYER_STOP_WHEN_TARGET_PROCEDURE_CHANGES = 4
    # Stop When Target Mission Changes.
    FORMATION_FLYER_STOP_WHEN_TARGET_MISSION_CHANGES = 5
    # Stop When Target PhaseOfFlight Changes.
    FORMATION_FLYER_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES = 6
    # Stop When Target PerfMode Changes.
    FORMATION_FLYER_STOP_WHEN_TARGET_PERF_MODE_CHANGES = 7

AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_FULL_MISSION.__doc__ = "Stop After FullMission."
AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_TIME.__doc__ = "Stop After Time."
AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_FUEL_STATE.__doc__ = "Stop After FuelState."
AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_DOWN_RANGE.__doc__ = "Stop After DownRange."
AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_PROCEDURE_CHANGES.__doc__ = "Stop When TargetProcedure Changes."
AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_MISSION_CHANGES.__doc__ = "Stop When Target Mission Changes."
AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES.__doc__ = "Stop When Target PhaseOfFlight Changes."
AVTR_FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_PERF_MODE_CHANGES.__doc__ = "Stop When Target PerfMode Changes."

agcls.AgTypeNameMap["AVTR_FORMATION_FLYER_STOP_CONDITION"] = AVTR_FORMATION_FLYER_STOP_CONDITION

class AVTR_EXT_EPHEM_FLIGHT_MODE(IntEnum):
    """Flight mode enums for ExtEphem."""
    # ForwardFlightClimb.
    EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CLIMB = 0
    # ForwardFlightCruise.
    EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CRUISE = 1
    # ForwardFlightDescend.
    EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_DESCEND = 2
    # Landing.
    EXT_EPHEM_FLIGHT_MODE_LANDING = 3
    # LandingWOW.
    EXT_EPHEM_FLIGHT_MODE_LANDING_WOW = 4
    # Takeoff.
    EXT_EPHEM_FLIGHT_MODE_TAKEOFF = 5
    # TakeoffWOW.
    EXT_EPHEM_FLIGHT_MODE_TAKEOFF_WOW = 6
    # VTOLHover .
    EXT_EPHEM_FLIGHT_MODE_VTOL_HOVER = 7

AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CLIMB.__doc__ = "ForwardFlightClimb."
AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CRUISE.__doc__ = "ForwardFlightCruise."
AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_DESCEND.__doc__ = "ForwardFlightDescend."
AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_LANDING.__doc__ = "Landing."
AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_LANDING_WOW.__doc__ = "LandingWOW."
AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_TAKEOFF.__doc__ = "Takeoff."
AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_TAKEOFF_WOW.__doc__ = "TakeoffWOW."
AVTR_EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_VTOL_HOVER.__doc__ = "VTOLHover ."

agcls.AgTypeNameMap["AVTR_EXT_EPHEM_FLIGHT_MODE"] = AVTR_EXT_EPHEM_FLIGHT_MODE

class AVTR_ACCEL_PERF_MODEL_OVERRIDE(IntEnum):
    """The acceleration performance model override mode."""
    # Use the acceleration performanc model value.
    ACCEL_PERF_MODEL_VALUE = 0
    # Override the performanc model value.
    ACCEL_OVERRIDE = 1
    # Set no limit on the acceleration.
    ACCEL_NO_LIMIT = 2

AVTR_ACCEL_PERF_MODEL_OVERRIDE.ACCEL_PERF_MODEL_VALUE.__doc__ = "Use the acceleration performanc model value."
AVTR_ACCEL_PERF_MODEL_OVERRIDE.ACCEL_OVERRIDE.__doc__ = "Override the performanc model value."
AVTR_ACCEL_PERF_MODEL_OVERRIDE.ACCEL_NO_LIMIT.__doc__ = "Set no limit on the acceleration."

agcls.AgTypeNameMap["AVTR_ACCEL_PERF_MODEL_OVERRIDE"] = AVTR_ACCEL_PERF_MODEL_OVERRIDE

class AVTR_STATIONKEEPING_STOP_CONDITION(IntEnum):
    """The stop condition options for a stationkeeping strategy."""
    # The basic stopping conditions will be used.
    STOP_CONDITION_NOT_SET = 0
    # Stop after a specified number of turns.
    STOP_AFTER_TURN_COUNT = 1
    # Stop after a specified duration.
    STOP_AFTER_DURATION = 2
    # Stop at the specified time.
    STOP_AFTER_TIME = 3

AVTR_STATIONKEEPING_STOP_CONDITION.STOP_CONDITION_NOT_SET.__doc__ = "The basic stopping conditions will be used."
AVTR_STATIONKEEPING_STOP_CONDITION.STOP_AFTER_TURN_COUNT.__doc__ = "Stop after a specified number of turns."
AVTR_STATIONKEEPING_STOP_CONDITION.STOP_AFTER_DURATION.__doc__ = "Stop after a specified duration."
AVTR_STATIONKEEPING_STOP_CONDITION.STOP_AFTER_TIME.__doc__ = "Stop at the specified time."

agcls.AgTypeNameMap["AVTR_STATIONKEEPING_STOP_CONDITION"] = AVTR_STATIONKEEPING_STOP_CONDITION

class AVTR_TURN_DIRECTION(IntEnum):
    """The roll direction for an aileron roll strategy for a basic maneuver procedure."""
    # Turn left
    TURN_LEFT = 0
    # Turn right
    TURN_RIGHT = 2

AVTR_TURN_DIRECTION.TURN_LEFT.__doc__ = "Turn left"
AVTR_TURN_DIRECTION.TURN_RIGHT.__doc__ = "Turn right"

agcls.AgTypeNameMap["AVTR_TURN_DIRECTION"] = AVTR_TURN_DIRECTION

class AVTR_PROFILE_CONTROL_LIMIT(IntEnum):
    """Method to define the control limits for a profile strategy of a basic maneuver procedure."""
    # Use Accel Perf Model
    PROFILE_ACCEL_PERF_MODEL = 0
    # Specify the pitch rate
    PROFILE_PITCH_RATE = 1

AVTR_PROFILE_CONTROL_LIMIT.PROFILE_ACCEL_PERF_MODEL.__doc__ = "Use Accel Perf Model"
AVTR_PROFILE_CONTROL_LIMIT.PROFILE_PITCH_RATE.__doc__ = "Specify the pitch rate"

agcls.AgTypeNameMap["AVTR_PROFILE_CONTROL_LIMIT"] = AVTR_PROFILE_CONTROL_LIMIT

class AVTR_REL_SPEED_ALT_STOP_CONDITION(IntEnum):
    """The stop condition options for a relative speed/altitude strategy."""
    # The basic stopping conditions will be used.
    REL_SPEED_ALT_STOP_NORMAL = 0
    # Stop when the aircraft achieves the range for equal speed.
    REL_SPEED_ALT_STOP_MIN_RANGE_FOR_EQUAL_SPEED = 1
    # Stop when the aircraft achieves the range to transition speed.
    REL_SPEED_ALT_STOP_TRANSITION_SPEED_RANGE = 2
    # Stop after the target completes the current procedure.
    REL_SPEED_ALT_STOP_AFTER_TARGET_CURRENT_PROCEDURE = 3
    # Stop after the target completes the current phase.
    REL_SPEED_ALT_STOP_AFTER_TARGET_CURRENT_PHASE = 4
    # Stop when the target enters a new mode of flight.
    REL_SPEED_ALT_STOP_WHEN_TARGET_PERF_MODE_CHANGES = 5
    # Stop when the target enters a new performance phase.
    REL_SPEED_ALT_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES = 6

AVTR_REL_SPEED_ALT_STOP_CONDITION.REL_SPEED_ALT_STOP_NORMAL.__doc__ = "The basic stopping conditions will be used."
AVTR_REL_SPEED_ALT_STOP_CONDITION.REL_SPEED_ALT_STOP_MIN_RANGE_FOR_EQUAL_SPEED.__doc__ = "Stop when the aircraft achieves the range for equal speed."
AVTR_REL_SPEED_ALT_STOP_CONDITION.REL_SPEED_ALT_STOP_TRANSITION_SPEED_RANGE.__doc__ = "Stop when the aircraft achieves the range to transition speed."
AVTR_REL_SPEED_ALT_STOP_CONDITION.REL_SPEED_ALT_STOP_AFTER_TARGET_CURRENT_PROCEDURE.__doc__ = "Stop after the target completes the current procedure."
AVTR_REL_SPEED_ALT_STOP_CONDITION.REL_SPEED_ALT_STOP_AFTER_TARGET_CURRENT_PHASE.__doc__ = "Stop after the target completes the current phase."
AVTR_REL_SPEED_ALT_STOP_CONDITION.REL_SPEED_ALT_STOP_WHEN_TARGET_PERF_MODE_CHANGES.__doc__ = "Stop when the target enters a new mode of flight."
AVTR_REL_SPEED_ALT_STOP_CONDITION.REL_SPEED_ALT_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES.__doc__ = "Stop when the target enters a new performance phase."

agcls.AgTypeNameMap["AVTR_REL_SPEED_ALT_STOP_CONDITION"] = AVTR_REL_SPEED_ALT_STOP_CONDITION

class AVTR_RELATIVE_ALTITUDE_MODE(IntEnum):
    """The relative altitude mode for a relative speed/altitude strategy."""
    # Maintain the specified altitude offset from the target.
    HOLD_OFFSET_ALT = 0
    # Maintain the altitude offset at the beginning of the maneuver.
    HOLD_INIT_ALT_OFFSET = 1
    # Maintain the specified elevation angle from the target.
    HOLD_ELEVATION_ANGLE = 2
    # Maintain the elevation angle at the beginning of the maneuver.
    HOLD_INIT_ELEVATION_ANGLE = 3

AVTR_RELATIVE_ALTITUDE_MODE.HOLD_OFFSET_ALT.__doc__ = "Maintain the specified altitude offset from the target."
AVTR_RELATIVE_ALTITUDE_MODE.HOLD_INIT_ALT_OFFSET.__doc__ = "Maintain the altitude offset at the beginning of the maneuver."
AVTR_RELATIVE_ALTITUDE_MODE.HOLD_ELEVATION_ANGLE.__doc__ = "Maintain the specified elevation angle from the target."
AVTR_RELATIVE_ALTITUDE_MODE.HOLD_INIT_ELEVATION_ANGLE.__doc__ = "Maintain the elevation angle at the beginning of the maneuver."

agcls.AgTypeNameMap["AVTR_RELATIVE_ALTITUDE_MODE"] = AVTR_RELATIVE_ALTITUDE_MODE

class AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE(IntEnum):
    """The flight path angle mode mode for a bezier profile strategy."""
    # Fly to a specified altitude rate.
    FLY_TO_ALT_RATE = 0
    # Fly to a specified flight path angle.
    FLY_TO_FLIGHT_PATH_ANGLE = 1

AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE.FLY_TO_ALT_RATE.__doc__ = "Fly to a specified altitude rate."
AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE.FLY_TO_FLIGHT_PATH_ANGLE.__doc__ = "Fly to a specified flight path angle."

agcls.AgTypeNameMap["AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE"] = AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE

class AVTR_PUSH_PULL(IntEnum):
    """The option to pull up or push over for a push/pull profile strategy."""
    # Pull up.
    PULL_UP = 0
    # Push over.
    PUSH_OVER = 1

AVTR_PUSH_PULL.PULL_UP.__doc__ = "Pull up."
AVTR_PUSH_PULL.PUSH_OVER.__doc__ = "Push over."

agcls.AgTypeNameMap["AVTR_PUSH_PULL"] = AVTR_PUSH_PULL

class AVTR_ACCEL_MODE(IntEnum):
    """The acceleration/decelation option for a push/pull profile strategy."""
    # Accelerate at specified G.
    ACCEL = 0
    # Decelerate at specified G.
    DECEL = 1
    # Maintain the initial airspeed.
    MAINTAIN_SPEED = 2

AVTR_ACCEL_MODE.ACCEL.__doc__ = "Accelerate at specified G."
AVTR_ACCEL_MODE.DECEL.__doc__ = "Decelerate at specified G."
AVTR_ACCEL_MODE.MAINTAIN_SPEED.__doc__ = "Maintain the initial airspeed."

agcls.AgTypeNameMap["AVTR_ACCEL_MODE"] = AVTR_ACCEL_MODE

class AVTR_DELAY_ALT_MODE(IntEnum):
    """The altitude options for a delay procedure."""
    # Use a level off maneuver to fly to the default altitude.
    DELAY_LEVEL_OFF = 0
    # The default cruise altitude.
    DELAY_DEFAULT_CRUISE_ALT = 1
    # Override the default altitude.
    DELAY_OVERRIDE = 2

AVTR_DELAY_ALT_MODE.DELAY_LEVEL_OFF.__doc__ = "Use a level off maneuver to fly to the default altitude."
AVTR_DELAY_ALT_MODE.DELAY_DEFAULT_CRUISE_ALT.__doc__ = "The default cruise altitude."
AVTR_DELAY_ALT_MODE.DELAY_OVERRIDE.__doc__ = "Override the default altitude."

agcls.AgTypeNameMap["AVTR_DELAY_ALT_MODE"] = AVTR_DELAY_ALT_MODE

class AVTR_JOIN_EXIT_ARC_METHOD(IntEnum):
    """The options to join or exit an arc."""
    # The aircraft begins/ends the procedure on a course away from the site.
    JOIN_EXIT_OUTBOUND = 0
    # The aircraft begins/ends the procedure at the start bearing.
    JOIN_EXIT_ON = 1
    # The aircraft begins/ends on a course towards the site.
    JOIN_EXIT_INBOUND = 2

AVTR_JOIN_EXIT_ARC_METHOD.JOIN_EXIT_OUTBOUND.__doc__ = "The aircraft begins/ends the procedure on a course away from the site."
AVTR_JOIN_EXIT_ARC_METHOD.JOIN_EXIT_ON.__doc__ = "The aircraft begins/ends the procedure at the start bearing."
AVTR_JOIN_EXIT_ARC_METHOD.JOIN_EXIT_INBOUND.__doc__ = "The aircraft begins/ends on a course towards the site."

agcls.AgTypeNameMap["AVTR_JOIN_EXIT_ARC_METHOD"] = AVTR_JOIN_EXIT_ARC_METHOD

class AVTR_FLIGHT_LINE_PROC_TYPE(IntEnum):
    """The procedure methodology used to calculate the flight line."""
    # An enroute procedure type.
    PROC_TYPE_ENROUTE = 0
    # A basic point to point procedure type.
    PROC_TYPE_BASIC_POINT_TO_POINT = 1
    # A terrain follow procedure type.
    PROC_TYPE_TERRAIN_FOLLOW = 2

AVTR_FLIGHT_LINE_PROC_TYPE.PROC_TYPE_ENROUTE.__doc__ = "An enroute procedure type."
AVTR_FLIGHT_LINE_PROC_TYPE.PROC_TYPE_BASIC_POINT_TO_POINT.__doc__ = "A basic point to point procedure type."
AVTR_FLIGHT_LINE_PROC_TYPE.PROC_TYPE_TERRAIN_FOLLOW.__doc__ = "A terrain follow procedure type."

agcls.AgTypeNameMap["AVTR_FLIGHT_LINE_PROC_TYPE"] = AVTR_FLIGHT_LINE_PROC_TYPE

class AVTR_TRANSITION_TO_HOVER_MODE(IntEnum):
    """The type of hover to transition to."""
    # Transition to a full stop hover.
    FULL_STOP = 0
    # Transition to a hover with a constant translation rate.
    TRANSLATION_ONLY = 1
    # Transition to a hover with a constant translation and altitude rate.
    TRANSLATION_AND_ALTITUDE = 2

AVTR_TRANSITION_TO_HOVER_MODE.FULL_STOP.__doc__ = "Transition to a full stop hover."
AVTR_TRANSITION_TO_HOVER_MODE.TRANSLATION_ONLY.__doc__ = "Transition to a hover with a constant translation rate."
AVTR_TRANSITION_TO_HOVER_MODE.TRANSLATION_AND_ALTITUDE.__doc__ = "Transition to a hover with a constant translation and altitude rate."

agcls.AgTypeNameMap["AVTR_TRANSITION_TO_HOVER_MODE"] = AVTR_TRANSITION_TO_HOVER_MODE

class AVTR_VTOL_RATE_MODE(IntEnum):
    """The rate mode for the VTOL procedure."""
    # The rate during the procedure will be maintained.
    HALT_AUTOMATIC = 0
    # The rate will be set to zero.
    ALWAYS_STOP = 1

AVTR_VTOL_RATE_MODE.HALT_AUTOMATIC.__doc__ = "The rate during the procedure will be maintained."
AVTR_VTOL_RATE_MODE.ALWAYS_STOP.__doc__ = "The rate will be set to zero."

agcls.AgTypeNameMap["AVTR_VTOL_RATE_MODE"] = AVTR_VTOL_RATE_MODE

class AVTR_HOLDING_PROFILE_MODE(IntEnum):
    """How the aircraft will perform during the holding pattern with respect to airspeed and altitude."""
    # The aircraft will fly the pattern at the speed at which it arrived at the entry point.
    STK8_COMPATIBLE = 0
    # The aircraft will level off and fly at the cruise speed
    LEVEL_OFF_CRUISE_SPEED = 1
    # The aircraft will climb or descend to the specified altitude.
    CLIMB_DESCENT_ON_STATION = 2

AVTR_HOLDING_PROFILE_MODE.STK8_COMPATIBLE.__doc__ = "The aircraft will fly the pattern at the speed at which it arrived at the entry point."
AVTR_HOLDING_PROFILE_MODE.LEVEL_OFF_CRUISE_SPEED.__doc__ = "The aircraft will level off and fly at the cruise speed"
AVTR_HOLDING_PROFILE_MODE.CLIMB_DESCENT_ON_STATION.__doc__ = "The aircraft will climb or descend to the specified altitude."

agcls.AgTypeNameMap["AVTR_HOLDING_PROFILE_MODE"] = AVTR_HOLDING_PROFILE_MODE

class AVTR_HOLDING_DIRECTION(IntEnum):
    """The turn direction for the aircraft to enter the holding pattern."""
    # Turn left on the way inbound to the site.
    INBOUND_LEFT_TURN = 0
    # Turn right on the way inbound to the site.
    INBOUND_RIGHT_TURN = 1
    # Turn left on the way outbound from the site.
    OUTBOUND_LEFT_TURN = 2
    # Turn right on the way outbound from the site.
    OUTBOUND_RIGHT_TURN = 3

AVTR_HOLDING_DIRECTION.INBOUND_LEFT_TURN.__doc__ = "Turn left on the way inbound to the site."
AVTR_HOLDING_DIRECTION.INBOUND_RIGHT_TURN.__doc__ = "Turn right on the way inbound to the site."
AVTR_HOLDING_DIRECTION.OUTBOUND_LEFT_TURN.__doc__ = "Turn left on the way outbound from the site."
AVTR_HOLDING_DIRECTION.OUTBOUND_RIGHT_TURN.__doc__ = "Turn right on the way outbound from the site."

agcls.AgTypeNameMap["AVTR_HOLDING_DIRECTION"] = AVTR_HOLDING_DIRECTION

class AVTR_HOLD_REFUEL_DUMP_MODE(IntEnum):
    """Defines when the aircraft will leave the holding pattern after it has completed refueling or dumping fuel."""
    # Turn left on the way inbound to the site.
    FULL_NUMER_OF_TURNS = 0
    # Turn right on the way inbound to the site.
    EXIT_AT_END_OF_TURN = 1
    # Turn left on the way outbound from the site.
    IMMEDIATE_EXIT = 2

AVTR_HOLD_REFUEL_DUMP_MODE.FULL_NUMER_OF_TURNS.__doc__ = "Turn left on the way inbound to the site."
AVTR_HOLD_REFUEL_DUMP_MODE.EXIT_AT_END_OF_TURN.__doc__ = "Turn right on the way inbound to the site."
AVTR_HOLD_REFUEL_DUMP_MODE.IMMEDIATE_EXIT.__doc__ = "Turn left on the way outbound from the site."

agcls.AgTypeNameMap["AVTR_HOLD_REFUEL_DUMP_MODE"] = AVTR_HOLD_REFUEL_DUMP_MODE

class AVTR_HOLDING_ENTRY_MANEUVER(IntEnum):
    """Defines how the aircraft will enter the holding pattern."""
    # The aircraft will enter the holding pattern at the normal holding point.
    HOLD_ENTRY_NO_MANEUVER = 0
    # The aircraft will enter the holding pattern using a standard entry maneuvers defined in the FAA Instrument Flying Handbook
    USE_STANDARD_ENTRY_TURNS = 1
    # The aircraft will enter the holding pattern at an alternate entry point.
    USE_ALTERNATE_ENTRY_POINTS = 2

AVTR_HOLDING_ENTRY_MANEUVER.HOLD_ENTRY_NO_MANEUVER.__doc__ = "The aircraft will enter the holding pattern at the normal holding point."
AVTR_HOLDING_ENTRY_MANEUVER.USE_STANDARD_ENTRY_TURNS.__doc__ = "The aircraft will enter the holding pattern using a standard entry maneuvers defined in the FAA Instrument Flying Handbook"
AVTR_HOLDING_ENTRY_MANEUVER.USE_ALTERNATE_ENTRY_POINTS.__doc__ = "The aircraft will enter the holding pattern at an alternate entry point."

agcls.AgTypeNameMap["AVTR_HOLDING_ENTRY_MANEUVER"] = AVTR_HOLDING_ENTRY_MANEUVER

class AVTR_VTOL_TRANSITION_MODE(IntEnum):
    """The mode to specify the course of the transition maneuver."""
    # Specify a heading relative to the previous procedure.
    TRANSITION_RELATIVE_HDG = 0
    # Specify an absolute heading.
    TRANSITION_ABSOLUTE_HDG = 1
    # Transition into the wind direction.
    TRANSITION_INTO_WIND = 2

AVTR_VTOL_TRANSITION_MODE.TRANSITION_RELATIVE_HDG.__doc__ = "Specify a heading relative to the previous procedure."
AVTR_VTOL_TRANSITION_MODE.TRANSITION_ABSOLUTE_HDG.__doc__ = "Specify an absolute heading."
AVTR_VTOL_TRANSITION_MODE.TRANSITION_INTO_WIND.__doc__ = "Transition into the wind direction."

agcls.AgTypeNameMap["AVTR_VTOL_TRANSITION_MODE"] = AVTR_VTOL_TRANSITION_MODE

class AVTR_VTOL_FINAL_HEADING_MODE(IntEnum):
    """The mode to specify the heading at the end of the maneuver."""
    # Specify a heading relative to the previous procedure.
    FINAL_HEADING_RELATIVE = 0
    # Specify an absolute heading.
    FINAL_HEADING_ABSOLUTE = 1
    # The aircraft have the same heading as the translation bearing.
    FINAL_HEADING_TRANSLATION_COURSE = 2

AVTR_VTOL_FINAL_HEADING_MODE.FINAL_HEADING_RELATIVE.__doc__ = "Specify a heading relative to the previous procedure."
AVTR_VTOL_FINAL_HEADING_MODE.FINAL_HEADING_ABSOLUTE.__doc__ = "Specify an absolute heading."
AVTR_VTOL_FINAL_HEADING_MODE.FINAL_HEADING_TRANSLATION_COURSE.__doc__ = "The aircraft have the same heading as the translation bearing."

agcls.AgTypeNameMap["AVTR_VTOL_FINAL_HEADING_MODE"] = AVTR_VTOL_FINAL_HEADING_MODE

class AVTR_VTOL_TRANSLATION_MODE(IntEnum):
    """The mode to specify the translation of the VTOL maneuver."""
    # The aircraft will translate on a specific bearing and range.
    SET_BEARING_AND_RANGE = 0
    # The aircraft will come to a complete stop.
    COME_TO_STOP = 1
    # The aircraft will continue to translate with the same rate and direction as it began the procedure.
    MAINTAIN_RATE = 2

AVTR_VTOL_TRANSLATION_MODE.SET_BEARING_AND_RANGE.__doc__ = "The aircraft will translate on a specific bearing and range."
AVTR_VTOL_TRANSLATION_MODE.COME_TO_STOP.__doc__ = "The aircraft will come to a complete stop."
AVTR_VTOL_TRANSLATION_MODE.MAINTAIN_RATE.__doc__ = "The aircraft will continue to translate with the same rate and direction as it began the procedure."

agcls.AgTypeNameMap["AVTR_VTOL_TRANSLATION_MODE"] = AVTR_VTOL_TRANSLATION_MODE

class AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE(IntEnum):
    """The mode to specify the final course of the VTOL maneuver."""
    # The aircraft will translate directly along the specified bearing and range.
    TRANSLATE_DIRECT = 0
    # The aircraft will translate along a bisecting line between the inbound and outbound course.
    BISECT_INBOUND_OUTBOUND = 1
    # The aircraft will evaluate the procedure ahead to determine the translation bearing and rate.
    ANTICIPATE_NEXT_TRANSLATION = 2

AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE.TRANSLATE_DIRECT.__doc__ = "The aircraft will translate directly along the specified bearing and range."
AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE.BISECT_INBOUND_OUTBOUND.__doc__ = "The aircraft will translate along a bisecting line between the inbound and outbound course."
AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE.ANTICIPATE_NEXT_TRANSLATION.__doc__ = "The aircraft will evaluate the procedure ahead to determine the translation bearing and rate."

agcls.AgTypeNameMap["AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE"] = AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE

class AVTR_HOVER_MODE(IntEnum):
    """The hover mode."""
    # Hover in place for a fixed time.
    HOVER_MODE_FIXED_TIME = 0
    # Perform a hovering maneuver.
    HOVER_MODE_MANEUVER = 1

AVTR_HOVER_MODE.HOVER_MODE_FIXED_TIME.__doc__ = "Hover in place for a fixed time."
AVTR_HOVER_MODE.HOVER_MODE_MANEUVER.__doc__ = "Perform a hovering maneuver."

agcls.AgTypeNameMap["AVTR_HOVER_MODE"] = AVTR_HOVER_MODE

class AVTR_VTOL_HEADING_MODE(IntEnum):
    """The heading mode for the hover maneuver."""
    # The aircraft's heading is independent of its translation.
    HEADING_INDEPENDENT = 0
    # The aircraft will align its heading with the translation course.
    HEADING_ALIGN_TRANSLATION_COURSE = 1
    # The aircraft will set its heading into the wind.
    HEADING_INTO_WIND = 2

AVTR_VTOL_HEADING_MODE.HEADING_INDEPENDENT.__doc__ = "The aircraft's heading is independent of its translation."
AVTR_VTOL_HEADING_MODE.HEADING_ALIGN_TRANSLATION_COURSE.__doc__ = "The aircraft will align its heading with the translation course."
AVTR_VTOL_HEADING_MODE.HEADING_INTO_WIND.__doc__ = "The aircraft will set its heading into the wind."

agcls.AgTypeNameMap["AVTR_VTOL_HEADING_MODE"] = AVTR_VTOL_HEADING_MODE

class AVTR_VERT_LANDING_MODE(IntEnum):
    """The heading mode for a vertical landing maneuver."""
    # The aircraft's heading is independent of its translation.
    VERT_LANDING_INDEPENDENT = 0
    # The aircraft will align its heading with the translation course.
    VERT_LANDING_ALIGN_TRANSLATION_COURSE = 1
    # The aircraft will set its heading into the wind.
    VERT_LANDING_INTO_WIND = 2
    # The aircraft will align its heading with the translation course  will achieve the specified heading upon arriving.
    VERT_LANDING_ALIGN_TRANSLATION_COURSE_OVERRIDE = 3

AVTR_VERT_LANDING_MODE.VERT_LANDING_INDEPENDENT.__doc__ = "The aircraft's heading is independent of its translation."
AVTR_VERT_LANDING_MODE.VERT_LANDING_ALIGN_TRANSLATION_COURSE.__doc__ = "The aircraft will align its heading with the translation course."
AVTR_VERT_LANDING_MODE.VERT_LANDING_INTO_WIND.__doc__ = "The aircraft will set its heading into the wind."
AVTR_VERT_LANDING_MODE.VERT_LANDING_ALIGN_TRANSLATION_COURSE_OVERRIDE.__doc__ = "The aircraft will align its heading with the translation course  will achieve the specified heading upon arriving."

agcls.AgTypeNameMap["AVTR_VERT_LANDING_MODE"] = AVTR_VERT_LANDING_MODE

class AVTR_LAUNCH_ATTITUDE_MODE(IntEnum):
    """The attitude mode for the launch procedure."""
    # The aircraft's attitude is aligned with the specified direction vector.
    LAUNCH_ALIGN_DIRECTION_VECTOR = 0
    # The aircraft will maintain the parent vehicle's attiude at the time of launch.
    LAUNCH_HOLD_PARENT_ATTITUDE = 1
    # The aircraft launches in level flight
    LAUNCH_VTOL = 2

AVTR_LAUNCH_ATTITUDE_MODE.LAUNCH_ALIGN_DIRECTION_VECTOR.__doc__ = "The aircraft's attitude is aligned with the specified direction vector."
AVTR_LAUNCH_ATTITUDE_MODE.LAUNCH_HOLD_PARENT_ATTITUDE.__doc__ = "The aircraft will maintain the parent vehicle's attiude at the time of launch."
AVTR_LAUNCH_ATTITUDE_MODE.LAUNCH_VTOL.__doc__ = "The aircraft launches in level flight"

agcls.AgTypeNameMap["AVTR_LAUNCH_ATTITUDE_MODE"] = AVTR_LAUNCH_ATTITUDE_MODE

class AVTR_FUEL_FLOW_TYPE(IntEnum):
    """The fuel flow type to use for the procedure."""
    # Fuel flow defined for the current Takeoff performance model.
    FUEL_FLOW_TAKEOFF = 0
    # Fuel flow defined for the current Cruise performance model.
    FUEL_FLOW_CRUISE = 1
    # Fuel flow defined for the current Landing performance model.
    FUEL_FLOW_LANDING = 2
    # Fuel flow defined for the current VTOL performance model.
    FUEL_FLOW_VTOL = 3
    # Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model.
    FUEL_FLOW_AERO_PROP = 4
    # Fuel flow defined manually.
    FUEL_FLOW_OVERRIDE = 5

AVTR_FUEL_FLOW_TYPE.FUEL_FLOW_TAKEOFF.__doc__ = "Fuel flow defined for the current Takeoff performance model."
AVTR_FUEL_FLOW_TYPE.FUEL_FLOW_CRUISE.__doc__ = "Fuel flow defined for the current Cruise performance model."
AVTR_FUEL_FLOW_TYPE.FUEL_FLOW_LANDING.__doc__ = "Fuel flow defined for the current Landing performance model."
AVTR_FUEL_FLOW_TYPE.FUEL_FLOW_VTOL.__doc__ = "Fuel flow defined for the current VTOL performance model."
AVTR_FUEL_FLOW_TYPE.FUEL_FLOW_AERO_PROP.__doc__ = "Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model."
AVTR_FUEL_FLOW_TYPE.FUEL_FLOW_OVERRIDE.__doc__ = "Fuel flow defined manually."

agcls.AgTypeNameMap["AVTR_FUEL_FLOW_TYPE"] = AVTR_FUEL_FLOW_TYPE

class AVTR_LINE_ORIENTATION(IntEnum):
    """The orientation for a parallel flight line procedure."""
    # Left of the previous flight line.
    FLIGHT_LINE_TO_LEFT = 0
    # Right of the previous flight line.
    FLIGHT_LINE_TO_RIGHT = 1

AVTR_LINE_ORIENTATION.FLIGHT_LINE_TO_LEFT.__doc__ = "Left of the previous flight line."
AVTR_LINE_ORIENTATION.FLIGHT_LINE_TO_RIGHT.__doc__ = "Right of the previous flight line."

agcls.AgTypeNameMap["AVTR_LINE_ORIENTATION"] = AVTR_LINE_ORIENTATION

class AVTR_REL_ABS_BEARING(IntEnum):
    """The options for a bearing that can be relative or absolute."""
    # A bearing relative to the previous course.
    RELATIVE_BEARING = 0
    # A bearing using true north.
    TRUE_BEARING = 1
    # A bearing using magnetic north.
    MAGNETIC_BEARING = 2

AVTR_REL_ABS_BEARING.RELATIVE_BEARING.__doc__ = "A bearing relative to the previous course."
AVTR_REL_ABS_BEARING.TRUE_BEARING.__doc__ = "A bearing using true north."
AVTR_REL_ABS_BEARING.MAGNETIC_BEARING.__doc__ = "A bearing using magnetic north."

agcls.AgTypeNameMap["AVTR_REL_ABS_BEARING"] = AVTR_REL_ABS_BEARING

class AVTR_BASIC_FIXED_WING_PROP_MODE(IntEnum):
    """The option to specify the thrust (jet engines) or power (propellers)."""
    # Jet - Specify net thrust.
    SPECIFY_THRUST = 0
    # Propeller - Specify net power.
    SPECIFY_POWER = 1

AVTR_BASIC_FIXED_WING_PROP_MODE.SPECIFY_THRUST.__doc__ = "Jet - Specify net thrust."
AVTR_BASIC_FIXED_WING_PROP_MODE.SPECIFY_POWER.__doc__ = "Propeller - Specify net power."

agcls.AgTypeNameMap["AVTR_BASIC_FIXED_WING_PROP_MODE"] = AVTR_BASIC_FIXED_WING_PROP_MODE

class AVTR_CLIMB_SPEED_TYPE(IntEnum):
    """The mode to calculate the aircraft's airspeed while climbing for an advanced climb performance model."""
    # The speed at which the aircraft's rate of climb is maximized.
    CLIMB_SPEED_BEST_RATE = 0
    # The speed at which the aircraft will gain the most altitude over downrange distance.
    CLIMB_SPEED_BEST_ANGLE = 1
    # The speed at which the aircraft's fuel consumption is minimized.
    CLIMB_SPEED_MIN_FUEL = 2
    # Manually specify the speed.
    CLIMB_SPEED_OVERRIDE = 3

AVTR_CLIMB_SPEED_TYPE.CLIMB_SPEED_BEST_RATE.__doc__ = "The speed at which the aircraft's rate of climb is maximized."
AVTR_CLIMB_SPEED_TYPE.CLIMB_SPEED_BEST_ANGLE.__doc__ = "The speed at which the aircraft will gain the most altitude over downrange distance."
AVTR_CLIMB_SPEED_TYPE.CLIMB_SPEED_MIN_FUEL.__doc__ = "The speed at which the aircraft's fuel consumption is minimized."
AVTR_CLIMB_SPEED_TYPE.CLIMB_SPEED_OVERRIDE.__doc__ = "Manually specify the speed."

agcls.AgTypeNameMap["AVTR_CLIMB_SPEED_TYPE"] = AVTR_CLIMB_SPEED_TYPE

class AVTR_CRUISE_MAX_PERF_SPEED_TYPE(IntEnum):
    """The method for defining the maximum performance airspeed of the aircraft for an advanced cruise model."""
    # The lowest speed at which the aircraft can generate lift while pulling maximum Gs.
    CORNER_SPEED = 0
    # The maximum specific excess power without afterburning.
    MAX_PS_DRY_THRUST = 1
    # The maximum specific excess power while afterburning.
    MAX_PS_AFTERBURNER = 2
    # The maximum speed without afterburning.
    MAX_SPEED_DRY_THRUST = 3
    # The speed which maximizes the aircraft range while afterburning.
    MAX_RANGE_AFTERBURNER = 4

AVTR_CRUISE_MAX_PERF_SPEED_TYPE.CORNER_SPEED.__doc__ = "The lowest speed at which the aircraft can generate lift while pulling maximum Gs."
AVTR_CRUISE_MAX_PERF_SPEED_TYPE.MAX_PS_DRY_THRUST.__doc__ = "The maximum specific excess power without afterburning."
AVTR_CRUISE_MAX_PERF_SPEED_TYPE.MAX_PS_AFTERBURNER.__doc__ = "The maximum specific excess power while afterburning."
AVTR_CRUISE_MAX_PERF_SPEED_TYPE.MAX_SPEED_DRY_THRUST.__doc__ = "The maximum speed without afterburning."
AVTR_CRUISE_MAX_PERF_SPEED_TYPE.MAX_RANGE_AFTERBURNER.__doc__ = "The speed which maximizes the aircraft range while afterburning."

agcls.AgTypeNameMap["AVTR_CRUISE_MAX_PERF_SPEED_TYPE"] = AVTR_CRUISE_MAX_PERF_SPEED_TYPE

class AVTR_DESCENT_SPEED_TYPE(IntEnum):
    """The method for calculating the aircraft's airspeed while descending."""
    # A variable airspeed that maximizes the distance that the aircraft can fly.
    DESCENT_MAX_RANGE_CRUISE = 0
    # The speed at which the aircraft's glide ratio is maximized.
    DESCENT_MAX_GLIDE_RATIO = 1
    # The speed at which the aircraft's rate of descent is minimized.
    DESCENT_MIN_SINK_RATE = 2
    # A speed relative to the aircraft's stall speed..
    DESCENT_STALL_SPEED_RATIO = 3
    # Manually define the airspeed.
    DESCENT_SPEED_OVERRIDE = 4

AVTR_DESCENT_SPEED_TYPE.DESCENT_MAX_RANGE_CRUISE.__doc__ = "A variable airspeed that maximizes the distance that the aircraft can fly."
AVTR_DESCENT_SPEED_TYPE.DESCENT_MAX_GLIDE_RATIO.__doc__ = "The speed at which the aircraft's glide ratio is maximized."
AVTR_DESCENT_SPEED_TYPE.DESCENT_MIN_SINK_RATE.__doc__ = "The speed at which the aircraft's rate of descent is minimized."
AVTR_DESCENT_SPEED_TYPE.DESCENT_STALL_SPEED_RATIO.__doc__ = "A speed relative to the aircraft's stall speed.."
AVTR_DESCENT_SPEED_TYPE.DESCENT_SPEED_OVERRIDE.__doc__ = "Manually define the airspeed."

agcls.AgTypeNameMap["AVTR_DESCENT_SPEED_TYPE"] = AVTR_DESCENT_SPEED_TYPE

class AVTR_TAKEOFF_LANDING_SPEED_MODE(IntEnum):
    """The method for calculating the aircraft's speed upon leaving the ground or at wheels down."""
    # A multiple of the aircraft's stall speed.
    TAKEOFF_LANDING_STALL_SPEED_RATIO = 0
    # The speed needed to achieve lift at the specified Angle of Attack.
    TAKEOFF_LANDING_ANGLE_OF_ATTACK = 1

AVTR_TAKEOFF_LANDING_SPEED_MODE.TAKEOFF_LANDING_STALL_SPEED_RATIO.__doc__ = "A multiple of the aircraft's stall speed."
AVTR_TAKEOFF_LANDING_SPEED_MODE.TAKEOFF_LANDING_ANGLE_OF_ATTACK.__doc__ = "The speed needed to achieve lift at the specified Angle of Attack."

agcls.AgTypeNameMap["AVTR_TAKEOFF_LANDING_SPEED_MODE"] = AVTR_TAKEOFF_LANDING_SPEED_MODE

class AVTR_DEPARTURE_SPEED_MODE(IntEnum):
    """The method for calculating the aircraft's airspeed upon leaving the ground."""
    # The aircraft will fly at the max climb angle.
    MAX_CLIMB_ANGLE = 0
    # The aircraft will fly at the max climb rate.
    MAX_CLIMB_RATE = 1
    # The aircraft will fly at the airspeed defined in the Climb performance model.
    USE_CLIMB_MODEL = 2

AVTR_DEPARTURE_SPEED_MODE.MAX_CLIMB_ANGLE.__doc__ = "The aircraft will fly at the max climb angle."
AVTR_DEPARTURE_SPEED_MODE.MAX_CLIMB_RATE.__doc__ = "The aircraft will fly at the max climb rate."
AVTR_DEPARTURE_SPEED_MODE.USE_CLIMB_MODEL.__doc__ = "The aircraft will fly at the airspeed defined in the Climb performance model."

agcls.AgTypeNameMap["AVTR_DEPARTURE_SPEED_MODE"] = AVTR_DEPARTURE_SPEED_MODE

class AVTR_ADV_FIXED_WING_AERO_STRATEGY(IntEnum):
    """The aerodynamic strategy for the Advanced Fixed Wing Tool."""
    # Define the aerodynamics using an external .aero file.
    EXTERNAL_AERO_FILE = 0
    # Define the aerodynamics using a model derived from first principles that is valid for the full speed range of high speed aircraft.
    SUB_SUPER_HYPER_AERO = 1
    # Define the aerodynamics for an aircraft that generally travels at subsonic speeds.
    SUBSONIC_AERO = 2
    # Define the aerodynamics for an aircraft that generally travels at supersonic speeds.
    SUPERSONIC_AERO = 3

AVTR_ADV_FIXED_WING_AERO_STRATEGY.EXTERNAL_AERO_FILE.__doc__ = "Define the aerodynamics using an external .aero file."
AVTR_ADV_FIXED_WING_AERO_STRATEGY.SUB_SUPER_HYPER_AERO.__doc__ = "Define the aerodynamics using a model derived from first principles that is valid for the full speed range of high speed aircraft."
AVTR_ADV_FIXED_WING_AERO_STRATEGY.SUBSONIC_AERO.__doc__ = "Define the aerodynamics for an aircraft that generally travels at subsonic speeds."
AVTR_ADV_FIXED_WING_AERO_STRATEGY.SUPERSONIC_AERO.__doc__ = "Define the aerodynamics for an aircraft that generally travels at supersonic speeds."

agcls.AgTypeNameMap["AVTR_ADV_FIXED_WING_AERO_STRATEGY"] = AVTR_ADV_FIXED_WING_AERO_STRATEGY

class AVTR_ADV_FIXED_WING_GEOMETRY(IntEnum):
    """The method to define the wing geometry of an aircraft in the Advanced Fixed Wing Tool."""
    # Define the static properties of an immovable wing.
    BASIC_GEOMETRY = 0
    # Define the minimum and maximum properties of an adjustable wing.
    VARIABLE_GEOMETRY = 1

AVTR_ADV_FIXED_WING_GEOMETRY.BASIC_GEOMETRY.__doc__ = "Define the static properties of an immovable wing."
AVTR_ADV_FIXED_WING_GEOMETRY.VARIABLE_GEOMETRY.__doc__ = "Define the minimum and maximum properties of an adjustable wing."

agcls.AgTypeNameMap["AVTR_ADV_FIXED_WING_GEOMETRY"] = AVTR_ADV_FIXED_WING_GEOMETRY

class AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY(IntEnum):
    """The powerplant strategy for the Advanced Fixed Wing Tool."""
    # An electric engine.
    ELECTRIC_POWERPLANT = 0
    # Define the powerplant using an external .prop file.
    EXTERNAL_PROP_FILE = 1
    # A piston, or reciprocating, engine.
    PISTON_POWERPLANT = 2
    # A thermodynamic model that includes turbine, ramjet, and scramjet performance modes.
    SUB_SUPER_HYPER_POWERPLANT = 3
    # A thermodynamic model of a dual-spool turbofan engine that has an afterburner.
    TURBOFAN_BASIC_AB = 4
    # An empirical model for a turbofan engine that produces significantly more fan thrust than jet thrust.
    TURBOFAN_HIGH_BYPASS = 5
    # An empirical model for a turbofan engine that produces significantly more jet thrust than fan thrust.
    TURBOFAN_LOW_BYPASS = 6
    # An empirical model for a turbofan engine that has an afterburner and produces significantly more jet thrust than fan thrust.
    TURBOFAN_LOW_BYPASS_AFTERBURNING = 7
    # An empirical model that models a turbojet engine that has an afterburner.
    TURBOJET_AFTERBURNING = 8
    # An empirical model that models a turbojet engine.
    TURBOJET_BASIC_AB = 9
    # An empirical model that models a turbojet engine.
    TURBOJET = 10
    # An empirical model that models a turboprop engine.
    TURBOPROP = 11

AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.ELECTRIC_POWERPLANT.__doc__ = "An electric engine."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.EXTERNAL_PROP_FILE.__doc__ = "Define the powerplant using an external .prop file."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.PISTON_POWERPLANT.__doc__ = "A piston, or reciprocating, engine."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.SUB_SUPER_HYPER_POWERPLANT.__doc__ = "A thermodynamic model that includes turbine, ramjet, and scramjet performance modes."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_BASIC_AB.__doc__ = "A thermodynamic model of a dual-spool turbofan engine that has an afterburner."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_HIGH_BYPASS.__doc__ = "An empirical model for a turbofan engine that produces significantly more fan thrust than jet thrust."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_LOW_BYPASS.__doc__ = "An empirical model for a turbofan engine that produces significantly more jet thrust than fan thrust."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_LOW_BYPASS_AFTERBURNING.__doc__ = "An empirical model for a turbofan engine that has an afterburner and produces significantly more jet thrust than fan thrust."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOJET_AFTERBURNING.__doc__ = "An empirical model that models a turbojet engine that has an afterburner."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOJET_BASIC_AB.__doc__ = "An empirical model that models a turbojet engine."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOJET.__doc__ = "An empirical model that models a turbojet engine."
AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOPROP.__doc__ = "An empirical model that models a turboprop engine."

agcls.AgTypeNameMap["AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY"] = AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY

class AVTR_MISSILE_AERO_STRATEGY(IntEnum):
    """The aerodynamic strategy used to compute lift, drag, angle of attack, sideslip and intermediate / derived values."""
    # Simple aerodynamics.
    MISSILE_AERO_SIMPLE = 0
    # External file aerodynamics.
    MISSILE_AERO_EXTERNAL_FILE = 1
    # Advanced missile aerodynamics.
    MISSILE_AERO_ADVANCED = 2

AVTR_MISSILE_AERO_STRATEGY.MISSILE_AERO_SIMPLE.__doc__ = "Simple aerodynamics."
AVTR_MISSILE_AERO_STRATEGY.MISSILE_AERO_EXTERNAL_FILE.__doc__ = "External file aerodynamics."
AVTR_MISSILE_AERO_STRATEGY.MISSILE_AERO_ADVANCED.__doc__ = "Advanced missile aerodynamics."

agcls.AgTypeNameMap["AVTR_MISSILE_AERO_STRATEGY"] = AVTR_MISSILE_AERO_STRATEGY

class AVTR_MISSILE_PROP_STRATEGY(IntEnum):
    """The propulsion strategy used to compute thrust and throttle setting."""
    # Simple propulsion.
    MISSILE_PROP_SIMPLE = 0
    # External file propulsion.
    MISSILE_PROP_EXTERNAL_FILE = 1
    # Ramjet propulsion.
    MISSILE_PROP_RAMJET = 2
    # Rocket propulsion.
    MISSILE_PROP_ROCKET = 3
    # Turbojet propulsion.
    MISSILE_PROP_TURBOJET = 4

AVTR_MISSILE_PROP_STRATEGY.MISSILE_PROP_SIMPLE.__doc__ = "Simple propulsion."
AVTR_MISSILE_PROP_STRATEGY.MISSILE_PROP_EXTERNAL_FILE.__doc__ = "External file propulsion."
AVTR_MISSILE_PROP_STRATEGY.MISSILE_PROP_RAMJET.__doc__ = "Ramjet propulsion."
AVTR_MISSILE_PROP_STRATEGY.MISSILE_PROP_ROCKET.__doc__ = "Rocket propulsion."
AVTR_MISSILE_PROP_STRATEGY.MISSILE_PROP_TURBOJET.__doc__ = "Turbojet propulsion."

agcls.AgTypeNameMap["AVTR_MISSILE_PROP_STRATEGY"] = AVTR_MISSILE_PROP_STRATEGY

class AVTR_ROTORCRAFT_POWERPLANT_TYPE(IntEnum):
    """The powerplant type for a rotorcraft."""
    # Electric propulsion.
    ROTORCRAFT_ELECTRIC = 0
    # Turboshaft propulsion.
    ROTORCRAFT_TURBOSHAFT = 1
    # Piston propulsion.
    ROTORCRAFT_PISTON = 2

AVTR_ROTORCRAFT_POWERPLANT_TYPE.ROTORCRAFT_ELECTRIC.__doc__ = "Electric propulsion."
AVTR_ROTORCRAFT_POWERPLANT_TYPE.ROTORCRAFT_TURBOSHAFT.__doc__ = "Turboshaft propulsion."
AVTR_ROTORCRAFT_POWERPLANT_TYPE.ROTORCRAFT_PISTON.__doc__ = "Piston propulsion."

agcls.AgTypeNameMap["AVTR_ROTORCRAFT_POWERPLANT_TYPE"] = AVTR_ROTORCRAFT_POWERPLANT_TYPE

class AVTR_MINIMIZE_SITE_PROC_TIME_DIFF(IntEnum):
    """Options for minimizing the time difference between the procedure and site times."""
    # Do not converge the procedure and site times.
    MINIMIZE_TIME_DIFFERENCE_OFF = 0
    # Always recalculate.
    MINIMIZE_TIME_DIFFERENCE_ALWAYS = 1
    # Only recalculate when updated.
    MINIMIZE_TIME_DIFFERENCE_NEXT_UPDATE = 2

AVTR_MINIMIZE_SITE_PROC_TIME_DIFF.MINIMIZE_TIME_DIFFERENCE_OFF.__doc__ = "Do not converge the procedure and site times."
AVTR_MINIMIZE_SITE_PROC_TIME_DIFF.MINIMIZE_TIME_DIFFERENCE_ALWAYS.__doc__ = "Always recalculate."
AVTR_MINIMIZE_SITE_PROC_TIME_DIFF.MINIMIZE_TIME_DIFFERENCE_NEXT_UPDATE.__doc__ = "Only recalculate when updated."

agcls.AgTypeNameMap["AVTR_MINIMIZE_SITE_PROC_TIME_DIFF"] = AVTR_MINIMIZE_SITE_PROC_TIME_DIFF

class AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE(IntEnum):
    """The options to offset the site location relative to the STK Object."""
    # No offset.
    OFFSET_NONE = 0
    # Bearing/Range (relative to North).
    OFFSET_BEARING_RANGE = 1
    # VGT Point.
    OFFSET_VGT_POINT = 2
    # Bearing/Reange relative to Vehicle course.
    OFFSET_RELATIVE_BEARING_RANGE = 3

AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_NONE.__doc__ = "No offset."
AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_BEARING_RANGE.__doc__ = "Bearing/Range (relative to North)."
AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_VGT_POINT.__doc__ = "VGT Point."
AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_RELATIVE_BEARING_RANGE.__doc__ = "Bearing/Reange relative to Vehicle course."

agcls.AgTypeNameMap["AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE"] = AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE

class AVTR_SEARCH_PATTERN_COURSE_MODE(IntEnum):
    """The mode to determine the course of the search pattern."""
    # Automatically begin the search pattern within 0 - 180 degrees.
    COURSE_MODE_LOW = 0
    # Automatically begin the search pattern within 180 - 360 degrees.
    COURSE_MODE_HIGH = 1
    # Manually define the course of the search pattern.
    COURSE_MODE_OVERRIDE = 2

AVTR_SEARCH_PATTERN_COURSE_MODE.COURSE_MODE_LOW.__doc__ = "Automatically begin the search pattern within 0 - 180 degrees."
AVTR_SEARCH_PATTERN_COURSE_MODE.COURSE_MODE_HIGH.__doc__ = "Automatically begin the search pattern within 180 - 360 degrees."
AVTR_SEARCH_PATTERN_COURSE_MODE.COURSE_MODE_OVERRIDE.__doc__ = "Manually define the course of the search pattern."

agcls.AgTypeNameMap["AVTR_SEARCH_PATTERN_COURSE_MODE"] = AVTR_SEARCH_PATTERN_COURSE_MODE

class AVTR_DELAY_TURN_DIR(IntEnum):
    """Turn mode for procedures with Delay options."""
    # Automatic turn. Aviator will determine the direction of the turn.
    DELAY_TURN_AUTO = 0
    # Left turn.
    DELAY_TURN_LEFT = 1
    # Right turn.
    DELAY_TURN_RIGHT = 2

AVTR_DELAY_TURN_DIR.DELAY_TURN_AUTO.__doc__ = "Automatic turn. Aviator will determine the direction of the turn."
AVTR_DELAY_TURN_DIR.DELAY_TURN_LEFT.__doc__ = "Left turn."
AVTR_DELAY_TURN_DIR.DELAY_TURN_RIGHT.__doc__ = "Right turn."

agcls.AgTypeNameMap["AVTR_DELAY_TURN_DIR"] = AVTR_DELAY_TURN_DIR

class AVTR_TRAJECTORY_BLEND_MODE(IntEnum):
    """The interpolation mode to determine the aircraft's position and velocity."""
    # Quadratic interpolation using the body frame.
    BLEND_BODY_QUADRATIC = 0
    # Cubic interpolation using the body frame.
    BLEND_BODY_CUBIC = 1
    # Quadratic interpolation using the local horizontal frame.
    BLEND_LH_QUADRATIC = 2
    # Cubic interpolation using the local horizontal frame.
    BLEND_LH_CUBIC = 3
    # Quadratic interpolation using the Earth-Centered Fixed frame.
    BLEND_ECF_QUADRATIC = 4
    # Cubic interpolation using the Earth-Centered Fixed frame.
    BLEND_ECF_CUBIC = 5

AVTR_TRAJECTORY_BLEND_MODE.BLEND_BODY_QUADRATIC.__doc__ = "Quadratic interpolation using the body frame."
AVTR_TRAJECTORY_BLEND_MODE.BLEND_BODY_CUBIC.__doc__ = "Cubic interpolation using the body frame."
AVTR_TRAJECTORY_BLEND_MODE.BLEND_LH_QUADRATIC.__doc__ = "Quadratic interpolation using the local horizontal frame."
AVTR_TRAJECTORY_BLEND_MODE.BLEND_LH_CUBIC.__doc__ = "Cubic interpolation using the local horizontal frame."
AVTR_TRAJECTORY_BLEND_MODE.BLEND_ECF_QUADRATIC.__doc__ = "Quadratic interpolation using the Earth-Centered Fixed frame."
AVTR_TRAJECTORY_BLEND_MODE.BLEND_ECF_CUBIC.__doc__ = "Cubic interpolation using the Earth-Centered Fixed frame."

agcls.AgTypeNameMap["AVTR_TRAJECTORY_BLEND_MODE"] = AVTR_TRAJECTORY_BLEND_MODE

class AVTR_REF_STATE_PERF_MODE(IntEnum):
    """The type of motion the aircraft is engaged in at the reference state."""
    # Forward Flight - Climb performance mode.
    REF_STATE_CLIMB = 0
    # Forward Flight - Cruise performance mode.
    REF_STATE_CRUISE = 1
    # Forward Flight - Descend performance mode.
    REF_STATE_DESCEND = 2
    # Hover performance mode.
    REF_STATE_HOVER = 3
    # Landing performance mode.
    REF_STATE_LANDING = 4
    # Takeoff performance mode.
    REF_STATE_TAKEOFF = 5
    # Weight On Wheels - Landing Rollout performance mode
    REF_STATE_LANDING_ROLLOUT = 6
    # Weight On Wheels - Takeoff Run performance mode
    REF_STATE_TAKEOFF_RUN = 7

AVTR_REF_STATE_PERF_MODE.REF_STATE_CLIMB.__doc__ = "Forward Flight - Climb performance mode."
AVTR_REF_STATE_PERF_MODE.REF_STATE_CRUISE.__doc__ = "Forward Flight - Cruise performance mode."
AVTR_REF_STATE_PERF_MODE.REF_STATE_DESCEND.__doc__ = "Forward Flight - Descend performance mode."
AVTR_REF_STATE_PERF_MODE.REF_STATE_HOVER.__doc__ = "Hover performance mode."
AVTR_REF_STATE_PERF_MODE.REF_STATE_LANDING.__doc__ = "Landing performance mode."
AVTR_REF_STATE_PERF_MODE.REF_STATE_TAKEOFF.__doc__ = "Takeoff performance mode."
AVTR_REF_STATE_PERF_MODE.REF_STATE_LANDING_ROLLOUT.__doc__ = "Weight On Wheels - Landing Rollout performance mode"
AVTR_REF_STATE_PERF_MODE.REF_STATE_TAKEOFF_RUN.__doc__ = "Weight On Wheels - Takeoff Run performance mode"

agcls.AgTypeNameMap["AVTR_REF_STATE_PERF_MODE"] = AVTR_REF_STATE_PERF_MODE

class AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE(IntEnum):
    """The mode to specify the longitudinal acceleration of the aircraft."""
    # Specify the true airspeed acceleration.
    SPECIFY_TAS_DOT = 0
    # Specify the groundspeed acceleration.
    SPECIFY_GROUND_SPEED_DOT = 1

AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE.SPECIFY_TAS_DOT.__doc__ = "Specify the true airspeed acceleration."
AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE.SPECIFY_GROUND_SPEED_DOT.__doc__ = "Specify the groundspeed acceleration."

agcls.AgTypeNameMap["AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE"] = AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE

class AVTR_REF_STATE_LATERAL_ACCEL_MODE(IntEnum):
    """The mode to specify the lateral acceleration of the aircraft."""
    # Specify the heading rate of change.
    SPECIFY_HEADING_DOT = 0
    # Specify the course rate of change.
    SPECIFY_COURSE_DOT = 1

AVTR_REF_STATE_LATERAL_ACCEL_MODE.SPECIFY_HEADING_DOT.__doc__ = "Specify the heading rate of change."
AVTR_REF_STATE_LATERAL_ACCEL_MODE.SPECIFY_COURSE_DOT.__doc__ = "Specify the course rate of change."

agcls.AgTypeNameMap["AVTR_REF_STATE_LATERAL_ACCEL_MODE"] = AVTR_REF_STATE_LATERAL_ACCEL_MODE

class AVTR_REF_STATE_ATTITUDE_MODE(IntEnum):
    """The mode to specify the attitude rate of change."""
    # Specify the push/pull G.
    SPECIFY_PUSH_PULL_G = 0
    # Specify the pitch rate of change.
    SPECIFY_PITCH_RATE = 1

AVTR_REF_STATE_ATTITUDE_MODE.SPECIFY_PUSH_PULL_G.__doc__ = "Specify the push/pull G."
AVTR_REF_STATE_ATTITUDE_MODE.SPECIFY_PITCH_RATE.__doc__ = "Specify the pitch rate of change."

agcls.AgTypeNameMap["AVTR_REF_STATE_ATTITUDE_MODE"] = AVTR_REF_STATE_ATTITUDE_MODE

class AVTR_AND_OR(IntEnum):
    """The option to specify AND or OR."""
    # And option.
    AND = 0
    # Or option.
    OR = 1

AVTR_AND_OR.AND.__doc__ = "And option."
AVTR_AND_OR.OR.__doc__ = "Or option."

agcls.AgTypeNameMap["AVTR_AND_OR"] = AVTR_AND_OR

class AVTR_JET_ENGINE_TECHNOLOGY_LEVEL(IntEnum):
    """The technology level of the jet engine."""
    # Ideal (perfect efficiencies).
    IDEAL = 0
    # Level 1 (1945-1965).
    LEVEL1 = 1
    # Level 2 (1965-1985).
    LEVEL2 = 2
    # Level 3 (1985-2005).
    LEVEL3 = 3
    # Level 4 (2005-2025).
    LEVEL4 = 4
    # Level 5 (2025-2045).
    LEVEL5 = 5

AVTR_JET_ENGINE_TECHNOLOGY_LEVEL.IDEAL.__doc__ = "Ideal (perfect efficiencies)."
AVTR_JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL1.__doc__ = "Level 1 (1945-1965)."
AVTR_JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL2.__doc__ = "Level 2 (1965-1985)."
AVTR_JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL3.__doc__ = "Level 3 (1985-2005)."
AVTR_JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL4.__doc__ = "Level 4 (2005-2025)."
AVTR_JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL5.__doc__ = "Level 5 (2025-2045)."

agcls.AgTypeNameMap["AVTR_JET_ENGINE_TECHNOLOGY_LEVEL"] = AVTR_JET_ENGINE_TECHNOLOGY_LEVEL

class AVTR_JET_ENGINE_INTAKE_TYPE(IntEnum):
    """The intake type of the jet engine."""
    # Subsonic nacelles.
    SUBSONIC_NACELLES = 0
    # Subsonic embedded.
    SUBSONIC_EMBEDDED = 1
    # Supersonic embedded.
    SUPERSONIC_EMBEDDED = 2

AVTR_JET_ENGINE_INTAKE_TYPE.SUBSONIC_NACELLES.__doc__ = "Subsonic nacelles."
AVTR_JET_ENGINE_INTAKE_TYPE.SUBSONIC_EMBEDDED.__doc__ = "Subsonic embedded."
AVTR_JET_ENGINE_INTAKE_TYPE.SUPERSONIC_EMBEDDED.__doc__ = "Supersonic embedded."

agcls.AgTypeNameMap["AVTR_JET_ENGINE_INTAKE_TYPE"] = AVTR_JET_ENGINE_INTAKE_TYPE

class AVTR_JET_ENGINE_TURBINE_TYPE(IntEnum):
    """The turbine type of the jet engine."""
    # Uncooled turbine.
    UNCOOLED = 0
    # Cooled turbine.
    COOLED = 1

AVTR_JET_ENGINE_TURBINE_TYPE.UNCOOLED.__doc__ = "Uncooled turbine."
AVTR_JET_ENGINE_TURBINE_TYPE.COOLED.__doc__ = "Cooled turbine."

agcls.AgTypeNameMap["AVTR_JET_ENGINE_TURBINE_TYPE"] = AVTR_JET_ENGINE_TURBINE_TYPE

class AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE(IntEnum):
    """The exhaust nozzle type of the jet engine."""
    # Fixed Area Convergent.
    FIXED_AREA_CONVERGENT = 0
    # Variable Area Convergent.
    VARIABLE_AREA_CONVERGENT = 1
    # Variable Area Convergent - Divergent.
    VARIABLE_AREA_CONVERGENT_DIVERGENT = 2

AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE.FIXED_AREA_CONVERGENT.__doc__ = "Fixed Area Convergent."
AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE.VARIABLE_AREA_CONVERGENT.__doc__ = "Variable Area Convergent."
AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE.VARIABLE_AREA_CONVERGENT_DIVERGENT.__doc__ = "Variable Area Convergent - Divergent."

agcls.AgTypeNameMap["AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE"] = AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE

class AVTR_JET_FUEL_TYPE(IntEnum):
    """The jet fuel type."""
    # A kerosene fuel model based on AFPROP.
    KEROSENE_AFPROP = 0
    # A kerosene fuel model based on NASA CEA.
    KEROSENE_CEA = 1
    # A hydrogen fuel model based on NASA CEA.
    HYDROGEN = 2

AVTR_JET_FUEL_TYPE.KEROSENE_AFPROP.__doc__ = "A kerosene fuel model based on AFPROP."
AVTR_JET_FUEL_TYPE.KEROSENE_CEA.__doc__ = "A kerosene fuel model based on NASA CEA."
AVTR_JET_FUEL_TYPE.HYDROGEN.__doc__ = "A hydrogen fuel model based on NASA CEA."

agcls.AgTypeNameMap["AVTR_JET_FUEL_TYPE"] = AVTR_JET_FUEL_TYPE

class AVTR_AFPROP_FUEL_TYPE(IntEnum):
    """The AFPROP fuel type."""
    # Override the specific energy.
    AFPROP_OVERRIDE = 0
    # Jet A fuel model based on AFPROP.
    AFPROP_JET_A = 1
    # Jet A-1 fuel model based on AFPROP.
    AFPROP_JET_A1 = 2
    # JP-5 fuel model based on AFPROP.
    AFPROPJP5 = 3
    # JP-7 fuel model based on AFPROP.
    AFPROPJP7 = 4

AVTR_AFPROP_FUEL_TYPE.AFPROP_OVERRIDE.__doc__ = "Override the specific energy."
AVTR_AFPROP_FUEL_TYPE.AFPROP_JET_A.__doc__ = "Jet A fuel model based on AFPROP."
AVTR_AFPROP_FUEL_TYPE.AFPROP_JET_A1.__doc__ = "Jet A-1 fuel model based on AFPROP."
AVTR_AFPROP_FUEL_TYPE.AFPROPJP5.__doc__ = "JP-5 fuel model based on AFPROP."
AVTR_AFPROP_FUEL_TYPE.AFPROPJP7.__doc__ = "JP-7 fuel model based on AFPROP."

agcls.AgTypeNameMap["AVTR_AFPROP_FUEL_TYPE"] = AVTR_AFPROP_FUEL_TYPE

class AVTR_CEA_FUEL_TYPE(IntEnum):
    """The CEA fuel type."""
    # Override the specific energy.
    CEA_OVERRIDE = 0
    # Jet A fuel model based on NASA CEA.
    CEA_JET_A = 1
    # Jet A-1 fuel model based on NASA CEA.
    CEA_JET_A1 = 2
    # JP-5 fuel model based on NASA CEA.
    CEAJP5 = 3
    # JP-7 fuel model based on NASA CEA.
    CEAJP7 = 4

AVTR_CEA_FUEL_TYPE.CEA_OVERRIDE.__doc__ = "Override the specific energy."
AVTR_CEA_FUEL_TYPE.CEA_JET_A.__doc__ = "Jet A fuel model based on NASA CEA."
AVTR_CEA_FUEL_TYPE.CEA_JET_A1.__doc__ = "Jet A-1 fuel model based on NASA CEA."
AVTR_CEA_FUEL_TYPE.CEAJP5.__doc__ = "JP-5 fuel model based on NASA CEA."
AVTR_CEA_FUEL_TYPE.CEAJP7.__doc__ = "JP-7 fuel model based on NASA CEA."

agcls.AgTypeNameMap["AVTR_CEA_FUEL_TYPE"] = AVTR_CEA_FUEL_TYPE

class AVTR_TURBINE_MODE(IntEnum):
    """The turbine mode for a Sub/Super/Hypersonic powerplant."""
    # Disabled turbine mode.
    TURBINE_MODE_DISABLED = 0
    # Turbojet - Basic w/AB (Thermodynamic model).
    TURBINE_MODE_TURBOJET_BASIC_AB = 1
    # Turbofan - Basic w/AB (Thermodynamic model).
    TURBINE_MODE_TURBOFAN_BASIC_AB = 2

AVTR_TURBINE_MODE.TURBINE_MODE_DISABLED.__doc__ = "Disabled turbine mode."
AVTR_TURBINE_MODE.TURBINE_MODE_TURBOJET_BASIC_AB.__doc__ = "Turbojet - Basic w/AB (Thermodynamic model)."
AVTR_TURBINE_MODE.TURBINE_MODE_TURBOFAN_BASIC_AB.__doc__ = "Turbofan - Basic w/AB (Thermodynamic model)."

agcls.AgTypeNameMap["AVTR_TURBINE_MODE"] = AVTR_TURBINE_MODE

class AVTR_RAMJET_MODE(IntEnum):
    """The ramjet mode for a Sub/Super/Hypersonic powerplant."""
    # Disabled ramjet mode.
    RAMJET_MODE_DISABLED = 0
    # Ramjet - Basic mode.
    RAMJET_MODE_BASIC = 1

AVTR_RAMJET_MODE.RAMJET_MODE_DISABLED.__doc__ = "Disabled ramjet mode."
AVTR_RAMJET_MODE.RAMJET_MODE_BASIC.__doc__ = "Ramjet - Basic mode."

agcls.AgTypeNameMap["AVTR_RAMJET_MODE"] = AVTR_RAMJET_MODE

class AVTR_SCRAMJET_MODE(IntEnum):
    """The scramjet mode for a Sub/Super/Hypersonic powerplant."""
    # Disabled scramjet mode.
    SCRAMJET_MODE_DISABLED = 0
    # Scramjet - Basic mode.
    SCRAMJET_MODE_BASIC = 1

AVTR_SCRAMJET_MODE.SCRAMJET_MODE_DISABLED.__doc__ = "Disabled scramjet mode."
AVTR_SCRAMJET_MODE.SCRAMJET_MODE_BASIC.__doc__ = "Scramjet - Basic mode."

agcls.AgTypeNameMap["AVTR_SCRAMJET_MODE"] = AVTR_SCRAMJET_MODE

class AVTR_NUMERICAL_INTEGRATOR(IntEnum):
    """The numerical integrator to be used for the procedure."""
    # Runge-Kutta 4th Order Fixed Time Step Integrator
    RK4 = 0
    # Runge-Kutta 4th Order Adpative Time Step Integrator.
    RK45 = 1

AVTR_NUMERICAL_INTEGRATOR.RK4.__doc__ = "Runge-Kutta 4th Order Fixed Time Step Integrator"
AVTR_NUMERICAL_INTEGRATOR.RK45.__doc__ = "Runge-Kutta 4th Order Adpative Time Step Integrator."

agcls.AgTypeNameMap["AVTR_NUMERICAL_INTEGRATOR"] = AVTR_NUMERICAL_INTEGRATOR

class AVTR_BALLISTIC3_D_CONTROL_MODE(IntEnum):
    """The control mode used to define the ballistic 3D strategy of the basic maneuver procedure."""
    # The vehicle will compensate for the wind along its ballistic trajectory.
    BALLISTIC3_D_COMPENSATE_FOR_WIND = 0
    # Allow the wind to affect the ballistic trajectory.
    BALLISTIC3_D_WIND_PUSHES_VEHICLE = 1
    # Model the vehicle as a parachute.
    BALLISTIC3_D_PARACHUTE_MODE = 2

AVTR_BALLISTIC3_D_CONTROL_MODE.BALLISTIC3_D_COMPENSATE_FOR_WIND.__doc__ = "The vehicle will compensate for the wind along its ballistic trajectory."
AVTR_BALLISTIC3_D_CONTROL_MODE.BALLISTIC3_D_WIND_PUSHES_VEHICLE.__doc__ = "Allow the wind to affect the ballistic trajectory."
AVTR_BALLISTIC3_D_CONTROL_MODE.BALLISTIC3_D_PARACHUTE_MODE.__doc__ = "Model the vehicle as a parachute."

agcls.AgTypeNameMap["AVTR_BALLISTIC3_D_CONTROL_MODE"] = AVTR_BALLISTIC3_D_CONTROL_MODE

class AVTR_LAUNCH_DYN_STATE_COORD_FRAME(IntEnum):
    """The coordinate frame used for a LaunchDynState procedure."""
    # The object's body frame.
    LAUNCH_DYN_STATE_COORD_FRAME_BODY = 0
    # The object's local horizontal frame.
    LAUNCH_DYN_STATE_COORD_FRAME_LOCAL_HORIZONTAL = 1

AVTR_LAUNCH_DYN_STATE_COORD_FRAME.LAUNCH_DYN_STATE_COORD_FRAME_BODY.__doc__ = "The object's body frame."
AVTR_LAUNCH_DYN_STATE_COORD_FRAME.LAUNCH_DYN_STATE_COORD_FRAME_LOCAL_HORIZONTAL.__doc__ = "The object's local horizontal frame."

agcls.AgTypeNameMap["AVTR_LAUNCH_DYN_STATE_COORD_FRAME"] = AVTR_LAUNCH_DYN_STATE_COORD_FRAME

class AVTR_LAUNCH_DYN_STATE_BEARING_REF(IntEnum):
    """The vector used as a bearing reference for a LaunchDynState procedure."""
    # The object's velocity vector.
    LAUNCH_DYN_STATE_BEARING_REF_VELOCITY = 0
    # The X vector of the object's coordinate frame.
    LAUNCH_DYN_STATE_BEARING_REF_COORD_FRAME_X = 1
    # The object's vector to North.
    LAUNCH_DYN_STATE_BEARING_REF_NORTH = 2

AVTR_LAUNCH_DYN_STATE_BEARING_REF.LAUNCH_DYN_STATE_BEARING_REF_VELOCITY.__doc__ = "The object's velocity vector."
AVTR_LAUNCH_DYN_STATE_BEARING_REF.LAUNCH_DYN_STATE_BEARING_REF_COORD_FRAME_X.__doc__ = "The X vector of the object's coordinate frame."
AVTR_LAUNCH_DYN_STATE_BEARING_REF.LAUNCH_DYN_STATE_BEARING_REF_NORTH.__doc__ = "The object's vector to North."

agcls.AgTypeNameMap["AVTR_LAUNCH_DYN_STATE_BEARING_REF"] = AVTR_LAUNCH_DYN_STATE_BEARING_REF

class AVTR_ALTITUDE_REF(IntEnum):
    """The altitude reference."""
    # Altitude above WGS84 ground reference.
    ALTITUDE_REF_WGS84 = 0
    # Altitude above Mean Sea Level (MSL).
    ALTITUDE_REF_MSL = 1
    # ALtitude above terrain.
    ALTITUDE_REF_TERRAIN = 2

AVTR_ALTITUDE_REF.ALTITUDE_REF_WGS84.__doc__ = "Altitude above WGS84 ground reference."
AVTR_ALTITUDE_REF.ALTITUDE_REF_MSL.__doc__ = "Altitude above Mean Sea Level (MSL)."
AVTR_ALTITUDE_REF.ALTITUDE_REF_TERRAIN.__doc__ = "ALtitude above terrain."

agcls.AgTypeNameMap["AVTR_ALTITUDE_REF"] = AVTR_ALTITUDE_REF

class AVTR_SMOOTH_TURN_FPA_MODE(IntEnum):
    """The flight path angle mode for the Smooth Turn strategy of the Basic Maneuver procedure."""
    # Hold the initial flight path angle.
    SMOOTH_TURN_FPA_HOLD_INITIAL = 0
    # Levell off the flight path angle.
    SMOOTH_TURN_FPA_LEVEL_OFF = 1

AVTR_SMOOTH_TURN_FPA_MODE.SMOOTH_TURN_FPA_HOLD_INITIAL.__doc__ = "Hold the initial flight path angle."
AVTR_SMOOTH_TURN_FPA_MODE.SMOOTH_TURN_FPA_LEVEL_OFF.__doc__ = "Levell off the flight path angle."

agcls.AgTypeNameMap["AVTR_SMOOTH_TURN_FPA_MODE"] = AVTR_SMOOTH_TURN_FPA_MODE

class AVTR_PITCH3_D_CONTROL_MODE(IntEnum):
    """The control mode used to define the pitch 3D strategy of the basic maneuver procedure."""
    # The vehicle will compensate for the wind along its trajectory.
    PITCH3_D_COMPENSATE_FOR_WIND = 0
    # Allow the wind to affect the trajectory.
    PITCH3_D_WIND_PUSHES_VEHICLE = 1

AVTR_PITCH3_D_CONTROL_MODE.PITCH3_D_COMPENSATE_FOR_WIND.__doc__ = "The vehicle will compensate for the wind along its trajectory."
AVTR_PITCH3_D_CONTROL_MODE.PITCH3_D_WIND_PUSHES_VEHICLE.__doc__ = "Allow the wind to affect the trajectory."

agcls.AgTypeNameMap["AVTR_PITCH3_D_CONTROL_MODE"] = AVTR_PITCH3_D_CONTROL_MODE

class AVTR_REFUEL_DUMP_MODE(IntEnum):
    """The modes used to define procedure refuel/dump modes."""
    # RefuelDump Disabled.
    REFUEL_DUMP_DISABLED = 0
    # Refuel Top Off.
    REFUEL_TOP_OFF = 1
    # Refuel to specified fuel state.
    REFUEL_TO_FUEL_STATE = 2
    # Refuel to specified weight.
    REFUEL_TO_WEIGHT = 3
    # Refuel specified quantity.
    REFUEL_QUANTITY = 4
    # Dump to specified fuel state.
    DUMP_TO_FUEL_STATE = 5
    # Dump to specified weight.
    DUMP_TO_WEIGHT = 6
    # Dump specified quantity.
    DUMP_QUANTITY = 7

AVTR_REFUEL_DUMP_MODE.REFUEL_DUMP_DISABLED.__doc__ = "RefuelDump Disabled."
AVTR_REFUEL_DUMP_MODE.REFUEL_TOP_OFF.__doc__ = "Refuel Top Off."
AVTR_REFUEL_DUMP_MODE.REFUEL_TO_FUEL_STATE.__doc__ = "Refuel to specified fuel state."
AVTR_REFUEL_DUMP_MODE.REFUEL_TO_WEIGHT.__doc__ = "Refuel to specified weight."
AVTR_REFUEL_DUMP_MODE.REFUEL_QUANTITY.__doc__ = "Refuel specified quantity."
AVTR_REFUEL_DUMP_MODE.DUMP_TO_FUEL_STATE.__doc__ = "Dump to specified fuel state."
AVTR_REFUEL_DUMP_MODE.DUMP_TO_WEIGHT.__doc__ = "Dump to specified weight."
AVTR_REFUEL_DUMP_MODE.DUMP_QUANTITY.__doc__ = "Dump specified quantity."

agcls.AgTypeNameMap["AVTR_REFUEL_DUMP_MODE"] = AVTR_REFUEL_DUMP_MODE

class AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE(IntEnum):
    """The modes used to define basic maneuver glide speed control modes."""
    # Immediate speed change.
    GLIDE_SPEED_IMMEDIATE_CHANGE = 0
    # Achieve speed at altitude.
    GLIDE_SPEED_AT_ALTITUDE = 1

AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE.GLIDE_SPEED_IMMEDIATE_CHANGE.__doc__ = "Immediate speed change."
AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE.GLIDE_SPEED_AT_ALTITUDE.__doc__ = "Achieve speed at altitude."

agcls.AgTypeNameMap["AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE"] = AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE


class ISite(object):
    """Interface to access Site options"""
    _uuid = "{ca4ddeac-d1c9-4bd8-9569-22c259ae7a1b}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISite = agcom.GUID(ISite._uuid)
        vtable_offset_local = ISite._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_ISite, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_ISite, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISite.__dict__ and type(ISite.__dict__[attrname]) == property:
            return ISite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISite.")
    
    @property
    def name(self) -> str:
        """The name of the site."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the site."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ca4ddeac-d1c9-4bd8-9569-22c259ae7a1b}", ISite)
agcls.AgTypeNameMap["ISite"] = ISite

class IWindModel(object):
    """Interface used to access the wind model for a mission, scenario, or procedure."""
    _uuid = "{7147f488-83c5-49be-949c-84e81fdcfb1a}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_wind_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_wind_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_wind_model_type_string"] = _raise_uninitialized_error
        self.__dict__["_set_wind_model_type_string"] = _raise_uninitialized_error
        self.__dict__["_get_wind_model_source"] = _raise_uninitialized_error
        self.__dict__["_set_wind_model_source"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_constant"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_adds"] = _raise_uninitialized_error
        self.__dict__["_copy"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWindModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWindModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWindModel = agcom.GUID(IWindModel._uuid)
        vtable_offset_local = IWindModel._vtable_offset - 1
        self.__dict__["_get_wind_model_type"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_wind_model_type"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_wind_model_type_string"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_wind_model_type_string"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_wind_model_source"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_wind_model_source"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_mode_as_constant"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_adds"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_copy"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+9, )
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IWindModel, vtable_offset_local+10, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWindModel.__dict__ and type(IWindModel.__dict__[attrname]) == property:
            return IWindModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWindModel.")
    
    @property
    def wind_model_type(self) -> "AVTR_WIND_MODEL_TYPE":
        """The wind model type."""
        with agmarshall.AgEnum_arg(AVTR_WIND_MODEL_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wind_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wind_model_type.setter
    def wind_model_type(self, pVal:"AVTR_WIND_MODEL_TYPE") -> None:
        """The wind model type."""
        with agmarshall.AgEnum_arg(AVTR_WIND_MODEL_TYPE, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_wind_model_type"](arg_pVal.COM_val))

    @property
    def wind_model_type_string(self) -> str:
        """The wind model type as a string value. Use this for custom models."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wind_model_type_string"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wind_model_type_string.setter
    def wind_model_type_string(self, pVal:str) -> None:
        """The wind model type as a string value. Use this for custom models."""
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_wind_model_type_string"](arg_pVal.COM_val))

    @property
    def wind_model_source(self) -> "AVTR_WIND_ATMOS_MODEL_SOURCE":
        """The wind model source."""
        with agmarshall.AgEnum_arg(AVTR_WIND_ATMOS_MODEL_SOURCE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wind_model_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wind_model_source.setter
    def wind_model_source(self, pVal:"AVTR_WIND_ATMOS_MODEL_SOURCE") -> None:
        """The wind model source."""
        with agmarshall.AgEnum_arg(AVTR_WIND_ATMOS_MODEL_SOURCE, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_wind_model_source"](arg_pVal.COM_val))

    @property
    def mode_as_constant(self) -> "IWindModelConstant":
        """Get the options for a Constant Bearing/Speed wind model."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_constant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_adds(self) -> "IWindModelADDS":
        """Get the options for a NOAA ADDS Service wind model."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_adds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def copy(self) -> None:
        """Copy the wind model."""
        agcls.evaluate_hresult(self.__dict__["_copy"]())

    def paste(self) -> None:
        """Paste the wind model."""
        agcls.evaluate_hresult(self.__dict__["_paste"]())


agcls.AgClassCatalog.add_catalog_entry("{7147f488-83c5-49be-949c-84e81fdcfb1a}", IWindModel)
agcls.AgTypeNameMap["IWindModel"] = IWindModel

class IADDSMessage(object):
    """Interface used to access a message from the NOAA ADDS forecast."""
    _uuid = "{cc723181-9845-44c1-b061-f3e516343d88}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_stop_time"] = _raise_uninitialized_error
        self.__dict__["_get_message_time"] = _raise_uninitialized_error
        self.__dict__["_get_type"] = _raise_uninitialized_error
        self.__dict__["_get_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IADDSMessage._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IADDSMessage from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IADDSMessage = agcom.GUID(IADDSMessage._uuid)
        vtable_offset_local = IADDSMessage._vtable_offset - 1
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IADDSMessage, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_get_stop_time"] = IAGFUNCTYPE(pUnk, IID_IADDSMessage, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_get_message_time"] = IAGFUNCTYPE(pUnk, IID_IADDSMessage, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_get_type"] = IAGFUNCTYPE(pUnk, IID_IADDSMessage, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_source"] = IAGFUNCTYPE(pUnk, IID_IADDSMessage, vtable_offset_local+5, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IADDSMessage.__dict__ and type(IADDSMessage.__dict__[attrname]) == property:
            return IADDSMessage.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IADDSMessage.")
    
    @property
    def start_time(self) -> typing.Any:
        """Valid start time for the ADDS message."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_time(self) -> typing.Any:
        """Valid stop time for the ADDS message."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def message_time(self) -> typing.Any:
        """The message time for the ADDS message."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_message_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def type(self) -> "AVTR_ADDS_FORECAST_TYPE":
        """The ADDS message type."""
        with agmarshall.AgEnum_arg(AVTR_ADDS_FORECAST_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def source(self) -> str:
        """The ADDS message source."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{cc723181-9845-44c1-b061-f3e516343d88}", IADDSMessage)
agcls.AgTypeNameMap["IADDSMessage"] = IADDSMessage

class IFuelTankInternal(object):
    """Interface used to set an aircraft's internal fuel tank."""
    _uuid = "{4cc46781-fe55-4b7e-9bd8-b4f174b208b2}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_capacity"] = _raise_uninitialized_error
        self.__dict__["_set_capacity"] = _raise_uninitialized_error
        self.__dict__["_get_consumption_order"] = _raise_uninitialized_error
        self.__dict__["_set_consumption_order"] = _raise_uninitialized_error
        self.__dict__["_get_initial_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_set_initial_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_get_position_x"] = _raise_uninitialized_error
        self.__dict__["_get_position_y"] = _raise_uninitialized_error
        self.__dict__["_get_position_z"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFuelTankInternal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFuelTankInternal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFuelTankInternal = agcom.GUID(IFuelTankInternal._uuid)
        vtable_offset_local = IFuelTankInternal._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_capacity"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_capacity"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_consumption_order"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_consumption_order"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_initial_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_position_x"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_get_position_y"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_get_position_z"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_IFuelTankInternal, vtable_offset_local+12, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelTankInternal.__dict__ and type(IFuelTankInternal.__dict__[attrname]) == property:
            return IFuelTankInternal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelTankInternal.")
    
    @property
    def name(self) -> str:
        """The name of the fuel tank."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the fuel tank."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def capacity(self) -> float:
        """The capacity of the fuel tank."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_capacity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @capacity.setter
    def capacity(self, newVal:float) -> None:
        """The capacity of the fuel tank."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_capacity"](arg_newVal.COM_val))

    @property
    def consumption_order(self) -> int:
        """The consumption order of the fuel tank."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_consumption_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @consumption_order.setter
    def consumption_order(self, newVal:int) -> None:
        """The consumption order of the fuel tank."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_consumption_order"](arg_newVal.COM_val))

    @property
    def initial_fuel_state(self) -> float:
        """The initial fuel state of the fuel tank."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_fuel_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_fuel_state.setter
    def initial_fuel_state(self, newVal:float) -> None:
        """The initial fuel state of the fuel tank."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_fuel_state"](arg_newVal.COM_val))

    @property
    def position_x(self) -> float:
        """The X value of the fuel tank's parent relative position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_x"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position_y(self) -> float:
        """The Y value of the fuel tank's parent relative position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_y"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position_z(self) -> float:
        """The Z value of the fuel tank's parent relative position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_z"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def set_position(self, x:float, y:float, z:float) -> None:
        """Set the fuel tank's parent relative position."""
        with agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.DOUBLE_arg(z) as arg_z:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_x.COM_val, arg_y.COM_val, arg_z.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4cc46781-fe55-4b7e-9bd8-b4f174b208b2}", IFuelTankInternal)
agcls.AgTypeNameMap["IFuelTankInternal"] = IFuelTankInternal

class IFuelTankExternal(object):
    """Interface used to set an aircraft's external fuel tank."""
    _uuid = "{d4c0aa70-49ba-4343-907b-d7271a23a42f}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_empty_weight"] = _raise_uninitialized_error
        self.__dict__["_set_empty_weight"] = _raise_uninitialized_error
        self.__dict__["_get_capacity"] = _raise_uninitialized_error
        self.__dict__["_set_capacity"] = _raise_uninitialized_error
        self.__dict__["_get_initial_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_set_initial_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_get_consumption_order"] = _raise_uninitialized_error
        self.__dict__["_set_consumption_order"] = _raise_uninitialized_error
        self.__dict__["_get_drag_index"] = _raise_uninitialized_error
        self.__dict__["_set_drag_index"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFuelTankExternal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFuelTankExternal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFuelTankExternal = agcom.GUID(IFuelTankExternal._uuid)
        vtable_offset_local = IFuelTankExternal._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_empty_weight"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_empty_weight"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_capacity"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_capacity"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_initial_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_consumption_order"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_consumption_order"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_drag_index"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_drag_index"] = IAGFUNCTYPE(pUnk, IID_IFuelTankExternal, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelTankExternal.__dict__ and type(IFuelTankExternal.__dict__[attrname]) == property:
            return IFuelTankExternal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelTankExternal.")
    
    @property
    def name(self) -> str:
        """The name of the fuel tank."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the fuel tank."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def empty_weight(self) -> float:
        """The empty weight of the fuel tank."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_empty_weight"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @empty_weight.setter
    def empty_weight(self, newVal:float) -> None:
        """The empty weight of the fuel tank."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_empty_weight"](arg_newVal.COM_val))

    @property
    def capacity(self) -> float:
        """The capacity of the fuel tank."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_capacity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @capacity.setter
    def capacity(self, newVal:float) -> None:
        """The capacity of the fuel tank."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_capacity"](arg_newVal.COM_val))

    @property
    def initial_fuel_state(self) -> float:
        """The initial fuel state of the fuel tank."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_fuel_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_fuel_state.setter
    def initial_fuel_state(self, newVal:float) -> None:
        """The initial fuel state of the fuel tank."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_fuel_state"](arg_newVal.COM_val))

    @property
    def consumption_order(self) -> int:
        """The consumption order of the fuel tank."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_consumption_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @consumption_order.setter
    def consumption_order(self, newVal:int) -> None:
        """The consumption order of the fuel tank."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_consumption_order"](arg_newVal.COM_val))

    @property
    def drag_index(self) -> float:
        """The drag index of the fuel tank."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_index"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_index.setter
    def drag_index(self, newVal:float) -> None:
        """The drag index of the fuel tank."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_index"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{d4c0aa70-49ba-4343-907b-d7271a23a42f}", IFuelTankExternal)
agcls.AgTypeNameMap["IFuelTankExternal"] = IFuelTankExternal

class IPayloadStation(object):
    """Interface used to set an aircraft's payload station."""
    _uuid = "{d13cdb7b-4771-4ca1-954b-772a87f77ad2}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_position_x"] = _raise_uninitialized_error
        self.__dict__["_get_position_y"] = _raise_uninitialized_error
        self.__dict__["_get_position_z"] = _raise_uninitialized_error
        self.__dict__["_set_position"] = _raise_uninitialized_error
        self.__dict__["_remove_sub_item"] = _raise_uninitialized_error
        self.__dict__["_add_external_fuel_tank"] = _raise_uninitialized_error
        self.__dict__["_get_external_fuel_tank"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPayloadStation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPayloadStation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPayloadStation = agcom.GUID(IPayloadStation._uuid)
        vtable_offset_local = IPayloadStation._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_position_x"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_position_y"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_get_position_z"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_position"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+6, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_remove_sub_item"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+7, )
        self.__dict__["_add_external_fuel_tank"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_external_fuel_tank"] = IAGFUNCTYPE(pUnk, IID_IPayloadStation, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPayloadStation.__dict__ and type(IPayloadStation.__dict__[attrname]) == property:
            return IPayloadStation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPayloadStation.")
    
    @property
    def name(self) -> str:
        """The name of the payload station."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the payload station."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def position_x(self) -> float:
        """The X value of the payload station's parent relative position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_x"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position_y(self) -> float:
        """The Y value of the payload station's parent relative position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_y"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def position_z(self) -> float:
        """The Z value of the payload station's parent relative position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_z"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def set_position(self, x:float, y:float, z:float) -> None:
        """Set the payload station's parent relative position."""
        with agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.DOUBLE_arg(z) as arg_z:
            agcls.evaluate_hresult(self.__dict__["_set_position"](arg_x.COM_val, arg_y.COM_val, arg_z.COM_val))

    def remove_sub_item(self) -> None:
        """Remove any sub item that may be attached to the payload station."""
        agcls.evaluate_hresult(self.__dict__["_remove_sub_item"]())

    def add_external_fuel_tank(self) -> "IFuelTankExternal":
        """Add an external fuel tank to the payload station."""
        with agmarshall.AgInterface_out_arg() as arg_ppFuelTank:
            agcls.evaluate_hresult(self.__dict__["_add_external_fuel_tank"](byref(arg_ppFuelTank.COM_val)))
            return arg_ppFuelTank.python_val

    def get_external_fuel_tank(self) -> "IFuelTankExternal":
        """Get the external fuel tank attached to the payload station."""
        with agmarshall.AgInterface_out_arg() as arg_ppFuelTank:
            agcls.evaluate_hresult(self.__dict__["_get_external_fuel_tank"](byref(arg_ppFuelTank.COM_val)))
            return arg_ppFuelTank.python_val


agcls.AgClassCatalog.add_catalog_entry("{d13cdb7b-4771-4ca1-954b-772a87f77ad2}", IPayloadStation)
agcls.AgTypeNameMap["IPayloadStation"] = IPayloadStation

class IAircraftModel(object):
    """Interface used to access the aircraft options in the Aviator catalog."""
    _uuid = "{42c19506-e18d-4500-bc0e-c5db5dad14a1}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_perf_model_types"] = _raise_uninitialized_error
        self.__dict__["_get_acceleration"] = _raise_uninitialized_error
        self.__dict__["_get_climb"] = _raise_uninitialized_error
        self.__dict__["_get_cruise"] = _raise_uninitialized_error
        self.__dict__["_get_descent"] = _raise_uninitialized_error
        self.__dict__["_get_landing"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff"] = _raise_uninitialized_error
        self.__dict__["_get_default_configuration"] = _raise_uninitialized_error
        self.__dict__["_get_adv_fixed_wing_tool"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        self.__dict__["_get_vtol"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_follow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftModel = agcom.GUID(IAircraftModel._uuid)
        vtable_offset_local = IAircraftModel._vtable_offset - 1
        self.__dict__["_get_perf_model_types"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_acceleration"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_climb"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_cruise"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_descent"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_landing"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_takeoff"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_default_configuration"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_adv_fixed_wing_tool"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_vtol"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_terrain_follow"] = IAGFUNCTYPE(pUnk, IID_IAircraftModel, vtable_offset_local+12, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftModel.__dict__ and type(IAircraftModel.__dict__[attrname]) == property:
            return IAircraftModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftModel.")
    
    @property
    def perf_model_types(self) -> list:
        """Get the types of performance models."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_perf_model_types"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def acceleration(self) -> "IAircraftAcceleration":
        """Get the acceleration interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppAcc:
            agcls.evaluate_hresult(self.__dict__["_get_acceleration"](byref(arg_ppAcc.COM_val)))
            return arg_ppAcc.python_val

    @property
    def climb(self) -> "IAircraftClimb":
        """Get the climb interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppClimb:
            agcls.evaluate_hresult(self.__dict__["_get_climb"](byref(arg_ppClimb.COM_val)))
            return arg_ppClimb.python_val

    @property
    def cruise(self) -> "IAircraftCruise":
        """Get the cruise interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppCruise:
            agcls.evaluate_hresult(self.__dict__["_get_cruise"](byref(arg_ppCruise.COM_val)))
            return arg_ppCruise.python_val

    @property
    def descent(self) -> "IAircraftDescent":
        """Get the descent interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppDescent:
            agcls.evaluate_hresult(self.__dict__["_get_descent"](byref(arg_ppDescent.COM_val)))
            return arg_ppDescent.python_val

    @property
    def landing(self) -> "IAircraftLanding":
        """Get the landing interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppLanding:
            agcls.evaluate_hresult(self.__dict__["_get_landing"](byref(arg_ppLanding.COM_val)))
            return arg_ppLanding.python_val

    @property
    def takeoff(self) -> "IAircraftTakeoff":
        """Get the takeoff interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppTakeoff:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff"](byref(arg_ppTakeoff.COM_val)))
            return arg_ppTakeoff.python_val

    @property
    def default_configuration(self) -> "IConfiguration":
        """The aircraft's default configuration as saved in the catalog."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrConfig:
            agcls.evaluate_hresult(self.__dict__["_get_default_configuration"](byref(arg_ppAvtrConfig.COM_val)))
            return arg_ppAvtrConfig.python_val

    @property
    def adv_fixed_wing_tool(self) -> "IAdvFixedWingTool":
        """Get the Advanced Fixed Wing Tool for the aircraft."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrAdvFWT:
            agcls.evaluate_hresult(self.__dict__["_get_adv_fixed_wing_tool"](byref(arg_ppAvtrAdvFWT.COM_val)))
            return arg_ppAvtrAdvFWT.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val

    @property
    def vtol(self) -> "IAircraftVTOL":
        """Get the VTOL interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppVTOL:
            agcls.evaluate_hresult(self.__dict__["_get_vtol"](byref(arg_ppVTOL.COM_val)))
            return arg_ppVTOL.python_val

    @property
    def terrain_follow(self) -> "IAircraftTerrainFollow":
        """Get the TerrainFollow interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppTerrainFollow:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_follow"](byref(arg_ppTerrainFollow.COM_val)))
            return arg_ppTerrainFollow.python_val


agcls.AgClassCatalog.add_catalog_entry("{42c19506-e18d-4500-bc0e-c5db5dad14a1}", IAircraftModel)
agcls.AgTypeNameMap["IAircraftModel"] = IAircraftModel

class IAircraftSimpleAero(object):
    """Interface used to access the Simple Aerodynamics options for the Basic Acceleration Model of an aircraft."""
    _uuid = "{b3a9d57b-8ebb-428c-b36a-b4c701931cc1}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_operating_mode"] = _raise_uninitialized_error
        self.__dict__["_set_operating_mode"] = _raise_uninitialized_error
        self.__dict__["_get_s_ref"] = _raise_uninitialized_error
        self.__dict__["_set_s_ref"] = _raise_uninitialized_error
        self.__dict__["_get_cl_max"] = _raise_uninitialized_error
        self.__dict__["_set_cl_max"] = _raise_uninitialized_error
        self.__dict__["_get_cd"] = _raise_uninitialized_error
        self.__dict__["_set_cd"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftSimpleAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftSimpleAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftSimpleAero = agcom.GUID(IAircraftSimpleAero._uuid)
        vtable_offset_local = IAircraftSimpleAero._vtable_offset - 1
        self.__dict__["_get_operating_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_operating_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_s_ref"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_s_ref"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_cl_max"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cl_max"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_cd"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cd"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleAero, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftSimpleAero.__dict__ and type(IAircraftSimpleAero.__dict__[attrname]) == property:
            return IAircraftSimpleAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftSimpleAero.")
    
    @property
    def operating_mode(self) -> "AVTR_AERO_PROP_SIMPLE_MODE":
        """The mode option to treat the aircraft as a helicopter or a fixed wing aircraft when calculating the aircraft's attitude."""
        with agmarshall.AgEnum_arg(AVTR_AERO_PROP_SIMPLE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_operating_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @operating_mode.setter
    def operating_mode(self, newVal:"AVTR_AERO_PROP_SIMPLE_MODE") -> None:
        """The mode option to treat the aircraft as a helicopter or a fixed wing aircraft when calculating the aircraft's attitude."""
        with agmarshall.AgEnum_arg(AVTR_AERO_PROP_SIMPLE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_operating_mode"](arg_newVal.COM_val))

    @property
    def s_ref(self) -> float:
        """The reference surface area of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_s_ref"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @s_ref.setter
    def s_ref(self, newVal:float) -> None:
        """The reference surface area of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_s_ref"](arg_newVal.COM_val))

    @property
    def cl_max(self) -> float:
        """The max coefficient of lift."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cl_max"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cl_max.setter
    def cl_max(self, newVal:float) -> None:
        """The max coefficient of lift."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cl_max"](arg_newVal.COM_val))

    @property
    def cd(self) -> float:
        """The coefficient of drag."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cd"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cd.setter
    def cd(self, newVal:float) -> None:
        """The coefficient of drag."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cd"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b3a9d57b-8ebb-428c-b36a-b4c701931cc1}", IAircraftSimpleAero)
agcls.AgTypeNameMap["IAircraftSimpleAero"] = IAircraftSimpleAero

class ILevelTurns(object):
    """Interface used to access the Level Turns Transitions options found in the Basic Acceleration Model of an aircraft."""
    _uuid = "{5c45254a-230f-4f6d-adb9-d33c0a1bf06c}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_turn_mode"] = _raise_uninitialized_error
        self.__dict__["_get_turn_g"] = _raise_uninitialized_error
        self.__dict__["_get_bank_angle"] = _raise_uninitialized_error
        self.__dict__["_get_turn_acceleration"] = _raise_uninitialized_error
        self.__dict__["_get_turn_radius"] = _raise_uninitialized_error
        self.__dict__["_get_turn_rate"] = _raise_uninitialized_error
        self.__dict__["_set_level_turn"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_mode"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_mode"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_mode_helper"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILevelTurns._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILevelTurns from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILevelTurns = agcom.GUID(ILevelTurns._uuid)
        vtable_offset_local = ILevelTurns._vtable_offset - 1
        self.__dict__["_get_turn_mode"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_turn_g"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_get_bank_angle"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_get_turn_acceleration"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_get_turn_radius"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_get_turn_rate"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_level_turn"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+7, agcom.LONG, agcom.VARIANT)
        self.__dict__["_get_maneuver_mode"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_maneuver_mode"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_get_maneuver_mode_helper"] = IAGFUNCTYPE(pUnk, IID_ILevelTurns, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILevelTurns.__dict__ and type(ILevelTurns.__dict__[attrname]) == property:
            return ILevelTurns.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILevelTurns.")
    
    @property
    def turn_mode(self) -> "AVTR_TURN_MODE":
        """Get the turn mode."""
        with agmarshall.AgEnum_arg(AVTR_TURN_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def turn_g(self) -> float:
        """Get the TurnG."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def bank_angle(self) -> typing.Any:
        """Get the bank angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bank_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def turn_acceleration(self) -> float:
        """Get the turn acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_acceleration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def turn_radius(self) -> float:
        """Get the turn radius."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def turn_rate(self) -> float:
        """get the turn rate."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_level_turn(self, turnMode:"AVTR_TURN_MODE", turnValue:typing.Any) -> None:
        """Set the level turn mode and corresponding value."""
        with agmarshall.AgEnum_arg(AVTR_TURN_MODE, turnMode) as arg_turnMode, \
             agmarshall.VARIANT_arg(turnValue) as arg_turnValue:
            agcls.evaluate_hresult(self.__dict__["_set_level_turn"](arg_turnMode.COM_val, arg_turnValue.COM_val))

    @property
    def maneuver_mode(self) -> "AVTR_ACCEL_MANEUVER_MODE":
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_mode.setter
    def maneuver_mode(self, newVal:"AVTR_ACCEL_MANEUVER_MODE") -> None:
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_mode"](arg_newVal.COM_val))

    @property
    def maneuver_mode_helper(self) -> "IAeroPropManeuverModeHelper":
        """Get the interface for the Aero/Prop Maneuver Mode helper. The maneuver mode must be set to Aero/Prop to access this interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_mode_helper"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5c45254a-230f-4f6d-adb9-d33c0a1bf06c}", ILevelTurns)
agcls.AgTypeNameMap["ILevelTurns"] = ILevelTurns

class IAttitudeTransitions(object):
    """Interface used to access the Attitude Transitions options found in the Basic Acceleration Model of an aircraft."""
    _uuid = "{3dd0e618-20a7-42be-b04d-63472b068f36}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_get_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_set_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_get_yaw_rate"] = _raise_uninitialized_error
        self.__dict__["_set_yaw_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeTransitions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeTransitions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAttitudeTransitions = agcom.GUID(IAttitudeTransitions._uuid)
        vtable_offset_local = IAttitudeTransitions._vtable_offset - 1
        self.__dict__["_get_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IAttitudeTransitions, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IAttitudeTransitions, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IAttitudeTransitions, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IAttitudeTransitions, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_yaw_rate"] = IAGFUNCTYPE(pUnk, IID_IAttitudeTransitions, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_yaw_rate"] = IAGFUNCTYPE(pUnk, IID_IAttitudeTransitions, vtable_offset_local+6, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeTransitions.__dict__ and type(IAttitudeTransitions.__dict__[attrname]) == property:
            return IAttitudeTransitions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAttitudeTransitions.")
    
    @property
    def roll_rate(self) -> typing.Any:
        """The roll rate when the aircraft in a turn."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate.setter
    def roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate when the aircraft in a turn."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate"](arg_newVal.COM_val))

    @property
    def pitch_rate(self) -> typing.Any:
        """The pitch rate when transitioning between attitude modes."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pitch_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pitch_rate.setter
    def pitch_rate(self, newVal:typing.Any) -> None:
        """The pitch rate when transitioning between attitude modes."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pitch_rate"](arg_newVal.COM_val))

    @property
    def yaw_rate(self) -> typing.Any:
        """The yaw rate when transitioning between attitude modes."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_yaw_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @yaw_rate.setter
    def yaw_rate(self, newVal:typing.Any) -> None:
        """The yaw rate when transitioning between attitude modes."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_yaw_rate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3dd0e618-20a7-42be-b04d-63472b068f36}", IAttitudeTransitions)
agcls.AgTypeNameMap["IAttitudeTransitions"] = IAttitudeTransitions

class IClimbAndDescentTransitions(object):
    """Interface used to access the Climb and Descent Transitions options found in the Basic Acceleration Model of an aircraft."""
    _uuid = "{8733914e-9bc9-4270-ab39-0b32af9ca84e}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_pull_up_g"] = _raise_uninitialized_error
        self.__dict__["_set_max_pull_up_g"] = _raise_uninitialized_error
        self.__dict__["_get_max_push_over_g"] = _raise_uninitialized_error
        self.__dict__["_set_max_push_over_g"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_mode"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_mode"] = _raise_uninitialized_error
        self.__dict__["_get_ignore_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_ignore_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_mode_helper"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IClimbAndDescentTransitions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IClimbAndDescentTransitions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IClimbAndDescentTransitions = agcom.GUID(IClimbAndDescentTransitions._uuid)
        vtable_offset_local = IClimbAndDescentTransitions._vtable_offset - 1
        self.__dict__["_get_max_pull_up_g"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_pull_up_g"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_max_push_over_g"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_push_over_g"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_maneuver_mode"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_maneuver_mode"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_ignore_fpa"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_ignore_fpa"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_maneuver_mode_helper"] = IAGFUNCTYPE(pUnk, IID_IClimbAndDescentTransitions, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IClimbAndDescentTransitions.__dict__ and type(IClimbAndDescentTransitions.__dict__[attrname]) == property:
            return IClimbAndDescentTransitions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IClimbAndDescentTransitions.")
    
    @property
    def max_pull_up_g(self) -> float:
        """The force normal to the velocity vector used to transition into a climb or to a transition out of a dive into the next flight segment."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_pull_up_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_pull_up_g.setter
    def max_pull_up_g(self, newVal:float) -> None:
        """The force normal to the velocity vector used to transition into a climb or to a transition out of a dive into the next flight segment."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_pull_up_g"](arg_newVal.COM_val))

    @property
    def max_push_over_g(self) -> float:
        """The force normal to the velocity vector used to transition into a descent or to a transition from a climb into the next flight segment."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_push_over_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_push_over_g.setter
    def max_push_over_g(self, newVal:float) -> None:
        """The force normal to the velocity vector used to transition into a descent or to a transition from a climb into the next flight segment."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_push_over_g"](arg_newVal.COM_val))

    @property
    def maneuver_mode(self) -> "AVTR_ACCEL_MANEUVER_MODE":
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_mode.setter
    def maneuver_mode(self, newVal:"AVTR_ACCEL_MANEUVER_MODE") -> None:
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_mode"](arg_newVal.COM_val))

    @property
    def ignore_fpa(self) -> bool:
        """Opt whether to ignore the flight path angle."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ignore_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ignore_fpa.setter
    def ignore_fpa(self, newVal:bool) -> None:
        """Opt whether to ignore the flight path angle."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ignore_fpa"](arg_newVal.COM_val))

    @property
    def maneuver_mode_helper(self) -> "IAeroPropManeuverModeHelper":
        """Get the interface for the Aero/Prop Maneuver Mode helper. The maneuver mode must be set to Aero/Prop to access this interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_mode_helper"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8733914e-9bc9-4270-ab39-0b32af9ca84e}", IClimbAndDescentTransitions)
agcls.AgTypeNameMap["IClimbAndDescentTransitions"] = IClimbAndDescentTransitions

class ICatalogItem(object):
    """Interface used to access the options for a Catalog Item in the Aviator Catalog. Use this interface to Create, Remove, Duplicate, or Rename items in the catalog."""
    _uuid = "{97dd0fde-8548-4bbf-b2c5-909c6013b32d}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_description"] = _raise_uninitialized_error
        self.__dict__["_duplicate"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_save"] = _raise_uninitialized_error
        self.__dict__["_get_is_read_only"] = _raise_uninitialized_error
        self.__dict__["_get_child_names"] = _raise_uninitialized_error
        self.__dict__["_get_child_item_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_child_types"] = _raise_uninitialized_error
        self.__dict__["_add_default_child"] = _raise_uninitialized_error
        self.__dict__["_add_child_of_type"] = _raise_uninitialized_error
        self.__dict__["_contains_child_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalogItem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalogItem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalogItem = agcom.GUID(ICatalogItem._uuid)
        vtable_offset_local = ICatalogItem._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_description"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_duplicate"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+5, )
        self.__dict__["_save"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+6, )
        self.__dict__["_get_is_read_only"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_child_names"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+8, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_child_item_by_name"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_child_types"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+10, POINTER(agcom.SAFEARRAY))
        self.__dict__["_add_default_child"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_child_of_type"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+12, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_contains_child_item"] = IAGFUNCTYPE(pUnk, IID_ICatalogItem, vtable_offset_local+13, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogItem.__dict__ and type(ICatalogItem.__dict__[attrname]) == property:
            return ICatalogItem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogItem.")
    
    @property
    def name(self) -> str:
        """Get the name of the catalog item."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, pVal:str) -> None:
        """Get the name of the catalog item."""
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_pVal.COM_val))

    @property
    def description(self) -> str:
        """Get the description of the catalog item."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_description"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def duplicate(self) -> "ICatalogItem":
        """Duplicates the catalog item."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_duplicate"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    def remove(self) -> None:
        """Removes the catalog item."""
        agcls.evaluate_hresult(self.__dict__["_remove"]())

    def save(self) -> None:
        """Saves the catalog item."""
        agcls.evaluate_hresult(self.__dict__["_save"]())

    @property
    def is_read_only(self) -> bool:
        """Get whether the catalog item is read only."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_read_only"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def child_names(self) -> list:
        """Get the child names of the catalog item."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_child_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_child_item_by_name(self, childName:str) -> "ICatalogItem":
        """Get the child of the catalog item with the given name."""
        with agmarshall.BSTR_arg(childName) as arg_childName, \
             agmarshall.AgInterface_out_arg() as arg_ppUnk:
            agcls.evaluate_hresult(self.__dict__["_get_child_item_by_name"](arg_childName.COM_val, byref(arg_ppUnk.COM_val)))
            return arg_ppUnk.python_val

    @property
    def child_types(self) -> list:
        """Get the child types."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_child_types"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add_default_child(self, childName:str) -> "ICatalogItem":
        """Creates a new child with the given name and default type."""
        with agmarshall.BSTR_arg(childName) as arg_childName, \
             agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_add_default_child"](arg_childName.COM_val, byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    def add_child_of_type(self, childType:str, childName:str) -> "ICatalogItem":
        """Creates a new child with the given name and specified type."""
        with agmarshall.BSTR_arg(childType) as arg_childType, \
             agmarshall.BSTR_arg(childName) as arg_childName, \
             agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_add_child_of_type"](arg_childType.COM_val, arg_childName.COM_val, byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    def contains_child_item(self, childItem:str) -> bool:
        """Get whether the catalog item is contains the given child item."""
        with agmarshall.BSTR_arg(childItem) as arg_childItem, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_contains_child_item"](arg_childItem.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{97dd0fde-8548-4bbf-b2c5-909c6013b32d}", ICatalogItem)
agcls.AgTypeNameMap["ICatalogItem"] = ICatalogItem

class IAircraftBasicClimbModel(object):
    """Interface used to access the basic climb model options for a climb model of an aircraft in the Aviator catalog."""
    _uuid = "{db58182c-ba76-44ea-be78-5c529aea4de7}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_ceiling_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_ceiling_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_enable_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_enable_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicClimbModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicClimbModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicClimbModel = agcom.GUID(IAircraftBasicClimbModel._uuid)
        vtable_offset_local = IAircraftBasicClimbModel._vtable_offset - 1
        self.__dict__["_get_ceiling_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ceiling_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+5, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_enable_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicClimbModel, vtable_offset_local+18, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicClimbModel.__dict__ and type(IAircraftBasicClimbModel.__dict__[attrname]) == property:
            return IAircraftBasicClimbModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicClimbModel.")
    
    @property
    def ceiling_altitude(self) -> float:
        """Get the ceiling altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ceiling_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ceiling_altitude.setter
    def ceiling_altitude(self, newVal:float) -> None:
        """Put the ceiling altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ceiling_altitude"](arg_newVal.COM_val))

    @property
    def airspeed(self) -> float:
        """Get the airsepeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed type and value."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def altitude_rate(self) -> float:
        """Get the altitude rate."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """Put the altitude rate."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_aero_prop_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_aero_prop_fuel"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow_by_non_std_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow_by_non_std_density"](arg_newVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """Get the Sea Level Fuel Flow."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """Put the Sea Level Fuel Flow."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_newVal.COM_val))

    @property
    def enable_relative_airspeed_tolerance(self) -> bool:
        """Get whether to enable relative airspeed tolerance."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_relative_airspeed_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_relative_airspeed_tolerance.setter
    def enable_relative_airspeed_tolerance(self, newVal:bool) -> None:
        """Put whether to enable relative airspeed tolerance."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_relative_airspeed_tolerance"](arg_newVal.COM_val))

    @property
    def relative_airspeed_tolerance(self) -> float:
        """Get the relative airspeed tolerance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_airspeed_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_airspeed_tolerance.setter
    def relative_airspeed_tolerance(self, newVal:float) -> None:
        """Put the relative airspeed tolerance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_airspeed_tolerance"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{db58182c-ba76-44ea-be78-5c529aea4de7}", IAircraftBasicClimbModel)
agcls.AgTypeNameMap["IAircraftBasicClimbModel"] = IAircraftBasicClimbModel

class IAircraftBasicAccelerationModel(object):
    """Interface used to access the basic acceleration model options for an acceleration model of an aircraft in the Aviator catalog."""
    _uuid = "{a1a75a12-5730-4442-b84c-dc51c7783896}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_level_turns"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_transitions"] = _raise_uninitialized_error
        self.__dict__["_get_climb_and_descent_transitions"] = _raise_uninitialized_error
        self.__dict__["_get_aerodynamics"] = _raise_uninitialized_error
        self.__dict__["_get_propulsion"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicAccelerationModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicAccelerationModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicAccelerationModel = agcom.GUID(IAircraftBasicAccelerationModel._uuid)
        vtable_offset_local = IAircraftBasicAccelerationModel._vtable_offset - 1
        self.__dict__["_get_level_turns"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicAccelerationModel, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_attitude_transitions"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicAccelerationModel, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_climb_and_descent_transitions"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicAccelerationModel, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_aerodynamics"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicAccelerationModel, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_propulsion"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicAccelerationModel, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicAccelerationModel, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicAccelerationModel.__dict__ and type(IAircraftBasicAccelerationModel.__dict__[attrname]) == property:
            return IAircraftBasicAccelerationModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicAccelerationModel.")
    
    @property
    def level_turns(self) -> "ILevelTurns":
        """Get the level turns interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_turns"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def attitude_transitions(self) -> "IAttitudeTransitions":
        """Get the attitude transitions interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_transitions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def climb_and_descent_transitions(self) -> "IClimbAndDescentTransitions":
        """Get the climb and descent transitions interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_and_descent_transitions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def aerodynamics(self) -> "IAircraftAero":
        """Get the aerodynamics interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aerodynamics"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def propulsion(self) -> "IAircraftProp":
        """Get the propulsion interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_propulsion"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{a1a75a12-5730-4442-b84c-dc51c7783896}", IAircraftBasicAccelerationModel)
agcls.AgTypeNameMap["IAircraftBasicAccelerationModel"] = IAircraftBasicAccelerationModel

class IAircraftCategory(object):
    """Interface used to access the Aircraft Category in the Aviator Catalog."""
    _uuid = "{222d5a63-81e6-4ada-b309-e5ada49f075d}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aircraft_models"] = _raise_uninitialized_error
        self.__dict__["_get_missile_models"] = _raise_uninitialized_error
        self.__dict__["_get_rotorcraft_models"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftCategory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftCategory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftCategory = agcom.GUID(IAircraftCategory._uuid)
        vtable_offset_local = IAircraftCategory._vtable_offset - 1
        self.__dict__["_get_aircraft_models"] = IAGFUNCTYPE(pUnk, IID_IAircraftCategory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_missile_models"] = IAGFUNCTYPE(pUnk, IID_IAircraftCategory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_rotorcraft_models"] = IAGFUNCTYPE(pUnk, IID_IAircraftCategory, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftCategory.__dict__ and type(IAircraftCategory.__dict__[attrname]) == property:
            return IAircraftCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftCategory.")
    
    @property
    def aircraft_models(self) -> "IAircraftModels":
        """Get the user aircraft models."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aircraft_models"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def missile_models(self) -> "IMissileModels":
        """Get the user missile models."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_missile_models"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def rotorcraft_models(self) -> "IRotorcraftModels":
        """Get the user rotorcraft models."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotorcraft_models"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{222d5a63-81e6-4ada-b309-e5ada49f075d}", IAircraftCategory)
agcls.AgTypeNameMap["IAircraftCategory"] = IAircraftCategory

class IRunwayCategory(object):
    """Interface used to access runways in the Aviator catalog."""
    _uuid = "{76f32dcb-0127-47b6-b347-c78c18de45c6}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_user_runways"] = _raise_uninitialized_error
        self.__dict__["_get_arinc424_runways"] = _raise_uninitialized_error
        self.__dict__["_get_dafif_runways"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRunwayCategory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRunwayCategory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRunwayCategory = agcom.GUID(IRunwayCategory._uuid)
        vtable_offset_local = IRunwayCategory._vtable_offset - 1
        self.__dict__["_get_user_runways"] = IAGFUNCTYPE(pUnk, IID_IRunwayCategory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_arinc424_runways"] = IAGFUNCTYPE(pUnk, IID_IRunwayCategory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_dafif_runways"] = IAGFUNCTYPE(pUnk, IID_IRunwayCategory, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRunwayCategory.__dict__ and type(IRunwayCategory.__dict__[attrname]) == property:
            return IRunwayCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRunwayCategory.")
    
    @property
    def user_runways(self) -> "IUserRunwaySource":
        """Get the user runways."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_runways"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def arinc424_runways(self) -> "IARINC424Source":
        """Get the ARINC-424 runways."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_runways"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def dafif_runways(self) -> "IDAFIFSource":
        """Get the DAFIF runways."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dafif_runways"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{76f32dcb-0127-47b6-b347-c78c18de45c6}", IRunwayCategory)
agcls.AgTypeNameMap["IRunwayCategory"] = IRunwayCategory

class IBasicManeuverStrategy(object):
    """Interface used to access options for a Basic Maneuver Strategy."""
    _uuid = "{55e05a46-43d4-41d7-9866-2b1255b5d08f}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategy = agcom.GUID(IBasicManeuverStrategy._uuid)
        vtable_offset_local = IBasicManeuverStrategy._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategy.__dict__ and type(IBasicManeuverStrategy.__dict__[attrname]) == property:
            return IBasicManeuverStrategy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategy.")
    

agcls.AgClassCatalog.add_catalog_entry("{55e05a46-43d4-41d7-9866-2b1255b5d08f}", IBasicManeuverStrategy)
agcls.AgTypeNameMap["IBasicManeuverStrategy"] = IBasicManeuverStrategy

class IAircraftVTOL(object):
    """Interface used to access the VTOL options for an aircraft in the Aviator catalog."""
    _uuid = "{dbf209b7-90de-455a-b287-1b0d6c6fd823}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_vtol_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftVTOL._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftVTOL from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftVTOL = agcom.GUID(IAircraftVTOL._uuid)
        vtable_offset_local = IAircraftVTOL._vtable_offset - 1
        self.__dict__["_get_vtol_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOL, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOL, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftVTOL.__dict__ and type(IAircraftVTOL.__dict__[attrname]) == property:
            return IAircraftVTOL.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftVTOL.")
    
    def get_vtol_by_name(self, name:str) -> "IAircraftVTOLModel":
        """Gets the VTOL model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVTOLModel:
            agcls.evaluate_hresult(self.__dict__["_get_vtol_by_name"](arg_name.COM_val, byref(arg_ppVTOLModel.COM_val)))
            return arg_ppVTOLModel.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{dbf209b7-90de-455a-b287-1b0d6c6fd823}", IAircraftVTOL)
agcls.AgTypeNameMap["IAircraftVTOL"] = IAircraftVTOL

class IAircraftExternalAero(object):
    """Interface used to access the External File Aerodynamics options for the Basic Acceleration Model of an aircraft."""
    _uuid = "{8edd99ca-d7c9-4552-aff5-540ae780d319}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_forward_flight_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_filepath"] = _raise_uninitialized_error
        self.__dict__["_reload_forward_flight_file"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_ref_area"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_can_set_forward_flight_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_is_forward_flight_valid"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_filepath"] = _raise_uninitialized_error
        self.__dict__["_reload_takeoff_landing_file"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_ref_area"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_can_set_takeoff_landing_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_is_takeoff_landing_valid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftExternalAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftExternalAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftExternalAero = agcom.GUID(IAircraftExternalAero._uuid)
        vtable_offset_local = IAircraftExternalAero._vtable_offset - 1
        self.__dict__["_get_forward_flight_filepath"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_forward_flight_filepath"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.BSTR))
        self.__dict__["_reload_forward_flight_file"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_forward_flight_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_forward_flight_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_can_set_forward_flight_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_is_forward_flight_valid"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_takeoff_landing_filepath"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+8, POINTER(agcom.BSTR))
        self.__dict__["_set_takeoff_landing_filepath"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.BSTR))
        self.__dict__["_reload_takeoff_landing_file"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_get_takeoff_landing_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_takeoff_landing_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_can_set_takeoff_landing_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_is_takeoff_landing_valid"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalAero, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftExternalAero.__dict__ and type(IAircraftExternalAero.__dict__[attrname]) == property:
            return IAircraftExternalAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftExternalAero.")
    
    @property
    def forward_flight_filepath(self) -> str:
        """The filepath for the forward flight aero file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_forward_flight_filepath(self, filepath:str) -> str:
        """Set the filepath for the forward flight aero file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_filepath"](arg_filepath.COM_val, byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    def reload_forward_flight_file(self) -> str:
        """Reload the forward flight aero file."""
        with agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_reload_forward_flight_file"](byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    @property
    def forward_flight_ref_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_ref_area.setter
    def forward_flight_ref_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_ref_area"](arg_pVal.COM_val))

    @property
    def can_set_forward_flight_ref_area(self) -> bool:
        """Check whether you can set the reference area or whether it is specified in the file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_set_forward_flight_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def is_forward_flight_valid(self) -> bool:
        """Check whether the forward flight file is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_forward_flight_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def takeoff_landing_filepath(self) -> str:
        """The filepath for the takeoff and landing aero file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_takeoff_landing_filepath(self, filepath:str) -> str:
        """Set the filepath for the takeoff and landing aero file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_filepath"](arg_filepath.COM_val, byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    def reload_takeoff_landing_file(self) -> str:
        """Reload the takeoff and landing aero file."""
        with agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_reload_takeoff_landing_file"](byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    @property
    def takeoff_landing_ref_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_ref_area.setter
    def takeoff_landing_ref_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_ref_area"](arg_pVal.COM_val))

    @property
    def can_set_takeoff_landing_ref_area(self) -> bool:
        """Check whether you can set the reference area or whether it is specified in the file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_set_takeoff_landing_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def is_takeoff_landing_valid(self) -> bool:
        """Check whether the takeoff and landing file is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_takeoff_landing_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8edd99ca-d7c9-4552-aff5-540ae780d319}", IAircraftExternalAero)
agcls.AgTypeNameMap["IAircraftExternalAero"] = IAircraftExternalAero

class IAircraftSimpleProp(object):
    """Interface used to access the Simple Propulsion options for the Basic Acceleration Model of an aircraft."""
    _uuid = "{e765bd7d-75d3-4b0e-afa6-cff14f98226c}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_thrust_accel"] = _raise_uninitialized_error
        self.__dict__["_set_max_thrust_accel"] = _raise_uninitialized_error
        self.__dict__["_get_min_thrust_decel"] = _raise_uninitialized_error
        self.__dict__["_set_min_thrust_decel"] = _raise_uninitialized_error
        self.__dict__["_get_use_density_scaling"] = _raise_uninitialized_error
        self.__dict__["_get_density_ratio_exponent"] = _raise_uninitialized_error
        self.__dict__["_set_density_scaling"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftSimpleProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftSimpleProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftSimpleProp = agcom.GUID(IAircraftSimpleProp._uuid)
        vtable_offset_local = IAircraftSimpleProp._vtable_offset - 1
        self.__dict__["_get_max_thrust_accel"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleProp, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_thrust_accel"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleProp, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_min_thrust_decel"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_thrust_decel"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_use_density_scaling"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleProp, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_density_ratio_exponent"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleProp, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_density_scaling"] = IAGFUNCTYPE(pUnk, IID_IAircraftSimpleProp, vtable_offset_local+7, agcom.VARIANT_BOOL, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftSimpleProp.__dict__ and type(IAircraftSimpleProp.__dict__[attrname]) == property:
            return IAircraftSimpleProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftSimpleProp.")
    
    @property
    def max_thrust_accel(self) -> float:
        """The rate at which the aircraft speeds up at max throttle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_thrust_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_thrust_accel.setter
    def max_thrust_accel(self, pVal:float) -> None:
        """The rate at which the aircraft speeds up at max throttle."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_thrust_accel"](arg_pVal.COM_val))

    @property
    def min_thrust_decel(self) -> float:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_thrust_decel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_thrust_decel.setter
    def min_thrust_decel(self, pVal:float) -> None:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_thrust_decel"](arg_pVal.COM_val))

    @property
    def use_density_scaling(self) -> bool:
        """Opt whether to scale the accel/decel performance by the density ratio."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_density_scaling"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def density_ratio_exponent(self) -> float:
        """The relative impace of atmospheric density on the aircraft's performance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_ratio_exponent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_density_scaling(self, useScaling:bool, exponent:float) -> None:
        """Set the option to use density scaling and set the density ratio exponent."""
        with agmarshall.VARIANT_BOOL_arg(useScaling) as arg_useScaling, \
             agmarshall.DOUBLE_arg(exponent) as arg_exponent:
            agcls.evaluate_hresult(self.__dict__["_set_density_scaling"](arg_useScaling.COM_val, arg_exponent.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e765bd7d-75d3-4b0e-afa6-cff14f98226c}", IAircraftSimpleProp)
agcls.AgTypeNameMap["IAircraftSimpleProp"] = IAircraftSimpleProp

class IAircraftExternalProp(object):
    """Interface used to access the External File Propulsion options for the Basic Acceleration Model of an aircraft."""
    _uuid = "{bc0afa8f-6ccd-4369-8cfd-ee88f8251eec}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_prop_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_prop_filepath"] = _raise_uninitialized_error
        self.__dict__["_reload_prop_file"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        self.__dict__["_get_can_set_accel_decel"] = _raise_uninitialized_error
        self.__dict__["_get_max_thrust_accel"] = _raise_uninitialized_error
        self.__dict__["_set_max_thrust_accel"] = _raise_uninitialized_error
        self.__dict__["_get_min_thrust_decel"] = _raise_uninitialized_error
        self.__dict__["_set_min_thrust_decel"] = _raise_uninitialized_error
        self.__dict__["_get_use_density_scaling"] = _raise_uninitialized_error
        self.__dict__["_get_density_ratio_exponent"] = _raise_uninitialized_error
        self.__dict__["_set_density_scaling"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftExternalProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftExternalProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftExternalProp = agcom.GUID(IAircraftExternalProp._uuid)
        vtable_offset_local = IAircraftExternalProp._vtable_offset - 1
        self.__dict__["_get_prop_filepath"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_prop_filepath"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.BSTR))
        self.__dict__["_reload_prop_file"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_can_set_accel_decel"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_max_thrust_accel"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_thrust_accel"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_min_thrust_decel"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_thrust_decel"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_use_density_scaling"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_density_ratio_exponent"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_density_scaling"] = IAGFUNCTYPE(pUnk, IID_IAircraftExternalProp, vtable_offset_local+12, agcom.VARIANT_BOOL, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftExternalProp.__dict__ and type(IAircraftExternalProp.__dict__[attrname]) == property:
            return IAircraftExternalProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftExternalProp.")
    
    @property
    def prop_filepath(self) -> str:
        """The filepath for the prop file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_prop_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_prop_filepath(self, filepath:str) -> str:
        """Set the filepath for the prop file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_set_prop_filepath"](arg_filepath.COM_val, byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    def reload_prop_file(self) -> str:
        """Reload the prop file."""
        with agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_reload_prop_file"](byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    @property
    def is_valid(self) -> bool:
        """Check if the prop file is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def can_set_accel_decel(self) -> bool:
        """Check whether you can set the acceleration and deceleration values or whether they are specified in the file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_set_accel_decel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_thrust_accel(self) -> float:
        """The rate at which the aircraft speeds up at max throttle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_thrust_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_thrust_accel.setter
    def max_thrust_accel(self, pVal:float) -> None:
        """The rate at which the aircraft speeds up at max throttle."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_thrust_accel"](arg_pVal.COM_val))

    @property
    def min_thrust_decel(self) -> float:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_thrust_decel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_thrust_decel.setter
    def min_thrust_decel(self, pVal:float) -> None:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_thrust_decel"](arg_pVal.COM_val))

    @property
    def use_density_scaling(self) -> bool:
        """Opt whether to scale the accel/decel performance by the density ratio."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_density_scaling"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def density_ratio_exponent(self) -> float:
        """The relative impace of atmospheric density on the aircraft's performance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_ratio_exponent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_density_scaling(self, useScaling:bool, exponent:float) -> None:
        """Set the option to use density scaling and set the density ratio exponent."""
        with agmarshall.VARIANT_BOOL_arg(useScaling) as arg_useScaling, \
             agmarshall.DOUBLE_arg(exponent) as arg_exponent:
            agcls.evaluate_hresult(self.__dict__["_set_density_scaling"](arg_useScaling.COM_val, arg_exponent.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{bc0afa8f-6ccd-4369-8cfd-ee88f8251eec}", IAircraftExternalProp)
agcls.AgTypeNameMap["IAircraftExternalProp"] = IAircraftExternalProp

class IAircraftBasicFixedWingProp(object):
    """Interface used to access the Basic Fixed Wing Propulsion options for the Basic Acceleration Model of an aircraft."""
    _uuid = "{0c92bc71-bb3f-4953-8171-6efb0d0ab922}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_propulsion_mode"] = _raise_uninitialized_error
        self.__dict__["_set_propulsion_mode"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_rpm"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_rpm"] = _raise_uninitialized_error
        self.__dict__["_get_min_power_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_min_power_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_min_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_min_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_power_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_max_power_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_max_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_thrust_accel"] = _raise_uninitialized_error
        self.__dict__["_set_max_thrust_accel"] = _raise_uninitialized_error
        self.__dict__["_get_min_thrust_decel"] = _raise_uninitialized_error
        self.__dict__["_set_min_thrust_decel"] = _raise_uninitialized_error
        self.__dict__["_get_use_density_scaling"] = _raise_uninitialized_error
        self.__dict__["_get_density_ratio_exponent"] = _raise_uninitialized_error
        self.__dict__["_set_density_scaling"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicFixedWingProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicFixedWingProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicFixedWingProp = agcom.GUID(IAircraftBasicFixedWingProp._uuid)
        vtable_offset_local = IAircraftBasicFixedWingProp._vtable_offset - 1
        self.__dict__["_get_propulsion_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_propulsion_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_propeller_rpm"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_propeller_rpm"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_min_power_thrust"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_power_thrust"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_min_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_power_thrust"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_power_thrust"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_max_thrust_accel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_thrust_accel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_min_thrust_decel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_thrust_decel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_use_density_scaling"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_density_ratio_exponent"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_density_scaling"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingProp, vtable_offset_local+23, agcom.VARIANT_BOOL, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicFixedWingProp.__dict__ and type(IAircraftBasicFixedWingProp.__dict__[attrname]) == property:
            return IAircraftBasicFixedWingProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicFixedWingProp.")
    
    @property
    def propulsion_mode(self) -> "AVTR_BASIC_FIXED_WING_PROP_MODE":
        """The option of whether to specify net thrust or net power."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_FIXED_WING_PROP_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propulsion_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propulsion_mode.setter
    def propulsion_mode(self, pVal:"AVTR_BASIC_FIXED_WING_PROP_MODE") -> None:
        """The option of whether to specify net thrust or net power."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_FIXED_WING_PROP_MODE, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_propulsion_mode"](arg_pVal.COM_val))

    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_count.setter
    def propeller_count(self, pVal:int) -> None:
        """The number of propellers."""
        with agmarshall.LONG_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_count"](arg_pVal.COM_val))

    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_diameter.setter
    def propeller_diameter(self, pVal:float) -> None:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_diameter"](arg_pVal.COM_val))

    @property
    def propeller_rpm(self) -> float:
        """The propeller RPM."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_rpm"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_rpm.setter
    def propeller_rpm(self, pVal:float) -> None:
        """The propeller RPM."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_rpm"](arg_pVal.COM_val))

    @property
    def min_power_thrust(self) -> float:
        """The minimum power/thrust depending on the propulsion mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_power_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_power_thrust.setter
    def min_power_thrust(self, pVal:float) -> None:
        """The minimum power/thrust depending on the propulsion mode."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_power_thrust"](arg_pVal.COM_val))

    @property
    def min_fuel_flow(self) -> float:
        """The fuel flow for the minimum thrust/power setting."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_fuel_flow.setter
    def min_fuel_flow(self, pVal:float) -> None:
        """The fuel flow for the minimum thrust/power setting."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_fuel_flow"](arg_pVal.COM_val))

    @property
    def max_power_thrust(self) -> float:
        """The maximum power/thrust depending on the propulsion mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_power_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_power_thrust.setter
    def max_power_thrust(self, pVal:float) -> None:
        """The maximum power/thrust depending on the propulsion mode."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_power_thrust"](arg_pVal.COM_val))

    @property
    def max_fuel_flow(self) -> float:
        """The fuel flow for the maximum thrust/power setting."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_fuel_flow.setter
    def max_fuel_flow(self, pVal:float) -> None:
        """The fuel flow for the maximum thrust/power setting."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_fuel_flow"](arg_pVal.COM_val))

    @property
    def max_thrust_accel(self) -> float:
        """The rate at which the aircraft speeds up at max throttle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_thrust_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_thrust_accel.setter
    def max_thrust_accel(self, pVal:float) -> None:
        """The rate at which the aircraft speeds up at max throttle."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_thrust_accel"](arg_pVal.COM_val))

    @property
    def min_thrust_decel(self) -> float:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_thrust_decel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_thrust_decel.setter
    def min_thrust_decel(self, pVal:float) -> None:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_thrust_decel"](arg_pVal.COM_val))

    @property
    def use_density_scaling(self) -> bool:
        """Opt whether to scale the accel/decel performance by the density ratio."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_density_scaling"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def density_ratio_exponent(self) -> float:
        """The relative impace of atmospheric density on the aircraft's performance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_ratio_exponent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_density_scaling(self, useScaling:bool, exponent:float) -> None:
        """Set the option to use density scaling and set the density ratio exponent."""
        with agmarshall.VARIANT_BOOL_arg(useScaling) as arg_useScaling, \
             agmarshall.DOUBLE_arg(exponent) as arg_exponent:
            agcls.evaluate_hresult(self.__dict__["_set_density_scaling"](arg_useScaling.COM_val, arg_exponent.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0c92bc71-bb3f-4953-8171-6efb0d0ab922}", IAircraftBasicFixedWingProp)
agcls.AgTypeNameMap["IAircraftBasicFixedWingProp"] = IAircraftBasicFixedWingProp

class IAircraftAdvClimbModel(object):
    """Interface used to access the advanced climb model options for a climb model of an aircraft in the Aviator catalog."""
    _uuid = "{3e994b97-b141-4cee-aada-d02409dc4756}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_climb_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_climb_speed_type"] = _raise_uninitialized_error
        self.__dict__["_get_climb_override_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_climb_override_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_climb_override_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_set_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_get_use_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_limit"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_limit"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_limit_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_use_flight_path_angle_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_flight_path_angle_limit"] = _raise_uninitialized_error
        self.__dict__["_get_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_compute_delta_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_compute_delta_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAdvClimbModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvClimbModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAdvClimbModel = agcom.GUID(IAircraftAdvClimbModel._uuid)
        vtable_offset_local = IAircraftAdvClimbModel._vtable_offset - 1
        self.__dict__["_get_climb_speed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_climb_speed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_climb_override_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_climb_override_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_climb_override_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+5, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_airspeed_limit_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+14, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_use_flight_path_angle_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_flight_path_angle_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+17, POINTER(agcom.VARIANT))
        self.__dict__["_set_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+18, agcom.VARIANT)
        self.__dict__["_get_compute_delta_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_compute_delta_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvClimbModel, vtable_offset_local+21, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvClimbModel.__dict__ and type(IAircraftAdvClimbModel.__dict__[attrname]) == property:
            return IAircraftAdvClimbModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvClimbModel.")
    
    @property
    def climb_speed_type(self) -> "AVTR_CLIMB_SPEED_TYPE":
        """The mode to calculate the aircraft's airspeed while climbing."""
        with agmarshall.AgEnum_arg(AVTR_CLIMB_SPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @climb_speed_type.setter
    def climb_speed_type(self, newVal:"AVTR_CLIMB_SPEED_TYPE") -> None:
        """The mode to calculate the aircraft's airspeed while climbing."""
        with agmarshall.AgEnum_arg(AVTR_CLIMB_SPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_climb_speed_type"](arg_newVal.COM_val))

    @property
    def climb_override_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the override airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_override_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def climb_override_airspeed(self) -> float:
        """Get the override airsepeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_override_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_climb_override_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the override airspeed and airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_climb_override_airspeed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def use_afterburner(self) -> bool:
        """Opt to use the engine's afterburner when climbing if available."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_afterburner"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_afterburner.setter
    def use_afterburner(self, newVal:bool) -> None:
        """Opt to use the engine's afterburner when climbing if available."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_afterburner"](arg_newVal.COM_val))

    @property
    def use_airspeed_limit(self) -> bool:
        """Opt to limit the airspeed below a specified altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_airspeed_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_airspeed_limit.setter
    def use_airspeed_limit(self, newVal:bool) -> None:
        """Opt to limit the airspeed below a specified altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_airspeed_limit"](arg_newVal.COM_val))

    @property
    def altitude_limit(self) -> float:
        """The altitude threshold, below which the airspeed limit will be applied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_limit.setter
    def altitude_limit(self, newVal:float) -> None:
        """The altitude threshold, below which the airspeed limit will be applied."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_limit"](arg_newVal.COM_val))

    @property
    def airspeed_limit_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the airspeed limit type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_limit_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_limit(self) -> float:
        """Get the airsepeed limit below the altitude threshold."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed_limit(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed limit and airspeed type below the altitude threshold."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_limit"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def use_flight_path_angle_limit(self) -> bool:
        """Opt to limit the flight path angle."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_flight_path_angle_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_flight_path_angle_limit.setter
    def use_flight_path_angle_limit(self, newVal:bool) -> None:
        """Opt to limit the flight path angle."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_flight_path_angle_limit"](arg_newVal.COM_val))

    @property
    def flight_path_angle(self) -> typing.Any:
        """Get the flight path angle limit."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_flight_path_angle(self, angle:typing.Any) -> None:
        """Enable the flight path angle limit an set the flight path angle value."""
        with agmarshall.VARIANT_arg(angle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_set_flight_path_angle"](arg_angle.COM_val))

    @property
    def compute_delta_altitude(self) -> float:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compute_delta_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compute_delta_altitude.setter
    def compute_delta_altitude(self, newVal:float) -> None:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compute_delta_altitude"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{3e994b97-b141-4cee-aada-d02409dc4756}", IAircraftAdvClimbModel)
agcls.AgTypeNameMap["IAircraftAdvClimbModel"] = IAircraftAdvClimbModel

class IAircraftBasicCruiseModel(object):
    """Interface used to access the basic cruise model options for a cruise model of an aircraft in the Aviator catalog."""
    _uuid = "{0416553d-3446-49c1-8b44-e677197bd059}"
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_ceiling_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_ceiling_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_endurance_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_endurance_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_range_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_range_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_perf_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_perf_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_min_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_endurance_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_endurance_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_range_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_range_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_perf_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_perf_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicCruiseModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicCruiseModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicCruiseModel = agcom.GUID(IAircraftBasicCruiseModel._uuid)
        vtable_offset_local = IAircraftBasicCruiseModel._vtable_offset - 1
        self.__dict__["_get_ceiling_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ceiling_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_endurance_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_endurance_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_range_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_range_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_max_perf_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_perf_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_min_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_max_endurance_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_endurance_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_max_range_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_range_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_max_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_max_perf_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_perf_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicCruiseModel, vtable_offset_local+31, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicCruiseModel.__dict__ and type(IAircraftBasicCruiseModel.__dict__[attrname]) == property:
            return IAircraftBasicCruiseModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicCruiseModel.")
    
    @property
    def ceiling_altitude(self) -> float:
        """The maximum altitude above mean sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ceiling_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ceiling_altitude.setter
    def ceiling_altitude(self, newVal:float) -> None:
        """The maximum altitude above mean sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ceiling_altitude"](arg_newVal.COM_val))

    @property
    def default_cruise_altitude(self) -> float:
        """The aircraft's default cruise altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @default_cruise_altitude.setter
    def default_cruise_altitude(self, newVal:float) -> None:
        """The aircraft's default cruise altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def use_aero_prop_fuel(self) -> bool:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_aero_prop_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_aero_prop_fuel"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow_by_non_std_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow_by_non_std_density"](arg_newVal.COM_val))

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @airspeed_type.setter
    def airspeed_type(self, newVal:"AVTR_AIRSPEED_TYPE") -> None:
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_type"](arg_newVal.COM_val))

    @property
    def min_airspeed(self) -> float:
        """The minimum cruising airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_airspeed.setter
    def min_airspeed(self, newVal:float) -> None:
        """The minimum cruising airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_airspeed"](arg_newVal.COM_val))

    @property
    def max_endurance_airspeed(self) -> float:
        """The cruising airspeed that will provide the maximum flying time for the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_endurance_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_endurance_airspeed.setter
    def max_endurance_airspeed(self, newVal:float) -> None:
        """The cruising airspeed that will provide the maximum flying time for the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_endurance_airspeed"](arg_newVal.COM_val))

    @property
    def max_range_airspeed(self) -> float:
        """The maximum range cruising airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_range_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_range_airspeed.setter
    def max_range_airspeed(self, newVal:float) -> None:
        """The maximum range cruising airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_range_airspeed"](arg_newVal.COM_val))

    @property
    def max_airspeed(self) -> float:
        """The maximum cruisng airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_airspeed.setter
    def max_airspeed(self, newVal:float) -> None:
        """The maximum cruisng airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_airspeed"](arg_newVal.COM_val))

    @property
    def max_perf_airspeed(self) -> float:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_perf_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_perf_airspeed.setter
    def max_perf_airspeed(self, newVal:float) -> None:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_perf_airspeed"](arg_newVal.COM_val))

    @property
    def min_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the minimum cruising airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_airspeed_fuel_flow.setter
    def min_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the minimum cruising airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_airspeed_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_endurance_fuel_flow(self) -> float:
        """The fuel flow for the maximum endurance cruising airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_endurance_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_endurance_fuel_flow.setter
    def max_endurance_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximumendurance cruising airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_endurance_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_range_fuel_flow(self) -> float:
        """The fuel flow for the maximum range cruising airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_range_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_range_fuel_flow.setter
    def max_range_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum range cruising airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_range_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum cruising airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_airspeed_fuel_flow.setter
    def max_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum cruising airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_airspeed_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_perf_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum performance cruising airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_perf_airspeed_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_perf_airspeed_fuel_flow.setter
    def max_perf_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum performance cruising airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_perf_airspeed_fuel_flow"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{0416553d-3446-49c1-8b44-e677197bd059}", IAircraftBasicCruiseModel)
agcls.AgTypeNameMap["IAircraftBasicCruiseModel"] = IAircraftBasicCruiseModel

class IAircraftAdvCruiseModel(object):
    """Interface used to access the advanced cruise model options for a cruise model of an aircraft in the Aviator catalog."""
    _uuid = "{49d2ea85-8dad-44b8-8ebd-596a3ef22c88}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_max_perf_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_perf_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_use_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_limit"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_limit"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_limit_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_compute_delta_downrange"] = _raise_uninitialized_error
        self.__dict__["_set_compute_delta_downrange"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAdvCruiseModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvCruiseModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAdvCruiseModel = agcom.GUID(IAircraftAdvCruiseModel._uuid)
        vtable_offset_local = IAircraftAdvCruiseModel._vtable_offset - 1
        self.__dict__["_get_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_max_perf_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_max_perf_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_use_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_airspeed_limit_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+11, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compute_delta_downrange"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_compute_delta_downrange"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvCruiseModel, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvCruiseModel.__dict__ and type(IAircraftAdvCruiseModel.__dict__[attrname]) == property:
            return IAircraftAdvCruiseModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvCruiseModel.")
    
    @property
    def default_cruise_altitude(self) -> float:
        """The aircraft's default cruising altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @default_cruise_altitude.setter
    def default_cruise_altitude(self, newVal:float) -> None:
        """The aircraft's default cruising altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def max_perf_airspeed(self) -> "AVTR_CRUISE_MAX_PERF_SPEED_TYPE":
        """The method for defining the maximum performance airspeed of the aircraft with respect to its altitude."""
        with agmarshall.AgEnum_arg(AVTR_CRUISE_MAX_PERF_SPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_perf_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_perf_airspeed.setter
    def max_perf_airspeed(self, newVal:"AVTR_CRUISE_MAX_PERF_SPEED_TYPE") -> None:
        """The method for defining the maximum performance airspeed of the aircraft with respect to its altitude."""
        with agmarshall.AgEnum_arg(AVTR_CRUISE_MAX_PERF_SPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_perf_airspeed"](arg_newVal.COM_val))

    @property
    def use_airspeed_limit(self) -> bool:
        """Opt to limit the airspeed below a specified altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_airspeed_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_airspeed_limit.setter
    def use_airspeed_limit(self, newVal:bool) -> None:
        """Opt to limit the airspeed below a specified altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_airspeed_limit"](arg_newVal.COM_val))

    @property
    def altitude_limit(self) -> float:
        """The altitude threshold, below which the airspeed limit will be applied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_limit.setter
    def altitude_limit(self, newVal:float) -> None:
        """The altitude threshold, below which the airspeed limit will be applied."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_limit"](arg_newVal.COM_val))

    @property
    def airspeed_limit_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the airspeed limit type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_limit_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_limit(self) -> float:
        """Get the airsepeed limit below the altitude threshold."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed_limit(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed limit and airspeed type below the altitude threshold."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_limit"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def compute_delta_downrange(self) -> float:
        """The maximum change in downrange distance in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compute_delta_downrange"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compute_delta_downrange.setter
    def compute_delta_downrange(self, newVal:float) -> None:
        """The maximum change in downrange distance in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compute_delta_downrange"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{49d2ea85-8dad-44b8-8ebd-596a3ef22c88}", IAircraftAdvCruiseModel)
agcls.AgTypeNameMap["IAircraftAdvCruiseModel"] = IAircraftAdvCruiseModel

class IAircraftBasicDescentModel(object):
    """Interface used to access the basic descent model options for a descent model of an aircraft in the Aviator catalog."""
    _uuid = "{b2fec1db-7e30-401b-91cf-b78db9b1401b}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_ceiling_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_ceiling_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_enable_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_enable_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_relative_airspeed_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicDescentModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicDescentModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicDescentModel = agcom.GUID(IAircraftBasicDescentModel._uuid)
        vtable_offset_local = IAircraftBasicDescentModel._vtable_offset - 1
        self.__dict__["_get_ceiling_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ceiling_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+5, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_enable_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_relative_airspeed_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicDescentModel, vtable_offset_local+18, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicDescentModel.__dict__ and type(IAircraftBasicDescentModel.__dict__[attrname]) == property:
            return IAircraftBasicDescentModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicDescentModel.")
    
    @property
    def ceiling_altitude(self) -> float:
        """Get the ceiling altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ceiling_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ceiling_altitude.setter
    def ceiling_altitude(self, newVal:float) -> None:
        """Put the ceiling altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ceiling_altitude"](arg_newVal.COM_val))

    @property
    def airspeed(self) -> float:
        """Get the airsepeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed type and value."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def altitude_rate(self) -> float:
        """Get the altitude rate."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """Put the altitude rate."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_aero_prop_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_aero_prop_fuel"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow_by_non_std_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow_by_non_std_density"](arg_newVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """Get the Sea Level Fuel Flow."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """Put the Sea Level Fuel Flow."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_newVal.COM_val))

    @property
    def enable_relative_airspeed_tolerance(self) -> bool:
        """Get whether to enable relative airspeed tolerance."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_relative_airspeed_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_relative_airspeed_tolerance.setter
    def enable_relative_airspeed_tolerance(self, newVal:bool) -> None:
        """Put whether to enable relative airspeed tolerance."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_relative_airspeed_tolerance"](arg_newVal.COM_val))

    @property
    def relative_airspeed_tolerance(self) -> float:
        """Get the relative airspeed tolerance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_airspeed_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_airspeed_tolerance.setter
    def relative_airspeed_tolerance(self, newVal:float) -> None:
        """Put the relative airspeed tolerance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_airspeed_tolerance"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{b2fec1db-7e30-401b-91cf-b78db9b1401b}", IAircraftBasicDescentModel)
agcls.AgTypeNameMap["IAircraftBasicDescentModel"] = IAircraftBasicDescentModel

class IAircraftAdvDescentModel(object):
    """Interface used to access the advanced descent model options for a descent model of an aircraft in the Aviator catalog."""
    _uuid = "{e668da71-2641-4751-a2eb-880eff768017}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_descent_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_descent_speed_type"] = _raise_uninitialized_error
        self.__dict__["_get_descent_stall_speed_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_descent_stall_speed_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_descent_override_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_descent_override_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_descent_override_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_speedbrakes"] = _raise_uninitialized_error
        self.__dict__["_set_speedbrakes"] = _raise_uninitialized_error
        self.__dict__["_get_use_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_limit"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_limit"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_limit_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_compute_delta_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_compute_delta_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAdvDescentModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvDescentModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAdvDescentModel = agcom.GUID(IAircraftAdvDescentModel._uuid)
        vtable_offset_local = IAircraftAdvDescentModel._vtable_offset - 1
        self.__dict__["_get_descent_speed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_descent_speed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_descent_stall_speed_ratio"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_descent_stall_speed_ratio"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_descent_override_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_get_descent_override_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_descent_override_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+7, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_speedbrakes"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_speedbrakes"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_use_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_airspeed_limit_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+16, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compute_delta_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_compute_delta_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvDescentModel, vtable_offset_local+19, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvDescentModel.__dict__ and type(IAircraftAdvDescentModel.__dict__[attrname]) == property:
            return IAircraftAdvDescentModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvDescentModel.")
    
    @property
    def descent_speed_type(self) -> "AVTR_DESCENT_SPEED_TYPE":
        """The mode to calculate the aircraft's airspeed while descending ."""
        with agmarshall.AgEnum_arg(AVTR_DESCENT_SPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @descent_speed_type.setter
    def descent_speed_type(self, newVal:"AVTR_DESCENT_SPEED_TYPE") -> None:
        """The mode to calculate the aircraft's airspeed while descending ."""
        with agmarshall.AgEnum_arg(AVTR_DESCENT_SPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_descent_speed_type"](arg_newVal.COM_val))

    @property
    def descent_stall_speed_ratio(self) -> float:
        """The ratio of the airspeed upon leaving the ground to the stall speed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_stall_speed_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @descent_stall_speed_ratio.setter
    def descent_stall_speed_ratio(self, newVal:float) -> None:
        """The ratio of the airspeed upon leaving the ground to the stall speed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_descent_stall_speed_ratio"](arg_newVal.COM_val))

    @property
    def descent_override_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the override airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_override_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def descent_override_airspeed(self) -> float:
        """Get the override airsepeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_override_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_descent_override_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the override airspeed and airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_descent_override_airspeed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def speedbrakes(self) -> float:
        """The extension of the speedbrakes during the landing."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_speedbrakes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @speedbrakes.setter
    def speedbrakes(self, newVal:float) -> None:
        """The extension of the speedbrakes during the landing."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_speedbrakes"](arg_newVal.COM_val))

    @property
    def use_airspeed_limit(self) -> bool:
        """Opt to limit the airspeed below a specified altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_airspeed_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_airspeed_limit.setter
    def use_airspeed_limit(self, newVal:bool) -> None:
        """Opt to limit the airspeed below a specified altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_airspeed_limit"](arg_newVal.COM_val))

    @property
    def altitude_limit(self) -> float:
        """The altitude threshold, below which the airspeed limit will be applied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_limit.setter
    def altitude_limit(self, newVal:float) -> None:
        """The altitude threshold, below which the airspeed limit will be applied."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_limit"](arg_newVal.COM_val))

    @property
    def airspeed_limit_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the airspeed limit type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_limit_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_limit(self) -> float:
        """Get the airsepeed limit below the altitude threshold."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed_limit(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed limit and airspeed type below the altitude threshold."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_limit"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def compute_delta_altitude(self) -> float:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compute_delta_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compute_delta_altitude.setter
    def compute_delta_altitude(self, newVal:float) -> None:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compute_delta_altitude"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{e668da71-2641-4751-a2eb-880eff768017}", IAircraftAdvDescentModel)
agcls.AgTypeNameMap["IAircraftAdvDescentModel"] = IAircraftAdvDescentModel

class IAircraftBasicLandingModel(object):
    """Interface used to access the basic landing model options for a landing model of an aircraft in the Aviator catalog."""
    _uuid = "{3e5cc8b6-970b-4412-8ee7-4863224e2ae5}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_landing_speed"] = _raise_uninitialized_error
        self.__dict__["_get_landing_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_landing_speed"] = _raise_uninitialized_error
        self.__dict__["_get_sea_level_ground_roll"] = _raise_uninitialized_error
        self.__dict__["_set_sea_level_ground_roll"] = _raise_uninitialized_error
        self.__dict__["_get_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicLandingModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicLandingModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicLandingModel = agcom.GUID(IAircraftBasicLandingModel._uuid)
        vtable_offset_local = IAircraftBasicLandingModel._vtable_offset - 1
        self.__dict__["_get_landing_speed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_get_landing_speed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_landing_speed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+3, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_sea_level_ground_roll"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_sea_level_ground_roll"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicLandingModel, vtable_offset_local+12, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicLandingModel.__dict__ and type(IAircraftBasicLandingModel.__dict__[attrname]) == property:
            return IAircraftBasicLandingModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicLandingModel.")
    
    @property
    def landing_speed(self) -> float:
        """The landing speed of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_landing_speed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def landing_speed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The landing speed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_landing_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_landing_speed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the landing speed of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_landing_speed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def sea_level_ground_roll(self) -> float:
        """The distance the aircraft travels along the ground while decelerating to a stop at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sea_level_ground_roll"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sea_level_ground_roll.setter
    def sea_level_ground_roll(self, newVal:float) -> None:
        """The distance the aircraft travels along the ground while decelerating to a stop at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sea_level_ground_roll"](arg_newVal.COM_val))

    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_aero_prop_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_aero_prop_fuel"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow_by_non_std_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow_by_non_std_density"](arg_newVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """Get the Sea Level Fuel Flow."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """Put the Sea Level Fuel Flow."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{3e5cc8b6-970b-4412-8ee7-4863224e2ae5}", IAircraftBasicLandingModel)
agcls.AgTypeNameMap["IAircraftBasicLandingModel"] = IAircraftBasicLandingModel

class IAircraftAdvLandingModel(object):
    """Interface used to access the advanced landing model options for a landing model of an aircraft in the Aviator catalog."""
    _uuid = "{bee9a455-0eeb-493f-aff6-93a11be34090}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_landing_speed_mode"] = _raise_uninitialized_error
        self.__dict__["_set_landing_speed_mode"] = _raise_uninitialized_error
        self.__dict__["_get_stall_speed_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_stall_speed_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_angle_of_attack"] = _raise_uninitialized_error
        self.__dict__["_set_angle_of_attack"] = _raise_uninitialized_error
        self.__dict__["_get_flaps"] = _raise_uninitialized_error
        self.__dict__["_set_flaps"] = _raise_uninitialized_error
        self.__dict__["_get_speedbrakes"] = _raise_uninitialized_error
        self.__dict__["_set_speedbrakes"] = _raise_uninitialized_error
        self.__dict__["_get_braking_decel_g"] = _raise_uninitialized_error
        self.__dict__["_set_braking_decel_g"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAdvLandingModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvLandingModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAdvLandingModel = agcom.GUID(IAircraftAdvLandingModel._uuid)
        vtable_offset_local = IAircraftAdvLandingModel._vtable_offset - 1
        self.__dict__["_get_landing_speed_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_landing_speed_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_stall_speed_ratio"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stall_speed_ratio"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_angle_of_attack"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_angle_of_attack"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_flaps"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_flaps"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_speedbrakes"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_speedbrakes"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_braking_decel_g"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_braking_decel_g"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvLandingModel, vtable_offset_local+13, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvLandingModel.__dict__ and type(IAircraftAdvLandingModel.__dict__[attrname]) == property:
            return IAircraftAdvLandingModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvLandingModel.")
    
    @property
    def landing_speed_mode(self) -> "AVTR_TAKEOFF_LANDING_SPEED_MODE":
        """The mode to calculate the aircraft's speed at wheels down."""
        with agmarshall.AgEnum_arg(AVTR_TAKEOFF_LANDING_SPEED_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_landing_speed_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @landing_speed_mode.setter
    def landing_speed_mode(self, newVal:"AVTR_TAKEOFF_LANDING_SPEED_MODE") -> None:
        """The mode to calculate the aircraft's speed at wheels down."""
        with agmarshall.AgEnum_arg(AVTR_TAKEOFF_LANDING_SPEED_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_landing_speed_mode"](arg_newVal.COM_val))

    @property
    def stall_speed_ratio(self) -> float:
        """The ratio of the airspeed to the stall speed at wheels down."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stall_speed_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stall_speed_ratio(self, stallSpeedRatio:float) -> None:
        """Set the landing speed mode to StallSpeedRatio and specify the stall speed ratio."""
        with agmarshall.DOUBLE_arg(stallSpeedRatio) as arg_stallSpeedRatio:
            agcls.evaluate_hresult(self.__dict__["_set_stall_speed_ratio"](arg_stallSpeedRatio.COM_val))

    @property
    def angle_of_attack(self) -> typing.Any:
        """The Angle of Attack at wheels down."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_angle_of_attack"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_angle_of_attack(self, angleOfAttack:typing.Any) -> None:
        """Set the landing speed mode to AngleOfAttack and specify the angle of attack"""
        with agmarshall.VARIANT_arg(angleOfAttack) as arg_angleOfAttack:
            agcls.evaluate_hresult(self.__dict__["_set_angle_of_attack"](arg_angleOfAttack.COM_val))

    @property
    def flaps(self) -> float:
        """The extension of the flaps during the landing."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flaps"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flaps.setter
    def flaps(self, newVal:float) -> None:
        """The extension of the flaps during the landing."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flaps"](arg_newVal.COM_val))

    @property
    def speedbrakes(self) -> float:
        """The extension of the speedbrakes during the landing."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_speedbrakes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @speedbrakes.setter
    def speedbrakes(self, newVal:float) -> None:
        """The extension of the speedbrakes during the landing."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_speedbrakes"](arg_newVal.COM_val))

    @property
    def braking_decel_g(self) -> float:
        """The deceleration rate, in G, when braking."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_braking_decel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @braking_decel_g.setter
    def braking_decel_g(self, newVal:float) -> None:
        """The deceleration rate, in G, when braking."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_braking_decel_g"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{bee9a455-0eeb-493f-aff6-93a11be34090}", IAircraftAdvLandingModel)
agcls.AgTypeNameMap["IAircraftAdvLandingModel"] = IAircraftAdvLandingModel

class IAircraftBasicTakeoffModel(object):
    """Interface used to access the basic takeoff model options for a takeoff model of an aircraft in the Aviator catalog."""
    _uuid = "{981697a5-e6b3-45d7-a3d4-7caec2237c0a}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_takeoff_speed"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_speed"] = _raise_uninitialized_error
        self.__dict__["_get_sea_level_ground_roll"] = _raise_uninitialized_error
        self.__dict__["_set_sea_level_ground_roll"] = _raise_uninitialized_error
        self.__dict__["_get_departure_speed"] = _raise_uninitialized_error
        self.__dict__["_get_departure_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_departure_speed"] = _raise_uninitialized_error
        self.__dict__["_get_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_get_accel_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_accel_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_departure_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_departure_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicTakeoffModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicTakeoffModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicTakeoffModel = agcom.GUID(IAircraftBasicTakeoffModel._uuid)
        vtable_offset_local = IAircraftBasicTakeoffModel._vtable_offset - 1
        self.__dict__["_get_takeoff_speed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_get_takeoff_speed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_takeoff_speed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+3, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_sea_level_ground_roll"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_sea_level_ground_roll"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_departure_speed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_get_departure_speed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_departure_speed"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+8, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_accel_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_departure_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_departure_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicTakeoffModel, vtable_offset_local+17, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicTakeoffModel.__dict__ and type(IAircraftBasicTakeoffModel.__dict__[attrname]) == property:
            return IAircraftBasicTakeoffModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicTakeoffModel.")
    
    @property
    def takeoff_speed(self) -> float:
        """The speed to which the aircraft accelerates on its ground roll for takeoff."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_speed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def takeoff_speed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The takeoff speed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_takeoff_speed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the takeoff speed of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_speed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def sea_level_ground_roll(self) -> float:
        """The distance the aircraft travels along the ground while accelerationg to takeoff at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sea_level_ground_roll"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sea_level_ground_roll.setter
    def sea_level_ground_roll(self, newVal:float) -> None:
        """The distance the aircraft travels along the ground while accelerationg to takeoff at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sea_level_ground_roll"](arg_newVal.COM_val))

    @property
    def departure_speed(self) -> float:
        """The aircraft's speed upon leaving the ground."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_speed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def departure_speed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The departure speed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_departure_speed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the departure speed of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_departure_speed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_aero_prop_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_aero_prop_fuel"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow_by_non_std_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow_by_non_std_density"](arg_newVal.COM_val))

    @property
    def accel_fuel_flow(self) -> float:
        """The aircraft's fuel flow rate while accelerating during takeoff."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_fuel_flow.setter
    def accel_fuel_flow(self, newVal:float) -> None:
        """The aircraft's fuel flow rate while accelerating during takeoff."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_fuel_flow"](arg_newVal.COM_val))

    @property
    def departure_fuel_flow(self) -> float:
        """The aircraft's fuel flow rate at departure speed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @departure_fuel_flow.setter
    def departure_fuel_flow(self, newVal:float) -> None:
        """The aircraft's fuel flow rate at departure speed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_departure_fuel_flow"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{981697a5-e6b3-45d7-a3d4-7caec2237c0a}", IAircraftBasicTakeoffModel)
agcls.AgTypeNameMap["IAircraftBasicTakeoffModel"] = IAircraftBasicTakeoffModel

class IAircraftAdvTakeoffModel(object):
    """Interface used to access the advanced takeoff model options for a takeoff model of an aircraft in the Aviator catalog."""
    _uuid = "{3290c530-62d6-49d7-8d89-69f0c3e6148d}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_takeoff_speed_mode"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_speed_mode"] = _raise_uninitialized_error
        self.__dict__["_get_stall_speed_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_stall_speed_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_angle_of_attack"] = _raise_uninitialized_error
        self.__dict__["_set_angle_of_attack"] = _raise_uninitialized_error
        self.__dict__["_get_flaps"] = _raise_uninitialized_error
        self.__dict__["_set_flaps"] = _raise_uninitialized_error
        self.__dict__["_get_departure_speed_mode"] = _raise_uninitialized_error
        self.__dict__["_set_departure_speed_mode"] = _raise_uninitialized_error
        self.__dict__["_get_departure_speed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_departure_speed_limit_type"] = _raise_uninitialized_error
        self.__dict__["_set_departure_speed_limit"] = _raise_uninitialized_error
        self.__dict__["_get_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_set_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAdvTakeoffModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvTakeoffModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAdvTakeoffModel = agcom.GUID(IAircraftAdvTakeoffModel._uuid)
        vtable_offset_local = IAircraftAdvTakeoffModel._vtable_offset - 1
        self.__dict__["_get_takeoff_speed_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_takeoff_speed_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_stall_speed_ratio"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stall_speed_ratio"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_angle_of_attack"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_angle_of_attack"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_flaps"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_flaps"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_departure_speed_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_departure_speed_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_departure_speed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_departure_speed_limit_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_departure_speed_limit"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+13, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvTakeoffModel, vtable_offset_local+16, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvTakeoffModel.__dict__ and type(IAircraftAdvTakeoffModel.__dict__[attrname]) == property:
            return IAircraftAdvTakeoffModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvTakeoffModel.")
    
    @property
    def takeoff_speed_mode(self) -> "AVTR_TAKEOFF_LANDING_SPEED_MODE":
        """The mode to calculate the aircraft's airspeed upon leaving the ground."""
        with agmarshall.AgEnum_arg(AVTR_TAKEOFF_LANDING_SPEED_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_speed_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_speed_mode.setter
    def takeoff_speed_mode(self, newVal:"AVTR_TAKEOFF_LANDING_SPEED_MODE") -> None:
        """The mode to calculate the aircraft's  airspeed upon leaving the ground."""
        with agmarshall.AgEnum_arg(AVTR_TAKEOFF_LANDING_SPEED_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_speed_mode"](arg_newVal.COM_val))

    @property
    def stall_speed_ratio(self) -> float:
        """The ratio of the airspeed to the stall speed upon leaving the ground."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stall_speed_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stall_speed_ratio(self, stallSpeedRatio:float) -> None:
        """Set the takeoff speed mode to StallSpeedRatio and specify the stall speed ratio."""
        with agmarshall.DOUBLE_arg(stallSpeedRatio) as arg_stallSpeedRatio:
            agcls.evaluate_hresult(self.__dict__["_set_stall_speed_ratio"](arg_stallSpeedRatio.COM_val))

    @property
    def angle_of_attack(self) -> typing.Any:
        """The Angle of Attack upon leaving the ground."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_angle_of_attack"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_angle_of_attack(self, angleOfAttack:typing.Any) -> None:
        """Set the takeoff speed mode to AngleOfAttack and specify the angle of attack"""
        with agmarshall.VARIANT_arg(angleOfAttack) as arg_angleOfAttack:
            agcls.evaluate_hresult(self.__dict__["_set_angle_of_attack"](arg_angleOfAttack.COM_val))

    @property
    def flaps(self) -> float:
        """The extension of the flaps during takeoff."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flaps"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flaps.setter
    def flaps(self, newVal:float) -> None:
        """The extension of the flaps during takeoff."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flaps"](arg_newVal.COM_val))

    @property
    def departure_speed_mode(self) -> "AVTR_DEPARTURE_SPEED_MODE":
        """The mode to calculate the airspeed upon leaving the ground."""
        with agmarshall.AgEnum_arg(AVTR_DEPARTURE_SPEED_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_speed_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @departure_speed_mode.setter
    def departure_speed_mode(self, newVal:"AVTR_DEPARTURE_SPEED_MODE") -> None:
        """The mode to calculate the airspeed upon leaving the ground."""
        with agmarshall.AgEnum_arg(AVTR_DEPARTURE_SPEED_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_departure_speed_mode"](arg_newVal.COM_val))

    @property
    def departure_speed_limit(self) -> float:
        """The aircraft's maximum airspeed upon leaving the ground."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_speed_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def departure_speed_limit_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The departure speed limim type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_speed_limit_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_departure_speed_limit(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the departure speed limit of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_departure_speed_limit"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def use_afterburner(self) -> bool:
        """Opt whether to use the afterburner if it is possible."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_afterburner"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_afterburner.setter
    def use_afterburner(self, newVal:bool) -> None:
        """Opt whether to use the afterburner if it is possible."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_afterburner"](arg_newVal.COM_val))

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{3290c530-62d6-49d7-8d89-69f0c3e6148d}", IAircraftAdvTakeoffModel)
agcls.AgTypeNameMap["IAircraftAdvTakeoffModel"] = IAircraftAdvTakeoffModel

class IAircraftVTOLModel(object):
    """Interface used to access the options for a VTOL performance model of an aircraft."""
    _uuid = "{e9a1ecac-84c0-4fed-bbfc-ae61a6b5d745}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_hover_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_max_hover_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_get_hover_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_hover_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_set_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_get_heading_transition_time"] = _raise_uninitialized_error
        self.__dict__["_set_heading_transition_time"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_rate"] = _raise_uninitialized_error
        self.__dict__["_set_vertical_rate"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_transition_time"] = _raise_uninitialized_error
        self.__dict__["_set_vertical_transition_time"] = _raise_uninitialized_error
        self.__dict__["_get_translation_rate"] = _raise_uninitialized_error
        self.__dict__["_set_translation_rate"] = _raise_uninitialized_error
        self.__dict__["_get_translation_transition_time"] = _raise_uninitialized_error
        self.__dict__["_set_translation_transition_time"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_transition_time"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_transition_time"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftVTOLModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftVTOLModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftVTOLModel = agcom.GUID(IAircraftVTOLModel._uuid)
        vtable_offset_local = IAircraftVTOLModel._vtable_offset - 1
        self.__dict__["_get_max_hover_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_hover_altitude"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_hover_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_hover_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_heading_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_heading_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_vertical_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_vertical_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_vertical_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_vertical_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_translation_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_translation_rate"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_translation_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_translation_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_forward_flight_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_get_forward_flight_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_forward_flight_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+23, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_forward_flight_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_set_forward_flight_transition_time"] = IAGFUNCTYPE(pUnk, IID_IAircraftVTOLModel, vtable_offset_local+25, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftVTOLModel.__dict__ and type(IAircraftVTOLModel.__dict__[attrname]) == property:
            return IAircraftVTOLModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftVTOLModel.")
    
    @property
    def max_hover_altitude(self) -> float:
        """The maximum altitude at which the aircraft is capable of hovering."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_hover_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_hover_altitude.setter
    def max_hover_altitude(self, newVal:float) -> None:
        """The maximum altitude at which the aircraft is capable of hovering."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_hover_altitude"](arg_newVal.COM_val))

    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_aero_prop_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_aero_prop_fuel"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow_by_non_std_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow_by_non_std_density"](arg_newVal.COM_val))

    @property
    def hover_fuel(self) -> float:
        """The aircraft's fuel flow rate while hovering."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hover_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hover_fuel.setter
    def hover_fuel(self, newVal:float) -> None:
        """The aircraft's fuel flow rate while hovering."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hover_fuel"](arg_newVal.COM_val))

    @property
    def heading_rate(self) -> typing.Any:
        """The rate at which the aircraft can change heading while hovering."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_rate.setter
    def heading_rate(self, newVal:typing.Any) -> None:
        """The rate at which the aircraft can change heading while hovering."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_rate"](arg_newVal.COM_val))

    @property
    def heading_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to heading change maneuver mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_transition_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_transition_time.setter
    def heading_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to heading change maneuver mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_transition_time"](arg_newVal.COM_val))

    @property
    def vertical_rate(self) -> float:
        """The aircraft's vertical rate."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vertical_rate.setter
    def vertical_rate(self, newVal:float) -> None:
        """The aircraft's vertical rate."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vertical_rate"](arg_newVal.COM_val))

    @property
    def vertical_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to vertical maneuver mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_transition_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vertical_transition_time.setter
    def vertical_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to vertical maneuver mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vertical_transition_time"](arg_newVal.COM_val))

    @property
    def translation_rate(self) -> float:
        """The rate at which the aircraft can translate while hovering."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_translation_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @translation_rate.setter
    def translation_rate(self, newVal:float) -> None:
        """The rate at which the aircraft can translate while hovering."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_translation_rate"](arg_newVal.COM_val))

    @property
    def translation_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to translation maneuver mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_translation_transition_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @translation_transition_time.setter
    def translation_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to translation maneuver mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_translation_transition_time"](arg_newVal.COM_val))

    @property
    def forward_flight_airspeed(self) -> float:
        """The speed at which the aircraft can begin forward flight."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def forward_flight_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The forward flight airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_forward_flight_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the speed at which the aircraft can begin forward flight."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def forward_flight_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to forward flight at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_transition_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_transition_time.setter
    def forward_flight_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to forward flight at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_transition_time"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e9a1ecac-84c0-4fed-bbfc-ae61a6b5d745}", IAircraftVTOLModel)
agcls.AgTypeNameMap["IAircraftVTOLModel"] = IAircraftVTOLModel

class IAircraftTerrainFollow(object):
    """Interface used to access the TerrainFollow options for an aircraft in the Aviator catalog."""
    _uuid = "{293c033c-5053-4a55-bfbb-fd8ea210749f}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_terrain_follow_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftTerrainFollow._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftTerrainFollow from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftTerrainFollow = agcom.GUID(IAircraftTerrainFollow._uuid)
        vtable_offset_local = IAircraftTerrainFollow._vtable_offset - 1
        self.__dict__["_get_terrain_follow_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollow, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollow, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftTerrainFollow.__dict__ and type(IAircraftTerrainFollow.__dict__[attrname]) == property:
            return IAircraftTerrainFollow.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftTerrainFollow.")
    
    def get_terrain_follow_by_name(self, name:str) -> "IAircraftTerrainFollowModel":
        """Gets the TerrainFollow model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppTerrainFollowModel:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_follow_by_name"](arg_name.COM_val, byref(arg_ppTerrainFollowModel.COM_val)))
            return arg_ppTerrainFollowModel.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{293c033c-5053-4a55-bfbb-fd8ea210749f}", IAircraftTerrainFollow)
agcls.AgTypeNameMap["IAircraftTerrainFollow"] = IAircraftTerrainFollow

class IPerformanceModelOptions(object):
    """Interface used to change the active performance model in a phase for a given model type."""
    _uuid = "{DE05DB32-36E7-4C14-916E-C626C4E084FD}"
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_link_to_catalog"] = _raise_uninitialized_error
        self.__dict__["_copy_from_catalog"] = _raise_uninitialized_error
        self.__dict__["_create_new"] = _raise_uninitialized_error
        self.__dict__["_rename"] = _raise_uninitialized_error
        self.__dict__["_delete"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_is_linked_to_catalog"] = _raise_uninitialized_error
        self.__dict__["_get_properties"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPerformanceModelOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPerformanceModelOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPerformanceModelOptions = agcom.GUID(IPerformanceModelOptions._uuid)
        vtable_offset_local = IPerformanceModelOptions._vtable_offset - 1
        self.__dict__["_link_to_catalog"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_copy_from_catalog"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_create_new"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_rename"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_delete"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+5, )
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_get_is_linked_to_catalog"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_properties"] = IAGFUNCTYPE(pUnk, IID_IPerformanceModelOptions, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPerformanceModelOptions.__dict__ and type(IPerformanceModelOptions.__dict__[attrname]) == property:
            return IPerformanceModelOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPerformanceModelOptions.")
    
    def link_to_catalog(self, name:str) -> None:
        """Link to the performance model in the catalog with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name:
            agcls.evaluate_hresult(self.__dict__["_link_to_catalog"](arg_name.COM_val))

    def copy_from_catalog(self, name:str) -> None:
        """Create a copy of the performance model in the catalog with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name:
            agcls.evaluate_hresult(self.__dict__["_copy_from_catalog"](arg_name.COM_val))

    def create_new(self, type:str) -> None:
        """Create a new performance model of the given type."""
        with agmarshall.BSTR_arg(type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_create_new"](arg_type.COM_val))

    def rename(self, type:str) -> None:
        """Rename the performance model."""
        with agmarshall.BSTR_arg(type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_rename"](arg_type.COM_val))

    def delete(self) -> None:
        """Delete the performance model."""
        agcls.evaluate_hresult(self.__dict__["_delete"]())

    @property
    def name(self) -> str:
        """Get the name of the performance model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def is_linked_to_catalog(self) -> bool:
        """Get whether the performance model is linked to the catalog."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_linked_to_catalog"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def properties(self) -> "IPerformanceModel":
        """Get the properties of the performance model."""
        with agmarshall.AgInterface_out_arg() as arg_ppPerfModel:
            agcls.evaluate_hresult(self.__dict__["_get_properties"](byref(arg_ppPerfModel.COM_val)))
            return arg_ppPerfModel.python_val


agcls.AgClassCatalog.add_catalog_entry("{DE05DB32-36E7-4C14-916E-C626C4E084FD}", IPerformanceModelOptions)
agcls.AgTypeNameMap["IPerformanceModelOptions"] = IPerformanceModelOptions

class IAdvFixedWingTool(object):
    """Interface used to access the options for the Advanced Fixed Wing Tool of an aircraft."""
    _uuid = "{3722BD33-A1BE-48AD-AF6F-4AC40B19FBBA}"
    _num_methods = 41
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_wing_area"] = _raise_uninitialized_error
        self.__dict__["_set_wing_area"] = _raise_uninitialized_error
        self.__dict__["_get_flaps_area"] = _raise_uninitialized_error
        self.__dict__["_set_flaps_area"] = _raise_uninitialized_error
        self.__dict__["_get_speedbrakes_area"] = _raise_uninitialized_error
        self.__dict__["_set_speedbrakes_area"] = _raise_uninitialized_error
        self.__dict__["_get_max_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_max_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_max_mach"] = _raise_uninitialized_error
        self.__dict__["_set_max_mach"] = _raise_uninitialized_error
        self.__dict__["_get_max_eas"] = _raise_uninitialized_error
        self.__dict__["_set_max_eas"] = _raise_uninitialized_error
        self.__dict__["_get_min_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_min_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_max_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_temperature_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_temperature_limit"] = _raise_uninitialized_error
        self.__dict__["_get_max_temperature"] = _raise_uninitialized_error
        self.__dict__["_set_max_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_cache_aero_data"] = _raise_uninitialized_error
        self.__dict__["_set_cache_aero_data"] = _raise_uninitialized_error
        self.__dict__["_get_cache_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_cache_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_aero_strategy"] = _raise_uninitialized_error
        self.__dict__["_set_aero_strategy"] = _raise_uninitialized_error
        self.__dict__["_get_aero_mode_as_external"] = _raise_uninitialized_error
        self.__dict__["_get_aero_mode_as_subsonic"] = _raise_uninitialized_error
        self.__dict__["_get_aero_mode_as_sub_super_hypersonic"] = _raise_uninitialized_error
        self.__dict__["_get_aero_mode_as_supersonic"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_strategy"] = _raise_uninitialized_error
        self.__dict__["_set_powerplant_strategy"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_electric"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_external"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_piston"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_turboprop"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_empirical_jet_engine"] = _raise_uninitialized_error
        self.__dict__["_create_all_perf_models"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_basic_turbofan"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_basic_turbojet"] = _raise_uninitialized_error
        self.__dict__["_get_powerplant_mode_as_sub_super_hypersonic"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingTool._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTool from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingTool = agcom.GUID(IAdvFixedWingTool._uuid)
        vtable_offset_local = IAdvFixedWingTool._vtable_offset - 1
        self.__dict__["_get_wing_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wing_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_flaps_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_flaps_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_speedbrakes_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_speedbrakes_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_max_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_max_eas"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_eas"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_min_load_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_load_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_load_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_load_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_use_max_temperature_limit"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_temperature_limit"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_temperature"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_temperature"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_cache_aero_data"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_cache_aero_data"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+22, agcom.VARIANT_BOOL)
        self.__dict__["_get_cache_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_cache_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+24, agcom.VARIANT_BOOL)
        self.__dict__["_get_aero_strategy"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+25, POINTER(agcom.LONG))
        self.__dict__["_set_aero_strategy"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+26, agcom.LONG)
        self.__dict__["_get_aero_mode_as_external"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+27, POINTER(agcom.PVOID))
        self.__dict__["_get_aero_mode_as_subsonic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_get_aero_mode_as_sub_super_hypersonic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+29, POINTER(agcom.PVOID))
        self.__dict__["_get_aero_mode_as_supersonic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_get_powerplant_strategy"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+31, POINTER(agcom.LONG))
        self.__dict__["_set_powerplant_strategy"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+32, agcom.LONG)
        self.__dict__["_get_powerplant_mode_as_electric"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+33, POINTER(agcom.PVOID))
        self.__dict__["_get_powerplant_mode_as_external"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+34, POINTER(agcom.PVOID))
        self.__dict__["_get_powerplant_mode_as_piston"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+35, POINTER(agcom.PVOID))
        self.__dict__["_get_powerplant_mode_as_turboprop"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+36, POINTER(agcom.PVOID))
        self.__dict__["_get_powerplant_mode_as_empirical_jet_engine"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+37, POINTER(agcom.PVOID))
        self.__dict__["_create_all_perf_models"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+38, agcom.BSTR, agcom.VARIANT_BOOL, agcom.VARIANT_BOOL)
        self.__dict__["_get_powerplant_mode_as_basic_turbofan"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+39, POINTER(agcom.PVOID))
        self.__dict__["_get_powerplant_mode_as_basic_turbojet"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+40, POINTER(agcom.PVOID))
        self.__dict__["_get_powerplant_mode_as_sub_super_hypersonic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTool, vtable_offset_local+41, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTool.__dict__ and type(IAdvFixedWingTool.__dict__[attrname]) == property:
            return IAdvFixedWingTool.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTool.")
    
    @property
    def wing_area(self) -> float:
        """The total surface area of the wing."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_area.setter
    def wing_area(self, newVal:float) -> None:
        """The total surface area of the wing."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_area"](arg_newVal.COM_val))

    @property
    def flaps_area(self) -> float:
        """The total surface area of the flaps."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flaps_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flaps_area.setter
    def flaps_area(self, newVal:float) -> None:
        """The total surface area of the flaps."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flaps_area"](arg_newVal.COM_val))

    @property
    def speedbrakes_area(self) -> float:
        """The total surface area of the speedbrakes."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_speedbrakes_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @speedbrakes_area.setter
    def speedbrakes_area(self, newVal:float) -> None:
        """The total surface area of the speedbrakes."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_speedbrakes_area"](arg_newVal.COM_val))

    @property
    def max_altitude(self) -> float:
        """The maximum altitude of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_altitude.setter
    def max_altitude(self, newVal:float) -> None:
        """The maximum altitude of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_altitude"](arg_newVal.COM_val))

    @property
    def max_mach(self) -> float:
        """The maximum mach number of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_mach.setter
    def max_mach(self, newVal:float) -> None:
        """The maximum mach number of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_mach"](arg_newVal.COM_val))

    @property
    def max_eas(self) -> float:
        """The maximum equivalent airspeed of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_eas"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_eas.setter
    def max_eas(self, newVal:float) -> None:
        """The maximum equivalent airspeed of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_eas"](arg_newVal.COM_val))

    @property
    def min_load_factor(self) -> float:
        """The minimum load factor the aircraft can bear."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_load_factor.setter
    def min_load_factor(self, newVal:float) -> None:
        """The minimum load factor the aircraft can bear."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_load_factor"](arg_newVal.COM_val))

    @property
    def max_load_factor(self) -> float:
        """The maximum load factor the aircraft can bear."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_load_factor.setter
    def max_load_factor(self, newVal:float) -> None:
        """The maximum load factor the aircraft can bear."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_load_factor"](arg_newVal.COM_val))

    @property
    def use_max_temperature_limit(self) -> bool:
        """The option to limit the maximum speed of the aircraft so the specified temperature is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_temperature_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_temperature_limit.setter
    def use_max_temperature_limit(self, newVal:bool) -> None:
        """The option to limit the maximum speed of the aircraft so the specified temperature is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_temperature_limit"](arg_newVal.COM_val))

    @property
    def max_temperature(self) -> float:
        """The maximum total temperature limit of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_temperature.setter
    def max_temperature(self, newVal:float) -> None:
        """The maximum total temperature limit of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_temperature"](arg_newVal.COM_val))

    @property
    def cache_aero_data(self) -> bool:
        """The option to store intermediate results for aerodynamics calculations."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cache_aero_data"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cache_aero_data.setter
    def cache_aero_data(self, newVal:bool) -> None:
        """The option to store intermediate results for aerodynamics calculations."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cache_aero_data"](arg_newVal.COM_val))

    @property
    def cache_fuel_flow(self) -> bool:
        """The option to store intermediate results for fuel flow calculations."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cache_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cache_fuel_flow.setter
    def cache_fuel_flow(self, newVal:bool) -> None:
        """The option to store intermediate results for fuel flow calculations."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cache_fuel_flow"](arg_newVal.COM_val))

    @property
    def aero_strategy(self) -> "AVTR_ADV_FIXED_WING_AERO_STRATEGY":
        """The aerodynamic strategy type."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_AERO_STRATEGY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aero_strategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aero_strategy.setter
    def aero_strategy(self, newVal:"AVTR_ADV_FIXED_WING_AERO_STRATEGY") -> None:
        """The aerodynamic strategy type."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_AERO_STRATEGY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_aero_strategy"](arg_newVal.COM_val))

    @property
    def aero_mode_as_external(self) -> "IAdvFixedWingExternalAero":
        """Get the interface for an Extern File Aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aero_mode_as_external"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def aero_mode_as_subsonic(self) -> "IAdvFixedWingSubsonicAero":
        """Get the interface for a Subsonic Aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aero_mode_as_subsonic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def aero_mode_as_sub_super_hypersonic(self) -> "IAdvFixedWingSubSuperHypersonicAero":
        """Get the interface for a Sub/Super/Hypersonic Aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aero_mode_as_sub_super_hypersonic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def aero_mode_as_supersonic(self) -> "IAdvFixedWingSupersonicAero":
        """Get the interface for a Supersonic Aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aero_mode_as_supersonic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def powerplant_strategy(self) -> "AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY":
        """The powerplant strategy type."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_strategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @powerplant_strategy.setter
    def powerplant_strategy(self, newVal:"AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY") -> None:
        """The powerplant  strategy type."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_POWERPLANT_STRATEGY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_powerplant_strategy"](arg_newVal.COM_val))

    @property
    def powerplant_mode_as_electric(self) -> "IAdvFixedWingElectricPowerplant":
        """Get the interface for an Electric Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_electric"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def powerplant_mode_as_external(self) -> "IAdvFixedWingExternalProp":
        """Get the interface for an External Prop File Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_external"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def powerplant_mode_as_piston(self) -> "IAdvFixedWingPistonPowerplant":
        """Get the interface for a Piston Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_piston"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def powerplant_mode_as_turboprop(self) -> "IAdvFixedWingTurbopropPowerplant":
        """Get the interface for a Turboprop Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_turboprop"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def powerplant_mode_as_empirical_jet_engine(self) -> "IAdvFixedWingEmpiricalJetEngine":
        """Get the interface for an Empirical Jet Engine Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_empirical_jet_engine"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def create_all_perf_models(self, name:str, overwrite:bool, makeDefault:bool) -> None:
        """Create a set of advanced performance models for the aircraft with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg(overwrite) as arg_overwrite, \
             agmarshall.VARIANT_BOOL_arg(makeDefault) as arg_makeDefault:
            agcls.evaluate_hresult(self.__dict__["_create_all_perf_models"](arg_name.COM_val, arg_overwrite.COM_val, arg_makeDefault.COM_val))

    @property
    def powerplant_mode_as_basic_turbofan(self) -> "IAdvFixedWingTurbofanBasicABProp":
        """Get the interface for a Turbofan - Basic w/ AB Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_basic_turbofan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def powerplant_mode_as_basic_turbojet(self) -> "IAdvFixedWingTurbojetBasicABProp":
        """Get the interface for a Turbojet - Basic w/ AB Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_basic_turbojet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def powerplant_mode_as_sub_super_hypersonic(self) -> "IAdvFixedWingSubSuperHypersonicProp":
        """Get the interface for a Sub/Super/Hypersoinc Powerplant strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_mode_as_sub_super_hypersonic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3722BD33-A1BE-48AD-AF6F-4AC40B19FBBA}", IAdvFixedWingTool)
agcls.AgTypeNameMap["IAdvFixedWingTool"] = IAdvFixedWingTool

class IAdvFixedWingExternalAero(object):
    """Interface used to access the options for an external file aerodynamic strategy in the advanced fixed wing tool."""
    _uuid = "{7A440104-B346-417B-98CB-7718A5A95848}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_filepath"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingExternalAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingExternalAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingExternalAero = agcom.GUID(IAdvFixedWingExternalAero._uuid)
        vtable_offset_local = IAdvFixedWingExternalAero._vtable_offset - 1
        self.__dict__["_get_filepath"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingExternalAero, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_filepath"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingExternalAero, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.BSTR))
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingExternalAero, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingExternalAero.__dict__ and type(IAdvFixedWingExternalAero.__dict__[attrname]) == property:
            return IAdvFixedWingExternalAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingExternalAero.")
    
    @property
    def filepath(self) -> str:
        """The filepath for the external aero file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external aero file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_set_filepath"](arg_filepath.COM_val, byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7A440104-B346-417B-98CB-7718A5A95848}", IAdvFixedWingExternalAero)
agcls.AgTypeNameMap["IAdvFixedWingExternalAero"] = IAdvFixedWingExternalAero

class IAdvFixedWingSubsonicAero(object):
    """Interface used to access the options for the subsonic aerodynamic strategy in the advanced fixed wing tool."""
    _uuid = "{9e4abf77-2ca1-4130-8ff8-e13d216d722b}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_geometry_type"] = _raise_uninitialized_error
        self.__dict__["_set_geometry_type"] = _raise_uninitialized_error
        self.__dict__["_get_geometry_mode_as_basic"] = _raise_uninitialized_error
        self.__dict__["_get_geometry_mode_as_variable"] = _raise_uninitialized_error
        self.__dict__["_get_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_cd0"] = _raise_uninitialized_error
        self.__dict__["_set_cd0"] = _raise_uninitialized_error
        self.__dict__["_get_mach_divergence"] = _raise_uninitialized_error
        self.__dict__["_set_mach_divergence"] = _raise_uninitialized_error
        self.__dict__["_get_transonic_mach_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_set_transonic_mach_drag_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingSubsonicAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSubsonicAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingSubsonicAero = agcom.GUID(IAdvFixedWingSubsonicAero._uuid)
        vtable_offset_local = IAdvFixedWingSubsonicAero._vtable_offset - 1
        self.__dict__["_get_geometry_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_geometry_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_geometry_mode_as_basic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_geometry_mode_as_variable"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_cd0"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cd0"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_mach_divergence"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mach_divergence"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_transonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubsonicAero, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSubsonicAero.__dict__ and type(IAdvFixedWingSubsonicAero.__dict__[attrname]) == property:
            return IAdvFixedWingSubsonicAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSubsonicAero.")
    
    @property
    def geometry_type(self) -> "AVTR_ADV_FIXED_WING_GEOMETRY":
        """The type of wing geometry for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_GEOMETRY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_geometry_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @geometry_type.setter
    def geometry_type(self, newVal:"AVTR_ADV_FIXED_WING_GEOMETRY") -> None:
        """The type of wing geometry for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_GEOMETRY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_geometry_type"](arg_newVal.COM_val))

    @property
    def geometry_mode_as_basic(self) -> "IAdvFixedWingGeometryBasic":
        """The options for a basic geometry wing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_geometry_mode_as_basic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def geometry_mode_as_variable(self) -> "IAdvFixedWingGeometryVariable":
        """The options for a variable geometry wing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_geometry_mode_as_variable"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_aoa"](arg_newVal.COM_val))

    @property
    def cd0(self) -> float:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cd0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cd0.setter
    def cd0(self, newVal:float) -> None:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cd0"](arg_newVal.COM_val))

    @property
    def mach_divergence(self) -> float:
        """The speed at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mach_divergence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mach_divergence.setter
    def mach_divergence(self, newVal:float) -> None:
        """The speed at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mach_divergence"](arg_newVal.COM_val))

    @property
    def transonic_mach_drag_factor(self) -> float:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying faster than the Mach Divergence."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transonic_mach_drag_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transonic_mach_drag_factor.setter
    def transonic_mach_drag_factor(self, newVal:float) -> None:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying faster than the Mach Divergence."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transonic_mach_drag_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9e4abf77-2ca1-4130-8ff8-e13d216d722b}", IAdvFixedWingSubsonicAero)
agcls.AgTypeNameMap["IAdvFixedWingSubsonicAero"] = IAdvFixedWingSubsonicAero

class IAdvFixedWingSubSuperHypersonicAero(object):
    """Interface used to access the options for the Sub/Super/Hypersonic aerodynamic strategy in the advanced fixed wing tool."""
    _uuid = "{c229225f-d608-457a-a100-7ef7a8618825}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_transonic_min_mach"] = _raise_uninitialized_error
        self.__dict__["_set_transonic_min_mach"] = _raise_uninitialized_error
        self.__dict__["_get_transonic_max_mach"] = _raise_uninitialized_error
        self.__dict__["_set_transonic_max_mach"] = _raise_uninitialized_error
        self.__dict__["_get_super_hyper_mach_transition"] = _raise_uninitialized_error
        self.__dict__["_set_super_hyper_mach_transition"] = _raise_uninitialized_error
        self.__dict__["_get_leading_edge_frontal_area_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_leading_edge_frontal_area_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_subsonic_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_subsonic_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_transonic_mach_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_set_transonic_mach_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_get_wave_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_set_wave_drag_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingSubSuperHypersonicAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSubSuperHypersonicAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingSubSuperHypersonicAero = agcom.GUID(IAdvFixedWingSubSuperHypersonicAero._uuid)
        vtable_offset_local = IAdvFixedWingSubSuperHypersonicAero._vtable_offset - 1
        self.__dict__["_get_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_transonic_min_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transonic_min_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_transonic_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transonic_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_super_hyper_mach_transition"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_super_hyper_mach_transition"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_leading_edge_frontal_area_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_leading_edge_frontal_area_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_subsonic_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_subsonic_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_transonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_wave_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wave_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicAero, vtable_offset_local+16, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSubSuperHypersonicAero.__dict__ and type(IAdvFixedWingSubSuperHypersonicAero.__dict__[attrname]) == property:
            return IAdvFixedWingSubSuperHypersonicAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSubSuperHypersonicAero.")
    
    @property
    def max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_aoa"](arg_newVal.COM_val))

    @property
    def transonic_min_mach(self) -> float:
        """The minimum speed at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transonic_min_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transonic_min_mach.setter
    def transonic_min_mach(self, newVal:float) -> None:
        """The minimum speed at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transonic_min_mach"](arg_newVal.COM_val))

    @property
    def transonic_max_mach(self) -> float:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transonic_max_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transonic_max_mach.setter
    def transonic_max_mach(self, newVal:float) -> None:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transonic_max_mach"](arg_newVal.COM_val))

    @property
    def super_hyper_mach_transition(self) -> float:
        """The minimum speed at which the air flow will be treated as hypersonic."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_super_hyper_mach_transition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @super_hyper_mach_transition.setter
    def super_hyper_mach_transition(self, newVal:float) -> None:
        """The minimum speed at which the air flow will be treated as hypersonic."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_super_hyper_mach_transition"](arg_newVal.COM_val))

    @property
    def leading_edge_frontal_area_ratio(self) -> float:
        """The frontal face thickness of the aircraft's wings at their leading edge."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_leading_edge_frontal_area_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @leading_edge_frontal_area_ratio.setter
    def leading_edge_frontal_area_ratio(self, newVal:float) -> None:
        """The frontal face thickness of the aircraft's wings at their leading edge."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_leading_edge_frontal_area_ratio"](arg_newVal.COM_val))

    @property
    def subsonic_aspect_ratio(self) -> float:
        """The aircraft's wingspan squared divided by the wing area."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_subsonic_aspect_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @subsonic_aspect_ratio.setter
    def subsonic_aspect_ratio(self, newVal:float) -> None:
        """The aircraft's wingspan squared divided by the wing area."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_subsonic_aspect_ratio"](arg_newVal.COM_val))

    @property
    def transonic_mach_drag_factor(self) -> float:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transonic_mach_drag_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transonic_mach_drag_factor.setter
    def transonic_mach_drag_factor(self, newVal:float) -> None:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transonic_mach_drag_factor"](arg_newVal.COM_val))

    @property
    def wave_drag_factor(self) -> float:
        """A scalar value that models drag produced by shock waves at or near the aircraft's critical Mach number."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wave_drag_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wave_drag_factor.setter
    def wave_drag_factor(self, newVal:float) -> None:
        """A scalar value that models drag produced by shock waves at or near the aircraft's critical Mach number."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wave_drag_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{c229225f-d608-457a-a100-7ef7a8618825}", IAdvFixedWingSubSuperHypersonicAero)
agcls.AgTypeNameMap["IAdvFixedWingSubSuperHypersonicAero"] = IAdvFixedWingSubSuperHypersonicAero

class IAdvFixedWingSubSuperHypersonicProp(object):
    """Interface used to access the options for the Sub/Super/Hypersonic powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{1a204443-6853-4897-b530-6e7231607545}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_turbine_mode"] = _raise_uninitialized_error
        self.__dict__["_set_turbine_mode"] = _raise_uninitialized_error
        self.__dict__["_get_turbine_mode_as_turbojet"] = _raise_uninitialized_error
        self.__dict__["_get_turbine_mode_as_turbofan"] = _raise_uninitialized_error
        self.__dict__["_get_ramjet_mode"] = _raise_uninitialized_error
        self.__dict__["_set_ramjet_mode"] = _raise_uninitialized_error
        self.__dict__["_get_ramjet_mode_as_basic"] = _raise_uninitialized_error
        self.__dict__["_get_scramjet_mode"] = _raise_uninitialized_error
        self.__dict__["_set_scramjet_mode"] = _raise_uninitialized_error
        self.__dict__["_get_scramjet_mode_as_basic"] = _raise_uninitialized_error
        self.__dict__["_get_turbine_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_ramjet_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_scramjet_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_max_turbine_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_turbine_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_get_max_turbine_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_turbine_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_get_can_ram_compressor_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_can_ram_compressor_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_must_ram_compressor_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_must_ram_compressor_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_max_ram_scram_compression_temperature"] = _raise_uninitialized_error
        self.__dict__["_set_max_ram_scram_compression_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_max_ram_scram_burner_total_temperature"] = _raise_uninitialized_error
        self.__dict__["_set_max_ram_scram_burner_total_temperature"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingSubSuperHypersonicProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSubSuperHypersonicProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingSubSuperHypersonicProp = agcom.GUID(IAdvFixedWingSubSuperHypersonicProp._uuid)
        vtable_offset_local = IAdvFixedWingSubSuperHypersonicProp._vtable_offset - 1
        self.__dict__["_get_turbine_mode"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_turbine_mode"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_turbine_mode_as_turbojet"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_turbine_mode_as_turbofan"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_ramjet_mode"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_ramjet_mode"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_ramjet_mode_as_basic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_scramjet_mode"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_scramjet_mode"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_get_scramjet_mode_as_basic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_turbine_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_ramjet_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_get_scramjet_ref_area"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_get_max_turbine_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_turbine_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_max_turbine_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_turbine_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_can_ram_compressor_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_can_ram_compressor_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_must_ram_compressor_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_must_ram_compressor_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_get_max_ram_scram_compression_temperature"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_ram_scram_compression_temperature"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_get_max_ram_scram_burner_total_temperature"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_ram_scram_burner_total_temperature"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSubSuperHypersonicProp, vtable_offset_local+25, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSubSuperHypersonicProp.__dict__ and type(IAdvFixedWingSubSuperHypersonicProp.__dict__[attrname]) == property:
            return IAdvFixedWingSubSuperHypersonicProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSubSuperHypersonicProp.")
    
    @property
    def turbine_mode(self) -> "AVTR_TURBINE_MODE":
        """The turbine operating mode."""
        with agmarshall.AgEnum_arg(AVTR_TURBINE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turbine_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turbine_mode.setter
    def turbine_mode(self, newVal:"AVTR_TURBINE_MODE") -> None:
        """The turbine operating mode."""
        with agmarshall.AgEnum_arg(AVTR_TURBINE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turbine_mode"](arg_newVal.COM_val))

    @property
    def turbine_mode_as_turbojet(self) -> "IAdvFixedWingTurbojetBasicABProp":
        """Get the interface for a Turbojet Basic w/ AB tubrine mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_turbine_mode_as_turbojet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def turbine_mode_as_turbofan(self) -> "IAdvFixedWingTurbofanBasicABProp":
        """Get the interface for a Turbojet Basic w/ AB tubrine mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_turbine_mode_as_turbofan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ramjet_mode(self) -> "AVTR_RAMJET_MODE":
        """The ramjet operating mode."""
        with agmarshall.AgEnum_arg(AVTR_RAMJET_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ramjet_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ramjet_mode.setter
    def ramjet_mode(self, newVal:"AVTR_RAMJET_MODE") -> None:
        """The ramjet operating mode."""
        with agmarshall.AgEnum_arg(AVTR_RAMJET_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ramjet_mode"](arg_newVal.COM_val))

    @property
    def ramjet_mode_as_basic(self) -> "IAdvFixedWingRamjetBasic":
        """Get the interface for a Ramjet - Basic."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_ramjet_mode_as_basic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scramjet_mode(self) -> "AVTR_SCRAMJET_MODE":
        """The scramjet operating mode."""
        with agmarshall.AgEnum_arg(AVTR_SCRAMJET_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scramjet_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scramjet_mode.setter
    def scramjet_mode(self, newVal:"AVTR_SCRAMJET_MODE") -> None:
        """The scramjet operating mode."""
        with agmarshall.AgEnum_arg(AVTR_SCRAMJET_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scramjet_mode"](arg_newVal.COM_val))

    @property
    def scramjet_mode_as_basic(self) -> "IAdvFixedWingScramjetBasic":
        """Get the interface for a Scramjet - Basic."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scramjet_mode_as_basic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def turbine_ref_area(self) -> float:
        """The reference area used for the turbine operating mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turbine_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ramjet_ref_area(self) -> float:
        """The reference area used for the ramjet operating mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ramjet_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def scramjet_ref_area(self) -> float:
        """The reference area used for the scramjet operating mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scramjet_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_turbine_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage in the turbine operating mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_turbine_compression_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_turbine_compression_temp.setter
    def max_turbine_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage in the turbine operating mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_turbine_compression_temp"](arg_newVal.COM_val))

    @property
    def max_turbine_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage in the turbine operating mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_turbine_burner_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_turbine_burner_temp.setter
    def max_turbine_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage in the turbine operating mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_turbine_burner_temp"](arg_newVal.COM_val))

    @property
    def can_ram_compressor_pressure_ratio(self) -> float:
        """Can Ram compressor pressure ratio."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_ram_compressor_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @can_ram_compressor_pressure_ratio.setter
    def can_ram_compressor_pressure_ratio(self, newVal:float) -> None:
        """Can Ram compressor pressure ratio."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_can_ram_compressor_pressure_ratio"](arg_newVal.COM_val))

    @property
    def must_ram_compressor_pressure_ratio(self) -> float:
        """Must Ram compressor pressure ratio."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_must_ram_compressor_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @must_ram_compressor_pressure_ratio.setter
    def must_ram_compressor_pressure_ratio(self, newVal:float) -> None:
        """Must Ram compressor pressure ratio."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_must_ram_compressor_pressure_ratio"](arg_newVal.COM_val))

    @property
    def max_ram_scram_compression_temperature(self) -> float:
        """The maximum temperature at the compressor stage in the Ramjet or Scramjet operating mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_ram_scram_compression_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_ram_scram_compression_temperature.setter
    def max_ram_scram_compression_temperature(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage in the Ramjet or Scramjet operating mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_ram_scram_compression_temperature"](arg_newVal.COM_val))

    @property
    def max_ram_scram_burner_total_temperature(self) -> float:
        """The maximum temperature at the combustion stage in the Ramjet or Scramjet operating mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_ram_scram_burner_total_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_ram_scram_burner_total_temperature.setter
    def max_ram_scram_burner_total_temperature(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage in the Ramjet or Scramjet operating mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_ram_scram_burner_total_temperature"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1a204443-6853-4897-b530-6e7231607545}", IAdvFixedWingSubSuperHypersonicProp)
agcls.AgTypeNameMap["IAdvFixedWingSubSuperHypersonicProp"] = IAdvFixedWingSubSuperHypersonicProp

class IAdvFixedWingSupersonicAero(object):
    """Interface used to access the options for the supersonic aerodynamic strategy in the advanced fixed wing tool."""
    _uuid = "{8864671c-5df8-40d1-95db-a2f92c6016ea}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_geometry_type"] = _raise_uninitialized_error
        self.__dict__["_set_geometry_type"] = _raise_uninitialized_error
        self.__dict__["_get_geometry_mode_as_basic"] = _raise_uninitialized_error
        self.__dict__["_get_geometry_mode_as_variable"] = _raise_uninitialized_error
        self.__dict__["_get_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_subsonic_cd0"] = _raise_uninitialized_error
        self.__dict__["_set_subsonic_cd0"] = _raise_uninitialized_error
        self.__dict__["_get_transonic_min_mach"] = _raise_uninitialized_error
        self.__dict__["_set_transonic_min_mach"] = _raise_uninitialized_error
        self.__dict__["_get_transonic_max_mach"] = _raise_uninitialized_error
        self.__dict__["_set_transonic_max_mach"] = _raise_uninitialized_error
        self.__dict__["_get_supersonic_max_mach"] = _raise_uninitialized_error
        self.__dict__["_set_supersonic_max_mach"] = _raise_uninitialized_error
        self.__dict__["_get_transonic_mach_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_set_transonic_mach_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_get_supersonic_mach_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_set_supersonic_mach_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_get_leading_edge_suction_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_leading_edge_suction_efficiency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingSupersonicAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSupersonicAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingSupersonicAero = agcom.GUID(IAdvFixedWingSupersonicAero._uuid)
        vtable_offset_local = IAdvFixedWingSupersonicAero._vtable_offset - 1
        self.__dict__["_get_geometry_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_geometry_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_geometry_mode_as_basic"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_geometry_mode_as_variable"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_subsonic_cd0"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_subsonic_cd0"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_transonic_min_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transonic_min_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_transonic_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transonic_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_supersonic_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_supersonic_max_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_transonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_supersonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_supersonic_mach_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_leading_edge_suction_efficiency"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_leading_edge_suction_efficiency"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingSupersonicAero, vtable_offset_local+20, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSupersonicAero.__dict__ and type(IAdvFixedWingSupersonicAero.__dict__[attrname]) == property:
            return IAdvFixedWingSupersonicAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSupersonicAero.")
    
    @property
    def geometry_type(self) -> "AVTR_ADV_FIXED_WING_GEOMETRY":
        """The type of wing geometry for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_GEOMETRY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_geometry_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @geometry_type.setter
    def geometry_type(self, newVal:"AVTR_ADV_FIXED_WING_GEOMETRY") -> None:
        """The type of wing geometry for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_ADV_FIXED_WING_GEOMETRY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_geometry_type"](arg_newVal.COM_val))

    @property
    def geometry_mode_as_basic(self) -> "IAdvFixedWingGeometryBasic":
        """The options for a basic geometry wing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_geometry_mode_as_basic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def geometry_mode_as_variable(self) -> "IAdvFixedWingGeometryVariable":
        """The options for a variable geometry wing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_geometry_mode_as_variable"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_aoa"](arg_newVal.COM_val))

    @property
    def subsonic_cd0(self) -> float:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_subsonic_cd0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @subsonic_cd0.setter
    def subsonic_cd0(self, newVal:float) -> None:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_subsonic_cd0"](arg_newVal.COM_val))

    @property
    def transonic_min_mach(self) -> float:
        """The minimum speed at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transonic_min_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transonic_min_mach.setter
    def transonic_min_mach(self, newVal:float) -> None:
        """The minimum speed at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transonic_min_mach"](arg_newVal.COM_val))

    @property
    def transonic_max_mach(self) -> float:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transonic_max_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transonic_max_mach.setter
    def transonic_max_mach(self, newVal:float) -> None:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transonic_max_mach"](arg_newVal.COM_val))

    @property
    def supersonic_max_mach(self) -> float:
        """The speed at which the Supersonic Mach Drag Factor is applied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_supersonic_max_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @supersonic_max_mach.setter
    def supersonic_max_mach(self, newVal:float) -> None:
        """The speed at which the Supersonic Mach Drag Factor is applied."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_supersonic_max_mach"](arg_newVal.COM_val))

    @property
    def transonic_mach_drag_factor(self) -> float:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transonic_mach_drag_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transonic_mach_drag_factor.setter
    def transonic_mach_drag_factor(self, newVal:float) -> None:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transonic_mach_drag_factor"](arg_newVal.COM_val))

    @property
    def supersonic_mach_drag_factor(self) -> float:
        """A scalar value applied to the aircraft's parasitic drag coefficient when it is flying faster than the Supersonic Max Mach."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_supersonic_mach_drag_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @supersonic_mach_drag_factor.setter
    def supersonic_mach_drag_factor(self, newVal:float) -> None:
        """A scalar value applied to the aircraft's parasitic drag coefficient when it is flying faster than the Supersonic Max Mach."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_supersonic_mach_drag_factor"](arg_newVal.COM_val))

    @property
    def leading_edge_suction_efficiency(self) -> float:
        """The ability of the wing's leading edge to ingest turbulent airflow and thereby reduce induced drag."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_leading_edge_suction_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @leading_edge_suction_efficiency.setter
    def leading_edge_suction_efficiency(self, newVal:float) -> None:
        """The ability of the wing's leading edge to ingest turbulent airflow and thereby reduce induced drag."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_leading_edge_suction_efficiency"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8864671c-5df8-40d1-95db-a2f92c6016ea}", IAdvFixedWingSupersonicAero)
agcls.AgTypeNameMap["IAdvFixedWingSupersonicAero"] = IAdvFixedWingSupersonicAero

class IAdvFixedWingGeometryBasic(object):
    """Interface used to access the options for a basic geometry wing in the advanced fixed wing tool."""
    _uuid = "{56a5685f-3271-4635-9989-24663bd35e0d}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_wing_sweep"] = _raise_uninitialized_error
        self.__dict__["_set_wing_sweep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingGeometryBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingGeometryBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingGeometryBasic = agcom.GUID(IAdvFixedWingGeometryBasic._uuid)
        vtable_offset_local = IAdvFixedWingGeometryBasic._vtable_offset - 1
        self.__dict__["_get_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryBasic, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryBasic, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_wing_sweep"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryBasic, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_wing_sweep"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryBasic, vtable_offset_local+4, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingGeometryBasic.__dict__ and type(IAdvFixedWingGeometryBasic.__dict__[attrname]) == property:
            return IAdvFixedWingGeometryBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingGeometryBasic.")
    
    @property
    def aspect_ratio(self) -> float:
        """The wing sweep of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aspect_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_aspect_ratio(self, aspectRatio:float) -> None:
        """The wing sweep of the aircraft."""
        with agmarshall.DOUBLE_arg(aspectRatio) as arg_aspectRatio:
            agcls.evaluate_hresult(self.__dict__["_set_aspect_ratio"](arg_aspectRatio.COM_val))

    @property
    def wing_sweep(self) -> typing.Any:
        """The wing sweep of the aircraft."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_sweep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_sweep.setter
    def wing_sweep(self, newVal:typing.Any) -> None:
        """The wing sweep of the aircraft."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_sweep"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{56a5685f-3271-4635-9989-24663bd35e0d}", IAdvFixedWingGeometryBasic)
agcls.AgTypeNameMap["IAdvFixedWingGeometryBasic"] = IAdvFixedWingGeometryBasic

class IAdvFixedWingGeometryVariable(object):
    """Interface used to access the options for a variable geometry wing in the advanced fixed wing tool."""
    _uuid = "{e6f7e882-f360-4744-858a-7ea1eb2104c6}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_aspect_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_start_sweep_mach"] = _raise_uninitialized_error
        self.__dict__["_set_start_sweep_mach"] = _raise_uninitialized_error
        self.__dict__["_get_stop_sweep_mach"] = _raise_uninitialized_error
        self.__dict__["_set_stop_sweep_mach"] = _raise_uninitialized_error
        self.__dict__["_get_min_sweep_angle"] = _raise_uninitialized_error
        self.__dict__["_set_min_sweep_angle"] = _raise_uninitialized_error
        self.__dict__["_get_max_sweep_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_sweep_angle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingGeometryVariable._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingGeometryVariable from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingGeometryVariable = agcom.GUID(IAdvFixedWingGeometryVariable._uuid)
        vtable_offset_local = IAdvFixedWingGeometryVariable._vtable_offset - 1
        self.__dict__["_get_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_aspect_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_start_sweep_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_start_sweep_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_stop_sweep_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_sweep_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_min_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_min_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_max_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingGeometryVariable, vtable_offset_local+10, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingGeometryVariable.__dict__ and type(IAdvFixedWingGeometryVariable.__dict__[attrname]) == property:
            return IAdvFixedWingGeometryVariable.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingGeometryVariable.")
    
    @property
    def aspect_ratio(self) -> float:
        """The wing sweep of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aspect_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_aspect_ratio(self, aspectRatio:float) -> None:
        """The wing sweep of the aircraft."""
        with agmarshall.DOUBLE_arg(aspectRatio) as arg_aspectRatio:
            agcls.evaluate_hresult(self.__dict__["_set_aspect_ratio"](arg_aspectRatio.COM_val))

    @property
    def start_sweep_mach(self) -> float:
        """The mach number at which the wings start to sweep from the min sweep angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_sweep_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_sweep_mach.setter
    def start_sweep_mach(self, newVal:float) -> None:
        """The mach number at which the wings start to sweep from the min sweep angle."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_sweep_mach"](arg_newVal.COM_val))

    @property
    def stop_sweep_mach(self) -> float:
        """The mach number at which the wings are swept to the max sweep angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_sweep_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_sweep_mach.setter
    def stop_sweep_mach(self, newVal:float) -> None:
        """The mach number at which the wings are swept to the max sweep angle."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_sweep_mach"](arg_newVal.COM_val))

    @property
    def min_sweep_angle(self) -> typing.Any:
        """The minimum sweep angle of the wings."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_sweep_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_sweep_angle.setter
    def min_sweep_angle(self, newVal:typing.Any) -> None:
        """The minimum sweep angle of the wings."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_sweep_angle"](arg_newVal.COM_val))

    @property
    def max_sweep_angle(self) -> typing.Any:
        """The maximum sweep angle of the wings."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_sweep_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_sweep_angle.setter
    def max_sweep_angle(self, newVal:typing.Any) -> None:
        """The maximum sweep angle of the wings."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_sweep_angle"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e6f7e882-f360-4744-858a-7ea1eb2104c6}", IAdvFixedWingGeometryVariable)
agcls.AgTypeNameMap["IAdvFixedWingGeometryVariable"] = IAdvFixedWingGeometryVariable

class IAdvFixedWingElectricPowerplant(object):
    """Interface used to access the options for the Electric powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{285ba7fc-1c89-49e1-983b-bf16ce641584}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_power"] = _raise_uninitialized_error
        self.__dict__["_set_max_power"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_diameter"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingElectricPowerplant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingElectricPowerplant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingElectricPowerplant = agcom.GUID(IAdvFixedWingElectricPowerplant._uuid)
        vtable_offset_local = IAdvFixedWingElectricPowerplant._vtable_offset - 1
        self.__dict__["_get_max_power"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingElectricPowerplant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_power"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingElectricPowerplant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingElectricPowerplant, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingElectricPowerplant, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingElectricPowerplant, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingElectricPowerplant, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingElectricPowerplant.__dict__ and type(IAdvFixedWingElectricPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingElectricPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingElectricPowerplant.")
    
    @property
    def max_power(self) -> float:
        """The maximum power of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_power"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_power.setter
    def max_power(self, newVal:float) -> None:
        """The maximum power of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_power"](arg_newVal.COM_val))

    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_count.setter
    def propeller_count(self, newVal:int) -> None:
        """The number of propellers."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_count"](arg_newVal.COM_val))

    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_diameter.setter
    def propeller_diameter(self, newVal:float) -> None:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_diameter"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{285ba7fc-1c89-49e1-983b-bf16ce641584}", IAdvFixedWingElectricPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingElectricPowerplant"] = IAdvFixedWingElectricPowerplant

class IAdvFixedWingExternalProp(object):
    """Interface used to access the options for the External Prop File powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{a886a5d9-63f4-455c-9cda-bce9c81d941d}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_filepath"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingExternalProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingExternalProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingExternalProp = agcom.GUID(IAdvFixedWingExternalProp._uuid)
        vtable_offset_local = IAdvFixedWingExternalProp._vtable_offset - 1
        self.__dict__["_get_filepath"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingExternalProp, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_filepath"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingExternalProp, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.BSTR))
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingExternalProp, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingExternalProp.__dict__ and type(IAdvFixedWingExternalProp.__dict__[attrname]) == property:
            return IAdvFixedWingExternalProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingExternalProp.")
    
    @property
    def filepath(self) -> str:
        """The filepath for the external aero file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external aero file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_set_filepath"](arg_filepath.COM_val, byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{a886a5d9-63f4-455c-9cda-bce9c81d941d}", IAdvFixedWingExternalProp)
agcls.AgTypeNameMap["IAdvFixedWingExternalProp"] = IAdvFixedWingExternalProp

class IAdvFixedWingPistonPowerplant(object):
    """Interface used to access the options for the Piston powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{891f9708-b367-447d-9e25-bb8fb24d6c83}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_sea_level_static_power"] = _raise_uninitialized_error
        self.__dict__["_set_max_sea_level_static_power"] = _raise_uninitialized_error
        self.__dict__["_get_critical_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_critical_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingPistonPowerplant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingPistonPowerplant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingPistonPowerplant = agcom.GUID(IAdvFixedWingPistonPowerplant._uuid)
        vtable_offset_local = IAdvFixedWingPistonPowerplant._vtable_offset - 1
        self.__dict__["_get_max_sea_level_static_power"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_sea_level_static_power"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_critical_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_critical_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingPistonPowerplant, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingPistonPowerplant.__dict__ and type(IAdvFixedWingPistonPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingPistonPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingPistonPowerplant.")
    
    @property
    def max_sea_level_static_power(self) -> float:
        """The maximum static power of the engine at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_sea_level_static_power"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_sea_level_static_power.setter
    def max_sea_level_static_power(self, newVal:float) -> None:
        """The maximum static power of the engine at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_sea_level_static_power"](arg_newVal.COM_val))

    @property
    def critical_altitude(self) -> float:
        """The engine's critical altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_critical_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @critical_altitude.setter
    def critical_altitude(self, newVal:float) -> None:
        """The engine's critical altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_critical_altitude"](arg_newVal.COM_val))

    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_count.setter
    def propeller_count(self, newVal:int) -> None:
        """The number of propellers."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_count"](arg_newVal.COM_val))

    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_diameter.setter
    def propeller_diameter(self, newVal:float) -> None:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_diameter"](arg_newVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """The engine's fuel flow at max power."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The engine's fuel flow at max power."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{891f9708-b367-447d-9e25-bb8fb24d6c83}", IAdvFixedWingPistonPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingPistonPowerplant"] = IAdvFixedWingPistonPowerplant

class IAdvFixedWingTurbopropPowerplant(object):
    """Interface used to access the options for the Turboprop powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{04fd63b4-761a-49b4-8a9c-c1610f676993}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_sea_level_static_power"] = _raise_uninitialized_error
        self.__dict__["_set_max_sea_level_static_power"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_count"] = _raise_uninitialized_error
        self.__dict__["_get_propeller_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_propeller_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingTurbopropPowerplant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbopropPowerplant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingTurbopropPowerplant = agcom.GUID(IAdvFixedWingTurbopropPowerplant._uuid)
        vtable_offset_local = IAdvFixedWingTurbopropPowerplant._vtable_offset - 1
        self.__dict__["_get_max_sea_level_static_power"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_sea_level_static_power"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_propeller_count"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_propeller_diameter"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbopropPowerplant, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbopropPowerplant.__dict__ and type(IAdvFixedWingTurbopropPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingTurbopropPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbopropPowerplant.")
    
    @property
    def max_sea_level_static_power(self) -> float:
        """The maximum static power of the engine at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_sea_level_static_power"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_sea_level_static_power.setter
    def max_sea_level_static_power(self, newVal:float) -> None:
        """The maximum static power of the engine at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_sea_level_static_power"](arg_newVal.COM_val))

    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_count.setter
    def propeller_count(self, newVal:int) -> None:
        """The number of propellers."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_count"](arg_newVal.COM_val))

    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propeller_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propeller_diameter.setter
    def propeller_diameter(self, newVal:float) -> None:
        """The propeller diameter."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propeller_diameter"](arg_newVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """The engine's fuel flow at max power."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The engine's fuel flow at max power."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{04fd63b4-761a-49b4-8a9c-c1610f676993}", IAdvFixedWingTurbopropPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingTurbopropPowerplant"] = IAdvFixedWingTurbopropPowerplant

class IAdvFixedWingEmpiricalJetEngine(object):
    """Interface used to access the options for the Sub/Super/Hypersonic powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{f8fa49f0-f901-4b85-ac60-0712141db32c}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_sea_level_static_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_max_sea_level_static_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_design_point_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_design_point_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_design_point_mach_number"] = _raise_uninitialized_error
        self.__dict__["_set_design_point_mach_number"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingEmpiricalJetEngine._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingEmpiricalJetEngine from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingEmpiricalJetEngine = agcom.GUID(IAdvFixedWingEmpiricalJetEngine._uuid)
        vtable_offset_local = IAdvFixedWingEmpiricalJetEngine._vtable_offset - 1
        self.__dict__["_get_max_sea_level_static_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_sea_level_static_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_design_point_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_point_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_design_point_mach_number"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_point_mach_number"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingEmpiricalJetEngine, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingEmpiricalJetEngine.__dict__ and type(IAdvFixedWingEmpiricalJetEngine.__dict__[attrname]) == property:
            return IAdvFixedWingEmpiricalJetEngine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingEmpiricalJetEngine.")
    
    @property
    def max_sea_level_static_thrust(self) -> float:
        """The maximum static thrust of the engine at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_sea_level_static_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_sea_level_static_thrust.setter
    def max_sea_level_static_thrust(self, newVal:float) -> None:
        """The maximum static thrust of the engine at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_sea_level_static_thrust"](arg_newVal.COM_val))

    @property
    def design_point_altitude(self) -> float:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_point_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_point_altitude.setter
    def design_point_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_point_altitude"](arg_newVal.COM_val))

    @property
    def design_point_mach_number(self) -> float:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_point_mach_number"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_point_mach_number.setter
    def design_point_mach_number(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_point_mach_number"](arg_newVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """The engine's fuel flow at max power."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The engine's fuel flow at max power."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{f8fa49f0-f901-4b85-ac60-0712141db32c}", IAdvFixedWingEmpiricalJetEngine)
agcls.AgTypeNameMap["IAdvFixedWingEmpiricalJetEngine"] = IAdvFixedWingEmpiricalJetEngine

class IAdvFixedWingTurbojetBasicABProp(object):
    """Interface used to access the options for the Turbojet - Basic w/AB (Thermodynamic) powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{7ff41deb-7c10-42ac-8805-0b251e250018}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_can_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_set_can_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_get_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_design_mach"] = _raise_uninitialized_error
        self.__dict__["_set_design_mach"] = _raise_uninitialized_error
        self.__dict__["_get_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_afterburner_on"] = _raise_uninitialized_error
        self.__dict__["_set_afterburner_on"] = _raise_uninitialized_error
        self.__dict__["_get_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_get_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_get_max_afterburner_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_afterburner_temp"] = _raise_uninitialized_error
        self.__dict__["_get_hpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_hpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_lpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_lpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_efficiencies_and_losses"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_afprop"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_cea"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingTurbojetBasicABProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbojetBasicABProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingTurbojetBasicABProp = agcom.GUID(IAdvFixedWingTurbojetBasicABProp._uuid)
        vtable_offset_local = IAdvFixedWingTurbojetBasicABProp._vtable_offset - 1
        self.__dict__["_get_can_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_can_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_afterburner_on"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_afterburner_on"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_afterburner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_afterburner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_hpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_hpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_lpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_efficiencies_and_losses"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_get_fuel_mode_as_afprop"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_mode_as_cea"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbojetBasicABProp, vtable_offset_local+25, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbojetBasicABProp.__dict__ and type(IAdvFixedWingTurbojetBasicABProp.__dict__[attrname]) == property:
            return IAdvFixedWingTurbojetBasicABProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbojetBasicABProp.")
    
    @property
    def can_use_afterburner(self) -> bool:
        """Opt whether the engine has an afterburner."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_use_afterburner"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @can_use_afterburner.setter
    def can_use_afterburner(self, newVal:bool) -> None:
        """Opt whether the engine has an afterburner."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_can_use_afterburner"](arg_newVal.COM_val))

    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_altitude"](arg_newVal.COM_val))

    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_mach"](arg_newVal.COM_val))

    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_thrust"](arg_newVal.COM_val))

    @property
    def afterburner_on(self) -> bool:
        """Opt whether to specify the design point with the afterburner on. """
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_afterburner_on"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @afterburner_on.setter
    def afterburner_on(self, newVal:bool) -> None:
        """Opt whether to specify the design point with the afterburner on."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_afterburner_on"](arg_newVal.COM_val))

    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_compression_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_compression_temp"](arg_newVal.COM_val))

    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_burner_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_burner_temp"](arg_newVal.COM_val))

    @property
    def max_afterburner_temp(self) -> float:
        """The maximum temperature at the afterburner."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_afterburner_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_afterburner_temp.setter
    def max_afterburner_temp(self, newVal:float) -> None:
        """The maximum temperature at the afterburner."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_afterburner_temp"](arg_newVal.COM_val))

    @property
    def hpc_pressure_ratio(self) -> float:
        """The pressure ratio of the high-pressure compressor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hpc_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hpc_pressure_ratio.setter
    def hpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the high-pressure compressor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hpc_pressure_ratio"](arg_newVal.COM_val))

    @property
    def lpc_pressure_ratio(self) -> float:
        """The pressure ratio of the low-pressure compressor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lpc_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lpc_pressure_ratio.setter
    def lpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the low-pressure compressor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lpc_pressure_ratio"](arg_newVal.COM_val))

    @property
    def efficiencies_and_losses(self) -> "IPropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_efficiencies_and_losses"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def fuel_type(self) -> "AVTR_JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_type.setter
    def fuel_type(self, newVal:"AVTR_JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_type"](arg_newVal.COM_val))

    @property
    def fuel_mode_as_afprop(self) -> "IFuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_afprop"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def fuel_mode_as_cea(self) -> "IFuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_cea"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7ff41deb-7c10-42ac-8805-0b251e250018}", IAdvFixedWingTurbojetBasicABProp)
agcls.AgTypeNameMap["IAdvFixedWingTurbojetBasicABProp"] = IAdvFixedWingTurbojetBasicABProp

class IAdvFixedWingTurbofanBasicABProp(object):
    """Interface used to access the options for the Turbofan - Basic w/AB (Thermodynamic) powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{f26a8761-895c-47b1-9836-9278313cf45d}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_can_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_set_can_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_get_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_design_mach"] = _raise_uninitialized_error
        self.__dict__["_set_design_mach"] = _raise_uninitialized_error
        self.__dict__["_get_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_afterburner_on"] = _raise_uninitialized_error
        self.__dict__["_set_afterburner_on"] = _raise_uninitialized_error
        self.__dict__["_get_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_get_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_get_max_afterburner_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_afterburner_temp"] = _raise_uninitialized_error
        self.__dict__["_get_hpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_hpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_lpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_lpc_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_fan_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_fan_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_efficiencies_and_losses"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_afprop"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_cea"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingTurbofanBasicABProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbofanBasicABProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingTurbofanBasicABProp = agcom.GUID(IAdvFixedWingTurbofanBasicABProp._uuid)
        vtable_offset_local = IAdvFixedWingTurbofanBasicABProp._vtable_offset - 1
        self.__dict__["_get_can_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_can_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_afterburner_on"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_afterburner_on"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_afterburner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_afterburner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_hpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_hpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_lpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lpc_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_fan_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fan_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_efficiencies_and_losses"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_get_fuel_mode_as_afprop"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+26, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_mode_as_cea"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingTurbofanBasicABProp, vtable_offset_local+27, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbofanBasicABProp.__dict__ and type(IAdvFixedWingTurbofanBasicABProp.__dict__[attrname]) == property:
            return IAdvFixedWingTurbofanBasicABProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbofanBasicABProp.")
    
    @property
    def can_use_afterburner(self) -> bool:
        """Opt whether the engine has an afterburner."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_use_afterburner"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @can_use_afterburner.setter
    def can_use_afterburner(self, newVal:bool) -> None:
        """Opt whether the engine has an afterburner."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_can_use_afterburner"](arg_newVal.COM_val))

    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_altitude"](arg_newVal.COM_val))

    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_mach"](arg_newVal.COM_val))

    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_thrust"](arg_newVal.COM_val))

    @property
    def afterburner_on(self) -> bool:
        """Opt whether to specify the design point with the afterburner on. """
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_afterburner_on"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @afterburner_on.setter
    def afterburner_on(self, newVal:bool) -> None:
        """Opt whether to specify the design point with the afterburner on."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_afterburner_on"](arg_newVal.COM_val))

    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_compression_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_compression_temp"](arg_newVal.COM_val))

    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_burner_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_burner_temp"](arg_newVal.COM_val))

    @property
    def max_afterburner_temp(self) -> float:
        """The maximum temperature at the afterburner."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_afterburner_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_afterburner_temp.setter
    def max_afterburner_temp(self, newVal:float) -> None:
        """The maximum temperature at the afterburner."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_afterburner_temp"](arg_newVal.COM_val))

    @property
    def hpc_pressure_ratio(self) -> float:
        """The pressure ratio of the high-pressure compressor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hpc_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hpc_pressure_ratio.setter
    def hpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the high-pressure compressor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hpc_pressure_ratio"](arg_newVal.COM_val))

    @property
    def lpc_pressure_ratio(self) -> float:
        """The pressure ratio of the low-pressure compressor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lpc_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lpc_pressure_ratio.setter
    def lpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the low-pressure compressor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lpc_pressure_ratio"](arg_newVal.COM_val))

    @property
    def fan_pressure_ratio(self) -> float:
        """The pressure ratio of the fan."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fan_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fan_pressure_ratio.setter
    def fan_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the fan."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fan_pressure_ratio"](arg_newVal.COM_val))

    @property
    def efficiencies_and_losses(self) -> "IPropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_efficiencies_and_losses"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def fuel_type(self) -> "AVTR_JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_type.setter
    def fuel_type(self, newVal:"AVTR_JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_type"](arg_newVal.COM_val))

    @property
    def fuel_mode_as_afprop(self) -> "IFuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_afprop"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def fuel_mode_as_cea(self) -> "IFuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_cea"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{f26a8761-895c-47b1-9836-9278313cf45d}", IAdvFixedWingTurbofanBasicABProp)
agcls.AgTypeNameMap["IAdvFixedWingTurbofanBasicABProp"] = IAdvFixedWingTurbofanBasicABProp

class IAviatorVehicle(object):
    """Interface for a vehicle in Aviator."""
    _uuid = "{9be54cfc-ba13-4a27-a829-2e10e04f2beb}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAviatorVehicle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAviatorVehicle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAviatorVehicle = agcom.GUID(IAviatorVehicle._uuid)
        vtable_offset_local = IAviatorVehicle._vtable_offset - 1
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAviatorVehicle, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAviatorVehicle.__dict__ and type(IAviatorVehicle.__dict__[attrname]) == property:
            return IAviatorVehicle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAviatorVehicle.")
    
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{9be54cfc-ba13-4a27-a829-2e10e04f2beb}", IAviatorVehicle)
agcls.AgTypeNameMap["IAviatorVehicle"] = IAviatorVehicle

class IMissileModel(object):
    """Interface used to access the missile options in the Aviator catalog."""
    _uuid = "{80168c56-998d-45e3-9a93-e0511478a44b}"
    _num_methods = 47
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_mode"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_mode"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_mode_helper"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_transitions"] = _raise_uninitialized_error
        self.__dict__["_get_ignore_fpa_for_climb_descent_transitions"] = _raise_uninitialized_error
        self.__dict__["_set_ignore_fpa_for_climb_descent_transitions"] = _raise_uninitialized_error
        self.__dict__["_get_climb_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_climb_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_climb_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_climb_max_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_climb_max_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_climb_min_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_climb_min_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_climb_fail_on_insufficient_performance"] = _raise_uninitialized_error
        self.__dict__["_set_climb_fail_on_insufficient_performance"] = _raise_uninitialized_error
        self.__dict__["_get_cruise_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_cruise_max_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_cruise_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_cruise_default_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_cruise_default_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_descent_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_descent_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_descent_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_descent_max_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_descent_max_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_descent_min_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_descent_min_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_descent_fail_on_insufficient_performance"] = _raise_uninitialized_error
        self.__dict__["_set_descent_fail_on_insufficient_performance"] = _raise_uninitialized_error
        self.__dict__["_get_use_total_temp_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_total_temp_limit"] = _raise_uninitialized_error
        self.__dict__["_get_total_temp_limit"] = _raise_uninitialized_error
        self.__dict__["_set_total_temp_limit"] = _raise_uninitialized_error
        self.__dict__["_get_use_mach_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_mach_limit"] = _raise_uninitialized_error
        self.__dict__["_get_mach_limit"] = _raise_uninitialized_error
        self.__dict__["_set_mach_limit"] = _raise_uninitialized_error
        self.__dict__["_get_use_eas_limit"] = _raise_uninitialized_error
        self.__dict__["_set_use_eas_limit"] = _raise_uninitialized_error
        self.__dict__["_get_eas_limit"] = _raise_uninitialized_error
        self.__dict__["_set_eas_limit"] = _raise_uninitialized_error
        self.__dict__["_get_default_configuration"] = _raise_uninitialized_error
        self.__dict__["_get_aerodynamics"] = _raise_uninitialized_error
        self.__dict__["_get_propulsion"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileModel = agcom.GUID(IMissileModel._uuid)
        vtable_offset_local = IMissileModel._vtable_offset - 1
        self.__dict__["_get_max_load_factor"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_load_factor"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_maneuver_mode"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_maneuver_mode"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_maneuver_mode_helper"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_attitude_transitions"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_ignore_fpa_for_climb_descent_transitions"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_ignore_fpa_for_climb_descent_transitions"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_climb_airspeed"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_get_climb_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_climb_airspeed"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+11, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_climb_max_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_climb_max_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_climb_min_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_climb_min_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+15, agcom.VARIANT)
        self.__dict__["_get_climb_fail_on_insufficient_performance"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_climb_fail_on_insufficient_performance"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_cruise_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_get_cruise_max_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_cruise_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+20, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_cruise_default_altitude"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cruise_default_altitude"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_descent_airspeed"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_get_descent_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_descent_airspeed"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+25, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_descent_max_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+26, POINTER(agcom.VARIANT))
        self.__dict__["_set_descent_max_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+27, agcom.VARIANT)
        self.__dict__["_get_descent_min_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+28, POINTER(agcom.VARIANT))
        self.__dict__["_set_descent_min_fpa"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+29, agcom.VARIANT)
        self.__dict__["_get_descent_fail_on_insufficient_performance"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+30, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_descent_fail_on_insufficient_performance"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+31, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_total_temp_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+32, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_total_temp_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+33, agcom.VARIANT_BOOL)
        self.__dict__["_get_total_temp_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+34, POINTER(agcom.DOUBLE))
        self.__dict__["_set_total_temp_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+35, agcom.DOUBLE)
        self.__dict__["_get_use_mach_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+36, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_mach_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+37, agcom.VARIANT_BOOL)
        self.__dict__["_get_mach_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+38, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mach_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+39, agcom.DOUBLE)
        self.__dict__["_get_use_eas_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+40, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_eas_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+41, agcom.VARIANT_BOOL)
        self.__dict__["_get_eas_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+42, POINTER(agcom.DOUBLE))
        self.__dict__["_set_eas_limit"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+43, agcom.DOUBLE)
        self.__dict__["_get_default_configuration"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+44, POINTER(agcom.PVOID))
        self.__dict__["_get_aerodynamics"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+45, POINTER(agcom.PVOID))
        self.__dict__["_get_propulsion"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+46, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IMissileModel, vtable_offset_local+47, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileModel.__dict__ and type(IMissileModel.__dict__[attrname]) == property:
            return IMissileModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileModel.")
    
    @property
    def max_load_factor(self) -> float:
        """The maximum load factor that the missile can withstand while maneuvering."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_load_factor.setter
    def max_load_factor(self, pVal:float) -> None:
        """The maximum load factor that the missile can withstand while maneuvering."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_load_factor"](arg_pVal.COM_val))

    @property
    def maneuver_mode(self) -> "AVTR_ACCEL_MANEUVER_MODE":
        """The mode that the missile will adhere to the specified load factor. Scale by atmospheric density will cause the missile to consider dynamic pressure when calculating turn radius."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_mode.setter
    def maneuver_mode(self, newVal:"AVTR_ACCEL_MANEUVER_MODE") -> None:
        """The mode that the missile will adhere to the specified load factor. Scale by atmospheric density will cause the missile to consider dynamic pressure when calculating turn radius."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_mode"](arg_newVal.COM_val))

    @property
    def maneuver_mode_helper(self) -> "IAeroPropManeuverModeHelper":
        """Get the interface for the Aero/Prop Maneuver Mode helper. The maneuver mode must be set to Aero/Prop to access this interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_mode_helper"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def attitude_transitions(self) -> "IAttitudeTransitions":
        """Get the attitude transitions interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_transitions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ignore_fpa_for_climb_descent_transitions(self) -> bool:
        """Opt whether to ignore the flight path angle limits for climb and descent transitions."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ignore_fpa_for_climb_descent_transitions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ignore_fpa_for_climb_descent_transitions.setter
    def ignore_fpa_for_climb_descent_transitions(self, pVal:bool) -> None:
        """Opt whether to ignore the flight path angle limits for climb and descent transitions."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_ignore_fpa_for_climb_descent_transitions"](arg_pVal.COM_val))

    @property
    def climb_airspeed(self) -> float:
        """The standard airspeed of the missile while climbing."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def climb_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The climb airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_climb_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the missile's climb airspeed and airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_climb_airspeed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def climb_max_fpa(self) -> typing.Any:
        """The maximum flight path angle of the missile's flight path while climbing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_max_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @climb_max_fpa.setter
    def climb_max_fpa(self, pVal:typing.Any) -> None:
        """The maximum flight path angle of the missile's flight path while climbing."""
        with agmarshall.VARIANT_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_climb_max_fpa"](arg_pVal.COM_val))

    @property
    def climb_min_fpa(self) -> typing.Any:
        """The minimum flight path angle of the missile's flight path while climbing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_min_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @climb_min_fpa.setter
    def climb_min_fpa(self, pVal:typing.Any) -> None:
        """The minimum flight path angle of the missile's flight path while climbing."""
        with agmarshall.VARIANT_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_climb_min_fpa"](arg_pVal.COM_val))

    @property
    def climb_fail_on_insufficient_performance(self) -> bool:
        """Opt whether to fail while climbing if there is insufficient specific excess power."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_fail_on_insufficient_performance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @climb_fail_on_insufficient_performance.setter
    def climb_fail_on_insufficient_performance(self, pVal:bool) -> None:
        """Opt whether to fail while climbing if there is insufficient specific excess power."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_climb_fail_on_insufficient_performance"](arg_pVal.COM_val))

    @property
    def cruise_max_airspeed(self) -> float:
        """The maximum airspeed of the missile while cruising."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cruise_max_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def cruise_max_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The cruise airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cruise_max_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_cruise_max_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the missile's max cruise airspeed and airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_cruise_max_airspeed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def cruise_default_altitude(self) -> float:
        """The missile's default cruising altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cruise_default_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cruise_default_altitude.setter
    def cruise_default_altitude(self, pVal:float) -> None:
        """The missile's default cruising altitude."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_cruise_default_altitude"](arg_pVal.COM_val))

    @property
    def descent_airspeed(self) -> float:
        """The standard airspeed of the missile while descending."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def descent_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The descent airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_descent_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the missile's descent airspeed and airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(aispeed) as arg_aispeed:
            agcls.evaluate_hresult(self.__dict__["_set_descent_airspeed"](arg_airspeedType.COM_val, arg_aispeed.COM_val))

    @property
    def descent_max_fpa(self) -> typing.Any:
        """The maximum flight path angle of the missile's flight path while descending."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_max_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @descent_max_fpa.setter
    def descent_max_fpa(self, pVal:typing.Any) -> None:
        """The maximum flight path angle of the missile's flight path while descending."""
        with agmarshall.VARIANT_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_descent_max_fpa"](arg_pVal.COM_val))

    @property
    def descent_min_fpa(self) -> typing.Any:
        """The minimum flight path angle of the missile's flight path while descending."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_min_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @descent_min_fpa.setter
    def descent_min_fpa(self, pVal:typing.Any) -> None:
        """The minimum flight path angle of the missile's flight path while descending."""
        with agmarshall.VARIANT_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_descent_min_fpa"](arg_pVal.COM_val))

    @property
    def descent_fail_on_insufficient_performance(self) -> bool:
        """Opt whether to fail while descending if there is insufficient specific excess power."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_fail_on_insufficient_performance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @descent_fail_on_insufficient_performance.setter
    def descent_fail_on_insufficient_performance(self, pVal:bool) -> None:
        """Opt whether to fail while descending if there is insufficient specific excess power."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_descent_fail_on_insufficient_performance"](arg_pVal.COM_val))

    @property
    def use_total_temp_limit(self) -> bool:
        """Opt whether to limit the speed of the missile so the specified temperature is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_total_temp_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_total_temp_limit.setter
    def use_total_temp_limit(self, pVal:bool) -> None:
        """Opt whether to limit the speed of the missile so the specified temperature is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_total_temp_limit"](arg_pVal.COM_val))

    @property
    def total_temp_limit(self) -> float:
        """The maximum total temperature limit of the missile."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_temp_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @total_temp_limit.setter
    def total_temp_limit(self, pVal:float) -> None:
        """The maximum total temperature limit of the missile."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_total_temp_limit"](arg_pVal.COM_val))

    @property
    def use_mach_limit(self) -> bool:
        """Opt whether to limit the speed of the missile so the specified mach number is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_mach_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_mach_limit.setter
    def use_mach_limit(self, pVal:bool) -> None:
        """Opt whether to limit the speed of the missile so the specified mach number is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_mach_limit"](arg_pVal.COM_val))

    @property
    def mach_limit(self) -> float:
        """The maximum allowable mach number."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mach_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mach_limit.setter
    def mach_limit(self, pVal:float) -> None:
        """The maximum allowable mach number."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_mach_limit"](arg_pVal.COM_val))

    @property
    def use_eas_limit(self) -> bool:
        """Opt whether to limit the speed of the missile so the specified Equivalent Airspeed is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_eas_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_eas_limit.setter
    def use_eas_limit(self, pVal:bool) -> None:
        """Opt whether to limit the speed of the missile so the specified Equivalent Airspeed is not exceeded."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_eas_limit"](arg_pVal.COM_val))

    @property
    def eas_limit(self) -> float:
        """The maximum allowable Equivalent Airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eas_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eas_limit.setter
    def eas_limit(self, pVal:float) -> None:
        """The maximum allowable Equivalent Airspeed."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_eas_limit"](arg_pVal.COM_val))

    @property
    def default_configuration(self) -> "IConfiguration":
        """The aircraft's default configuration as saved in the catalog."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrConfig:
            agcls.evaluate_hresult(self.__dict__["_get_default_configuration"](byref(arg_ppAvtrConfig.COM_val)))
            return arg_ppAvtrConfig.python_val

    @property
    def aerodynamics(self) -> "IMissileAero":
        """Get the aerodynamics interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aerodynamics"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def propulsion(self) -> "IMissileProp":
        """Get the propulsion interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_propulsion"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{80168c56-998d-45e3-9a93-e0511478a44b}", IMissileModel)
agcls.AgTypeNameMap["IMissileModel"] = IMissileModel

class IMissileAero(object):
    """Interface used to access the aerodynamics options for a missile."""
    _uuid = "{b7e5c31a-5fbd-4a71-b99b-48707d6af556}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aero_strategy"] = _raise_uninitialized_error
        self.__dict__["_set_aero_strategy"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_simple"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_external"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_advanced"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileAero = agcom.GUID(IMissileAero._uuid)
        vtable_offset_local = IMissileAero._vtable_offset - 1
        self.__dict__["_get_aero_strategy"] = IAGFUNCTYPE(pUnk, IID_IMissileAero, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_aero_strategy"] = IAGFUNCTYPE(pUnk, IID_IMissileAero, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_mode_as_simple"] = IAGFUNCTYPE(pUnk, IID_IMissileAero, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_external"] = IAGFUNCTYPE(pUnk, IID_IMissileAero, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_advanced"] = IAGFUNCTYPE(pUnk, IID_IMissileAero, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileAero.__dict__ and type(IMissileAero.__dict__[attrname]) == property:
            return IMissileAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileAero.")
    
    @property
    def aero_strategy(self) -> "AVTR_MISSILE_AERO_STRATEGY":
        """The aerodynamic strategy type."""
        with agmarshall.AgEnum_arg(AVTR_MISSILE_AERO_STRATEGY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aero_strategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aero_strategy.setter
    def aero_strategy(self, newVal:"AVTR_MISSILE_AERO_STRATEGY") -> None:
        """The aerodynamic strategy type."""
        with agmarshall.AgEnum_arg(AVTR_MISSILE_AERO_STRATEGY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_aero_strategy"](arg_newVal.COM_val))

    @property
    def mode_as_simple(self) -> "IMissileSimpleAero":
        """Get the interface for a simple aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_simple"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_external(self) -> "IMissileExternalAero":
        """Get the interface for an external file aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_external"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_advanced(self) -> "IMissileAdvancedAero":
        """Get the interface for an advanced aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_advanced"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b7e5c31a-5fbd-4a71-b99b-48707d6af556}", IMissileAero)
agcls.AgTypeNameMap["IMissileAero"] = IMissileAero

class IMissileProp(object):
    """Interface used to access the Propulsion options for a missile."""
    _uuid = "{3a29d5aa-b4f4-4431-9857-1d61bd3250cb}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_prop_strategy"] = _raise_uninitialized_error
        self.__dict__["_set_prop_strategy"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_simple"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_external"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_ramjet"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_turbojet"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_rocket"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileProp = agcom.GUID(IMissileProp._uuid)
        vtable_offset_local = IMissileProp._vtable_offset - 1
        self.__dict__["_get_prop_strategy"] = IAGFUNCTYPE(pUnk, IID_IMissileProp, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_prop_strategy"] = IAGFUNCTYPE(pUnk, IID_IMissileProp, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_mode_as_simple"] = IAGFUNCTYPE(pUnk, IID_IMissileProp, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_external"] = IAGFUNCTYPE(pUnk, IID_IMissileProp, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_ramjet"] = IAGFUNCTYPE(pUnk, IID_IMissileProp, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_turbojet"] = IAGFUNCTYPE(pUnk, IID_IMissileProp, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_rocket"] = IAGFUNCTYPE(pUnk, IID_IMissileProp, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileProp.__dict__ and type(IMissileProp.__dict__[attrname]) == property:
            return IMissileProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileProp.")
    
    @property
    def prop_strategy(self) -> "AVTR_MISSILE_PROP_STRATEGY":
        """The propulsion strategy type."""
        with agmarshall.AgEnum_arg(AVTR_MISSILE_PROP_STRATEGY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_prop_strategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @prop_strategy.setter
    def prop_strategy(self, newVal:"AVTR_MISSILE_PROP_STRATEGY") -> None:
        """The propulsion strategy type."""
        with agmarshall.AgEnum_arg(AVTR_MISSILE_PROP_STRATEGY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_prop_strategy"](arg_newVal.COM_val))

    @property
    def mode_as_simple(self) -> "IMissileSimpleProp":
        """Get the interface for a simple propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_simple"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_external(self) -> "IMissileExternalProp":
        """Get the interface for an external file propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_external"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_ramjet(self) -> "IMissileRamjetProp":
        """Get the interface for an Ramjet propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_ramjet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_turbojet(self) -> "IMissileTurbojetProp":
        """Get the interface for an Turbojet propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_turbojet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_rocket(self) -> "IMissileRocketProp":
        """Get the interface for an Rocket propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_rocket"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3a29d5aa-b4f4-4431-9857-1d61bd3250cb}", IMissileProp)
agcls.AgTypeNameMap["IMissileProp"] = IMissileProp

class IMissileSimpleAero(object):
    """Interface used to access the Simple aerodynamics options for a missile."""
    _uuid = "{e189fccd-ff74-40ee-9181-ed655a619480}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_s_ref"] = _raise_uninitialized_error
        self.__dict__["_set_s_ref"] = _raise_uninitialized_error
        self.__dict__["_get_cl_max"] = _raise_uninitialized_error
        self.__dict__["_set_cl_max"] = _raise_uninitialized_error
        self.__dict__["_get_cd"] = _raise_uninitialized_error
        self.__dict__["_set_cd"] = _raise_uninitialized_error
        self.__dict__["_get_calculate_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_max_aoa"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileSimpleAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileSimpleAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileSimpleAero = agcom.GUID(IMissileSimpleAero._uuid)
        vtable_offset_local = IMissileSimpleAero._vtable_offset - 1
        self.__dict__["_get_s_ref"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_s_ref"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_cl_max"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cl_max"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_cd"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cd"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_calculate_aoa"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleAero, vtable_offset_local+9, agcom.VARIANT_BOOL, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileSimpleAero.__dict__ and type(IMissileSimpleAero.__dict__[attrname]) == property:
            return IMissileSimpleAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileSimpleAero.")
    
    @property
    def s_ref(self) -> float:
        """The area of the lifting surface of the missile."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_s_ref"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @s_ref.setter
    def s_ref(self, newVal:float) -> None:
        """The area of the lifting surface of the missile."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_s_ref"](arg_newVal.COM_val))

    @property
    def cl_max(self) -> float:
        """The max coefficient of lift."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cl_max"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cl_max.setter
    def cl_max(self, newVal:float) -> None:
        """The max coefficient of lift."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cl_max"](arg_newVal.COM_val))

    @property
    def cd(self) -> float:
        """The coefficient of drag."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cd"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cd.setter
    def cd(self, newVal:float) -> None:
        """The coefficient of drag."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cd"](arg_newVal.COM_val))

    @property
    def calculate_aoa(self) -> bool:
        """Opt to allow Aviator to calculate the Angle of Attack. Otherwise, the value will be 0 by default."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calculate_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_aoa(self) -> typing.Any:
        """The missile's maximum angle of attack."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_max_aoa(self, calculateAoA:bool, maxAoA:typing.Any) -> None:
        """Set whether to calculate the Angle of Attack and the corresponding value."""
        with agmarshall.VARIANT_BOOL_arg(calculateAoA) as arg_calculateAoA, \
             agmarshall.VARIANT_arg(maxAoA) as arg_maxAoA:
            agcls.evaluate_hresult(self.__dict__["_set_max_aoa"](arg_calculateAoA.COM_val, arg_maxAoA.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{e189fccd-ff74-40ee-9181-ed655a619480}", IMissileSimpleAero)
agcls.AgTypeNameMap["IMissileSimpleAero"] = IMissileSimpleAero

class IMissileSimpleProp(object):
    """Interface used to access the Simple propulsion options for a missile."""
    _uuid = "{410fb08c-ae20-4f74-9b91-9035b813b146}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_max_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileSimpleProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileSimpleProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileSimpleProp = agcom.GUID(IMissileSimpleProp._uuid)
        vtable_offset_local = IMissileSimpleProp._vtable_offset - 1
        self.__dict__["_get_max_thrust"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleProp, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_thrust"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleProp, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleProp, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileSimpleProp, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileSimpleProp.__dict__ and type(IMissileSimpleProp.__dict__[attrname]) == property:
            return IMissileSimpleProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileSimpleProp.")
    
    @property
    def max_thrust(self) -> float:
        """The maximum thrust of the missile."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_thrust.setter
    def max_thrust(self, pVal:float) -> None:
        """The maximum thrust of the missile."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_thrust"](arg_pVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """The fuel flow at max thrust."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, pVal:float) -> None:
        """The fuel flow at max thrust."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_pVal.COM_val))

    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_no_thrust_when_no_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_no_thrust_when_no_fuel"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{410fb08c-ae20-4f74-9b91-9035b813b146}", IMissileSimpleProp)
agcls.AgTypeNameMap["IMissileSimpleProp"] = IMissileSimpleProp

class IMissileExternalAero(object):
    """Interface used to access the External aerodynamics options for a missile."""
    _uuid = "{fed723ce-0c02-41bb-8e61-d602b3543049}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_filepath"] = _raise_uninitialized_error
        self.__dict__["_reload"] = _raise_uninitialized_error
        self.__dict__["_get_ref_area"] = _raise_uninitialized_error
        self.__dict__["_set_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_can_set_ref_area"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileExternalAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileExternalAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileExternalAero = agcom.GUID(IMissileExternalAero._uuid)
        vtable_offset_local = IMissileExternalAero._vtable_offset - 1
        self.__dict__["_get_filepath"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalAero, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_filepath"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalAero, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.BSTR))
        self.__dict__["_reload"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalAero, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_ref_area"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalAero, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ref_area"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalAero, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_can_set_ref_area"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalAero, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalAero, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileExternalAero.__dict__ and type(IMissileExternalAero.__dict__[attrname]) == property:
            return IMissileExternalAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileExternalAero.")
    
    @property
    def filepath(self) -> str:
        """The filepath for the external aero file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external aero file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_set_filepath"](arg_filepath.COM_val, byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    def reload(self) -> str:
        """Reload the external aero file."""
        with agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_reload"](byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    @property
    def ref_area(self) -> float:
        """The area of the lifting surface of the missile."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_area.setter
    def ref_area(self, pVal:float) -> None:
        """The area of the lifting surface of the missile."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_area"](arg_pVal.COM_val))

    @property
    def can_set_ref_area(self) -> bool:
        """Check whether you can set the reference area or whether it is specified in the file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_set_ref_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{fed723ce-0c02-41bb-8e61-d602b3543049}", IMissileExternalAero)
agcls.AgTypeNameMap["IMissileExternalAero"] = IMissileExternalAero

class IMissileExternalProp(object):
    """Interface used to access the External Prop file options for a missile."""
    _uuid = "{14bcb2f5-2893-4743-9e3c-1b9c52505e0c}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_filepath"] = _raise_uninitialized_error
        self.__dict__["_reload"] = _raise_uninitialized_error
        self.__dict__["_get_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileExternalProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileExternalProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileExternalProp = agcom.GUID(IMissileExternalProp._uuid)
        vtable_offset_local = IMissileExternalProp._vtable_offset - 1
        self.__dict__["_get_filepath"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalProp, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_filepath"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalProp, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.BSTR))
        self.__dict__["_reload"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalProp, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalProp, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalProp, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IMissileExternalProp, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileExternalProp.__dict__ and type(IMissileExternalProp.__dict__[attrname]) == property:
            return IMissileExternalProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileExternalProp.")
    
    @property
    def filepath(self) -> str:
        """The filepath for the external prop file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external prop file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_set_filepath"](arg_filepath.COM_val, byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    def reload(self) -> str:
        """Reload the external prop file."""
        with agmarshall.BSTR_arg() as arg_pReturnMsg:
            agcls.evaluate_hresult(self.__dict__["_reload"](byref(arg_pReturnMsg.COM_val)))
            return arg_pReturnMsg.python_val

    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_no_thrust_when_no_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_no_thrust_when_no_fuel"](arg_pVal.COM_val))

    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{14bcb2f5-2893-4743-9e3c-1b9c52505e0c}", IMissileExternalProp)
agcls.AgTypeNameMap["IMissileExternalProp"] = IMissileExternalProp

class IMissileAdvancedAero(object):
    """Interface used to access the Advanced aerodynamics options for a missile."""
    _uuid = "{a26fe490-218c-44e4-95ab-69c20d3d6629}"
    _num_methods = 48
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_body_width"] = _raise_uninitialized_error
        self.__dict__["_set_body_width"] = _raise_uninitialized_error
        self.__dict__["_get_body_height"] = _raise_uninitialized_error
        self.__dict__["_set_body_height"] = _raise_uninitialized_error
        self.__dict__["_get_body_length"] = _raise_uninitialized_error
        self.__dict__["_set_body_length"] = _raise_uninitialized_error
        self.__dict__["_get_nose_length"] = _raise_uninitialized_error
        self.__dict__["_set_nose_length"] = _raise_uninitialized_error
        self.__dict__["_get_nose_tip_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_nose_tip_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_nozzle_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_nozzle_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_min_mach"] = _raise_uninitialized_error
        self.__dict__["_set_min_mach"] = _raise_uninitialized_error
        self.__dict__["_get_wing_count"] = _raise_uninitialized_error
        self.__dict__["_set_wing_count"] = _raise_uninitialized_error
        self.__dict__["_get_wing_span"] = _raise_uninitialized_error
        self.__dict__["_set_wing_span"] = _raise_uninitialized_error
        self.__dict__["_get_wing_surface_area"] = _raise_uninitialized_error
        self.__dict__["_set_wing_surface_area"] = _raise_uninitialized_error
        self.__dict__["_get_wing_leading_edge_sweep_angle"] = _raise_uninitialized_error
        self.__dict__["_set_wing_leading_edge_sweep_angle"] = _raise_uninitialized_error
        self.__dict__["_get_wing_leading_edge_section_angle"] = _raise_uninitialized_error
        self.__dict__["_set_wing_leading_edge_section_angle"] = _raise_uninitialized_error
        self.__dict__["_get_wing_mean_aero_chord_length"] = _raise_uninitialized_error
        self.__dict__["_set_wing_mean_aero_chord_length"] = _raise_uninitialized_error
        self.__dict__["_get_wing_max_thickness_along_mac"] = _raise_uninitialized_error
        self.__dict__["_set_wing_max_thickness_along_mac"] = _raise_uninitialized_error
        self.__dict__["_get_wing_lift_fraction"] = _raise_uninitialized_error
        self.__dict__["_set_wing_lift_fraction"] = _raise_uninitialized_error
        self.__dict__["_get_tail_count"] = _raise_uninitialized_error
        self.__dict__["_set_tail_count"] = _raise_uninitialized_error
        self.__dict__["_get_tail_span"] = _raise_uninitialized_error
        self.__dict__["_set_tail_span"] = _raise_uninitialized_error
        self.__dict__["_get_tail_surface_area"] = _raise_uninitialized_error
        self.__dict__["_set_tail_surface_area"] = _raise_uninitialized_error
        self.__dict__["_get_tail_leading_edge_sweep_angle"] = _raise_uninitialized_error
        self.__dict__["_set_tail_leading_edge_sweep_angle"] = _raise_uninitialized_error
        self.__dict__["_get_tail_leading_edge_section_angle"] = _raise_uninitialized_error
        self.__dict__["_set_tail_leading_edge_section_angle"] = _raise_uninitialized_error
        self.__dict__["_get_tail_mean_aero_chord_length"] = _raise_uninitialized_error
        self.__dict__["_set_tail_mean_aero_chord_length"] = _raise_uninitialized_error
        self.__dict__["_get_tail_max_thickness_along_mac"] = _raise_uninitialized_error
        self.__dict__["_set_tail_max_thickness_along_mac"] = _raise_uninitialized_error
        self.__dict__["_get_tail_lift_fraction"] = _raise_uninitialized_error
        self.__dict__["_set_tail_lift_fraction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileAdvancedAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileAdvancedAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileAdvancedAero = agcom.GUID(IMissileAdvancedAero._uuid)
        vtable_offset_local = IMissileAdvancedAero._vtable_offset - 1
        self.__dict__["_get_body_width"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_body_width"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_body_height"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_body_height"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_body_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_body_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_nose_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nose_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_nose_tip_diameter"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nose_tip_diameter"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_nozzle_diameter"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nozzle_diameter"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_min_mach"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_mach"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_wing_count"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_wing_count"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_wing_span"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wing_span"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_wing_surface_area"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wing_surface_area"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_wing_leading_edge_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+23, POINTER(agcom.VARIANT))
        self.__dict__["_set_wing_leading_edge_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+24, agcom.VARIANT)
        self.__dict__["_get_wing_leading_edge_section_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+25, POINTER(agcom.VARIANT))
        self.__dict__["_set_wing_leading_edge_section_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+26, agcom.VARIANT)
        self.__dict__["_get_wing_mean_aero_chord_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wing_mean_aero_chord_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_wing_max_thickness_along_mac"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wing_max_thickness_along_mac"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_wing_lift_fraction"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wing_lift_fraction"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_tail_count"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+33, POINTER(agcom.LONG))
        self.__dict__["_set_tail_count"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+34, agcom.LONG)
        self.__dict__["_get_tail_span"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+35, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tail_span"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+36, agcom.DOUBLE)
        self.__dict__["_get_tail_surface_area"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+37, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tail_surface_area"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+38, agcom.DOUBLE)
        self.__dict__["_get_tail_leading_edge_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+39, POINTER(agcom.VARIANT))
        self.__dict__["_set_tail_leading_edge_sweep_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+40, agcom.VARIANT)
        self.__dict__["_get_tail_leading_edge_section_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+41, POINTER(agcom.VARIANT))
        self.__dict__["_set_tail_leading_edge_section_angle"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+42, agcom.VARIANT)
        self.__dict__["_get_tail_mean_aero_chord_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+43, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tail_mean_aero_chord_length"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+44, agcom.DOUBLE)
        self.__dict__["_get_tail_max_thickness_along_mac"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+45, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tail_max_thickness_along_mac"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+46, agcom.DOUBLE)
        self.__dict__["_get_tail_lift_fraction"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+47, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tail_lift_fraction"] = IAGFUNCTYPE(pUnk, IID_IMissileAdvancedAero, vtable_offset_local+48, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileAdvancedAero.__dict__ and type(IMissileAdvancedAero.__dict__[attrname]) == property:
            return IMissileAdvancedAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileAdvancedAero.")
    
    @property
    def body_width(self) -> float:
        """The missile body's width."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_body_width"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @body_width.setter
    def body_width(self, newVal:float) -> None:
        """The missile body's width."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_body_width"](arg_newVal.COM_val))

    @property
    def body_height(self) -> float:
        """The missile body's height."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_body_height"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @body_height.setter
    def body_height(self, newVal:float) -> None:
        """The missile body's height."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_body_height"](arg_newVal.COM_val))

    @property
    def body_length(self) -> float:
        """The missile body's length."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_body_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @body_length.setter
    def body_length(self, newVal:float) -> None:
        """The missile body's length."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_body_length"](arg_newVal.COM_val))

    @property
    def nose_length(self) -> float:
        """The missile nose's length."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nose_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nose_length.setter
    def nose_length(self, newVal:float) -> None:
        """The missile nose's length."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nose_length"](arg_newVal.COM_val))

    @property
    def nose_tip_diameter(self) -> float:
        """The missile nose's diameter at the tip."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nose_tip_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nose_tip_diameter.setter
    def nose_tip_diameter(self, newVal:float) -> None:
        """The missile nose's diameter at the tip."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nose_tip_diameter"](arg_newVal.COM_val))

    @property
    def nozzle_diameter(self) -> float:
        """The diameter of the missile's nozzle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nozzle_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nozzle_diameter.setter
    def nozzle_diameter(self, newVal:float) -> None:
        """The diameter of the missile's nozzle."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nozzle_diameter"](arg_newVal.COM_val))

    @property
    def max_aoa(self) -> typing.Any:
        """The missile's maximum angle of attack."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The missile's maximum angle of attack."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_aoa"](arg_newVal.COM_val))

    @property
    def min_mach(self) -> float:
        """The minimum mach number of the missile."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_mach.setter
    def min_mach(self, newVal:float) -> None:
        """The minimum mach number of the missile."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_mach"](arg_newVal.COM_val))

    @property
    def wing_count(self) -> int:
        """The number of wings on the missile."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_count.setter
    def wing_count(self, newVal:int) -> None:
        """The number of wings on the missile."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_count"](arg_newVal.COM_val))

    @property
    def wing_span(self) -> float:
        """The span of one of the missile's wings."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_span"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_span.setter
    def wing_span(self, newVal:float) -> None:
        """The span of one of the missile's wings."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_span"](arg_newVal.COM_val))

    @property
    def wing_surface_area(self) -> float:
        """The area of one of the missile's wings."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_surface_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_surface_area.setter
    def wing_surface_area(self, newVal:float) -> None:
        """The area of one of the missile's wings."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_surface_area"](arg_newVal.COM_val))

    @property
    def wing_leading_edge_sweep_angle(self) -> typing.Any:
        """The leading edge weep angle of the wings."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_leading_edge_sweep_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_leading_edge_sweep_angle.setter
    def wing_leading_edge_sweep_angle(self, newVal:typing.Any) -> None:
        """The leading edge weep angle of the wings."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_leading_edge_sweep_angle"](arg_newVal.COM_val))

    @property
    def wing_leading_edge_section_angle(self) -> typing.Any:
        """The leading edge section angle of the wings."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_leading_edge_section_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_leading_edge_section_angle.setter
    def wing_leading_edge_section_angle(self, newVal:typing.Any) -> None:
        """The leading edge section angle of the wings."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_leading_edge_section_angle"](arg_newVal.COM_val))

    @property
    def wing_mean_aero_chord_length(self) -> float:
        """The mean chord length of one of the missile's wings."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_mean_aero_chord_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_mean_aero_chord_length.setter
    def wing_mean_aero_chord_length(self, newVal:float) -> None:
        """The mean chord length of one of the missile's wings."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_mean_aero_chord_length"](arg_newVal.COM_val))

    @property
    def wing_max_thickness_along_mac(self) -> float:
        """The max thickness of the wing along the mean aerodynamic chord."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_max_thickness_along_mac"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_max_thickness_along_mac.setter
    def wing_max_thickness_along_mac(self, newVal:float) -> None:
        """The max thickness of the wing along the mean aerodynamic chord."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_max_thickness_along_mac"](arg_newVal.COM_val))

    @property
    def wing_lift_fraction(self) -> float:
        """The lift fraction of the wing."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wing_lift_fraction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wing_lift_fraction.setter
    def wing_lift_fraction(self, newVal:float) -> None:
        """The lift fraction of the wing."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wing_lift_fraction"](arg_newVal.COM_val))

    @property
    def tail_count(self) -> int:
        """The number of tails on the missile."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_count.setter
    def tail_count(self, newVal:int) -> None:
        """The number of tails on the missile."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_count"](arg_newVal.COM_val))

    @property
    def tail_span(self) -> float:
        """The span of one of the missile's tails."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_span"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_span.setter
    def tail_span(self, newVal:float) -> None:
        """The span of one of the missile's tails."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_span"](arg_newVal.COM_val))

    @property
    def tail_surface_area(self) -> float:
        """The area of one of the missile's tails."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_surface_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_surface_area.setter
    def tail_surface_area(self, newVal:float) -> None:
        """The area of one of the missile's tails."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_surface_area"](arg_newVal.COM_val))

    @property
    def tail_leading_edge_sweep_angle(self) -> typing.Any:
        """The leading edge weep angle of the tails."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_leading_edge_sweep_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_leading_edge_sweep_angle.setter
    def tail_leading_edge_sweep_angle(self, newVal:typing.Any) -> None:
        """The leading edge weep angle of the tails."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_leading_edge_sweep_angle"](arg_newVal.COM_val))

    @property
    def tail_leading_edge_section_angle(self) -> typing.Any:
        """The leading edge section angle of the tails."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_leading_edge_section_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_leading_edge_section_angle.setter
    def tail_leading_edge_section_angle(self, newVal:typing.Any) -> None:
        """The leading edge section angle of the tails."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_leading_edge_section_angle"](arg_newVal.COM_val))

    @property
    def tail_mean_aero_chord_length(self) -> float:
        """The mean chord length of one of the missile's tails."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_mean_aero_chord_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_mean_aero_chord_length.setter
    def tail_mean_aero_chord_length(self, newVal:float) -> None:
        """The mean chord length of one of the missile's tails."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_mean_aero_chord_length"](arg_newVal.COM_val))

    @property
    def tail_max_thickness_along_mac(self) -> float:
        """The max thickness of the tail along the mean aerodynamic chord."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_max_thickness_along_mac"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_max_thickness_along_mac.setter
    def tail_max_thickness_along_mac(self, newVal:float) -> None:
        """The max thickness of the tail along the mean aerodynamic chord."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_max_thickness_along_mac"](arg_newVal.COM_val))

    @property
    def tail_lift_fraction(self) -> float:
        """The lift fraction of the tail."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_lift_fraction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_lift_fraction.setter
    def tail_lift_fraction(self, newVal:float) -> None:
        """The lift fraction of the tail."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_lift_fraction"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{a26fe490-218c-44e4-95ab-69c20d3d6629}", IMissileAdvancedAero)
agcls.AgTypeNameMap["IMissileAdvancedAero"] = IMissileAdvancedAero

class IMissileRamjetProp(object):
    """Interface used to access the Ramjet propulsion options for a missile."""
    _uuid = "{a0a4fb0a-67cb-44bd-b0e9-2362cfedbb0e}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_design_mach"] = _raise_uninitialized_error
        self.__dict__["_set_design_mach"] = _raise_uninitialized_error
        self.__dict__["_get_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_engine_temp"] = _raise_uninitialized_error
        self.__dict__["_set_engine_temp"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_heating_value"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_heating_value"] = _raise_uninitialized_error
        self.__dict__["_get_inlet_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_inlet_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_burner_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_burner_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_nozzle_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_nozzle_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_p_0over_p9"] = _raise_uninitialized_error
        self.__dict__["_set_p_0over_p9"] = _raise_uninitialized_error
        self.__dict__["_get_burner_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_burner_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileRamjetProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileRamjetProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileRamjetProp = agcom.GUID(IMissileRamjetProp._uuid)
        vtable_offset_local = IMissileRamjetProp._vtable_offset - 1
        self.__dict__["_get_design_mach"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_mach"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_engine_temp"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_engine_temp"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_fuel_heating_value"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_heating_value"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_inlet_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_inlet_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_burner_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_burner_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_nozzle_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nozzle_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_p_0over_p9"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_p_0over_p9"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_burner_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_burner_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileRamjetProp, vtable_offset_local+22, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileRamjetProp.__dict__ and type(IMissileRamjetProp.__dict__[attrname]) == property:
            return IMissileRamjetProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileRamjetProp.")
    
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_mach"](arg_newVal.COM_val))

    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_altitude"](arg_newVal.COM_val))

    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_thrust"](arg_newVal.COM_val))

    @property
    def engine_temp(self) -> float:
        """The maximum temperature that the engine material can support."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_engine_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @engine_temp.setter
    def engine_temp(self, newVal:float) -> None:
        """The maximum temperature that the engine material can support."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_engine_temp"](arg_newVal.COM_val))

    @property
    def fuel_heating_value(self) -> float:
        """The heating value of the fuel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_heating_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_heating_value.setter
    def fuel_heating_value(self, newVal:float) -> None:
        """The heating value of the fuel."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_heating_value"](arg_newVal.COM_val))

    @property
    def inlet_pressure_ratio(self) -> float:
        """The pressure ratio from the inlet exit to the entrance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inlet_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inlet_pressure_ratio.setter
    def inlet_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the inlet exit to the entrance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inlet_pressure_ratio"](arg_newVal.COM_val))

    @property
    def burner_pressure_ratio(self) -> float:
        """The pressure ratio from the burner exit to the entrance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_burner_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @burner_pressure_ratio.setter
    def burner_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the burner exit to the entrance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_burner_pressure_ratio"](arg_newVal.COM_val))

    @property
    def nozzle_pressure_ratio(self) -> float:
        """The pressure ratio from the nozzle exit to the entrance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nozzle_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nozzle_pressure_ratio.setter
    def nozzle_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the nozzle exit to the entrance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nozzle_pressure_ratio"](arg_newVal.COM_val))

    @property
    def p_0over_p9(self) -> float:
        """The pressure ratio from ambient conditions to the engine exit."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_p_0over_p9"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @p_0over_p9.setter
    def p_0over_p9(self, newVal:float) -> None:
        """The pressure ratio from ambient conditions to the engine exit."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_p_0over_p9"](arg_newVal.COM_val))

    @property
    def burner_efficiency(self) -> float:
        """The efficiency of the burner."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_burner_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @burner_efficiency.setter
    def burner_efficiency(self, newVal:float) -> None:
        """The efficiency of the burner."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_burner_efficiency"](arg_newVal.COM_val))

    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_no_thrust_when_no_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_no_thrust_when_no_fuel"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{a0a4fb0a-67cb-44bd-b0e9-2362cfedbb0e}", IMissileRamjetProp)
agcls.AgTypeNameMap["IMissileRamjetProp"] = IMissileRamjetProp

class IMissileRocketProp(object):
    """Interface used to access the Rocket propulsion options for a missile."""
    _uuid = "{4aa12da8-8ff9-40f4-bbf7-1e09aa7f04f8}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_nozzle_expansion_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_nozzle_expansion_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_nozzle_exit_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_nozzle_exit_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_combustion_chamber_pressure"] = _raise_uninitialized_error
        self.__dict__["_set_combustion_chamber_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_propellant_specific_heat_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_propellant_specific_heat_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_propellant_characteristic_velocity"] = _raise_uninitialized_error
        self.__dict__["_set_propellant_characteristic_velocity"] = _raise_uninitialized_error
        self.__dict__["_get_use_boost_sustain_mode"] = _raise_uninitialized_error
        self.__dict__["_set_use_boost_sustain_mode"] = _raise_uninitialized_error
        self.__dict__["_get_boost_fuel_fraction"] = _raise_uninitialized_error
        self.__dict__["_set_boost_fuel_fraction"] = _raise_uninitialized_error
        self.__dict__["_get_boost_chamber_pressure"] = _raise_uninitialized_error
        self.__dict__["_set_boost_chamber_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileRocketProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileRocketProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileRocketProp = agcom.GUID(IMissileRocketProp._uuid)
        vtable_offset_local = IMissileRocketProp._vtable_offset - 1
        self.__dict__["_get_nozzle_expansion_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nozzle_expansion_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_nozzle_exit_diameter"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nozzle_exit_diameter"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_combustion_chamber_pressure"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_combustion_chamber_pressure"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_propellant_specific_heat_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_propellant_specific_heat_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_propellant_characteristic_velocity"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_propellant_characteristic_velocity"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_use_boost_sustain_mode"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_boost_sustain_mode"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_boost_fuel_fraction"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_boost_fuel_fraction"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_boost_chamber_pressure"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_boost_chamber_pressure"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileRocketProp, vtable_offset_local+18, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileRocketProp.__dict__ and type(IMissileRocketProp.__dict__[attrname]) == property:
            return IMissileRocketProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileRocketProp.")
    
    @property
    def nozzle_expansion_ratio(self) -> float:
        """The exit area divided by the throat area."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nozzle_expansion_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nozzle_expansion_ratio.setter
    def nozzle_expansion_ratio(self, newVal:float) -> None:
        """The exit area divided by the throat area."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nozzle_expansion_ratio"](arg_newVal.COM_val))

    @property
    def nozzle_exit_diameter(self) -> float:
        """The diameter of the nozzle exit."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nozzle_exit_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nozzle_exit_diameter.setter
    def nozzle_exit_diameter(self, newVal:float) -> None:
        """The diameter of the nozzle exit."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nozzle_exit_diameter"](arg_newVal.COM_val))

    @property
    def combustion_chamber_pressure(self) -> float:
        """The pressure in the combustion chamber."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_combustion_chamber_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @combustion_chamber_pressure.setter
    def combustion_chamber_pressure(self, newVal:float) -> None:
        """The pressure in the combustion chamber."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_combustion_chamber_pressure"](arg_newVal.COM_val))

    @property
    def propellant_specific_heat_ratio(self) -> float:
        """The ratio of the propellant's constant-pressure specific heat to the constant volume specific heat."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propellant_specific_heat_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propellant_specific_heat_ratio.setter
    def propellant_specific_heat_ratio(self, newVal:float) -> None:
        """The ratio of the propellant's constant-pressure specific heat to the constant volume specific heat."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propellant_specific_heat_ratio"](arg_newVal.COM_val))

    @property
    def propellant_characteristic_velocity(self) -> float:
        """The propellant's characteristic velocity (Chamber Pressure * Throat Area / Mass Flow Rate of the engine)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propellant_characteristic_velocity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propellant_characteristic_velocity.setter
    def propellant_characteristic_velocity(self, newVal:float) -> None:
        """The propellant's characteristic velocity (Chamber Pressure * Throat Area / Mass Flow Rate of the engine)."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propellant_characteristic_velocity"](arg_newVal.COM_val))

    @property
    def use_boost_sustain_mode(self) -> bool:
        """Opt for the engine to use a boost phase to achieve a target velocity and then transition to a sustenance phase."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_boost_sustain_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_boost_sustain_mode.setter
    def use_boost_sustain_mode(self, newVal:bool) -> None:
        """Opt for the engine to use a boost phase to achieve a target velocity and then transition to a sustenance phase."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_boost_sustain_mode"](arg_newVal.COM_val))

    @property
    def boost_fuel_fraction(self) -> float:
        """The amount of fuel that is consumed during the boost phase."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_boost_fuel_fraction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @boost_fuel_fraction.setter
    def boost_fuel_fraction(self, newVal:float) -> None:
        """The amount of fuel that is consumed during the boost phase."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_boost_fuel_fraction"](arg_newVal.COM_val))

    @property
    def boost_chamber_pressure(self) -> float:
        """The combustion chamber pressure during the boost phase."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_boost_chamber_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @boost_chamber_pressure.setter
    def boost_chamber_pressure(self, newVal:float) -> None:
        """The combustion chamber pressure during the boost phase."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_boost_chamber_pressure"](arg_newVal.COM_val))

    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_no_thrust_when_no_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_no_thrust_when_no_fuel"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4aa12da8-8ff9-40f4-bbf7-1e09aa7f04f8}", IMissileRocketProp)
agcls.AgTypeNameMap["IMissileRocketProp"] = IMissileRocketProp

class IMissileTurbojetProp(object):
    """Interface used to access the Turbojet propulsion options for a missile."""
    _uuid = "{7d849783-6cbc-442e-aec8-4137fb673619}"
    _num_methods = 30
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_design_mach"] = _raise_uninitialized_error
        self.__dict__["_set_design_mach"] = _raise_uninitialized_error
        self.__dict__["_get_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_turbine_temp"] = _raise_uninitialized_error
        self.__dict__["_set_turbine_temp"] = _raise_uninitialized_error
        self.__dict__["_get_compressor_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_compressor_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_heating_value"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_heating_value"] = _raise_uninitialized_error
        self.__dict__["_get_inlet_subsonic_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_inlet_subsonic_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_burner_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_burner_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_nozzle_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_nozzle_pressure_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_p_0over_p9"] = _raise_uninitialized_error
        self.__dict__["_set_p_0over_p9"] = _raise_uninitialized_error
        self.__dict__["_get_compressor_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_compressor_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_turbine_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_turbine_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_burner_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_burner_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_mechanical_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_mechanical_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_no_thrust_when_no_fuel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileTurbojetProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileTurbojetProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileTurbojetProp = agcom.GUID(IMissileTurbojetProp._uuid)
        vtable_offset_local = IMissileTurbojetProp._vtable_offset - 1
        self.__dict__["_get_design_mach"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_mach"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_turbine_temp"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_turbine_temp"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_compressor_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_compressor_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_fuel_heating_value"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_heating_value"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_inlet_subsonic_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_inlet_subsonic_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_burner_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_burner_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_nozzle_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nozzle_pressure_ratio"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_p_0over_p9"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_p_0over_p9"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_compressor_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_compressor_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_turbine_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_turbine_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_burner_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_burner_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_mechanical_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mechanical_efficiency"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_no_thrust_when_no_fuel"] = IAGFUNCTYPE(pUnk, IID_IMissileTurbojetProp, vtable_offset_local+30, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileTurbojetProp.__dict__ and type(IMissileTurbojetProp.__dict__[attrname]) == property:
            return IMissileTurbojetProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileTurbojetProp.")
    
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_mach"](arg_newVal.COM_val))

    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_altitude"](arg_newVal.COM_val))

    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_thrust"](arg_newVal.COM_val))

    @property
    def turbine_temp(self) -> float:
        """The maximum temperature that the turbine material can support."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turbine_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turbine_temp.setter
    def turbine_temp(self, newVal:float) -> None:
        """The maximum temperature that the turbine material can support."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turbine_temp"](arg_newVal.COM_val))

    @property
    def compressor_pressure_ratio(self) -> float:
        """The maximum compressor pressure ratio."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compressor_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compressor_pressure_ratio.setter
    def compressor_pressure_ratio(self, newVal:float) -> None:
        """The maximum compressor pressure ratio."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compressor_pressure_ratio"](arg_newVal.COM_val))

    @property
    def fuel_heating_value(self) -> float:
        """The heating value of the fuel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_heating_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_heating_value.setter
    def fuel_heating_value(self, newVal:float) -> None:
        """The heating value of the fuel."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_heating_value"](arg_newVal.COM_val))

    @property
    def inlet_subsonic_pressure_ratio(self) -> float:
        """The subsonic pressure ratio from the inlet exit to the entrance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inlet_subsonic_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inlet_subsonic_pressure_ratio.setter
    def inlet_subsonic_pressure_ratio(self, newVal:float) -> None:
        """The subsonic pressure ratio from the inlet exit to the entrance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inlet_subsonic_pressure_ratio"](arg_newVal.COM_val))

    @property
    def burner_pressure_ratio(self) -> float:
        """The pressure ratio from the burner exit to the entrance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_burner_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @burner_pressure_ratio.setter
    def burner_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the burner exit to the entrance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_burner_pressure_ratio"](arg_newVal.COM_val))

    @property
    def nozzle_pressure_ratio(self) -> float:
        """The pressure ratio from the nozzle exit to the entrance."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nozzle_pressure_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nozzle_pressure_ratio.setter
    def nozzle_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the nozzle exit to the entrance."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nozzle_pressure_ratio"](arg_newVal.COM_val))

    @property
    def p_0over_p9(self) -> float:
        """The pressure ratio from ambient conditions to the engine exit."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_p_0over_p9"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @p_0over_p9.setter
    def p_0over_p9(self, newVal:float) -> None:
        """The pressure ratio from ambient conditions to the engine exit."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_p_0over_p9"](arg_newVal.COM_val))

    @property
    def compressor_efficiency(self) -> float:
        """The efficiency of the compressor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compressor_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compressor_efficiency.setter
    def compressor_efficiency(self, newVal:float) -> None:
        """The efficiency of the compressor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compressor_efficiency"](arg_newVal.COM_val))

    @property
    def turbine_efficiency(self) -> float:
        """The efficiency of the turbine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turbine_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turbine_efficiency.setter
    def turbine_efficiency(self, newVal:float) -> None:
        """The efficiency of the turbine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turbine_efficiency"](arg_newVal.COM_val))

    @property
    def burner_efficiency(self) -> float:
        """The efficiency of the burner."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_burner_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @burner_efficiency.setter
    def burner_efficiency(self, newVal:float) -> None:
        """The efficiency of the burner."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_burner_efficiency"](arg_newVal.COM_val))

    @property
    def mechanical_efficiency(self) -> float:
        """The mechanical efficiency of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mechanical_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mechanical_efficiency.setter
    def mechanical_efficiency(self, newVal:float) -> None:
        """The mechanical efficiency of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mechanical_efficiency"](arg_newVal.COM_val))

    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_no_thrust_when_no_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_no_thrust_when_no_fuel"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7d849783-6cbc-442e-aec8-4137fb673619}", IMissileTurbojetProp)
agcls.AgTypeNameMap["IMissileTurbojetProp"] = IMissileTurbojetProp

class IRotorcraftModel(object):
    """Interface used to access the rotorcraft options in the Aviator catalog."""
    _uuid = "{34b21f79-51d4-4687-8d0f-9ae1d8ac063c}"
    _num_methods = 44
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_max_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_descent_rate_factor"] = _raise_uninitialized_error
        self.__dict__["_set_descent_rate_factor"] = _raise_uninitialized_error
        self.__dict__["_get_max_climb_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_climb_angle"] = _raise_uninitialized_error
        self.__dict__["_get_climb_at_cruise_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_climb_at_cruise_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_descent_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_descent_angle"] = _raise_uninitialized_error
        self.__dict__["_get_min_descent_rate"] = _raise_uninitialized_error
        self.__dict__["_set_min_descent_rate"] = _raise_uninitialized_error
        self.__dict__["_get_max_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_get_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_set_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_get_yaw_rate"] = _raise_uninitialized_error
        self.__dict__["_set_yaw_rate"] = _raise_uninitialized_error
        self.__dict__["_get_yaw_rate_dot"] = _raise_uninitialized_error
        self.__dict__["_set_yaw_rate_dot"] = _raise_uninitialized_error
        self.__dict__["_get_max_transition_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_transition_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_get_tf_max_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_tf_max_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_tf_terrain_window"] = _raise_uninitialized_error
        self.__dict__["_set_tf_terrain_window"] = _raise_uninitialized_error
        self.__dict__["_get_compute_delta_alt"] = _raise_uninitialized_error
        self.__dict__["_set_compute_delta_alt"] = _raise_uninitialized_error
        self.__dict__["_get_max_safe_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_safe_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_max_safe_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_safe_translation_speed"] = _raise_uninitialized_error
        self.__dict__["_get_max_safe_translation_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_max_safe_translation_speed"] = _raise_uninitialized_error
        self.__dict__["_get_ignore_fpa_for_climb_descent_transitions"] = _raise_uninitialized_error
        self.__dict__["_set_ignore_fpa_for_climb_descent_transitions"] = _raise_uninitialized_error
        self.__dict__["_get_default_configuration"] = _raise_uninitialized_error
        self.__dict__["_get_aerodynamics"] = _raise_uninitialized_error
        self.__dict__["_get_propulsion"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRotorcraftModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRotorcraftModel = agcom.GUID(IRotorcraftModel._uuid)
        vtable_offset_local = IRotorcraftModel._vtable_offset - 1
        self.__dict__["_get_max_altitude"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_altitude"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_descent_rate_factor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_descent_rate_factor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_max_climb_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_climb_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_climb_at_cruise_airspeed"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_climb_at_cruise_airspeed"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_descent_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_descent_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_min_descent_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_descent_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_load_factor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_load_factor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+17, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+18, agcom.VARIANT)
        self.__dict__["_get_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+19, POINTER(agcom.VARIANT))
        self.__dict__["_set_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+20, agcom.VARIANT)
        self.__dict__["_get_yaw_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+21, POINTER(agcom.VARIANT))
        self.__dict__["_set_yaw_rate"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+22, agcom.VARIANT)
        self.__dict__["_get_yaw_rate_dot"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+23, POINTER(agcom.VARIANT))
        self.__dict__["_set_yaw_rate_dot"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+24, agcom.VARIANT)
        self.__dict__["_get_max_transition_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+25, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_transition_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+26, agcom.VARIANT)
        self.__dict__["_get_tf_max_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+27, POINTER(agcom.VARIANT))
        self.__dict__["_set_tf_max_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+28, agcom.VARIANT)
        self.__dict__["_get_tf_terrain_window"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tf_terrain_window"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_compute_delta_alt"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_compute_delta_alt"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_max_safe_airspeed"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_get_max_safe_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+34, POINTER(agcom.LONG))
        self.__dict__["_set_max_safe_airspeed"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+35, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_max_safe_translation_speed"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+36, POINTER(agcom.DOUBLE))
        self.__dict__["_get_max_safe_translation_speed_type"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_set_max_safe_translation_speed"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+38, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_ignore_fpa_for_climb_descent_transitions"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+39, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_ignore_fpa_for_climb_descent_transitions"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+40, agcom.VARIANT_BOOL)
        self.__dict__["_get_default_configuration"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+41, POINTER(agcom.PVOID))
        self.__dict__["_get_aerodynamics"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+42, POINTER(agcom.PVOID))
        self.__dict__["_get_propulsion"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+43, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModel, vtable_offset_local+44, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftModel.__dict__ and type(IRotorcraftModel.__dict__[attrname]) == property:
            return IRotorcraftModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftModel.")
    
    @property
    def max_altitude(self) -> float:
        """The maximum altitude at which the rotorcraft is capable of operating."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_altitude.setter
    def max_altitude(self, newVal:float) -> None:
        """The maximum altitude at which the rotorcraft is capable of operating."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_altitude"](arg_newVal.COM_val))

    @property
    def default_cruise_altitude(self) -> float:
        """The rotorcraft's default cruising altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @default_cruise_altitude.setter
    def default_cruise_altitude(self, newVal:float) -> None:
        """The rotorcraft's default cruising altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def descent_rate_factor(self) -> float:
        """The descent rate of the rotorcraft as a factor multiplied by the altitude change rate calculated at zero throttle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_descent_rate_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @descent_rate_factor.setter
    def descent_rate_factor(self, newVal:float) -> None:
        """The descent rate of the rotorcraft as a factor multiplied by the altitude change rate calculated at zero throttle."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_descent_rate_factor"](arg_newVal.COM_val))

    @property
    def max_climb_angle(self) -> typing.Any:
        """The maximum pitch angle of the rotorcraft's flight path while climbing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_climb_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_climb_angle.setter
    def max_climb_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the rotorcraft's flight path while climbing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_climb_angle"](arg_newVal.COM_val))

    @property
    def climb_at_cruise_airspeed(self) -> bool:
        """Select to define the climbing airspeed of the rotorcraft using the cruise airspeed of the current procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_at_cruise_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @climb_at_cruise_airspeed.setter
    def climb_at_cruise_airspeed(self, newVal:bool) -> None:
        """Select to define the climbing airspeed of the rotorcraft using the cruise airspeed of the current procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_climb_at_cruise_airspeed"](arg_newVal.COM_val))

    @property
    def max_descent_angle(self) -> typing.Any:
        """The maximum pitch angle of the rotorcraft's flight path while descending."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_descent_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_descent_angle.setter
    def max_descent_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the rotorcraft's flight path while descending."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_descent_angle"](arg_newVal.COM_val))

    @property
    def min_descent_rate(self) -> float:
        """The minimum rate at which the aircraft will descend once established in a steady descent."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_descent_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_descent_rate.setter
    def min_descent_rate(self, newVal:float) -> None:
        """The minimum rate at which the aircraft will descend once established in a steady descent."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_descent_rate"](arg_newVal.COM_val))

    @property
    def max_load_factor(self) -> float:
        """The maximum load factor that the aircraft can bear while maneuvering in formation."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_load_factor.setter
    def max_load_factor(self, newVal:float) -> None:
        """The maximum load factor that the aircraft can bear while maneuvering in formation."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_load_factor"](arg_newVal.COM_val))

    @property
    def roll_rate(self) -> typing.Any:
        """The standard roll rate of the rotorcraft in a turn."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate.setter
    def roll_rate(self, newVal:typing.Any) -> None:
        """The standard roll rate of the rotorcraft in a turn."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate"](arg_newVal.COM_val))

    @property
    def pitch_rate(self) -> typing.Any:
        """The pitch rate when transitioning between attitude modes or procedures."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pitch_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pitch_rate.setter
    def pitch_rate(self, newVal:typing.Any) -> None:
        """The pitch rate when transitioning between attitude modes or procedures."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pitch_rate"](arg_newVal.COM_val))

    @property
    def yaw_rate(self) -> typing.Any:
        """The yaw rate when transitioning between attitude modes."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_yaw_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @yaw_rate.setter
    def yaw_rate(self, newVal:typing.Any) -> None:
        """The yaw rate when transitioning between attitude modes."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_yaw_rate"](arg_newVal.COM_val))

    @property
    def yaw_rate_dot(self) -> typing.Any:
        """The rate of change of the yaw rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_yaw_rate_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @yaw_rate_dot.setter
    def yaw_rate_dot(self, newVal:typing.Any) -> None:
        """The rate of change of the yaw rate."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_yaw_rate_dot"](arg_newVal.COM_val))

    @property
    def max_transition_pitch_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path when transitioning between forward flight and hovering."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_transition_pitch_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_transition_pitch_angle.setter
    def max_transition_pitch_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path when transitioning between forward flight and hovering."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_transition_pitch_angle"](arg_newVal.COM_val))

    @property
    def tf_max_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path when the rotorcraft is engaged in terrain following flight."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tf_max_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tf_max_flight_path_angle.setter
    def tf_max_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path when the rotorcraft is engaged in terrain following flight."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tf_max_flight_path_angle"](arg_newVal.COM_val))

    @property
    def tf_terrain_window(self) -> float:
        """The time interval over which terrain points are sampled when the rotorcraft is engaged in terrain following flight."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tf_terrain_window"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tf_terrain_window.setter
    def tf_terrain_window(self, newVal:float) -> None:
        """The time interval over which terrain points are sampled when the rotorcraft is engaged in terrain following flight."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tf_terrain_window"](arg_newVal.COM_val))

    @property
    def compute_delta_alt(self) -> float:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compute_delta_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compute_delta_alt.setter
    def compute_delta_alt(self, newVal:float) -> None:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compute_delta_alt"](arg_newVal.COM_val))

    @property
    def max_safe_airspeed(self) -> float:
        """The maximum cruising airspeed of the rotorcraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_safe_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_safe_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The maximum safe airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_safe_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_max_safe_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the maximum safe airspeed and airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_max_safe_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def max_safe_translation_speed(self) -> float:
        """The maximum translation speed of the rotorcraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_safe_translation_speed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_safe_translation_speed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The maximum safe translation speed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_safe_translation_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_max_safe_translation_speed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the maximum safe translation airspeed and airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_max_safe_translation_speed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def ignore_fpa_for_climb_descent_transitions(self) -> bool:
        """Opt to ignore load factor limits when pushing over or pulling up."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ignore_fpa_for_climb_descent_transitions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ignore_fpa_for_climb_descent_transitions.setter
    def ignore_fpa_for_climb_descent_transitions(self, newVal:bool) -> None:
        """Opt to ignore load factor limits when pushing over or pulling up."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ignore_fpa_for_climb_descent_transitions"](arg_newVal.COM_val))

    @property
    def default_configuration(self) -> "IConfiguration":
        """The aircraft's default configuration as saved in the catalog."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrConfig:
            agcls.evaluate_hresult(self.__dict__["_get_default_configuration"](byref(arg_ppAvtrConfig.COM_val)))
            return arg_ppAvtrConfig.python_val

    @property
    def aerodynamics(self) -> "IRotorcraftAero":
        """Get the aerodynamics interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_aerodynamics"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def propulsion(self) -> "IRotorcraftProp":
        """Get the propulsion interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_propulsion"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{34b21f79-51d4-4687-8d0f-9ae1d8ac063c}", IRotorcraftModel)
agcls.AgTypeNameMap["IRotorcraftModel"] = IRotorcraftModel

class IRotorcraftAero(object):
    """Interface used to access the aerodynamics options for a rotorcraft."""
    _uuid = "{76dc620d-2f8f-49ce-b043-7f502815bcb3}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_rotor_count"] = _raise_uninitialized_error
        self.__dict__["_set_rotor_count"] = _raise_uninitialized_error
        self.__dict__["_get_rotor_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_rotor_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_blades_per_rotor"] = _raise_uninitialized_error
        self.__dict__["_set_blades_per_rotor"] = _raise_uninitialized_error
        self.__dict__["_get_blade_chord"] = _raise_uninitialized_error
        self.__dict__["_set_blade_chord"] = _raise_uninitialized_error
        self.__dict__["_get_rotor_tip_mach"] = _raise_uninitialized_error
        self.__dict__["_set_rotor_tip_mach"] = _raise_uninitialized_error
        self.__dict__["_get_fuselage_flat_plate_area"] = _raise_uninitialized_error
        self.__dict__["_set_fuselage_flat_plate_area"] = _raise_uninitialized_error
        self.__dict__["_get_tail_rotor_offset"] = _raise_uninitialized_error
        self.__dict__["_set_tail_rotor_offset"] = _raise_uninitialized_error
        self.__dict__["_get_tail_rotor_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_tail_rotor_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_blade_profile_drag_cd0"] = _raise_uninitialized_error
        self.__dict__["_set_blade_profile_drag_cd0"] = _raise_uninitialized_error
        self.__dict__["_get_blade_profile_drag_k"] = _raise_uninitialized_error
        self.__dict__["_set_blade_profile_drag_k"] = _raise_uninitialized_error
        self.__dict__["_get_induced_power_correction_factor"] = _raise_uninitialized_error
        self.__dict__["_set_induced_power_correction_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRotorcraftAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRotorcraftAero = agcom.GUID(IRotorcraftAero._uuid)
        vtable_offset_local = IRotorcraftAero._vtable_offset - 1
        self.__dict__["_get_rotor_count"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_rotor_count"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_rotor_diameter"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rotor_diameter"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_blades_per_rotor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_blades_per_rotor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_blade_chord"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_blade_chord"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_rotor_tip_mach"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rotor_tip_mach"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_fuselage_flat_plate_area"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuselage_flat_plate_area"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_tail_rotor_offset"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tail_rotor_offset"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_tail_rotor_diameter"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tail_rotor_diameter"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_blade_profile_drag_cd0"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_blade_profile_drag_cd0"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_blade_profile_drag_k"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_blade_profile_drag_k"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_induced_power_correction_factor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_induced_power_correction_factor"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftAero, vtable_offset_local+22, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftAero.__dict__ and type(IRotorcraftAero.__dict__[attrname]) == property:
            return IRotorcraftAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftAero.")
    
    @property
    def rotor_count(self) -> int:
        """The number of rotors."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotor_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rotor_count.setter
    def rotor_count(self, newVal:int) -> None:
        """The number of rotors."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rotor_count"](arg_newVal.COM_val))

    @property
    def rotor_diameter(self) -> float:
        """The diameter of the rotor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotor_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rotor_diameter.setter
    def rotor_diameter(self, newVal:float) -> None:
        """The diameter of the rotor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rotor_diameter"](arg_newVal.COM_val))

    @property
    def blades_per_rotor(self) -> int:
        """The number of blades on each rotor."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_blades_per_rotor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @blades_per_rotor.setter
    def blades_per_rotor(self, newVal:int) -> None:
        """The number of blades on each rotor."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_blades_per_rotor"](arg_newVal.COM_val))

    @property
    def blade_chord(self) -> float:
        """The chord length of the blade."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_blade_chord"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @blade_chord.setter
    def blade_chord(self, newVal:float) -> None:
        """The chord length of the blade."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_blade_chord"](arg_newVal.COM_val))

    @property
    def rotor_tip_mach(self) -> float:
        """The Mach number of the advancing blade tip."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotor_tip_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rotor_tip_mach.setter
    def rotor_tip_mach(self, newVal:float) -> None:
        """The Mach number of the advancing blade tip."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rotor_tip_mach"](arg_newVal.COM_val))

    @property
    def fuselage_flat_plate_area(self) -> float:
        """The flat plate area for the fuselage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuselage_flat_plate_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuselage_flat_plate_area.setter
    def fuselage_flat_plate_area(self, newVal:float) -> None:
        """The flat plate area for the fuselage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuselage_flat_plate_area"](arg_newVal.COM_val))

    @property
    def tail_rotor_offset(self) -> float:
        """The offset of the tail rotor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_rotor_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_rotor_offset.setter
    def tail_rotor_offset(self, newVal:float) -> None:
        """The offset of the tail rotor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_rotor_offset"](arg_newVal.COM_val))

    @property
    def tail_rotor_diameter(self) -> float:
        """The diameter of the tail rotor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tail_rotor_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tail_rotor_diameter.setter
    def tail_rotor_diameter(self, newVal:float) -> None:
        """The diameter of the tail rotor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tail_rotor_diameter"](arg_newVal.COM_val))

    @property
    def blade_profile_drag_cd0(self) -> float:
        """The drag coefficient when the rotor disc does not generate any lift."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_blade_profile_drag_cd0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @blade_profile_drag_cd0.setter
    def blade_profile_drag_cd0(self, newVal:float) -> None:
        """The drag coefficient when the rotor disc does not generate any lift."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_blade_profile_drag_cd0"](arg_newVal.COM_val))

    @property
    def blade_profile_drag_k(self) -> float:
        """The induced drag coefficient, which accounts for how lift generation impacts drag."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_blade_profile_drag_k"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @blade_profile_drag_k.setter
    def blade_profile_drag_k(self, newVal:float) -> None:
        """The induced drag coefficient, which accounts for how lift generation impacts drag."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_blade_profile_drag_k"](arg_newVal.COM_val))

    @property
    def induced_power_correction_factor(self) -> float:
        """The slop factor that accounts for losses."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_induced_power_correction_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @induced_power_correction_factor.setter
    def induced_power_correction_factor(self, newVal:float) -> None:
        """The slop factor that accounts for losses."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_induced_power_correction_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{76dc620d-2f8f-49ce-b043-7f502815bcb3}", IRotorcraftAero)
agcls.AgTypeNameMap["IRotorcraftAero"] = IRotorcraftAero

class IRotorcraftProp(object):
    """Interface used to access the Propulsion options for a rotorcraft."""
    _uuid = "{83f50978-efae-48fd-b5e7-df4f1a487aac}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_powerplant_type"] = _raise_uninitialized_error
        self.__dict__["_set_powerplant_type"] = _raise_uninitialized_error
        self.__dict__["_get_max_sl_power"] = _raise_uninitialized_error
        self.__dict__["_set_max_sl_power"] = _raise_uninitialized_error
        self.__dict__["_get_max_sl_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_sl_fuel_flow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRotorcraftProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRotorcraftProp = agcom.GUID(IRotorcraftProp._uuid)
        vtable_offset_local = IRotorcraftProp._vtable_offset - 1
        self.__dict__["_get_powerplant_type"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftProp, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_powerplant_type"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftProp, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_max_sl_power"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftProp, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_sl_power"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftProp, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_max_sl_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftProp, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_sl_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftProp, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftProp.__dict__ and type(IRotorcraftProp.__dict__[attrname]) == property:
            return IRotorcraftProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftProp.")
    
    @property
    def powerplant_type(self) -> "AVTR_ROTORCRAFT_POWERPLANT_TYPE":
        """The rotorcraft's powerplant type."""
        with agmarshall.AgEnum_arg(AVTR_ROTORCRAFT_POWERPLANT_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_powerplant_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @powerplant_type.setter
    def powerplant_type(self, newVal:"AVTR_ROTORCRAFT_POWERPLANT_TYPE") -> None:
        """The rotorcraft's powerplant type."""
        with agmarshall.AgEnum_arg(AVTR_ROTORCRAFT_POWERPLANT_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_powerplant_type"](arg_newVal.COM_val))

    @property
    def max_sl_power(self) -> float:
        """The maximum power at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_sl_power"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_sl_power.setter
    def max_sl_power(self, newVal:float) -> None:
        """The maximum power at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_sl_power"](arg_newVal.COM_val))

    @property
    def max_sl_fuel_flow(self) -> float:
        """The maximum fuel flow at sea level."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_sl_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_sl_fuel_flow.setter
    def max_sl_fuel_flow(self, newVal:float) -> None:
        """The maximum fuel flow at sea level."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_sl_fuel_flow"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{83f50978-efae-48fd-b5e7-df4f1a487aac}", IRotorcraftProp)
agcls.AgTypeNameMap["IRotorcraftProp"] = IRotorcraftProp

class IUserRunwaySource(object):
    """Interface used to access the user runways in the Aviator catalog."""
    _uuid = "{684e58b2-17da-40e6-ab75-00f965dc947c}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_user_runway"] = _raise_uninitialized_error
        self.__dict__["_add_user_runway"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserRunwaySource._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserRunwaySource from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserRunwaySource = agcom.GUID(IUserRunwaySource._uuid)
        vtable_offset_local = IUserRunwaySource._vtable_offset - 1
        self.__dict__["_get_user_runway"] = IAGFUNCTYPE(pUnk, IID_IUserRunwaySource, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_user_runway"] = IAGFUNCTYPE(pUnk, IID_IUserRunwaySource, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IUserRunwaySource, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserRunwaySource.__dict__ and type(IUserRunwaySource.__dict__[attrname]) == property:
            return IUserRunwaySource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserRunwaySource.")
    
    def get_user_runway(self, name:str) -> "IUserRunway":
        """Gets the user runway with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppUserRunway:
            agcls.evaluate_hresult(self.__dict__["_get_user_runway"](arg_name.COM_val, byref(arg_ppUserRunway.COM_val)))
            return arg_ppUserRunway.python_val

    def add_user_runway(self, name:str) -> "IUserRunway":
        """Creates a new user runway with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppUserRunway:
            agcls.evaluate_hresult(self.__dict__["_add_user_runway"](arg_name.COM_val, byref(arg_ppUserRunway.COM_val)))
            return arg_ppUserRunway.python_val

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogSource:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogSource.COM_val)))
            return arg_ppCatalogSource.python_val


agcls.AgClassCatalog.add_catalog_entry("{684e58b2-17da-40e6-ab75-00f965dc947c}", IUserRunwaySource)
agcls.AgTypeNameMap["IUserRunwaySource"] = IUserRunwaySource

class IUserRunway(object):
    """Interface used to access a user runway in the Aviator catalog."""
    _uuid = "{74B0531F-504B-42E6-A8AF-7A6B891A88F8}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_alt"] = _raise_uninitialized_error
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_length"] = _raise_uninitialized_error
        self.__dict__["_set_length"] = _raise_uninitialized_error
        self.__dict__["_get_low_end_heading"] = _raise_uninitialized_error
        self.__dict__["_set_low_end_heading"] = _raise_uninitialized_error
        self.__dict__["_get_high_end_heading"] = _raise_uninitialized_error
        self.__dict__["_set_high_end_heading"] = _raise_uninitialized_error
        self.__dict__["_get_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_copy_site"] = _raise_uninitialized_error
        self.__dict__["_paste_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserRunway._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserRunway from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserRunway = agcom.GUID(IUserRunway._uuid)
        vtable_offset_local = IUserRunway._vtable_offset - 1
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_get_terrain_alt"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_length"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_length"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_low_end_heading"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_low_end_heading"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_high_end_heading"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_high_end_heading"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_copy_site"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+17, )
        self.__dict__["_paste_site"] = IAGFUNCTYPE(pUnk, IID_IUserRunway, vtable_offset_local+18, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserRunway.__dict__ and type(IUserRunway.__dict__[attrname]) == property:
            return IUserRunway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserRunway.")
    
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val

    @property
    def altitude(self) -> float:
        """The runway altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The runway altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    def get_terrain_alt(self) -> float:
        """Set the runway altitude to the terrain altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def latitude(self) -> typing.Any:
        """The runway latitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The runway latitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The runway longitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The runway longitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def length(self) -> float:
        """The length of the runway"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @length.setter
    def length(self, newVal:float) -> None:
        """The length of the runway"""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_length"](arg_newVal.COM_val))

    @property
    def low_end_heading(self) -> typing.Any:
        """The low end heading of the runway."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_end_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @low_end_heading.setter
    def low_end_heading(self, newVal:typing.Any) -> None:
        """The low end heading of the runway."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_low_end_heading"](arg_newVal.COM_val))

    @property
    def high_end_heading(self) -> typing.Any:
        """The high end heading of the runway."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_high_end_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @high_end_heading.setter
    def high_end_heading(self, newVal:typing.Any) -> None:
        """The high end heading of the runway."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_high_end_heading"](arg_newVal.COM_val))

    @property
    def is_magnetic(self) -> bool:
        """Opt whether to use a magnetic heading for the runway heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @is_magnetic.setter
    def is_magnetic(self, newVal:bool) -> None:
        """Opt whether to use a magnetic heading for the runway heading."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_is_magnetic"](arg_newVal.COM_val))

    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_site"]())

    def paste_site(self) -> None:
        """Paste the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_site"]())


agcls.AgClassCatalog.add_catalog_entry("{74B0531F-504B-42E6-A8AF-7A6B891A88F8}", IUserRunway)
agcls.AgTypeNameMap["IUserRunway"] = IUserRunway

class IARINC424Item(object):
    """Interface used to access the options for an ARINC424 Item found in the Aviator catalog."""
    _uuid = "{ec9a6d30-e195-49d8-a5fd-635114490f7c}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        self.__dict__["_get_value"] = _raise_uninitialized_error
        self.__dict__["_get_all_fields"] = _raise_uninitialized_error
        self.__dict__["_get_all_fields_and_values"] = _raise_uninitialized_error
        self.__dict__["_copy_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IARINC424Item._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Item from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IARINC424Item = agcom.GUID(IARINC424Item._uuid)
        vtable_offset_local = IARINC424Item._vtable_offset - 1
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IARINC424Item, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_value"] = IAGFUNCTYPE(pUnk, IID_IARINC424Item, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.VARIANT))
        self.__dict__["_get_all_fields"] = IAGFUNCTYPE(pUnk, IID_IARINC424Item, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_all_fields_and_values"] = IAGFUNCTYPE(pUnk, IID_IARINC424Item, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_copy_site"] = IAGFUNCTYPE(pUnk, IID_IARINC424Item, vtable_offset_local+5, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Item.__dict__ and type(IARINC424Item.__dict__[attrname]) == property:
            return IARINC424Item.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Item.")
    
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val

    def get_value(self, fieldName:str) -> typing.Any:
        """Get the value of the field with the given name."""
        with agmarshall.BSTR_arg(fieldName) as arg_fieldName, \
             agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_value"](arg_fieldName.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_all_fields(self) -> list:
        """Get all the field names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_all_fields"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_all_fields_and_values(self) -> list:
        """Get all the field names along with the corresponding value."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_all_fields_and_values"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_site"]())


agcls.AgClassCatalog.add_catalog_entry("{ec9a6d30-e195-49d8-a5fd-635114490f7c}", IARINC424Item)
agcls.AgTypeNameMap["IARINC424Item"] = IARINC424Item

class IARINC424Source(object):
    """Interface used to access the options for any ARINC424 source in the Aviator catalog."""
    _uuid = "{949959c7-31af-48e3-9267-27acdcbedc5e}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_arinc424_item"] = _raise_uninitialized_error
        self.__dict__["_get_use_master_data_file"] = _raise_uninitialized_error
        self.__dict__["_set_use_master_data_file"] = _raise_uninitialized_error
        self.__dict__["_get_master_data_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_master_data_filepath"] = _raise_uninitialized_error
        self.__dict__["_get_override_data_filepath"] = _raise_uninitialized_error
        self.__dict__["_set_override_data_filepath"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IARINC424Source._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Source from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IARINC424Source = agcom.GUID(IARINC424Source._uuid)
        vtable_offset_local = IARINC424Source._vtable_offset - 1
        self.__dict__["_get_arinc424_item"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_use_master_data_file"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_master_data_file"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__["_get_master_data_filepath"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_set_master_data_filepath"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+5, agcom.BSTR)
        self.__dict__["_get_override_data_filepath"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_set_override_data_filepath"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IARINC424Source, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Source.__dict__ and type(IARINC424Source.__dict__[attrname]) == property:
            return IARINC424Source.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Source.")
    
    def get_arinc424_item(self, name:str) -> "IARINC424Item":
        """Gets the ARINC-424 item with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppItem:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_item"](arg_name.COM_val, byref(arg_ppItem.COM_val)))
            return arg_ppItem.python_val

    @property
    def use_master_data_file(self) -> bool:
        """Opt whether to use the master data file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_master_data_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_master_data_file.setter
    def use_master_data_file(self, newVal:bool) -> None:
        """Opt whether to use the master data file."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_master_data_file"](arg_newVal.COM_val))

    @property
    def master_data_filepath(self) -> str:
        """The master data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_master_data_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @master_data_filepath.setter
    def master_data_filepath(self, newVal:str) -> None:
        """The master data file path."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_master_data_filepath"](arg_newVal.COM_val))

    @property
    def override_data_filepath(self) -> str:
        """The file path to the data overriding the mader data file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_data_filepath"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_data_filepath.setter
    def override_data_filepath(self, newVal:str) -> None:
        """The file path to the data overriding the mader data file."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_data_filepath"](arg_newVal.COM_val))

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{949959c7-31af-48e3-9267-27acdcbedc5e}", IARINC424Source)
agcls.AgTypeNameMap["IARINC424Source"] = IARINC424Source

class IDAFIFSource(object):
    """Interface used to access the options for any DAFIF source in the Aviator catalog."""
    _uuid = "{a5045bd9-f91e-4213-b4f3-0b7a3acce45c}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_dafif_item"] = _raise_uninitialized_error
        self.__dict__["_get_data_path"] = _raise_uninitialized_error
        self.__dict__["_set_data_path"] = _raise_uninitialized_error
        self.__dict__["_get_effective_date"] = _raise_uninitialized_error
        self.__dict__["_get_expiration_date"] = _raise_uninitialized_error
        self.__dict__["_get_spec_revision"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDAFIFSource._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDAFIFSource from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDAFIFSource = agcom.GUID(IDAFIFSource._uuid)
        vtable_offset_local = IDAFIFSource._vtable_offset - 1
        self.__dict__["_get_dafif_item"] = IAGFUNCTYPE(pUnk, IID_IDAFIFSource, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_data_path"] = IAGFUNCTYPE(pUnk, IID_IDAFIFSource, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_set_data_path"] = IAGFUNCTYPE(pUnk, IID_IDAFIFSource, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_get_effective_date"] = IAGFUNCTYPE(pUnk, IID_IDAFIFSource, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_expiration_date"] = IAGFUNCTYPE(pUnk, IID_IDAFIFSource, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_spec_revision"] = IAGFUNCTYPE(pUnk, IID_IDAFIFSource, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IDAFIFSource, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDAFIFSource.__dict__ and type(IDAFIFSource.__dict__[attrname]) == property:
            return IDAFIFSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDAFIFSource.")
    
    def get_dafif_item(self, name:str) -> "IDAFIFItem":
        """Get the DAFIF item with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppItem:
            agcls.evaluate_hresult(self.__dict__["_get_dafif_item"](arg_name.COM_val, byref(arg_ppItem.COM_val)))
            return arg_ppItem.python_val

    @property
    def data_path(self) -> str:
        """The DAFIF data path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_data_path"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @data_path.setter
    def data_path(self, newVal:str) -> None:
        """The DAFIF data path."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_data_path"](arg_newVal.COM_val))

    @property
    def effective_date(self) -> str:
        """The effective date of the DAFIF catalog."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_effective_date"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def expiration_date(self) -> str:
        """The expiration date of the DAFIF catalog."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_expiration_date"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def spec_revision(self) -> str:
        """The DAFIF edition."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_spec_revision"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{a5045bd9-f91e-4213-b4f3-0b7a3acce45c}", IDAFIFSource)
agcls.AgTypeNameMap["IDAFIFSource"] = IDAFIFSource

class IUserVTOLPoint(object):
    """Interface used to access a user VTOL Point in the Aviator catalog."""
    _uuid = "{10055426-0046-406c-85db-b418e7b0810e}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_alt"] = _raise_uninitialized_error
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_copy_site"] = _raise_uninitialized_error
        self.__dict__["_paste_site"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVTOLPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVTOLPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVTOLPoint = agcom.GUID(IUserVTOLPoint._uuid)
        vtable_offset_local = IUserVTOLPoint._vtable_offset - 1
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_terrain_alt"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_copy_site"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+8, )
        self.__dict__["_paste_site"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+9, )
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPoint, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVTOLPoint.__dict__ and type(IUserVTOLPoint.__dict__[attrname]) == property:
            return IUserVTOLPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVTOLPoint.")
    
    @property
    def altitude(self) -> float:
        """The VTOL Point altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The VTOL Point altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    def get_terrain_alt(self) -> float:
        """Set the VTOL Point altitude to the terrain altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def latitude(self) -> typing.Any:
        """The VTOL Point latitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The VTOL Point latitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The VTOL Point longitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The VTOL Point longitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_site"]())

    def paste_site(self) -> None:
        """Paste the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_site"]())

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{10055426-0046-406c-85db-b418e7b0810e}", IUserVTOLPoint)
agcls.AgTypeNameMap["IUserVTOLPoint"] = IUserVTOLPoint

class IUserVTOLPointSource(object):
    """Interface used to access the user VTOL Points in the Aviator catalog."""
    _uuid = "{f5a61b9c-b511-4cf4-b1ee-058153530c70}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_user_vtol_point"] = _raise_uninitialized_error
        self.__dict__["_add_user_vtol_point"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVTOLPointSource._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVTOLPointSource from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVTOLPointSource = agcom.GUID(IUserVTOLPointSource._uuid)
        vtable_offset_local = IUserVTOLPointSource._vtable_offset - 1
        self.__dict__["_get_user_vtol_point"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPointSource, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_user_vtol_point"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPointSource, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IUserVTOLPointSource, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVTOLPointSource.__dict__ and type(IUserVTOLPointSource.__dict__[attrname]) == property:
            return IUserVTOLPointSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVTOLPointSource.")
    
    def get_user_vtol_point(self, name:str) -> "IUserVTOLPoint":
        """Gets the user VTOL Point with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppUserVTOLPoint:
            agcls.evaluate_hresult(self.__dict__["_get_user_vtol_point"](arg_name.COM_val, byref(arg_ppUserVTOLPoint.COM_val)))
            return arg_ppUserVTOLPoint.python_val

    def add_user_vtol_point(self, name:str) -> "IUserVTOLPoint":
        """Creates a new user VTOL Point with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppUserVTOLPoint:
            agcls.evaluate_hresult(self.__dict__["_add_user_vtol_point"](arg_name.COM_val, byref(arg_ppUserVTOLPoint.COM_val)))
            return arg_ppUserVTOLPoint.python_val

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogSource:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogSource.COM_val)))
            return arg_ppCatalogSource.python_val


agcls.AgClassCatalog.add_catalog_entry("{f5a61b9c-b511-4cf4-b1ee-058153530c70}", IUserVTOLPointSource)
agcls.AgTypeNameMap["IUserVTOLPointSource"] = IUserVTOLPointSource

class IUserWaypoint(object):
    """Interface used to access a user waypoint in the Aviator catalog."""
    _uuid = "{2b18b860-070a-41cf-803c-c14d7f87ee8c}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_copy_site"] = _raise_uninitialized_error
        self.__dict__["_paste_site"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserWaypoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserWaypoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserWaypoint = agcom.GUID(IUserWaypoint._uuid)
        vtable_offset_local = IUserWaypoint._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IUserWaypoint, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IUserWaypoint, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IUserWaypoint, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IUserWaypoint, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_copy_site"] = IAGFUNCTYPE(pUnk, IID_IUserWaypoint, vtable_offset_local+5, )
        self.__dict__["_paste_site"] = IAGFUNCTYPE(pUnk, IID_IUserWaypoint, vtable_offset_local+6, )
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IUserWaypoint, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserWaypoint.__dict__ and type(IUserWaypoint.__dict__[attrname]) == property:
            return IUserWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserWaypoint.")
    
    @property
    def latitude(self) -> typing.Any:
        """The waypoint latitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The waypoint latitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The waypoint longitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The waypoint longitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_site"]())

    def paste_site(self) -> None:
        """Paste the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_site"]())

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{2b18b860-070a-41cf-803c-c14d7f87ee8c}", IUserWaypoint)
agcls.AgTypeNameMap["IUserWaypoint"] = IUserWaypoint

class IUserWaypointSource(object):
    """Interface used to access the user waypoints in the Aviator catalog."""
    _uuid = "{381b23fb-f3b9-4944-996a-efdd9dde16d8}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_user_waypoint"] = _raise_uninitialized_error
        self.__dict__["_add_user_waypoint"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserWaypointSource._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserWaypointSource from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserWaypointSource = agcom.GUID(IUserWaypointSource._uuid)
        vtable_offset_local = IUserWaypointSource._vtable_offset - 1
        self.__dict__["_get_user_waypoint"] = IAGFUNCTYPE(pUnk, IID_IUserWaypointSource, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_user_waypoint"] = IAGFUNCTYPE(pUnk, IID_IUserWaypointSource, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IUserWaypointSource, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserWaypointSource.__dict__ and type(IUserWaypointSource.__dict__[attrname]) == property:
            return IUserWaypointSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserWaypointSource.")
    
    def get_user_waypoint(self, name:str) -> "IUserWaypoint":
        """Gets the user waypoint with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppUserWaypoint:
            agcls.evaluate_hresult(self.__dict__["_get_user_waypoint"](arg_name.COM_val, byref(arg_ppUserWaypoint.COM_val)))
            return arg_ppUserWaypoint.python_val

    def add_user_waypoint(self, name:str) -> "IUserWaypoint":
        """Creates a new user waypoint with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppUserWaypoint:
            agcls.evaluate_hresult(self.__dict__["_add_user_waypoint"](arg_name.COM_val, byref(arg_ppUserWaypoint.COM_val)))
            return arg_ppUserWaypoint.python_val

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogSource:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogSource.COM_val)))
            return arg_ppCatalogSource.python_val


agcls.AgClassCatalog.add_catalog_entry("{381b23fb-f3b9-4944-996a-efdd9dde16d8}", IUserWaypointSource)
agcls.AgTypeNameMap["IUserWaypointSource"] = IUserWaypointSource

class IPropulsionEfficiencies(object):
    """Interface used to access the options for the Efficiencies and Losses of a jet engine powerplant in the advanced fixed wing tool."""
    _uuid = "{ff3eeabb-ada1-40dd-99ce-acacb6c390f2}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_technology_level"] = _raise_uninitialized_error
        self.__dict__["_set_technology_level"] = _raise_uninitialized_error
        self.__dict__["_get_intake_type"] = _raise_uninitialized_error
        self.__dict__["_set_intake_type"] = _raise_uninitialized_error
        self.__dict__["_get_turbine_type"] = _raise_uninitialized_error
        self.__dict__["_set_turbine_type"] = _raise_uninitialized_error
        self.__dict__["_get_exhaust_nozzle_type"] = _raise_uninitialized_error
        self.__dict__["_set_exhaust_nozzle_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPropulsionEfficiencies._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPropulsionEfficiencies from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPropulsionEfficiencies = agcom.GUID(IPropulsionEfficiencies._uuid)
        vtable_offset_local = IPropulsionEfficiencies._vtable_offset - 1
        self.__dict__["_get_technology_level"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_technology_level"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_intake_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_intake_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_turbine_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_turbine_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_exhaust_nozzle_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_exhaust_nozzle_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionEfficiencies, vtable_offset_local+8, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPropulsionEfficiencies.__dict__ and type(IPropulsionEfficiencies.__dict__[attrname]) == property:
            return IPropulsionEfficiencies.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPropulsionEfficiencies.")
    
    @property
    def technology_level(self) -> "AVTR_JET_ENGINE_TECHNOLOGY_LEVEL":
        """The technology level of the jet engine."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_TECHNOLOGY_LEVEL) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_technology_level"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @technology_level.setter
    def technology_level(self, newVal:"AVTR_JET_ENGINE_TECHNOLOGY_LEVEL") -> None:
        """The technology level of the jet engine."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_TECHNOLOGY_LEVEL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_technology_level"](arg_newVal.COM_val))

    @property
    def intake_type(self) -> "AVTR_JET_ENGINE_INTAKE_TYPE":
        """The jet engine intake type."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_INTAKE_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_intake_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @intake_type.setter
    def intake_type(self, newVal:"AVTR_JET_ENGINE_INTAKE_TYPE") -> None:
        """The jet engine intake type."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_INTAKE_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_intake_type"](arg_newVal.COM_val))

    @property
    def turbine_type(self) -> "AVTR_JET_ENGINE_TURBINE_TYPE":
        """The jet engine turbine type."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_TURBINE_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turbine_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turbine_type.setter
    def turbine_type(self, newVal:"AVTR_JET_ENGINE_TURBINE_TYPE") -> None:
        """The jet engine turbine type."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_TURBINE_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turbine_type"](arg_newVal.COM_val))

    @property
    def exhaust_nozzle_type(self) -> "AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE":
        """The jet engine exhaust nozzle type."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_exhaust_nozzle_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @exhaust_nozzle_type.setter
    def exhaust_nozzle_type(self, newVal:"AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE") -> None:
        """The jet engine exhaust nozzle type."""
        with agmarshall.AgEnum_arg(AVTR_JET_ENGINE_EXHAUST_NOZZLE_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_exhaust_nozzle_type"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ff3eeabb-ada1-40dd-99ce-acacb6c390f2}", IPropulsionEfficiencies)
agcls.AgTypeNameMap["IPropulsionEfficiencies"] = IPropulsionEfficiencies

class IFuelModelKeroseneAFPROP(object):
    """Interface used to access the options for Kerosense - CEA fuel for a thermodynamic a jet engine model."""
    _uuid = "{f32e5943-6656-4ef2-983b-e80105acf859}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_subtype"] = _raise_uninitialized_error
        self.__dict__["_set_subtype"] = _raise_uninitialized_error
        self.__dict__["_get_specific_energy"] = _raise_uninitialized_error
        self.__dict__["_set_specific_energy"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFuelModelKeroseneAFPROP._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFuelModelKeroseneAFPROP from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFuelModelKeroseneAFPROP = agcom.GUID(IFuelModelKeroseneAFPROP._uuid)
        vtable_offset_local = IFuelModelKeroseneAFPROP._vtable_offset - 1
        self.__dict__["_get_subtype"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneAFPROP, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_subtype"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneAFPROP, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_specific_energy"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneAFPROP, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_specific_energy"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneAFPROP, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelModelKeroseneAFPROP.__dict__ and type(IFuelModelKeroseneAFPROP.__dict__[attrname]) == property:
            return IFuelModelKeroseneAFPROP.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelModelKeroseneAFPROP.")
    
    @property
    def subtype(self) -> "AVTR_AFPROP_FUEL_TYPE":
        """The fuel subtype."""
        with agmarshall.AgEnum_arg(AVTR_AFPROP_FUEL_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_subtype"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @subtype.setter
    def subtype(self, newVal:"AVTR_AFPROP_FUEL_TYPE") -> None:
        """The fuel subtype."""
        with agmarshall.AgEnum_arg(AVTR_AFPROP_FUEL_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_subtype"](arg_newVal.COM_val))

    @property
    def specific_energy(self) -> float:
        """The specific energy of the jet fuel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specific_energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specific_energy.setter
    def specific_energy(self, newVal:float) -> None:
        """The specific energy of the jet fuel."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specific_energy"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{f32e5943-6656-4ef2-983b-e80105acf859}", IFuelModelKeroseneAFPROP)
agcls.AgTypeNameMap["IFuelModelKeroseneAFPROP"] = IFuelModelKeroseneAFPROP

class IFuelModelKeroseneCEA(object):
    """Interface used to access the options for Kerosense - CEA fuel for a thermodynamic a jet engine model."""
    _uuid = "{52d8882c-bc92-469c-ae5b-2ac105b2f88b}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_subtype"] = _raise_uninitialized_error
        self.__dict__["_set_subtype"] = _raise_uninitialized_error
        self.__dict__["_get_specific_energy"] = _raise_uninitialized_error
        self.__dict__["_set_specific_energy"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFuelModelKeroseneCEA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFuelModelKeroseneCEA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFuelModelKeroseneCEA = agcom.GUID(IFuelModelKeroseneCEA._uuid)
        vtable_offset_local = IFuelModelKeroseneCEA._vtable_offset - 1
        self.__dict__["_get_subtype"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneCEA, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_subtype"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneCEA, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_specific_energy"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneCEA, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_specific_energy"] = IAGFUNCTYPE(pUnk, IID_IFuelModelKeroseneCEA, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelModelKeroseneCEA.__dict__ and type(IFuelModelKeroseneCEA.__dict__[attrname]) == property:
            return IFuelModelKeroseneCEA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelModelKeroseneCEA.")
    
    @property
    def subtype(self) -> "AVTR_CEA_FUEL_TYPE":
        """The fuel subtype."""
        with agmarshall.AgEnum_arg(AVTR_CEA_FUEL_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_subtype"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @subtype.setter
    def subtype(self, newVal:"AVTR_CEA_FUEL_TYPE") -> None:
        """The fuel subtype."""
        with agmarshall.AgEnum_arg(AVTR_CEA_FUEL_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_subtype"](arg_newVal.COM_val))

    @property
    def specific_energy(self) -> float:
        """The specific energy of the jet fuel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specific_energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specific_energy.setter
    def specific_energy(self, newVal:float) -> None:
        """The specific energy of the jet fuel."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specific_energy"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{52d8882c-bc92-469c-ae5b-2ac105b2f88b}", IFuelModelKeroseneCEA)
agcls.AgTypeNameMap["IFuelModelKeroseneCEA"] = IFuelModelKeroseneCEA

class IAdvFixedWingRamjetBasic(object):
    """Interface used to access the options for a basic Ramjet mode."""
    _uuid = "{9533600c-479f-42f8-b14d-a56199f9f64f}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_design_mach"] = _raise_uninitialized_error
        self.__dict__["_set_design_mach"] = _raise_uninitialized_error
        self.__dict__["_get_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_get_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_afprop"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_cea"] = _raise_uninitialized_error
        self.__dict__["_get_efficiencies_and_losses"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingRamjetBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingRamjetBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingRamjetBasic = agcom.GUID(IAdvFixedWingRamjetBasic._uuid)
        vtable_offset_local = IAdvFixedWingRamjetBasic._vtable_offset - 1
        self.__dict__["_get_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_fuel_mode_as_afprop"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_mode_as_cea"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_get_efficiencies_and_losses"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingRamjetBasic, vtable_offset_local+15, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingRamjetBasic.__dict__ and type(IAdvFixedWingRamjetBasic.__dict__[attrname]) == property:
            return IAdvFixedWingRamjetBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingRamjetBasic.")
    
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_altitude"](arg_newVal.COM_val))

    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_mach"](arg_newVal.COM_val))

    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_thrust"](arg_newVal.COM_val))

    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_compression_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_compression_temp"](arg_newVal.COM_val))

    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_burner_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_burner_temp"](arg_newVal.COM_val))

    @property
    def fuel_type(self) -> "AVTR_JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_type.setter
    def fuel_type(self, newVal:"AVTR_JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_type"](arg_newVal.COM_val))

    @property
    def fuel_mode_as_afprop(self) -> "IFuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_afprop"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def fuel_mode_as_cea(self) -> "IFuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_cea"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def efficiencies_and_losses(self) -> "IPropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_efficiencies_and_losses"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9533600c-479f-42f8-b14d-a56199f9f64f}", IAdvFixedWingRamjetBasic)
agcls.AgTypeNameMap["IAdvFixedWingRamjetBasic"] = IAdvFixedWingRamjetBasic

class IAdvFixedWingScramjetBasic(object):
    """Interface used to access the options for a basic Scramjet mode."""
    _uuid = "{24585a26-2d65-4fa8-850d-d19e5f7d190d}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_design_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_design_mach"] = _raise_uninitialized_error
        self.__dict__["_set_design_mach"] = _raise_uninitialized_error
        self.__dict__["_get_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_design_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_compression_temp"] = _raise_uninitialized_error
        self.__dict__["_get_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_set_max_burner_temp"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_type"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_afprop"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mode_as_cea"] = _raise_uninitialized_error
        self.__dict__["_get_efficiencies_and_losses"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingScramjetBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingScramjetBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingScramjetBasic = agcom.GUID(IAdvFixedWingScramjetBasic._uuid)
        vtable_offset_local = IAdvFixedWingScramjetBasic._vtable_offset - 1
        self.__dict__["_get_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_altitude"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_mach"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_design_thrust"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_compression_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_burner_temp"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_type"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_fuel_mode_as_afprop"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_mode_as_cea"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_get_efficiencies_and_losses"] = IAGFUNCTYPE(pUnk, IID_IAdvFixedWingScramjetBasic, vtable_offset_local+15, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingScramjetBasic.__dict__ and type(IAdvFixedWingScramjetBasic.__dict__[attrname]) == property:
            return IAdvFixedWingScramjetBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingScramjetBasic.")
    
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_altitude"](arg_newVal.COM_val))

    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_mach"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_mach"](arg_newVal.COM_val))

    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_design_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_design_thrust"](arg_newVal.COM_val))

    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_compression_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_compression_temp"](arg_newVal.COM_val))

    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_burner_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_burner_temp"](arg_newVal.COM_val))

    @property
    def fuel_type(self) -> "AVTR_JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_type.setter
    def fuel_type(self, newVal:"AVTR_JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        with agmarshall.AgEnum_arg(AVTR_JET_FUEL_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_type"](arg_newVal.COM_val))

    @property
    def fuel_mode_as_afprop(self) -> "IFuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_afprop"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def fuel_mode_as_cea(self) -> "IFuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mode_as_cea"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def efficiencies_and_losses(self) -> "IPropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_efficiencies_and_losses"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{24585a26-2d65-4fa8-850d-d19e5f7d190d}", IAdvFixedWingScramjetBasic)
agcls.AgTypeNameMap["IAdvFixedWingScramjetBasic"] = IAdvFixedWingScramjetBasic

class IRefuelDumpProperties(object):
    """Interface used to access the refuel/dump properties for the current procedure."""
    _uuid = "{8C37F92D-E841-456E-8E12-A09C84D5EFF5}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_mode_value"] = _raise_uninitialized_error
        self.__dict__["_set_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_rate"] = _raise_uninitialized_error
        self.__dict__["_set_refuel_dump_rate"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_time_offset"] = _raise_uninitialized_error
        self.__dict__["_set_refuel_dump_time_offset"] = _raise_uninitialized_error
        self.__dict__["_get_can_use_end_of_enroute_segment_as_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_use_end_of_enroute_segment_as_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_use_end_of_enroute_segment_as_epoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRefuelDumpProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRefuelDumpProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRefuelDumpProperties = agcom.GUID(IRefuelDumpProperties._uuid)
        vtable_offset_local = IRefuelDumpProperties._vtable_offset - 1
        self.__dict__["_get_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_refuel_dump_mode_value"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_set_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+3, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_refuel_dump_rate"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_refuel_dump_rate"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_refuel_dump_time_offset"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_refuel_dump_time_offset"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_can_use_end_of_enroute_segment_as_epoch"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_use_end_of_enroute_segment_as_epoch"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_end_of_enroute_segment_as_epoch"] = IAGFUNCTYPE(pUnk, IID_IRefuelDumpProperties, vtable_offset_local+10, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRefuelDumpProperties.__dict__ and type(IRefuelDumpProperties.__dict__[attrname]) == property:
            return IRefuelDumpProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRefuelDumpProperties.")
    
    @property
    def refuel_dump_mode(self) -> "AVTR_REFUEL_DUMP_MODE":
        """Get the RefuelDumpMode"""
        with agmarshall.AgEnum_arg(AVTR_REFUEL_DUMP_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def refuel_dump_mode_value(self) -> float:
        """Get the RefuelDumpModeValue if applicable"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_mode_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_refuel_dump_mode(self, mode:"AVTR_REFUEL_DUMP_MODE", value:float) -> None:
        """Set RefuelDumpMode and RefuelDumpModeValue if applicable"""
        with agmarshall.AgEnum_arg(AVTR_REFUEL_DUMP_MODE, mode) as arg_mode, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_refuel_dump_mode"](arg_mode.COM_val, arg_value.COM_val))

    @property
    def refuel_dump_rate(self) -> float:
        """Get the RefuelDump rate"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @refuel_dump_rate.setter
    def refuel_dump_rate(self, newVal:float) -> None:
        """Set the RefuelDump rate"""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_refuel_dump_rate"](arg_newVal.COM_val))

    @property
    def refuel_dump_time_offset(self) -> float:
        """Get the RefuelDump time offset"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_time_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @refuel_dump_time_offset.setter
    def refuel_dump_time_offset(self, newVal:float) -> None:
        """Set the RefuelDump time offset"""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_refuel_dump_time_offset"](arg_newVal.COM_val))

    @property
    def can_use_end_of_enroute_segment_as_epoch(self) -> bool:
        """Can use end of enroute segment as the epoch"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_can_use_end_of_enroute_segment_as_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_end_of_enroute_segment_as_epoch(self) -> bool:
        """Use end of enroute segment as the epoch"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_end_of_enroute_segment_as_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_end_of_enroute_segment_as_epoch.setter
    def use_end_of_enroute_segment_as_epoch(self, newVal:bool) -> None:
        """Use end of enroute segment as the epoch"""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_end_of_enroute_segment_as_epoch"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8C37F92D-E841-456E-8E12-A09C84D5EFF5}", IRefuelDumpProperties)
agcls.AgTypeNameMap["IRefuelDumpProperties"] = IRefuelDumpProperties

class IProcedureFastTimeOptions(object):
    """Interface used to access the fast time options (without error or constraint checks) for the current procedure. Use this interface to set an Interrupt Time or Fixed Duration for a procedure."""
    _uuid = "{776EACCB-1B06-4CB2-A915-01B3B2E15E10}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_interrupt_time"] = _raise_uninitialized_error
        self.__dict__["_get_stop_time"] = _raise_uninitialized_error
        self.__dict__["_set_stop_time"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureFastTimeOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFastTimeOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureFastTimeOptions = agcom.GUID(IProcedureFastTimeOptions._uuid)
        vtable_offset_local = IProcedureFastTimeOptions._vtable_offset - 1
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFastTimeOptions, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFastTimeOptions, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_set_interrupt_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFastTimeOptions, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFastTimeOptions, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFastTimeOptions, vtable_offset_local+5, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFastTimeOptions.__dict__ and type(IProcedureFastTimeOptions.__dict__[attrname]) == property:
            return IProcedureFastTimeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFastTimeOptions.")
    
    @property
    def start_time(self) -> typing.Any:
        """Start time for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_start_time(self, time:typing.Any) -> None:
        """Set the start time for the procedure."""
        with agmarshall.VARIANT_arg(time) as arg_time:
            agcls.evaluate_hresult(self.__dict__["_set_start_time"](arg_time.COM_val))

    def set_interrupt_time(self, time:typing.Any) -> None:
        """Set the interrupt time for the procedure."""
        with agmarshall.VARIANT_arg(time) as arg_time:
            agcls.evaluate_hresult(self.__dict__["_set_interrupt_time"](arg_time.COM_val))

    @property
    def stop_time(self) -> typing.Any:
        """Stop time for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_time(self, time:typing.Any) -> None:
        """Set the stop time for the procedure."""
        with agmarshall.VARIANT_arg(time) as arg_time:
            agcls.evaluate_hresult(self.__dict__["_set_stop_time"](arg_time.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{776EACCB-1B06-4CB2-A915-01B3B2E15E10}", IProcedureFastTimeOptions)
agcls.AgTypeNameMap["IProcedureFastTimeOptions"] = IProcedureFastTimeOptions

class IAtmosphereModelBasic(object):
    """Interface used to access the basic atmosphere model."""
    _uuid = "{c39ccd9f-0996-4325-95bf-4b0af8d47b2f}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_basic_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_basic_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_use_non_standard_atmosphere"] = _raise_uninitialized_error
        self.__dict__["_set_use_non_standard_atmosphere"] = _raise_uninitialized_error
        self.__dict__["_get_temperature"] = _raise_uninitialized_error
        self.__dict__["_set_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_pressure"] = _raise_uninitialized_error
        self.__dict__["_set_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_density_alt"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAtmosphereModelBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAtmosphereModelBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAtmosphereModelBasic = agcom.GUID(IAtmosphereModelBasic._uuid)
        vtable_offset_local = IAtmosphereModelBasic._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_basic_model_type"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_basic_model_type"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_use_non_standard_atmosphere"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_non_standard_atmosphere"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_temperature"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_temperature"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_pressure"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_pressure"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_density_alt"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModelBasic, vtable_offset_local+11, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAtmosphereModelBasic.__dict__ and type(IAtmosphereModelBasic.__dict__[attrname]) == property:
            return IAtmosphereModelBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAtmosphereModelBasic.")
    
    @property
    def name(self) -> str:
        """The name of the atmosphere model."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the atmospheremodel."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def basic_model_type(self) -> "AVTR_ATMOSPHERE_MODEL":
        """The type of basic atmosphere."""
        with agmarshall.AgEnum_arg(AVTR_ATMOSPHERE_MODEL) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_basic_model_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @basic_model_type.setter
    def basic_model_type(self, newVal:"AVTR_ATMOSPHERE_MODEL") -> None:
        """The type of basic atmosphere."""
        with agmarshall.AgEnum_arg(AVTR_ATMOSPHERE_MODEL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_basic_model_type"](arg_newVal.COM_val))

    @property
    def use_non_standard_atmosphere(self) -> bool:
        """Opt whether to use non standard atmosphere conditions."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_non_standard_atmosphere"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_non_standard_atmosphere.setter
    def use_non_standard_atmosphere(self, newVal:bool) -> None:
        """Opt whether to use non standard atmosphere conditions."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_non_standard_atmosphere"](arg_newVal.COM_val))

    @property
    def temperature(self) -> float:
        """The sea-level temperature."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_temperature"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @temperature.setter
    def temperature(self, newVal:float) -> None:
        """The sea-level temperature."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_temperature"](arg_newVal.COM_val))

    @property
    def pressure(self) -> float:
        """The sea-level pressure."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_pressure"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @pressure.setter
    def pressure(self, newVal:float) -> None:
        """The sea-level pressure."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pressure"](arg_newVal.COM_val))

    @property
    def density_alt(self) -> float:
        """The sea-level density altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_alt"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{c39ccd9f-0996-4325-95bf-4b0af8d47b2f}", IAtmosphereModelBasic)
agcls.AgTypeNameMap["IAtmosphereModelBasic"] = IAtmosphereModelBasic

class IAtmosphereModel(object):
    """Interface used to access the atmosphere model for a mission, scenario, or procedure."""
    _uuid = "{1f18b697-794a-4001-a3ee-ccfb21c27e44}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmosphere_model_type_string"] = _raise_uninitialized_error
        self.__dict__["_set_atmosphere_model_type_string"] = _raise_uninitialized_error
        self.__dict__["_get_atmosphere_model_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmosphere_model_source"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_basic"] = _raise_uninitialized_error
        self.__dict__["_copy"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAtmosphereModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAtmosphereModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAtmosphereModel = agcom.GUID(IAtmosphereModel._uuid)
        vtable_offset_local = IAtmosphereModel._vtable_offset - 1
        self.__dict__["_get_atmosphere_model_type_string"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModel, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_atmosphere_model_type_string"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModel, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_atmosphere_model_source"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModel, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_atmosphere_model_source"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModel, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_mode_as_basic"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModel, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_copy"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModel, vtable_offset_local+6, )
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IAtmosphereModel, vtable_offset_local+7, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAtmosphereModel.__dict__ and type(IAtmosphereModel.__dict__[attrname]) == property:
            return IAtmosphereModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAtmosphereModel.")
    
    @property
    def atmosphere_model_type_string(self) -> str:
        """The atmosphere model type as a string value."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmosphere_model_type_string"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmosphere_model_type_string.setter
    def atmosphere_model_type_string(self, pVal:str) -> None:
        """The atmosphere model type as a string value."""
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmosphere_model_type_string"](arg_pVal.COM_val))

    @property
    def atmosphere_model_source(self) -> "AVTR_WIND_ATMOS_MODEL_SOURCE":
        """The atmosphere model source."""
        with agmarshall.AgEnum_arg(AVTR_WIND_ATMOS_MODEL_SOURCE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmosphere_model_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmosphere_model_source.setter
    def atmosphere_model_source(self, pVal:"AVTR_WIND_ATMOS_MODEL_SOURCE") -> None:
        """The atmosphere model source."""
        with agmarshall.AgEnum_arg(AVTR_WIND_ATMOS_MODEL_SOURCE, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmosphere_model_source"](arg_pVal.COM_val))

    @property
    def mode_as_basic(self) -> "IAtmosphereModelBasic":
        """Get the options for a Basic Atmosphere model."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_basic"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def copy(self) -> None:
        """Copy the atmosphere model."""
        agcls.evaluate_hresult(self.__dict__["_copy"]())

    def paste(self) -> None:
        """Paste the atmosphere model."""
        agcls.evaluate_hresult(self.__dict__["_paste"]())


agcls.AgClassCatalog.add_catalog_entry("{1f18b697-794a-4001-a3ee-ccfb21c27e44}", IAtmosphereModel)
agcls.AgTypeNameMap["IAtmosphereModel"] = IAtmosphereModel

class IADDSMessageCollection(object):
    """Interface used to access the collection of messages from the NOAA ADDS forecast."""
    _uuid = "{fecb8f81-541f-4e86-8f34-ed7570047450}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_remove_message"] = _raise_uninitialized_error
        self.__dict__["_clear_messages"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IADDSMessageCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IADDSMessageCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IADDSMessageCollection = agcom.GUID(IADDSMessageCollection._uuid)
        vtable_offset_local = IADDSMessageCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IADDSMessageCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IADDSMessageCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IADDSMessageCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_remove_message"] = IAGFUNCTYPE(pUnk, IID_IADDSMessageCollection, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_clear_messages"] = IAGFUNCTYPE(pUnk, IID_IADDSMessageCollection, vtable_offset_local+5, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IADDSMessageCollection.__dict__ and type(IADDSMessageCollection.__dict__[attrname]) == property:
            return IADDSMessageCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IADDSMessageCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IADDSMessage":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IADDSMessage":
        """Given an index, returns an element in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that can iterate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def remove_message(self, message:"IADDSMessage") -> None:
        """Remove this message from the forecast."""
        with agmarshall.AgInterface_in_arg(message, IADDSMessage) as arg_message:
            agcls.evaluate_hresult(self.__dict__["_remove_message"](arg_message.COM_val))

    def clear_messages(self) -> None:
        """Clears all of the messages in the collection."""
        agcls.evaluate_hresult(self.__dict__["_clear_messages"]())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{fecb8f81-541f-4e86-8f34-ed7570047450}", IADDSMessageCollection)
agcls.AgTypeNameMap["IADDSMessageCollection"] = IADDSMessageCollection

class IWindModelADDS(object):
    """Interface used to access the options for a NOAA ADDS wind model."""
    _uuid = "{56b53131-0902-4469-9acc-75b68ed298d4}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_blend_time"] = _raise_uninitialized_error
        self.__dict__["_set_blend_time"] = _raise_uninitialized_error
        self.__dict__["_get_msg_interpolation_type"] = _raise_uninitialized_error
        self.__dict__["_set_msg_interpolation_type"] = _raise_uninitialized_error
        self.__dict__["_get_msg_extrapolation_type"] = _raise_uninitialized_error
        self.__dict__["_set_msg_extrapolation_type"] = _raise_uninitialized_error
        self.__dict__["_get_missing_msg_type"] = _raise_uninitialized_error
        self.__dict__["_set_missing_msg_type"] = _raise_uninitialized_error
        self.__dict__["_get_interp_blend_time"] = _raise_uninitialized_error
        self.__dict__["_set_interp_blend_time"] = _raise_uninitialized_error
        self.__dict__["_add_current_forecast"] = _raise_uninitialized_error
        self.__dict__["_get_messages"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWindModelADDS._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWindModelADDS from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWindModelADDS = agcom.GUID(IWindModelADDS._uuid)
        vtable_offset_local = IWindModelADDS._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_blend_time"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_blend_time"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_msg_interpolation_type"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_msg_interpolation_type"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_msg_extrapolation_type"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_msg_extrapolation_type"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_missing_msg_type"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_missing_msg_type"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_interp_blend_time"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_interp_blend_time"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_add_current_forecast"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_get_messages"] = IAGFUNCTYPE(pUnk, IID_IWindModelADDS, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWindModelADDS.__dict__ and type(IWindModelADDS.__dict__[attrname]) == property:
            return IWindModelADDS.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWindModelADDS.")
    
    @property
    def name(self) -> str:
        """The name of the wind model."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the wind model."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def blend_time(self) -> float:
        """The blend time to transition from the previous wind model if one exists."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_blend_time"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @blend_time.setter
    def blend_time(self, newVal:float) -> None:
        """The blend time to transition from the previous wind model if one exists."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_blend_time"](arg_newVal.COM_val))

    @property
    def msg_interpolation_type(self) -> "AVTR_ADDS_MSG_INTERP_TYPE":
        """The message interpolation type."""
        with agmarshall.AgEnum_arg(AVTR_ADDS_MSG_INTERP_TYPE) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_msg_interpolation_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @msg_interpolation_type.setter
    def msg_interpolation_type(self, newVal:"AVTR_ADDS_MSG_INTERP_TYPE") -> None:
        """The message interpolation type."""
        with agmarshall.AgEnum_arg(AVTR_ADDS_MSG_INTERP_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_msg_interpolation_type"](arg_newVal.COM_val))

    @property
    def msg_extrapolation_type(self) -> "AVTR_ADDS_MSG_EXTRAP_TYPE":
        """The message extrapolation type."""
        with agmarshall.AgEnum_arg(AVTR_ADDS_MSG_EXTRAP_TYPE) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_msg_extrapolation_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @msg_extrapolation_type.setter
    def msg_extrapolation_type(self, newVal:"AVTR_ADDS_MSG_EXTRAP_TYPE") -> None:
        """The message extrapolation type."""
        with agmarshall.AgEnum_arg(AVTR_ADDS_MSG_EXTRAP_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_msg_extrapolation_type"](arg_newVal.COM_val))

    @property
    def missing_msg_type(self) -> "AVTR_ADDS_MISSING_MSG_TYPE":
        """The missing message type."""
        with agmarshall.AgEnum_arg(AVTR_ADDS_MISSING_MSG_TYPE) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_missing_msg_type"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @missing_msg_type.setter
    def missing_msg_type(self, newVal:"AVTR_ADDS_MISSING_MSG_TYPE") -> None:
        """The missing message type."""
        with agmarshall.AgEnum_arg(AVTR_ADDS_MISSING_MSG_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_missing_msg_type"](arg_newVal.COM_val))

    @property
    def interp_blend_time(self) -> float:
        """The blend time to transition from the previous wind condition."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_interp_blend_time"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @interp_blend_time.setter
    def interp_blend_time(self, newVal:float) -> None:
        """The blend time to transition from the previous wind condition."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_interp_blend_time"](arg_newVal.COM_val))

    def add_current_forecast(self) -> str:
        """Add the current forecast from the ADDS service."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_add_current_forecast"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def messages(self) -> "IADDSMessageCollection":
        """Get the messages from the current forecast."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_messages"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{56b53131-0902-4469-9acc-75b68ed298d4}", IWindModelADDS)
agcls.AgTypeNameMap["IWindModelADDS"] = IWindModelADDS

class IWindModelConstant(object):
    """Interface used to access the options for a Constant Bearing/Speed wind model."""
    _uuid = "{d40dcd05-eccc-4264-8b84-39be36b58406}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_blend_time"] = _raise_uninitialized_error
        self.__dict__["_set_blend_time"] = _raise_uninitialized_error
        self.__dict__["_get_wind_speed"] = _raise_uninitialized_error
        self.__dict__["_set_wind_speed"] = _raise_uninitialized_error
        self.__dict__["_get_wind_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_wind_bearing"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWindModelConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWindModelConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWindModelConstant = agcom.GUID(IWindModelConstant._uuid)
        vtable_offset_local = IWindModelConstant._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_blend_time"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_blend_time"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_wind_speed"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wind_speed"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_wind_bearing"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_wind_bearing"] = IAGFUNCTYPE(pUnk, IID_IWindModelConstant, vtable_offset_local+8, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWindModelConstant.__dict__ and type(IWindModelConstant.__dict__[attrname]) == property:
            return IWindModelConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWindModelConstant.")
    
    @property
    def name(self) -> str:
        """The name of the wind model."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the wind model."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def blend_time(self) -> float:
        """The blend time to transition from the previous wind model if one exists."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_blend_time"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @blend_time.setter
    def blend_time(self, newVal:float) -> None:
        """The blend time to transition from the previous wind model if one exists."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_blend_time"](arg_newVal.COM_val))

    @property
    def wind_speed(self) -> float:
        """The constant wind speed."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_wind_speed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @wind_speed.setter
    def wind_speed(self, newVal:float) -> None:
        """The constant wind speed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wind_speed"](arg_newVal.COM_val))

    @property
    def wind_bearing(self) -> typing.Any:
        """The wind's true bearing."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_wind_bearing"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @wind_bearing.setter
    def wind_bearing(self, newVal:typing.Any) -> None:
        """The wind's true bearing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wind_bearing"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{d40dcd05-eccc-4264-8b84-39be36b58406}", IWindModelConstant)
agcls.AgTypeNameMap["IWindModelConstant"] = IWindModelConstant

class IStation(object):
    """Interface used to access a station for an Aviator aircraft."""
    _uuid = "{ac0b6aed-ff8d-4f69-ba75-d31e2285b436}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStation = agcom.GUID(IStation._uuid)
        vtable_offset_local = IStation._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStation.__dict__ and type(IStation.__dict__[attrname]) == property:
            return IStation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStation.")
    

agcls.AgClassCatalog.add_catalog_entry("{ac0b6aed-ff8d-4f69-ba75-d31e2285b436}", IStation)
agcls.AgTypeNameMap["IStation"] = IStation

class IStationCollection(object):
    """Interface used to access the list of stations for an Aviator aircraft."""
    _uuid = "{c4e09526-9742-4f58-9943-b176e5192b24}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_internal_fuel_tank_by_name"] = _raise_uninitialized_error
        self.__dict__["_add_internal_fuel_tank"] = _raise_uninitialized_error
        self.__dict__["_get_payload_station_by_name"] = _raise_uninitialized_error
        self.__dict__["_add_payload_station"] = _raise_uninitialized_error
        self.__dict__["_contains_station"] = _raise_uninitialized_error
        self.__dict__["_remove_station_by_name"] = _raise_uninitialized_error
        self.__dict__["_remove_at_index"] = _raise_uninitialized_error
        self.__dict__["_get_station_names"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStationCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStationCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStationCollection = agcom.GUID(IStationCollection._uuid)
        vtable_offset_local = IStationCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_internal_fuel_tank_by_name"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_internal_fuel_tank"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_payload_station_by_name"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_payload_station"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_contains_station"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_remove_station_by_name"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+9, agcom.BSTR)
        self.__dict__["_remove_at_index"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_station_names"] = IAGFUNCTYPE(pUnk, IID_IStationCollection, vtable_offset_local+11, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStationCollection.__dict__ and type(IStationCollection.__dict__[attrname]) == property:
            return IStationCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStationCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IStation":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IStation":
        """Given an index, returns an element in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that can iterate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_internal_fuel_tank_by_name(self, name:str) -> "IFuelTankInternal":
        """Get the internal fuel tank with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppFuelTank:
            agcls.evaluate_hresult(self.__dict__["_get_internal_fuel_tank_by_name"](arg_name.COM_val, byref(arg_ppFuelTank.COM_val)))
            return arg_ppFuelTank.python_val

    def add_internal_fuel_tank(self) -> "IFuelTankInternal":
        """Add an internal fuel tank"""
        with agmarshall.AgInterface_out_arg() as arg_ppFuelTankInternal:
            agcls.evaluate_hresult(self.__dict__["_add_internal_fuel_tank"](byref(arg_ppFuelTankInternal.COM_val)))
            return arg_ppFuelTankInternal.python_val

    def get_payload_station_by_name(self, name:str) -> "IPayloadStation":
        """Get the payload station with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppPayloadStation:
            agcls.evaluate_hresult(self.__dict__["_get_payload_station_by_name"](arg_name.COM_val, byref(arg_ppPayloadStation.COM_val)))
            return arg_ppPayloadStation.python_val

    def add_payload_station(self) -> "IPayloadStation":
        """Add a payload station"""
        with agmarshall.AgInterface_out_arg() as arg_ppNewPayloadStation:
            agcls.evaluate_hresult(self.__dict__["_add_payload_station"](byref(arg_ppNewPayloadStation.COM_val)))
            return arg_ppNewPayloadStation.python_val

    def contains_station(self, name:str) -> bool:
        """Get whether the station list contains an item with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_contains_station"](arg_name.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def remove_station_by_name(self, name:str) -> None:
        """Remove an station by name."""
        with agmarshall.BSTR_arg(name) as arg_name:
            agcls.evaluate_hresult(self.__dict__["_remove_station_by_name"](arg_name.COM_val))

    def remove_at_index(self, index:int) -> None:
        """Remove procedure at the given index."""
        with agmarshall.LONG_arg(index) as arg_index:
            agcls.evaluate_hresult(self.__dict__["_remove_at_index"](arg_index.COM_val))

    @property
    def station_names(self) -> list:
        """Returns the station names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_station_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{c4e09526-9742-4f58-9943-b176e5192b24}", IStationCollection)
agcls.AgTypeNameMap["IStationCollection"] = IStationCollection

class IConfiguration(object):
    """Interface used to change an aircraft's configuration for an Aviator mission."""
    _uuid = "{33bb7422-861d-4949-a165-cb4a416c400b}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_empty_weight"] = _raise_uninitialized_error
        self.__dict__["_set_empty_weight"] = _raise_uninitialized_error
        self.__dict__["_get_max_landing_weight"] = _raise_uninitialized_error
        self.__dict__["_set_max_landing_weight"] = _raise_uninitialized_error
        self.__dict__["_get_base_drag_index"] = _raise_uninitialized_error
        self.__dict__["_set_base_drag_index"] = _raise_uninitialized_error
        self.__dict__["_get_empty_cgx"] = _raise_uninitialized_error
        self.__dict__["_get_empty_cgy"] = _raise_uninitialized_error
        self.__dict__["_get_empty_cgz"] = _raise_uninitialized_error
        self.__dict__["_set_empty_cg"] = _raise_uninitialized_error
        self.__dict__["_get_total_weight"] = _raise_uninitialized_error
        self.__dict__["_get_total_weight_max_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_total_drag_index"] = _raise_uninitialized_error
        self.__dict__["_get_total_cgx"] = _raise_uninitialized_error
        self.__dict__["_get_total_cgy"] = _raise_uninitialized_error
        self.__dict__["_get_total_cgz"] = _raise_uninitialized_error
        self.__dict__["_paste_configuration"] = _raise_uninitialized_error
        self.__dict__["_get_stations"] = _raise_uninitialized_error
        self.__dict__["_get_total_capacity"] = _raise_uninitialized_error
        self.__dict__["_get_initial_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_save"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConfiguration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConfiguration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConfiguration = agcom.GUID(IConfiguration._uuid)
        vtable_offset_local = IConfiguration._vtable_offset - 1
        self.__dict__["_get_empty_weight"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_empty_weight"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_max_landing_weight"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_landing_weight"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_base_drag_index"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_base_drag_index"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_empty_cgx"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_get_empty_cgy"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_get_empty_cgz"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_empty_cg"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+10, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_get_total_weight"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_total_weight_max_fuel"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_get_total_drag_index"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_get_total_cgx"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_get_total_cgy"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_get_total_cgz"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_paste_configuration"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+17, agcom.PVOID)
        self.__dict__["_get_stations"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_get_total_capacity"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_get_initial_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_save"] = IAGFUNCTYPE(pUnk, IID_IConfiguration, vtable_offset_local+21, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConfiguration.__dict__ and type(IConfiguration.__dict__[attrname]) == property:
            return IConfiguration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConfiguration.")
    
    @property
    def empty_weight(self) -> float:
        """The empty weight of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_empty_weight"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @empty_weight.setter
    def empty_weight(self, newVal:float) -> None:
        """The empty weight of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_empty_weight"](arg_newVal.COM_val))

    @property
    def max_landing_weight(self) -> float:
        """The max landing weight of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_landing_weight"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @max_landing_weight.setter
    def max_landing_weight(self, newVal:float) -> None:
        """The max landing weight of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_landing_weight"](arg_newVal.COM_val))

    @property
    def base_drag_index(self) -> float:
        """The base drag index of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_base_drag_index"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @base_drag_index.setter
    def base_drag_index(self, newVal:float) -> None:
        """The base drag index of the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_base_drag_index"](arg_newVal.COM_val))

    @property
    def empty_cgx(self) -> float:
        """The X value of the aircraft's Empty CG position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_empty_cgx"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def empty_cgy(self) -> float:
        """The Y value of the aircraft's Empty CG position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_empty_cgy"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def empty_cgz(self) -> float:
        """The Z value of the aircraft's Empty CG position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_empty_cgz"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def set_empty_cg(self, x:float, y:float, z:float) -> None:
        """Set the aircraft's Empty CG position."""
        with agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.DOUBLE_arg(z) as arg_z:
            agcls.evaluate_hresult(self.__dict__["_set_empty_cg"](arg_x.COM_val, arg_y.COM_val, arg_z.COM_val))

    @property
    def total_weight(self) -> float:
        """The total weight of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_weight"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def total_weight_max_fuel(self) -> float:
        """The total weight of the aircraft with all fuel tanks full."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_weight_max_fuel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def total_drag_index(self) -> float:
        """The total drag index of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_drag_index"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def total_cgx(self) -> float:
        """The X value of the aircraft's Total CG position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_cgx"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def total_cgy(self) -> float:
        """The Y value of the aircraft's Total CG position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_cgy"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def total_cgz(self) -> float:
        """The Z value of the aircraft's Total CG position."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_cgz"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def paste_configuration(self, otherConfiguration:"IConfiguration") -> None:
        """Paste the aircraft's configuration."""
        with agmarshall.AgInterface_in_arg(otherConfiguration, IConfiguration) as arg_otherConfiguration:
            agcls.evaluate_hresult(self.__dict__["_paste_configuration"](arg_otherConfiguration.COM_val))

    def get_stations(self) -> "IStationCollection":
        """Get a collection of the aircraft's payload stations."""
        with agmarshall.AgInterface_out_arg() as arg_ppStationList:
            agcls.evaluate_hresult(self.__dict__["_get_stations"](byref(arg_ppStationList.COM_val)))
            return arg_ppStationList.python_val

    @property
    def total_capacity(self) -> float:
        """The total fuel capacity of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_total_capacity"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def initial_fuel_state(self) -> float:
        """The initial fuel state of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_fuel_state"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def save(self) -> None:
        """Save."""
        agcls.evaluate_hresult(self.__dict__["_save"]())


agcls.AgClassCatalog.add_catalog_entry("{33bb7422-861d-4949-a165-cb4a416c400b}", IConfiguration)
agcls.AgTypeNameMap["IConfiguration"] = IConfiguration

class ICatalogSource(object):
    """Interface used to access options for a source in the Aviator Catalog. Examples of sources include User Aircraft Models, ARINC424runways, User Runways, etc."""
    _uuid = "{ea6e896f-5c4d-4614-9835-4a9f598e52b3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_child_names"] = _raise_uninitialized_error
        self.__dict__["_contains"] = _raise_uninitialized_error
        self.__dict__["_remove_child"] = _raise_uninitialized_error
        self.__dict__["_save"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalogSource._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalogSource from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalogSource = agcom.GUID(ICatalogSource._uuid)
        vtable_offset_local = ICatalogSource._vtable_offset - 1
        self.__dict__["_get_child_names"] = IAGFUNCTYPE(pUnk, IID_ICatalogSource, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_contains"] = IAGFUNCTYPE(pUnk, IID_ICatalogSource, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_remove_child"] = IAGFUNCTYPE(pUnk, IID_ICatalogSource, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_save"] = IAGFUNCTYPE(pUnk, IID_ICatalogSource, vtable_offset_local+4, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogSource.__dict__ and type(ICatalogSource.__dict__[attrname]) == property:
            return ICatalogSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogSource.")
    
    @property
    def child_names(self) -> list:
        """Returns the child names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_child_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def contains(self, aircraftName:str) -> bool:
        """Checks whether the catalog source contains the catalog item with the given name."""
        with agmarshall.BSTR_arg(aircraftName) as arg_aircraftName, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_contains"](arg_aircraftName.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def remove_child(self, childName:str) -> None:
        """Removes the child with the given name."""
        with agmarshall.BSTR_arg(childName) as arg_childName:
            agcls.evaluate_hresult(self.__dict__["_remove_child"](arg_childName.COM_val))

    def save(self) -> None:
        """Saves the catalog item."""
        agcls.evaluate_hresult(self.__dict__["_save"]())


agcls.AgClassCatalog.add_catalog_entry("{ea6e896f-5c4d-4614-9835-4a9f598e52b3}", ICatalogSource)
agcls.AgTypeNameMap["ICatalogSource"] = ICatalogSource

class IAircraftModels(object):
    """Interface for the User Aircraft Models in the Aviator Catalog."""
    _uuid = "{7fffbf9b-1624-4cc9-ba50-ad078c509123}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aircraft"] = _raise_uninitialized_error
        self.__dict__["_add_aircraft"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftModels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftModels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftModels = agcom.GUID(IAircraftModels._uuid)
        vtable_offset_local = IAircraftModels._vtable_offset - 1
        self.__dict__["_get_aircraft"] = IAGFUNCTYPE(pUnk, IID_IAircraftModels, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_aircraft"] = IAGFUNCTYPE(pUnk, IID_IAircraftModels, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IAircraftModels, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftModels.__dict__ and type(IAircraftModels.__dict__[attrname]) == property:
            return IAircraftModels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftModels.")
    
    def get_aircraft(self, aircraftName:str) -> "IAircraftModel":
        """Gets the aircraft with the given name."""
        with agmarshall.BSTR_arg(aircraftName) as arg_aircraftName, \
             agmarshall.AgInterface_out_arg() as arg_ppAircraft:
            agcls.evaluate_hresult(self.__dict__["_get_aircraft"](arg_aircraftName.COM_val, byref(arg_ppAircraft.COM_val)))
            return arg_ppAircraft.python_val

    def add_aircraft(self, aircraftName:str) -> "IAircraftModel":
        """Creates a new aircraft with the given name."""
        with agmarshall.BSTR_arg(aircraftName) as arg_aircraftName, \
             agmarshall.AgInterface_out_arg() as arg_ppAircraft:
            agcls.evaluate_hresult(self.__dict__["_add_aircraft"](arg_aircraftName.COM_val, byref(arg_ppAircraft.COM_val)))
            return arg_ppAircraft.python_val

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogSource:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogSource.COM_val)))
            return arg_ppCatalogSource.python_val


agcls.AgClassCatalog.add_catalog_entry("{7fffbf9b-1624-4cc9-ba50-ad078c509123}", IAircraftModels)
agcls.AgTypeNameMap["IAircraftModels"] = IAircraftModels

class IMissileModels(object):
    """Interface for the User Missile Models in the Aviator Catalog."""
    _uuid = "{7d284b91-7746-4fb4-bb96-a115192c18b6}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_missile"] = _raise_uninitialized_error
        self.__dict__["_add_missile"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissileModels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissileModels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissileModels = agcom.GUID(IMissileModels._uuid)
        vtable_offset_local = IMissileModels._vtable_offset - 1
        self.__dict__["_get_missile"] = IAGFUNCTYPE(pUnk, IID_IMissileModels, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_missile"] = IAGFUNCTYPE(pUnk, IID_IMissileModels, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IMissileModels, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileModels.__dict__ and type(IMissileModels.__dict__[attrname]) == property:
            return IMissileModels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileModels.")
    
    def get_missile(self, name:str) -> "IMissileModel":
        """Gets the missile with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppMissile:
            agcls.evaluate_hresult(self.__dict__["_get_missile"](arg_name.COM_val, byref(arg_ppMissile.COM_val)))
            return arg_ppMissile.python_val

    def add_missile(self, name:str) -> "IMissileModel":
        """Creates a new missile with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppMissile:
            agcls.evaluate_hresult(self.__dict__["_add_missile"](arg_name.COM_val, byref(arg_ppMissile.COM_val)))
            return arg_ppMissile.python_val

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogSource:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogSource.COM_val)))
            return arg_ppCatalogSource.python_val


agcls.AgClassCatalog.add_catalog_entry("{7d284b91-7746-4fb4-bb96-a115192c18b6}", IMissileModels)
agcls.AgTypeNameMap["IMissileModels"] = IMissileModels

class IRotorcraftModels(object):
    """Interface for the User Rotorcraft Models in the Aviator Catalog."""
    _uuid = "{60605557-ec23-4435-a778-d524335f9244}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_rotorcraft"] = _raise_uninitialized_error
        self.__dict__["_add_rotorcraft"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_source"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRotorcraftModels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftModels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRotorcraftModels = agcom.GUID(IRotorcraftModels._uuid)
        vtable_offset_local = IRotorcraftModels._vtable_offset - 1
        self.__dict__["_get_rotorcraft"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModels, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_add_rotorcraft"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModels, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_source"] = IAGFUNCTYPE(pUnk, IID_IRotorcraftModels, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftModels.__dict__ and type(IRotorcraftModels.__dict__[attrname]) == property:
            return IRotorcraftModels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftModels.")
    
    def get_rotorcraft(self, name:str) -> "IRotorcraftModel":
        """Gets the rotorcraft with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRotorcraft:
            agcls.evaluate_hresult(self.__dict__["_get_rotorcraft"](arg_name.COM_val, byref(arg_ppRotorcraft.COM_val)))
            return arg_ppRotorcraft.python_val

    def add_rotorcraft(self, name:str) -> "IRotorcraftModel":
        """Creates a new rotorcraft with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRotorcraft:
            agcls.evaluate_hresult(self.__dict__["_add_rotorcraft"](arg_name.COM_val, byref(arg_ppRotorcraft.COM_val)))
            return arg_ppRotorcraft.python_val

    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogSource:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_source"](byref(arg_ppCatalogSource.COM_val)))
            return arg_ppCatalogSource.python_val


agcls.AgClassCatalog.add_catalog_entry("{60605557-ec23-4435-a778-d524335f9244}", IRotorcraftModels)
agcls.AgTypeNameMap["IRotorcraftModels"] = IRotorcraftModels

class IBasicFixedWingLiftHelper(object):
    """Interface used to access Lift Coefficient Helper in the Basic Fixed Wing Aerodynamics interface for the Basic Acceleration Model of an aircraft."""
    _uuid = "{6c9d7ac9-cf16-4110-87e4-080c83a44322}"
    _num_methods = 0
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicFixedWingLiftHelper._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicFixedWingLiftHelper from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicFixedWingLiftHelper = agcom.GUID(IBasicFixedWingLiftHelper._uuid)
        vtable_offset_local = IBasicFixedWingLiftHelper._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicFixedWingLiftHelper.__dict__ and type(IBasicFixedWingLiftHelper.__dict__[attrname]) == property:
            return IBasicFixedWingLiftHelper.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicFixedWingLiftHelper.")
    

agcls.AgClassCatalog.add_catalog_entry("{6c9d7ac9-cf16-4110-87e4-080c83a44322}", IBasicFixedWingLiftHelper)
agcls.AgTypeNameMap["IBasicFixedWingLiftHelper"] = IBasicFixedWingLiftHelper

class IAircraftBasicFixedWingAero(object):
    """Interface used to access Basic Fixed Wing Aerodynamics interface for the Basic Acceleration Model of an aircraft."""
    _uuid = "{cdf3e057-6192-4817-a72b-8f3cba8b38e5}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_forward_flight_reference_area"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_reference_area"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_use_compressible_flow"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_use_compressible_flow"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_cl0"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_cl0"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_cl_alpha"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_cl_alpha"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_min_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_min_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_cd0"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_cd0"] = _raise_uninitialized_error
        self.__dict__["_get_forward_flight_k"] = _raise_uninitialized_error
        self.__dict__["_set_forward_flight_k"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_reference_area"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_reference_area"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_use_compressible_flow"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_use_compressible_flow"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_cl0"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_cl0"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_cl_alpha"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_cl_alpha"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_min_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_min_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_max_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_cd0"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_cd0"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_landing_k"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_landing_k"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftBasicFixedWingAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicFixedWingAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftBasicFixedWingAero = agcom.GUID(IAircraftBasicFixedWingAero._uuid)
        vtable_offset_local = IAircraftBasicFixedWingAero._vtable_offset - 1
        self.__dict__["_get_forward_flight_reference_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_forward_flight_reference_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_forward_flight_use_compressible_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_forward_flight_use_compressible_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_forward_flight_cl0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_forward_flight_cl0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_forward_flight_cl_alpha"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_forward_flight_cl_alpha"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_forward_flight_min_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_forward_flight_min_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_forward_flight_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_forward_flight_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_forward_flight_cd0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_forward_flight_cd0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_forward_flight_k"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_forward_flight_k"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_takeoff_landing_reference_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_takeoff_landing_reference_area"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_takeoff_landing_use_compressible_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_takeoff_landing_use_compressible_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_get_takeoff_landing_cl0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_takeoff_landing_cl0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_takeoff_landing_cl_alpha"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_takeoff_landing_cl_alpha"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_takeoff_landing_min_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+25, POINTER(agcom.VARIANT))
        self.__dict__["_set_takeoff_landing_min_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+26, agcom.VARIANT)
        self.__dict__["_get_takeoff_landing_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+27, POINTER(agcom.VARIANT))
        self.__dict__["_set_takeoff_landing_max_aoa"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+28, agcom.VARIANT)
        self.__dict__["_get_takeoff_landing_cd0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_takeoff_landing_cd0"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_takeoff_landing_k"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_takeoff_landing_k"] = IAGFUNCTYPE(pUnk, IID_IAircraftBasicFixedWingAero, vtable_offset_local+32, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicFixedWingAero.__dict__ and type(IAircraftBasicFixedWingAero.__dict__[attrname]) == property:
            return IAircraftBasicFixedWingAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicFixedWingAero.")
    
    @property
    def forward_flight_reference_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_reference_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_reference_area.setter
    def forward_flight_reference_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_reference_area"](arg_pVal.COM_val))

    @property
    def forward_flight_use_compressible_flow(self) -> bool:
        """Opt to define the aerodynamic parameters for forward flight with respect to supersonic flight conditions."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_use_compressible_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_use_compressible_flow.setter
    def forward_flight_use_compressible_flow(self, newVal:bool) -> None:
        """Opt to define the aerodynamic parameters for forward flight with respect to supersonic flight conditions."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_use_compressible_flow"](arg_newVal.COM_val))

    @property
    def forward_flight_cl0(self) -> float:
        """The coefficient of lift at zero angle of attack."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_cl0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_cl0.setter
    def forward_flight_cl0(self, newVal:float) -> None:
        """The coefficient of lift at zero angle of attack."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_cl0"](arg_newVal.COM_val))

    @property
    def forward_flight_cl_alpha(self) -> float:
        """The slope of the coefficient of lift curve."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_cl_alpha"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_cl_alpha.setter
    def forward_flight_cl_alpha(self, newVal:float) -> None:
        """The slope of the coefficient of lift curve."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_cl_alpha"](arg_newVal.COM_val))

    @property
    def forward_flight_min_aoa(self) -> typing.Any:
        """The minimum angle of attack possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_min_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_min_aoa.setter
    def forward_flight_min_aoa(self, newVal:typing.Any) -> None:
        """The minimum angle of attack possible."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_min_aoa"](arg_newVal.COM_val))

    @property
    def forward_flight_max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_max_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_max_aoa.setter
    def forward_flight_max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_max_aoa"](arg_newVal.COM_val))

    @property
    def forward_flight_cd0(self) -> float:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_cd0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_cd0.setter
    def forward_flight_cd0(self, newVal:float) -> None:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_cd0"](arg_newVal.COM_val))

    @property
    def forward_flight_k(self) -> float:
        """The coefficient of induced drag."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_forward_flight_k"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @forward_flight_k.setter
    def forward_flight_k(self, newVal:float) -> None:
        """The coefficient of induced drag."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_forward_flight_k"](arg_newVal.COM_val))

    @property
    def takeoff_landing_reference_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_reference_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_reference_area.setter
    def takeoff_landing_reference_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_reference_area"](arg_pVal.COM_val))

    @property
    def takeoff_landing_use_compressible_flow(self) -> bool:
        """Opt to define the aerodynamic parameters for takeoff and landing with respect to supersonic flight conditions."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_use_compressible_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_use_compressible_flow.setter
    def takeoff_landing_use_compressible_flow(self, newVal:bool) -> None:
        """Opt to define the aerodynamic parameters for takeoff and landing with respect to supersonic flight conditions."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_use_compressible_flow"](arg_newVal.COM_val))

    @property
    def takeoff_landing_cl0(self) -> float:
        """The coefficient of lift at zero angle of attack."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_cl0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_cl0.setter
    def takeoff_landing_cl0(self, newVal:float) -> None:
        """The coefficient of lift at zero angle of attack."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_cl0"](arg_newVal.COM_val))

    @property
    def takeoff_landing_cl_alpha(self) -> float:
        """The slope of the coefficient of lift curve."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_cl_alpha"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_cl_alpha.setter
    def takeoff_landing_cl_alpha(self, newVal:float) -> None:
        """The slope of the coefficient of lift curve."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_cl_alpha"](arg_newVal.COM_val))

    @property
    def takeoff_landing_min_aoa(self) -> typing.Any:
        """The minimum angle of attack possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_min_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_min_aoa.setter
    def takeoff_landing_min_aoa(self, newVal:typing.Any) -> None:
        """The minimum angle of attack possible."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_min_aoa"](arg_newVal.COM_val))

    @property
    def takeoff_landing_max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_max_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_max_aoa.setter
    def takeoff_landing_max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_max_aoa"](arg_newVal.COM_val))

    @property
    def takeoff_landing_cd0(self) -> float:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_cd0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_cd0.setter
    def takeoff_landing_cd0(self, newVal:float) -> None:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_cd0"](arg_newVal.COM_val))

    @property
    def takeoff_landing_k(self) -> float:
        """The coefficient of induced drag."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_landing_k"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_landing_k.setter
    def takeoff_landing_k(self, newVal:float) -> None:
        """The coefficient of induced drag."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_landing_k"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{cdf3e057-6192-4817-a72b-8f3cba8b38e5}", IAircraftBasicFixedWingAero)
agcls.AgTypeNameMap["IAircraftBasicFixedWingAero"] = IAircraftBasicFixedWingAero

class IAircraftAero(object):
    """Interface used to access the Aerodynamics options for the Basic Acceleration Model of an aircraft."""
    _uuid = "{cade76fa-36f7-4711-affc-77d00899be77}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aero_strategy"] = _raise_uninitialized_error
        self.__dict__["_set_aero_strategy"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_simple"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_basic_fixed_wing"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_external"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_advanced_missile"] = _raise_uninitialized_error
        self.__dict__["_get_lift_factor"] = _raise_uninitialized_error
        self.__dict__["_set_lift_factor"] = _raise_uninitialized_error
        self.__dict__["_get_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_set_drag_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAero._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAero from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAero = agcom.GUID(IAircraftAero._uuid)
        vtable_offset_local = IAircraftAero._vtable_offset - 1
        self.__dict__["_get_aero_strategy"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_aero_strategy"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_mode_as_simple"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_basic_fixed_wing"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_external"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_advanced_missile"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_lift_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lift_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftAero, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAero.__dict__ and type(IAircraftAero.__dict__[attrname]) == property:
            return IAircraftAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAero.")
    
    @property
    def aero_strategy(self) -> "AVTR_AIRCRAFT_AERO_STRATEGY":
        """The aerodynamic strategy type."""
        with agmarshall.AgEnum_arg(AVTR_AIRCRAFT_AERO_STRATEGY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aero_strategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aero_strategy.setter
    def aero_strategy(self, newVal:"AVTR_AIRCRAFT_AERO_STRATEGY") -> None:
        """The aerodynamic strategy type."""
        with agmarshall.AgEnum_arg(AVTR_AIRCRAFT_AERO_STRATEGY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_aero_strategy"](arg_newVal.COM_val))

    @property
    def mode_as_simple(self) -> "IAircraftSimpleAero":
        """Get the interface for a simple aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_simple"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_basic_fixed_wing(self) -> "IAircraftBasicFixedWingAero":
        """Get the interface for a basic fixed wing aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_basic_fixed_wing"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_external(self) -> "IAircraftExternalAero":
        """Get the interface for an external file aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_external"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_advanced_missile(self) -> "IMissileAdvancedAero":
        """Get the interface for an advanced missile aerodynamics strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_advanced_missile"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def lift_factor(self) -> float:
        """A scalar value applied to the lift for parametric analysis."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lift_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lift_factor.setter
    def lift_factor(self, newVal:float) -> None:
        """A scalar value applied to the lift for parametric analysis."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lift_factor"](arg_newVal.COM_val))

    @property
    def drag_factor(self) -> float:
        """A scalar value applied to the drag for parametric analysis."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_factor.setter
    def drag_factor(self, newVal:float) -> None:
        """A scalar value applied to the drag for parametric analysis."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{cade76fa-36f7-4711-affc-77d00899be77}", IAircraftAero)
agcls.AgTypeNameMap["IAircraftAero"] = IAircraftAero

class IAircraftProp(object):
    """Interface used to access the propulsion options for the Basic Acceleration Model of an aircraft."""
    _uuid = "{f2c9e37e-da9b-4210-94d6-b90c90d1a696}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_prop_strategy"] = _raise_uninitialized_error
        self.__dict__["_set_prop_strategy"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_simple"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_basic_fixed_wing"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_external"] = _raise_uninitialized_error
        self.__dict__["_get_lift_factor"] = _raise_uninitialized_error
        self.__dict__["_set_lift_factor"] = _raise_uninitialized_error
        self.__dict__["_get_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_set_drag_factor"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_ramjet"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_turbojet"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_rocket"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftProp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftProp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftProp = agcom.GUID(IAircraftProp._uuid)
        vtable_offset_local = IAircraftProp._vtable_offset - 1
        self.__dict__["_get_prop_strategy"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_prop_strategy"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_mode_as_simple"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_basic_fixed_wing"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_external"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_lift_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lift_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_drag_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_mode_as_ramjet"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_turbojet"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_rocket"] = IAGFUNCTYPE(pUnk, IID_IAircraftProp, vtable_offset_local+12, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftProp.__dict__ and type(IAircraftProp.__dict__[attrname]) == property:
            return IAircraftProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftProp.")
    
    @property
    def prop_strategy(self) -> "AVTR_AIRCRAFT_PROP_STRATEGY":
        """The propulsion strategy type."""
        with agmarshall.AgEnum_arg(AVTR_AIRCRAFT_PROP_STRATEGY) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_prop_strategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @prop_strategy.setter
    def prop_strategy(self, newVal:"AVTR_AIRCRAFT_PROP_STRATEGY") -> None:
        """The propulsion strategy type."""
        with agmarshall.AgEnum_arg(AVTR_AIRCRAFT_PROP_STRATEGY, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_prop_strategy"](arg_newVal.COM_val))

    @property
    def mode_as_simple(self) -> "IAircraftSimpleProp":
        """Get the interface for a simple propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_simple"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_basic_fixed_wing(self) -> "IAircraftBasicFixedWingProp":
        """Get the interface for a basic fixed wing propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_basic_fixed_wing"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_external(self) -> "IAircraftExternalProp":
        """Get the interface for an external file propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_external"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def lift_factor(self) -> float:
        """A scalar value applied to the lift for parametric analysis."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lift_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lift_factor.setter
    def lift_factor(self, newVal:float) -> None:
        """A scalar value applied to the lift for parametric analysis."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lift_factor"](arg_newVal.COM_val))

    @property
    def drag_factor(self) -> float:
        """A scalar value applied to the drag for parametric analysis."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_factor.setter
    def drag_factor(self, newVal:float) -> None:
        """A scalar value applied to the drag for parametric analysis."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_factor"](arg_newVal.COM_val))

    @property
    def mode_as_ramjet(self) -> "IMissileRamjetProp":
        """Get the interface for a Ramjet propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_ramjet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_turbojet(self) -> "IMissileTurbojetProp":
        """Get the interface for a Turbojet propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_turbojet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def mode_as_rocket(self) -> "IMissileRocketProp":
        """Get the interface for a Rocket propulsion strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_rocket"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{f2c9e37e-da9b-4210-94d6-b90c90d1a696}", IAircraftProp)
agcls.AgTypeNameMap["IAircraftProp"] = IAircraftProp

class IAircraftAccelerationMode(object):
    """Interface used to set the Acceleration Mode for the Advanced Acceleration Model of an aircraft."""
    _uuid = "{ed792861-7946-4e82-bf56-24fd86d3fdb2}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_accel_mode"] = _raise_uninitialized_error
        self.__dict__["_set_accel_mode"] = _raise_uninitialized_error
        self.__dict__["_get_accel_g"] = _raise_uninitialized_error
        self.__dict__["_set_accel_g"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAccelerationMode._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAccelerationMode from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAccelerationMode = agcom.GUID(IAircraftAccelerationMode._uuid)
        vtable_offset_local = IAircraftAccelerationMode._vtable_offset - 1
        self.__dict__["_get_accel_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAccelerationMode, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_accel_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAccelerationMode, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_accel_g"] = IAGFUNCTYPE(pUnk, IID_IAircraftAccelerationMode, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_g"] = IAGFUNCTYPE(pUnk, IID_IAircraftAccelerationMode, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAccelerationMode.__dict__ and type(IAircraftAccelerationMode.__dict__[attrname]) == property:
            return IAircraftAccelerationMode.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAccelerationMode.")
    
    @property
    def accel_mode(self) -> "AVTR_ACCELERATION_ADV_ACCEL_MODE":
        """Opt whether to override the acceleration or deceleration of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_ACCELERATION_ADV_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_mode.setter
    def accel_mode(self, newVal:"AVTR_ACCELERATION_ADV_ACCEL_MODE") -> None:
        """Opt whether to override the acceleration or deceleration of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_ACCELERATION_ADV_ACCEL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_mode"](arg_newVal.COM_val))

    @property
    def accel_g(self) -> float:
        """The rate of acceleration or deceleration of the aircraft if the accleeration mode is set to override."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The rate of acceleration or deceleration of the aircraft if the accleeration mode is set to override."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_g"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ed792861-7946-4e82-bf56-24fd86d3fdb2}", IAircraftAccelerationMode)
agcls.AgTypeNameMap["IAircraftAccelerationMode"] = IAircraftAccelerationMode

class IAircraftAdvAccelerationModel(object):
    """Interface used to access the Advanced Acceleration Model options of an aircraft."""
    _uuid = "{bb08fcaa-8e26-49be-bde2-9bbe5408c1fa}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_level_turns"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_transitions"] = _raise_uninitialized_error
        self.__dict__["_get_climb_and_descent_transitions"] = _raise_uninitialized_error
        self.__dict__["_get_acceleration_mode"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAdvAccelerationModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvAccelerationModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAdvAccelerationModel = agcom.GUID(IAircraftAdvAccelerationModel._uuid)
        vtable_offset_local = IAircraftAdvAccelerationModel._vtable_offset - 1
        self.__dict__["_get_level_turns"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvAccelerationModel, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_attitude_transitions"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvAccelerationModel, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_climb_and_descent_transitions"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvAccelerationModel, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_acceleration_mode"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvAccelerationModel, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftAdvAccelerationModel, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvAccelerationModel.__dict__ and type(IAircraftAdvAccelerationModel.__dict__[attrname]) == property:
            return IAircraftAdvAccelerationModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvAccelerationModel.")
    
    @property
    def level_turns(self) -> "ILevelTurns":
        """Get the level turns interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_turns"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def attitude_transitions(self) -> "IAttitudeTransitions":
        """Get the attitude transitions interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_transitions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def climb_and_descent_transitions(self) -> "IClimbAndDescentTransitions":
        """Get the climb and descent transitions interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_climb_and_descent_transitions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def acceleration_mode(self) -> "IAircraftAccelerationMode":
        """Get the acceleration mode interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_acceleration_mode"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{bb08fcaa-8e26-49be-bde2-9bbe5408c1fa}", IAircraftAdvAccelerationModel)
agcls.AgTypeNameMap["IAircraftAdvAccelerationModel"] = IAircraftAdvAccelerationModel

class IAeroPropManeuverModeHelper(object):
    """Interface used to access the The calculation mode for the Aero/Prop maneuver mode helper. Helper found in the Basic Acceleration Model of an aircraft."""
    _uuid = "{52d6c08d-32e5-49f1-bda0-96469ed01a6f}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_mode"] = _raise_uninitialized_error
        self.__dict__["_set_mode"] = _raise_uninitialized_error
        self.__dict__["_get_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_set_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_get_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_set_use_afterburner"] = _raise_uninitialized_error
        self.__dict__["_get_ref_weight"] = _raise_uninitialized_error
        self.__dict__["_set_ref_weight"] = _raise_uninitialized_error
        self.__dict__["_get_ref_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_ref_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_ref_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_ref_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_ref_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_ref_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_ref_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_estimated_ps"] = _raise_uninitialized_error
        self.__dict__["_get_control_authority"] = _raise_uninitialized_error
        self.__dict__["_set_control_authority"] = _raise_uninitialized_error
        self.__dict__["_get_status_msg"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAeroPropManeuverModeHelper._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAeroPropManeuverModeHelper from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAeroPropManeuverModeHelper = agcom.GUID(IAeroPropManeuverModeHelper._uuid)
        vtable_offset_local = IAeroPropManeuverModeHelper._vtable_offset - 1
        self.__dict__["_get_mode"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_mode"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_afterburner"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_ref_weight"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ref_weight"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_ref_altitude"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ref_altitude"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_ref_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_ref_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_ref_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+13, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_ref_load_factor"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ref_load_factor"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_estimated_ps"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_get_control_authority"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_authority"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_status_msg"] = IAGFUNCTYPE(pUnk, IID_IAeroPropManeuverModeHelper, vtable_offset_local+19, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAeroPropManeuverModeHelper.__dict__ and type(IAeroPropManeuverModeHelper.__dict__[attrname]) == property:
            return IAeroPropManeuverModeHelper.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAeroPropManeuverModeHelper.")
    
    @property
    def mode(self) -> "AVTR_ACCEL_MANEUVER_AERO_PROP_MODE":
        """The calculation mode for the Aero/Prop maneuver mode helper."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_AERO_PROP_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mode.setter
    def mode(self, newVal:"AVTR_ACCEL_MANEUVER_AERO_PROP_MODE") -> None:
        """The calculation mode for the Aero/Prop maneuver mode helper."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MANEUVER_AERO_PROP_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mode"](arg_newVal.COM_val))

    @property
    def flight_mode(self) -> "AVTR_AERO_PROP_FLIGHT_MODE":
        """The performance flight mode."""
        with agmarshall.AgEnum_arg(AVTR_AERO_PROP_FLIGHT_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_mode.setter
    def flight_mode(self, newVal:"AVTR_AERO_PROP_FLIGHT_MODE") -> None:
        """The performance flight mode."""
        with agmarshall.AgEnum_arg(AVTR_AERO_PROP_FLIGHT_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_mode"](arg_newVal.COM_val))

    @property
    def use_afterburner(self) -> bool:
        """Opt whether to use the afterburner if it is possible."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_afterburner"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_afterburner.setter
    def use_afterburner(self, newVal:bool) -> None:
        """Opt whether to use the afterburner if it is possible."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_afterburner"](arg_newVal.COM_val))

    @property
    def ref_weight(self) -> float:
        """The reference weight."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_weight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_weight.setter
    def ref_weight(self, newVal:float) -> None:
        """The reference weight."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_weight"](arg_newVal.COM_val))

    @property
    def ref_altitude(self) -> float:
        """The reference altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_altitude.setter
    def ref_altitude(self, newVal:float) -> None:
        """The reference altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_altitude"](arg_newVal.COM_val))

    @property
    def ref_airspeed(self) -> float:
        """The reference airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ref_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The reference airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_ref_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the reference airspeed and reference airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_ref_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def ref_load_factor(self) -> float:
        """The reference load factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_load_factor.setter
    def ref_load_factor(self, newVal:float) -> None:
        """The reference load factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_load_factor"](arg_newVal.COM_val))

    @property
    def estimated_ps(self) -> float:
        """The estimated specific excess power."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_estimated_ps"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_authority(self) -> float:
        """The control authority of how much to factor a turn over push/pull."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_authority"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_authority.setter
    def control_authority(self, newVal:float) -> None:
        """The control authority of how much to factor a turn over push/pull."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_authority"](arg_newVal.COM_val))

    @property
    def status_msg(self) -> str:
        """Get the status message in the message window."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_status_msg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{52d6c08d-32e5-49f1-bda0-96469ed01a6f}", IAeroPropManeuverModeHelper)
agcls.AgTypeNameMap["IAeroPropManeuverModeHelper"] = IAeroPropManeuverModeHelper

class ICatalogRunway(object):
    """Interface used to access a runway in the Aviator catalog."""
    _uuid = "{120d6778-93cd-4d78-a63f-c3fb3ca55eb6}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalogRunway._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalogRunway from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalogRunway = agcom.GUID(ICatalogRunway._uuid)
        vtable_offset_local = ICatalogRunway._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogRunway.__dict__ and type(ICatalogRunway.__dict__[attrname]) == property:
            return ICatalogRunway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogRunway.")
    

agcls.AgClassCatalog.add_catalog_entry("{120d6778-93cd-4d78-a63f-c3fb3ca55eb6}", ICatalogRunway)
agcls.AgTypeNameMap["ICatalogRunway"] = ICatalogRunway

class ICatalogAirport(object):
    """Interface used to access a airport in the Aviator catalog."""
    _uuid = "{aed7cf8c-257e-4c91-b829-0d3489bd7bef}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalogAirport._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalogAirport from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalogAirport = agcom.GUID(ICatalogAirport._uuid)
        vtable_offset_local = ICatalogAirport._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogAirport.__dict__ and type(ICatalogAirport.__dict__[attrname]) == property:
            return ICatalogAirport.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogAirport.")
    

agcls.AgClassCatalog.add_catalog_entry("{aed7cf8c-257e-4c91-b829-0d3489bd7bef}", ICatalogAirport)
agcls.AgTypeNameMap["ICatalogAirport"] = ICatalogAirport

class ICatalogNavaid(object):
    """Interface used to access a navaid in the Aviator catalog."""
    _uuid = "{a019db80-a2e3-49bd-9bb0-09d1af40ca00}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalogNavaid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalogNavaid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalogNavaid = agcom.GUID(ICatalogNavaid._uuid)
        vtable_offset_local = ICatalogNavaid._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogNavaid.__dict__ and type(ICatalogNavaid.__dict__[attrname]) == property:
            return ICatalogNavaid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogNavaid.")
    

agcls.AgClassCatalog.add_catalog_entry("{a019db80-a2e3-49bd-9bb0-09d1af40ca00}", ICatalogNavaid)
agcls.AgTypeNameMap["ICatalogNavaid"] = ICatalogNavaid

class ICatalogVTOLPoint(object):
    """Interface used to access a VTOL Point in the Aviator catalog."""
    _uuid = "{f4818560-bc87-4fa4-84bc-33d25a14eac5}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalogVTOLPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalogVTOLPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalogVTOLPoint = agcom.GUID(ICatalogVTOLPoint._uuid)
        vtable_offset_local = ICatalogVTOLPoint._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogVTOLPoint.__dict__ and type(ICatalogVTOLPoint.__dict__[attrname]) == property:
            return ICatalogVTOLPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogVTOLPoint.")
    

agcls.AgClassCatalog.add_catalog_entry("{f4818560-bc87-4fa4-84bc-33d25a14eac5}", ICatalogVTOLPoint)
agcls.AgTypeNameMap["ICatalogVTOLPoint"] = ICatalogVTOLPoint

class ICatalogWaypoint(object):
    """Interface used to access a waypoint in the Aviator catalog."""
    _uuid = "{a3a67fca-89f4-4cc8-9ef0-194707369ef9}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalogWaypoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalogWaypoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalogWaypoint = agcom.GUID(ICatalogWaypoint._uuid)
        vtable_offset_local = ICatalogWaypoint._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogWaypoint.__dict__ and type(ICatalogWaypoint.__dict__[attrname]) == property:
            return ICatalogWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogWaypoint.")
    

agcls.AgClassCatalog.add_catalog_entry("{a3a67fca-89f4-4cc8-9ef0-194707369ef9}", ICatalogWaypoint)
agcls.AgTypeNameMap["ICatalogWaypoint"] = ICatalogWaypoint

class IARINC424Airport(object):
    """This interface is deprecated. Use IARINC424Item instead."""
    _uuid = "{38a8e2de-6ca0-42b4-a5c9-9a2ae40ac0d7}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IARINC424Airport._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Airport from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IARINC424Airport = agcom.GUID(IARINC424Airport._uuid)
        vtable_offset_local = IARINC424Airport._vtable_offset - 1
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IARINC424Airport, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Airport.__dict__ and type(IARINC424Airport.__dict__[attrname]) == property:
            return IARINC424Airport.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Airport.")
    
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{38a8e2de-6ca0-42b4-a5c9-9a2ae40ac0d7}", IARINC424Airport)
agcls.AgTypeNameMap["IARINC424Airport"] = IARINC424Airport

class IDAFIFItem(object):
    """Interface used to access the options for an DAFIF Item found in the Aviator catalog."""
    _uuid = "{5725c989-94a3-47c9-8115-6d5b88b992aa}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_value"] = _raise_uninitialized_error
        self.__dict__["_get_all_fields"] = _raise_uninitialized_error
        self.__dict__["_get_all_fields_and_values"] = _raise_uninitialized_error
        self.__dict__["_copy_site"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDAFIFItem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDAFIFItem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDAFIFItem = agcom.GUID(IDAFIFItem._uuid)
        vtable_offset_local = IDAFIFItem._vtable_offset - 1
        self.__dict__["_get_value"] = IAGFUNCTYPE(pUnk, IID_IDAFIFItem, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.VARIANT))
        self.__dict__["_get_all_fields"] = IAGFUNCTYPE(pUnk, IID_IDAFIFItem, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_all_fields_and_values"] = IAGFUNCTYPE(pUnk, IID_IDAFIFItem, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_copy_site"] = IAGFUNCTYPE(pUnk, IID_IDAFIFItem, vtable_offset_local+4, )
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IDAFIFItem, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDAFIFItem.__dict__ and type(IDAFIFItem.__dict__[attrname]) == property:
            return IDAFIFItem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDAFIFItem.")
    
    def get_value(self, fieldName:str) -> typing.Any:
        """Get the value of the field with the given name."""
        with agmarshall.BSTR_arg(fieldName) as arg_fieldName, \
             agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_value"](arg_fieldName.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_all_fields(self) -> list:
        """Get all the field names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_all_fields"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_all_fields_and_values(self) -> list:
        """Get all the field names along with the corresponding value."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_all_fields_and_values"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_site"]())

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{5725c989-94a3-47c9-8115-6d5b88b992aa}", IDAFIFItem)
agcls.AgTypeNameMap["IDAFIFItem"] = IDAFIFItem

class IARINC424Runway(object):
    """This interface is deprecated. Use IARINC424Item instead."""
    _uuid = "{fafcfc3b-d259-498d-9000-8ec380048afa}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IARINC424Runway._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Runway from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IARINC424Runway = agcom.GUID(IARINC424Runway._uuid)
        vtable_offset_local = IARINC424Runway._vtable_offset - 1
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IARINC424Runway, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Runway.__dict__ and type(IARINC424Runway.__dict__[attrname]) == property:
            return IARINC424Runway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Runway.")
    
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{fafcfc3b-d259-498d-9000-8ec380048afa}", IARINC424Runway)
agcls.AgTypeNameMap["IARINC424Runway"] = IARINC424Runway

class IAirportCategory(object):
    """Interface used to access the airports in the Aviator catalog."""
    _uuid = "{b1430df6-bb64-4173-af26-0b8c42724d29}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_arinc424_airports"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAirportCategory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAirportCategory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAirportCategory = agcom.GUID(IAirportCategory._uuid)
        vtable_offset_local = IAirportCategory._vtable_offset - 1
        self.__dict__["_get_arinc424_airports"] = IAGFUNCTYPE(pUnk, IID_IAirportCategory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAirportCategory.__dict__ and type(IAirportCategory.__dict__[attrname]) == property:
            return IAirportCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAirportCategory.")
    
    @property
    def arinc424_airports(self) -> "IARINC424Source":
        """Get the ARINC-424 airports."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_airports"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b1430df6-bb64-4173-af26-0b8c42724d29}", IAirportCategory)
agcls.AgTypeNameMap["IAirportCategory"] = IAirportCategory

class INavaidCategory(object):
    """Interface used to access the navaids in the Aviator catalog."""
    _uuid = "{5b17c73b-f045-4228-bd66-9b0ed6eb40a1}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_arinc424_navaids"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(INavaidCategory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create INavaidCategory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_INavaidCategory = agcom.GUID(INavaidCategory._uuid)
        vtable_offset_local = INavaidCategory._vtable_offset - 1
        self.__dict__["_get_arinc424_navaids"] = IAGFUNCTYPE(pUnk, IID_INavaidCategory, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INavaidCategory.__dict__ and type(INavaidCategory.__dict__[attrname]) == property:
            return INavaidCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INavaidCategory.")
    
    @property
    def arinc424_navaids(self) -> "IARINC424Source":
        """Get the ARINC-424 navaids."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_navaids"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5b17c73b-f045-4228-bd66-9b0ed6eb40a1}", INavaidCategory)
agcls.AgTypeNameMap["INavaidCategory"] = INavaidCategory

class IVTOLPointCategory(object):
    """Interface used to access the VTOL Points in the Aviator catalog."""
    _uuid = "{1753d173-fd39-4755-932f-88a091f1ac63}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_user_vtol_points"] = _raise_uninitialized_error
        self.__dict__["_get_arinc424_helipads"] = _raise_uninitialized_error
        self.__dict__["_get_dafif_helipads"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVTOLPointCategory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVTOLPointCategory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVTOLPointCategory = agcom.GUID(IVTOLPointCategory._uuid)
        vtable_offset_local = IVTOLPointCategory._vtable_offset - 1
        self.__dict__["_get_user_vtol_points"] = IAGFUNCTYPE(pUnk, IID_IVTOLPointCategory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_arinc424_helipads"] = IAGFUNCTYPE(pUnk, IID_IVTOLPointCategory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_dafif_helipads"] = IAGFUNCTYPE(pUnk, IID_IVTOLPointCategory, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVTOLPointCategory.__dict__ and type(IVTOLPointCategory.__dict__[attrname]) == property:
            return IVTOLPointCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVTOLPointCategory.")
    
    @property
    def user_vtol_points(self) -> "IUserVTOLPointSource":
        """Get the User VTOL Points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_vtol_points"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def arinc424_helipads(self) -> "IARINC424Source":
        """Get the ARINC-424 helipads."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_helipads"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def dafif_helipads(self) -> "IDAFIFSource":
        """Get the DAFIF helipads."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dafif_helipads"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1753d173-fd39-4755-932f-88a091f1ac63}", IVTOLPointCategory)
agcls.AgTypeNameMap["IVTOLPointCategory"] = IVTOLPointCategory

class IWaypointCategory(object):
    """Interface used to access the waypoints in the Aviator catalog."""
    _uuid = "{3bdd04fa-d1ac-42ea-9978-f3a9c6718899}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_user_waypoints"] = _raise_uninitialized_error
        self.__dict__["_get_user_runways"] = _raise_uninitialized_error
        self.__dict__["_get_user_vtol_points"] = _raise_uninitialized_error
        self.__dict__["_get_arinc424_airports"] = _raise_uninitialized_error
        self.__dict__["_get_arinc424_helipads"] = _raise_uninitialized_error
        self.__dict__["_get_arinc424_navaids"] = _raise_uninitialized_error
        self.__dict__["_get_arinc424_runways"] = _raise_uninitialized_error
        self.__dict__["_get_arinc424_waypoints"] = _raise_uninitialized_error
        self.__dict__["_get_dafif_helipads"] = _raise_uninitialized_error
        self.__dict__["_get_dafif_runways"] = _raise_uninitialized_error
        self.__dict__["_get_dafif_waypoints"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IWaypointCategory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IWaypointCategory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IWaypointCategory = agcom.GUID(IWaypointCategory._uuid)
        vtable_offset_local = IWaypointCategory._vtable_offset - 1
        self.__dict__["_get_user_waypoints"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_user_runways"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_user_vtol_points"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_arinc424_airports"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_arinc424_helipads"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_arinc424_navaids"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_arinc424_runways"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_arinc424_waypoints"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_dafif_helipads"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_dafif_runways"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_dafif_waypoints"] = IAGFUNCTYPE(pUnk, IID_IWaypointCategory, vtable_offset_local+11, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWaypointCategory.__dict__ and type(IWaypointCategory.__dict__[attrname]) == property:
            return IWaypointCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWaypointCategory.")
    
    @property
    def user_waypoints(self) -> "IUserWaypointSource":
        """Get the User Waypoints."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_waypoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def user_runways(self) -> "IUserRunwaySource":
        """Get the User Runways."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_runways"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def user_vtol_points(self) -> "IUserVTOLPointSource":
        """Get the User VTOL Points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_vtol_points"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def arinc424_airports(self) -> "IARINC424Source":
        """Get the ARINC-424 airports."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_airports"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def arinc424_helipads(self) -> "IARINC424Source":
        """Get the ARINC-424 helipads."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_helipads"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def arinc424_navaids(self) -> "IARINC424Source":
        """Get the ARINC-424 navaids."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_navaids"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def arinc424_runways(self) -> "IARINC424Source":
        """Get the ARINC-424 runways."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_runways"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def arinc424_waypoints(self) -> "IARINC424Source":
        """Get the ARINC-424 waypoints."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_arinc424_waypoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def dafif_helipads(self) -> "IDAFIFSource":
        """Get the DAFIF helipads."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dafif_helipads"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def dafif_runways(self) -> "IDAFIFSource":
        """Get the DAFIF runways."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dafif_runways"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def dafif_waypoints(self) -> "IDAFIFSource":
        """Get the DAFIF waypoints."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dafif_waypoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3bdd04fa-d1ac-42ea-9978-f3a9c6718899}", IWaypointCategory)
agcls.AgTypeNameMap["IWaypointCategory"] = IWaypointCategory

class IAircraftClimb(object):
    """Interface used to access the climb options for an aircraft in the Aviator catalog."""
    _uuid = "{66bca11a-e1e6-490a-8127-3aeb9e2f1aab}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_built_in_model"] = _raise_uninitialized_error
        self.__dict__["_get_basic_climb_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_adv_climb_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftClimb._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftClimb from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftClimb = agcom.GUID(IAircraftClimb._uuid)
        vtable_offset_local = IAircraftClimb._vtable_offset - 1
        self.__dict__["_get_built_in_model"] = IAGFUNCTYPE(pUnk, IID_IAircraftClimb, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_basic_climb_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftClimb, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_adv_climb_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftClimb, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftClimb, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftClimb.__dict__ and type(IAircraftClimb.__dict__[attrname]) == property:
            return IAircraftClimb.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftClimb.")
    
    def get_built_in_model(self) -> "IAircraftBasicClimbModel":
        """Get the built-in model."""
        with agmarshall.AgInterface_out_arg() as arg_ppBasicClimb:
            agcls.evaluate_hresult(self.__dict__["_get_built_in_model"](byref(arg_ppBasicClimb.COM_val)))
            return arg_ppBasicClimb.python_val

    def get_basic_climb_by_name(self, name:str) -> "IAircraftBasicClimbModel":
        """Gets the basic climb model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppBasicClimb:
            agcls.evaluate_hresult(self.__dict__["_get_basic_climb_by_name"](arg_name.COM_val, byref(arg_ppBasicClimb.COM_val)))
            return arg_ppBasicClimb.python_val

    def get_adv_climb_by_name(self, name:str) -> "IAircraftAdvClimbModel":
        """Gets the advanced climb model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppAdvClimb:
            agcls.evaluate_hresult(self.__dict__["_get_adv_climb_by_name"](arg_name.COM_val, byref(arg_ppAdvClimb.COM_val)))
            return arg_ppAdvClimb.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{66bca11a-e1e6-490a-8127-3aeb9e2f1aab}", IAircraftClimb)
agcls.AgTypeNameMap["IAircraftClimb"] = IAircraftClimb

class IAircraftCruise(object):
    """Interface used to access the cruise options for an aircraft in the Aviator catalog."""
    _uuid = "{b67511c7-87c1-472c-89a5-59da8c09f07c}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_built_in_model"] = _raise_uninitialized_error
        self.__dict__["_get_basic_cruise_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_adv_cruise_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftCruise._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftCruise from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftCruise = agcom.GUID(IAircraftCruise._uuid)
        vtable_offset_local = IAircraftCruise._vtable_offset - 1
        self.__dict__["_get_built_in_model"] = IAGFUNCTYPE(pUnk, IID_IAircraftCruise, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_basic_cruise_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftCruise, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_adv_cruise_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftCruise, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftCruise, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftCruise.__dict__ and type(IAircraftCruise.__dict__[attrname]) == property:
            return IAircraftCruise.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftCruise.")
    
    def get_built_in_model(self) -> "IAircraftBasicCruiseModel":
        """Get the built-in model."""
        with agmarshall.AgInterface_out_arg() as arg_ppBasicCruise:
            agcls.evaluate_hresult(self.__dict__["_get_built_in_model"](byref(arg_ppBasicCruise.COM_val)))
            return arg_ppBasicCruise.python_val

    def get_basic_cruise_by_name(self, name:str) -> "IAircraftBasicCruiseModel":
        """Gets the basic cruise model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppBasicCruise:
            agcls.evaluate_hresult(self.__dict__["_get_basic_cruise_by_name"](arg_name.COM_val, byref(arg_ppBasicCruise.COM_val)))
            return arg_ppBasicCruise.python_val

    def get_adv_cruise_by_name(self, name:str) -> "IAircraftAdvCruiseModel":
        """Gets the advanced cruise model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppAdvCruise:
            agcls.evaluate_hresult(self.__dict__["_get_adv_cruise_by_name"](arg_name.COM_val, byref(arg_ppAdvCruise.COM_val)))
            return arg_ppAdvCruise.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{b67511c7-87c1-472c-89a5-59da8c09f07c}", IAircraftCruise)
agcls.AgTypeNameMap["IAircraftCruise"] = IAircraftCruise

class IAircraftDescent(object):
    """Interface used to access the descent options for an aircraft in the Aviator catalog."""
    _uuid = "{568db25b-e93e-4982-9131-82e1527ab875}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_built_in_model"] = _raise_uninitialized_error
        self.__dict__["_get_basic_descent_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_adv_descent_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftDescent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftDescent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftDescent = agcom.GUID(IAircraftDescent._uuid)
        vtable_offset_local = IAircraftDescent._vtable_offset - 1
        self.__dict__["_get_built_in_model"] = IAGFUNCTYPE(pUnk, IID_IAircraftDescent, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_basic_descent_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftDescent, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_adv_descent_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftDescent, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftDescent, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftDescent.__dict__ and type(IAircraftDescent.__dict__[attrname]) == property:
            return IAircraftDescent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftDescent.")
    
    def get_built_in_model(self) -> "IAircraftBasicDescentModel":
        """Get the built-in model."""
        with agmarshall.AgInterface_out_arg() as arg_ppBasicDescentModel:
            agcls.evaluate_hresult(self.__dict__["_get_built_in_model"](byref(arg_ppBasicDescentModel.COM_val)))
            return arg_ppBasicDescentModel.python_val

    def get_basic_descent_by_name(self, name:str) -> "IAircraftBasicDescentModel":
        """Gets the basic descent model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppBasicDescentModel:
            agcls.evaluate_hresult(self.__dict__["_get_basic_descent_by_name"](arg_name.COM_val, byref(arg_ppBasicDescentModel.COM_val)))
            return arg_ppBasicDescentModel.python_val

    def get_adv_descent_by_name(self, name:str) -> "IAircraftAdvDescentModel":
        """Gets the advanced descent model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppAdvDescent:
            agcls.evaluate_hresult(self.__dict__["_get_adv_descent_by_name"](arg_name.COM_val, byref(arg_ppAdvDescent.COM_val)))
            return arg_ppAdvDescent.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val


agcls.AgClassCatalog.add_catalog_entry("{568db25b-e93e-4982-9131-82e1527ab875}", IAircraftDescent)
agcls.AgTypeNameMap["IAircraftDescent"] = IAircraftDescent

class IAircraftLanding(object):
    """Interface used to access the landing options for an aircraft in the Aviator catalog."""
    _uuid = "{4a0055a5-4224-42c3-b113-704c110093e8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_built_in_model"] = _raise_uninitialized_error
        self.__dict__["_get_basic_landing_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_adv_landing_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftLanding._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftLanding from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftLanding = agcom.GUID(IAircraftLanding._uuid)
        vtable_offset_local = IAircraftLanding._vtable_offset - 1
        self.__dict__["_get_built_in_model"] = IAGFUNCTYPE(pUnk, IID_IAircraftLanding, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_basic_landing_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftLanding, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_adv_landing_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftLanding, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftLanding, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftLanding.__dict__ and type(IAircraftLanding.__dict__[attrname]) == property:
            return IAircraftLanding.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftLanding.")
    
    def get_built_in_model(self) -> "IAircraftBasicLandingModel":
        """Get the built-in model."""
        with agmarshall.AgInterface_out_arg() as arg_ppBasicLandingModel:
            agcls.evaluate_hresult(self.__dict__["_get_built_in_model"](byref(arg_ppBasicLandingModel.COM_val)))
            return arg_ppBasicLandingModel.python_val

    def get_basic_landing_by_name(self, name:str) -> "IAircraftBasicLandingModel":
        """Gets the basic Landing model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppBasicLandingModel:
            agcls.evaluate_hresult(self.__dict__["_get_basic_landing_by_name"](arg_name.COM_val, byref(arg_ppBasicLandingModel.COM_val)))
            return arg_ppBasicLandingModel.python_val

    def get_adv_landing_by_name(self, name:str) -> "IAircraftAdvLandingModel":
        """Gets the advanced Landing model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppAdvLanding:
            agcls.evaluate_hresult(self.__dict__["_get_adv_landing_by_name"](arg_name.COM_val, byref(arg_ppAdvLanding.COM_val)))
            return arg_ppAdvLanding.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{4a0055a5-4224-42c3-b113-704c110093e8}", IAircraftLanding)
agcls.AgTypeNameMap["IAircraftLanding"] = IAircraftLanding

class IAircraftTakeoff(object):
    """Interface used to access the takeoff options for an aircraft in the Aviator catalog."""
    _uuid = "{0a5a6393-8473-4f08-8501-9ca2a66494f4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_built_in_model"] = _raise_uninitialized_error
        self.__dict__["_get_basic_takeoff_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_adv_takeoff_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftTakeoff._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftTakeoff from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftTakeoff = agcom.GUID(IAircraftTakeoff._uuid)
        vtable_offset_local = IAircraftTakeoff._vtable_offset - 1
        self.__dict__["_get_built_in_model"] = IAGFUNCTYPE(pUnk, IID_IAircraftTakeoff, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_basic_takeoff_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftTakeoff, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_adv_takeoff_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftTakeoff, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftTakeoff, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftTakeoff.__dict__ and type(IAircraftTakeoff.__dict__[attrname]) == property:
            return IAircraftTakeoff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftTakeoff.")
    
    def get_built_in_model(self) -> "IAircraftBasicTakeoffModel":
        """Get the built-in model."""
        with agmarshall.AgInterface_out_arg() as arg_ppBasicTakeoffModel:
            agcls.evaluate_hresult(self.__dict__["_get_built_in_model"](byref(arg_ppBasicTakeoffModel.COM_val)))
            return arg_ppBasicTakeoffModel.python_val

    def get_basic_takeoff_by_name(self, name:str) -> "IAircraftBasicTakeoffModel":
        """Gets the basic Takeoff model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppBasicTakeoffModel:
            agcls.evaluate_hresult(self.__dict__["_get_basic_takeoff_by_name"](arg_name.COM_val, byref(arg_ppBasicTakeoffModel.COM_val)))
            return arg_ppBasicTakeoffModel.python_val

    def get_adv_takeoff_by_name(self, name:str) -> "IAircraftAdvTakeoffModel":
        """Gets the advanced Takeoff model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppAdvTakeoff:
            agcls.evaluate_hresult(self.__dict__["_get_adv_takeoff_by_name"](arg_name.COM_val, byref(arg_ppAdvTakeoff.COM_val)))
            return arg_ppAdvTakeoff.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{0a5a6393-8473-4f08-8501-9ca2a66494f4}", IAircraftTakeoff)
agcls.AgTypeNameMap["IAircraftTakeoff"] = IAircraftTakeoff

class IAircraftAcceleration(object):
    """Interface used to access the acceleration options for an aircraft in the Aviator catalog."""
    _uuid = "{f40c1168-8650-4aad-9790-192041602734}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_built_in_model"] = _raise_uninitialized_error
        self.__dict__["_get_basic_acceleration_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_adv_acceleration_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_as_catalog_item"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftAcceleration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAcceleration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftAcceleration = agcom.GUID(IAircraftAcceleration._uuid)
        vtable_offset_local = IAircraftAcceleration._vtable_offset - 1
        self.__dict__["_get_built_in_model"] = IAGFUNCTYPE(pUnk, IID_IAircraftAcceleration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_basic_acceleration_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftAcceleration, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_adv_acceleration_by_name"] = IAGFUNCTYPE(pUnk, IID_IAircraftAcceleration, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_as_catalog_item"] = IAGFUNCTYPE(pUnk, IID_IAircraftAcceleration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAcceleration.__dict__ and type(IAircraftAcceleration.__dict__[attrname]) == property:
            return IAircraftAcceleration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAcceleration.")
    
    def get_built_in_model(self) -> "IAircraftBasicAccelerationModel":
        """Get the built-in model."""
        with agmarshall.AgInterface_out_arg() as arg_ppBasicAcc:
            agcls.evaluate_hresult(self.__dict__["_get_built_in_model"](byref(arg_ppBasicAcc.COM_val)))
            return arg_ppBasicAcc.python_val

    def get_basic_acceleration_by_name(self, name:str) -> "IAircraftBasicAccelerationModel":
        """Get the basic acceleration model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppBasicAcc:
            agcls.evaluate_hresult(self.__dict__["_get_basic_acceleration_by_name"](arg_name.COM_val, byref(arg_ppBasicAcc.COM_val)))
            return arg_ppBasicAcc.python_val

    def get_adv_acceleration_by_name(self, name:str) -> "IAircraftAdvAccelerationModel":
        """Get the advanced acceleration model with the given name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppAdvAcc:
            agcls.evaluate_hresult(self.__dict__["_get_adv_acceleration_by_name"](arg_name.COM_val, byref(arg_ppAdvAcc.COM_val)))
            return arg_ppAdvAcc.python_val

    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogData:
            agcls.evaluate_hresult(self.__dict__["_get_as_catalog_item"](byref(arg_ppCatalogData.COM_val)))
            return arg_ppCatalogData.python_val


agcls.AgClassCatalog.add_catalog_entry("{f40c1168-8650-4aad-9790-192041602734}", IAircraftAcceleration)
agcls.AgTypeNameMap["IAircraftAcceleration"] = IAircraftAcceleration

class ICatalog(object):
    """Interface used to access the Aviator catalog."""
    _uuid = "{a9756132-0cd0-438d-bc8c-77fb748cebbd}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aircraft_category"] = _raise_uninitialized_error
        self.__dict__["_get_runway_category"] = _raise_uninitialized_error
        self.__dict__["_get_airport_category"] = _raise_uninitialized_error
        self.__dict__["_get_navaid_category"] = _raise_uninitialized_error
        self.__dict__["_get_vtol_point_category"] = _raise_uninitialized_error
        self.__dict__["_get_waypoint_category"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICatalog._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICatalog from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICatalog = agcom.GUID(ICatalog._uuid)
        vtable_offset_local = ICatalog._vtable_offset - 1
        self.__dict__["_get_aircraft_category"] = IAGFUNCTYPE(pUnk, IID_ICatalog, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_runway_category"] = IAGFUNCTYPE(pUnk, IID_ICatalog, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_airport_category"] = IAGFUNCTYPE(pUnk, IID_ICatalog, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_navaid_category"] = IAGFUNCTYPE(pUnk, IID_ICatalog, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_vtol_point_category"] = IAGFUNCTYPE(pUnk, IID_ICatalog, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_waypoint_category"] = IAGFUNCTYPE(pUnk, IID_ICatalog, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalog.__dict__ and type(ICatalog.__dict__[attrname]) == property:
            return ICatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalog.")
    
    @property
    def aircraft_category(self) -> "IAircraftCategory":
        """Get the aircraft category."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_get_aircraft_category"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    @property
    def runway_category(self) -> "IRunwayCategory":
        """Get the runway category."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_get_runway_category"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    @property
    def airport_category(self) -> "IAirportCategory":
        """Get the airport category."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_get_airport_category"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    @property
    def navaid_category(self) -> "INavaidCategory":
        """Get the navaid category."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_get_navaid_category"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    @property
    def vtol_point_category(self) -> "IVTOLPointCategory":
        """Get the vtol point category."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_get_vtol_point_category"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val

    @property
    def waypoint_category(self) -> "IWaypointCategory":
        """Get the waypoint category."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalogItem:
            agcls.evaluate_hresult(self.__dict__["_get_waypoint_category"](byref(arg_ppCatalogItem.COM_val)))
            return arg_ppCatalogItem.python_val


agcls.AgClassCatalog.add_catalog_entry("{a9756132-0cd0-438d-bc8c-77fb748cebbd}", ICatalog)
agcls.AgTypeNameMap["ICatalog"] = ICatalog

class IProcedureTimeOptions(object):
    """Interface used to access the time options for the current procedure. Use this interface to set an Interrupt Time or Fixed Duration for a procedure."""
    _uuid = "{19d372f4-0dce-4b60-8517-cbdfc1e5939c}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_start_time_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_use_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_use_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_interrupt_time_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_use_interrupt_time"] = _raise_uninitialized_error
        self.__dict__["_set_use_interrupt_time"] = _raise_uninitialized_error
        self.__dict__["_get_interrupt_time"] = _raise_uninitialized_error
        self.__dict__["_set_interrupt_time"] = _raise_uninitialized_error
        self.__dict__["_get_stop_time_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_time"] = _raise_uninitialized_error
        self.__dict__["_set_use_stop_time"] = _raise_uninitialized_error
        self.__dict__["_get_stop_time"] = _raise_uninitialized_error
        self.__dict__["_set_stop_time"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureTimeOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTimeOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureTimeOptions = agcom.GUID(IProcedureTimeOptions._uuid)
        vtable_offset_local = IProcedureTimeOptions._vtable_offset - 1
        self.__dict__["_get_start_time_enabled"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_use_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_interrupt_time_enabled"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_use_interrupt_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_interrupt_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_interrupt_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_interrupt_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_stop_time_enabled"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_use_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_get_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureTimeOptions, vtable_offset_local+15, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTimeOptions.__dict__ and type(IProcedureTimeOptions.__dict__[attrname]) == property:
            return IProcedureTimeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTimeOptions.")
    
    @property
    def start_time_enabled(self) -> bool:
        """Check to see if the start time is enabled for this procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time_enabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_start_time(self) -> bool:
        """Opt whether to set a start time for the procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_start_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_start_time.setter
    def use_start_time(self, newVal:bool) -> None:
        """Opt whether to set a start time for the procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_start_time"](arg_newVal.COM_val))

    @property
    def start_time(self) -> typing.Any:
        """Start time for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_start_time(self, time:typing.Any) -> None:
        """Set the start time for the procedure."""
        with agmarshall.VARIANT_arg(time) as arg_time:
            agcls.evaluate_hresult(self.__dict__["_set_start_time"](arg_time.COM_val))

    @property
    def interrupt_time_enabled(self) -> bool:
        """Check to see if the interrupt time is enabled for this procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interrupt_time_enabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_interrupt_time(self) -> bool:
        """Opt whether to set an interrupt time for the procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_interrupt_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_interrupt_time.setter
    def use_interrupt_time(self, newVal:bool) -> None:
        """Opt whether to set an interrupt time for the procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_interrupt_time"](arg_newVal.COM_val))

    @property
    def interrupt_time(self) -> typing.Any:
        """Interrupt time for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interrupt_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_interrupt_time(self, time:typing.Any) -> None:
        """Set the interrupt time for the procedure."""
        with agmarshall.VARIANT_arg(time) as arg_time:
            agcls.evaluate_hresult(self.__dict__["_set_interrupt_time"](arg_time.COM_val))

    @property
    def stop_time_enabled(self) -> bool:
        """Check to see if the stop time is enabled for this procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_time_enabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_stop_time(self) -> bool:
        """Opt whether to set a stop  time for the procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_stop_time.setter
    def use_stop_time(self, newVal:bool) -> None:
        """Opt whether to set a stop time for the procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_stop_time"](arg_newVal.COM_val))

    @property
    def stop_time(self) -> typing.Any:
        """Stop time for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_time(self, time:typing.Any) -> None:
        """Set the stop time for the procedure."""
        with agmarshall.VARIANT_arg(time) as arg_time:
            agcls.evaluate_hresult(self.__dict__["_set_stop_time"](arg_time.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{19d372f4-0dce-4b60-8517-cbdfc1e5939c}", IProcedureTimeOptions)
agcls.AgTypeNameMap["IProcedureTimeOptions"] = IProcedureTimeOptions

class ICalculationOptions(object):
    """Interface used to access the calculation options for a procedure or phase."""
    _uuid = "{B398DB5E-FA44-446B-B1AE-31761CB12D50}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_rel_motion_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_rel_motion_factor"] = _raise_uninitialized_error
        self.__dict__["_get_state_cache_time_interval"] = _raise_uninitialized_error
        self.__dict__["_set_state_cache_time_interval"] = _raise_uninitialized_error
        self.__dict__["_get_time_resolution"] = _raise_uninitialized_error
        self.__dict__["_set_time_resolution"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_max_bad_steps"] = _raise_uninitialized_error
        self.__dict__["_set_max_bad_steps"] = _raise_uninitialized_error
        self.__dict__["_get_integrator_type"] = _raise_uninitialized_error
        self.__dict__["_set_integrator_type"] = _raise_uninitialized_error
        self.__dict__["_get_integrator_type_string"] = _raise_uninitialized_error
        self.__dict__["_set_integrator_type_string"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationOptions = agcom.GUID(ICalculationOptions._uuid)
        vtable_offset_local = ICalculationOptions._vtable_offset - 1
        self.__dict__["_get_max_rel_motion_factor"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_rel_motion_factor"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_state_cache_time_interval"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_state_cache_time_interval"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_time_resolution"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_resolution"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_max_bad_steps"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_max_bad_steps"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_integrator_type"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_integrator_type"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_integrator_type_string"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_set_integrator_type_string"] = IAGFUNCTYPE(pUnk, IID_ICalculationOptions, vtable_offset_local+14, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationOptions.__dict__ and type(ICalculationOptions.__dict__[attrname]) == property:
            return ICalculationOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationOptions.")
    
    @property
    def max_rel_motion_factor(self) -> float:
        """The maximum motion allowed between sampling points."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_rel_motion_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_rel_motion_factor.setter
    def max_rel_motion_factor(self, newVal:float) -> None:
        """The maximum motion allowed between sampling points."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_rel_motion_factor"](arg_newVal.COM_val))

    @property
    def state_cache_time_interval(self) -> float:
        """The time interval used to store the state information."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_state_cache_time_interval"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @state_cache_time_interval.setter
    def state_cache_time_interval(self, newVal:float) -> None:
        """The time interval used to store the state information."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_state_cache_time_interval"](arg_newVal.COM_val))

    @property
    def time_resolution(self) -> float:
        """The tolerance for resolving time calculations."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_resolution"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_resolution.setter
    def time_resolution(self, newVal:float) -> None:
        """The tolerance for resolving time calculations."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_resolution"](arg_newVal.COM_val))

    @property
    def max_iterations(self) -> int:
        """The maximum number of iterations per time step Aviator will attempt."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, newVal:int) -> None:
        """The maximum number of iterations per time step Aviator will attempt."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_newVal.COM_val))

    @property
    def max_bad_steps(self) -> int:
        """The maximum number of bad steps Aviator will allow before ceasing calculation."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_bad_steps"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_bad_steps.setter
    def max_bad_steps(self, newVal:int) -> None:
        """The maximum number of bad steps Aviator will allow before ceasing calculation."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_bad_steps"](arg_newVal.COM_val))

    @property
    def integrator_type(self) -> "AVTR_NUMERICAL_INTEGRATOR":
        """The integrator type."""
        with agmarshall.AgEnum_arg(AVTR_NUMERICAL_INTEGRATOR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_integrator_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @integrator_type.setter
    def integrator_type(self, pVal:"AVTR_NUMERICAL_INTEGRATOR") -> None:
        """The integrator type."""
        with agmarshall.AgEnum_arg(AVTR_NUMERICAL_INTEGRATOR, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_integrator_type"](arg_pVal.COM_val))

    @property
    def integrator_type_string(self) -> str:
        """The integrator type as a string value. Use this for custom integrators."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_integrator_type_string"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @integrator_type_string.setter
    def integrator_type_string(self, pVal:str) -> None:
        """The integrator type as a string value. Use this for custom integrators."""
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_integrator_type_string"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B398DB5E-FA44-446B-B1AE-31761CB12D50}", ICalculationOptions)
agcls.AgTypeNameMap["ICalculationOptions"] = ICalculationOptions

class INavigationOptions(object):
    """Interface used to access the navigation options for an Aviator procedure."""
    _uuid = "{d0b367a7-0df0-454b-b059-e27f55a04730}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_nav_mode"] = _raise_uninitialized_error
        self.__dict__["_set_nav_mode"] = _raise_uninitialized_error
        self.__dict__["_get_arrive_on_course"] = _raise_uninitialized_error
        self.__dict__["_set_arrive_on_course"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_first_turn"] = _raise_uninitialized_error
        self.__dict__["_set_enroute_first_turn"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_second_turn"] = _raise_uninitialized_error
        self.__dict__["_set_enroute_second_turn"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(INavigationOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create INavigationOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_INavigationOptions = agcom.GUID(INavigationOptions._uuid)
        vtable_offset_local = INavigationOptions._vtable_offset - 1
        self.__dict__["_get_nav_mode"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_nav_mode"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_arrive_on_course"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_arrive_on_course"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_enroute_first_turn"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_enroute_first_turn"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_enroute_second_turn"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_enroute_second_turn"] = IAGFUNCTYPE(pUnk, IID_INavigationOptions, vtable_offset_local+10, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INavigationOptions.__dict__ and type(INavigationOptions.__dict__[attrname]) == property:
            return INavigationOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INavigationOptions.")
    
    @property
    def nav_mode(self) -> "AVTR_POINT_TO_POINT_MODE":
        """The navigation mode."""
        with agmarshall.AgEnum_arg(AVTR_POINT_TO_POINT_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nav_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nav_mode.setter
    def nav_mode(self, newVal:"AVTR_POINT_TO_POINT_MODE") -> None:
        """The navigation mode."""
        with agmarshall.AgEnum_arg(AVTR_POINT_TO_POINT_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_nav_mode"](arg_newVal.COM_val))

    @property
    def arrive_on_course(self) -> typing.Any:
        """The aircraft will start or arrive at the procedure site with the specified course. The nav mode must be set to Arrive on Course to set this value."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_arrive_on_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @arrive_on_course.setter
    def arrive_on_course(self, newVal:typing.Any) -> None:
        """The aircraft will start or arrive at the procedure site with the specified course. The nav mode must be set to Arrive on Course to set this value."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_arrive_on_course"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """Opt whether to use a magnetic heading to arrive on course. The nav mode must be set to Arrive on Course to set this value."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """Opt whether to use a magnetic heading to arrive on course. The nav mode must be set to Arrive on Course to set this value."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_heading"](arg_newVal.COM_val))

    @property
    def enroute_first_turn(self) -> "AVTR_NAVIGATOR_TURN_DIR":
        """Option for the first turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_first_turn"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enroute_first_turn.setter
    def enroute_first_turn(self, newVal:"AVTR_NAVIGATOR_TURN_DIR") -> None:
        """Option for the first turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enroute_first_turn"](arg_newVal.COM_val))

    @property
    def enroute_second_turn(self) -> "AVTR_NAVIGATOR_TURN_DIR":
        """Option for the second turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_second_turn"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enroute_second_turn.setter
    def enroute_second_turn(self, newVal:"AVTR_NAVIGATOR_TURN_DIR") -> None:
        """Option for the second turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enroute_second_turn"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{d0b367a7-0df0-454b-b059-e27f55a04730}", INavigationOptions)
agcls.AgTypeNameMap["INavigationOptions"] = INavigationOptions

class IAltitudeMSLAndLevelOffOptions(object):
    """Interface used to access the altitude MSL and Level off options for an Aviator procedure."""
    _uuid = "{c7939666-f5a2-44fa-9a4b-9e2d84e93aa5}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_msl_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_msl_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_set_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAltitudeMSLAndLevelOffOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeMSLAndLevelOffOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAltitudeMSLAndLevelOffOptions = agcom.GUID(IAltitudeMSLAndLevelOffOptions._uuid)
        vtable_offset_local = IAltitudeMSLAndLevelOffOptions._vtable_offset - 1
        self.__dict__["_get_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_msl_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_msl_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLAndLevelOffOptions, vtable_offset_local+8, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeMSLAndLevelOffOptions.__dict__ and type(IAltitudeMSLAndLevelOffOptions.__dict__[attrname]) == property:
            return IAltitudeMSLAndLevelOffOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeMSLAndLevelOffOptions.")
    
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def msl_altitude(self) -> float:
        """The MSL altitude. Can only be used when the option to use the default cruise altitude is off."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_msl_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @msl_altitude.setter
    def msl_altitude(self, newVal:float) -> None:
        """Set the MSLAltitude"""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_msl_altitude"](arg_newVal.COM_val))

    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_must_level_off"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_must_level_off"](arg_newVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, newVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{c7939666-f5a2-44fa-9a4b-9e2d84e93aa5}", IAltitudeMSLAndLevelOffOptions)
agcls.AgTypeNameMap["IAltitudeMSLAndLevelOffOptions"] = IAltitudeMSLAndLevelOffOptions

class IAltitudeMSLOptions(object):
    """Interface used to access the altitude MSL options for an Aviator procedure."""
    _uuid = "{bde058f8-a355-4a4f-9884-7e2961b212e7}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_msl_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_msl_altitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAltitudeMSLOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeMSLOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAltitudeMSLOptions = agcom.GUID(IAltitudeMSLOptions._uuid)
        vtable_offset_local = IAltitudeMSLOptions._vtable_offset - 1
        self.__dict__["_get_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_msl_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_msl_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeMSLOptions, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeMSLOptions.__dict__ and type(IAltitudeMSLOptions.__dict__[attrname]) == property:
            return IAltitudeMSLOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeMSLOptions.")
    
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def msl_altitude(self) -> float:
        """The MSL altitude. Can only be used when the option to use the default cruise altitude is off."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_msl_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @msl_altitude.setter
    def msl_altitude(self, newVal:float) -> None:
        """Set the MSLAltitude"""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_msl_altitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{bde058f8-a355-4a4f-9884-7e2961b212e7}", IAltitudeMSLOptions)
agcls.AgTypeNameMap["IAltitudeMSLOptions"] = IAltitudeMSLOptions

class IAltitudeOptions(object):
    """Interface used to access the altitude options for an Aviator procedure."""
    _uuid = "{be4fccc8-7fe4-443b-9dc9-c337369c4560}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAltitudeOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAltitudeOptions = agcom.GUID(IAltitudeOptions._uuid)
        vtable_offset_local = IAltitudeOptions._vtable_offset - 1
        self.__dict__["_get_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_IAltitudeOptions, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_IAltitudeOptions, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeOptions, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IAltitudeOptions, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeOptions.__dict__ and type(IAltitudeOptions.__dict__[attrname]) == property:
            return IAltitudeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeOptions.")
    
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def altitude_reference(self) -> "AVTR_AGLMSL":
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_reference"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_reference.setter
    def altitude_reference(self, newVal:"AVTR_AGLMSL") -> None:
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_reference"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The altitude for the procedure."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the procedure."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{be4fccc8-7fe4-443b-9dc9-c337369c4560}", IAltitudeOptions)
agcls.AgTypeNameMap["IAltitudeOptions"] = IAltitudeOptions

class IHoverAltitudeOptions(object):
    """Interface used to access the altitude options for VTOL procedure."""
    _uuid = "{61d092fc-5b7c-4056-9f82-ac024ea4d4bd}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_final_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_final_altitude_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IHoverAltitudeOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IHoverAltitudeOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IHoverAltitudeOptions = agcom.GUID(IHoverAltitudeOptions._uuid)
        vtable_offset_local = IHoverAltitudeOptions._vtable_offset - 1
        self.__dict__["_get_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_IHoverAltitudeOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_IHoverAltitudeOptions, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IHoverAltitudeOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IHoverAltitudeOptions, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_final_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IHoverAltitudeOptions, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_final_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IHoverAltitudeOptions, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IHoverAltitudeOptions.__dict__ and type(IHoverAltitudeOptions.__dict__[attrname]) == property:
            return IHoverAltitudeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IHoverAltitudeOptions.")
    
    @property
    def altitude_reference(self) -> "AVTR_AGLMSL":
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_reference"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_reference.setter
    def altitude_reference(self, newVal:"AVTR_AGLMSL") -> None:
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_reference"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The altitude for the procedure."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the procedure."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def final_altitude_rate(self) -> "AVTR_VTOL_RATE_MODE":
        """The altitude rate of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_altitude_rate.setter
    def final_altitude_rate(self, newVal:"AVTR_VTOL_RATE_MODE") -> None:
        """The altitude rate of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_altitude_rate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{61d092fc-5b7c-4056-9f82-ac024ea4d4bd}", IHoverAltitudeOptions)
agcls.AgTypeNameMap["IHoverAltitudeOptions"] = IHoverAltitudeOptions

class IArcAltitudeOptions(object):
    """Interface used to access the altitude options for an Arc procedure."""
    _uuid = "{5aa7a535-fbc0-49b5-99e7-c93309863a6d}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_start_arc_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_start_arc_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_stop_arc_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_stop_arc_altitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IArcAltitudeOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IArcAltitudeOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IArcAltitudeOptions = agcom.GUID(IArcAltitudeOptions._uuid)
        vtable_offset_local = IArcAltitudeOptions._vtable_offset - 1
        self.__dict__["_get_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_start_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_start_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeOptions, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_stop_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeOptions, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeOptions, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcAltitudeOptions.__dict__ and type(IArcAltitudeOptions.__dict__[attrname]) == property:
            return IArcAltitudeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcAltitudeOptions.")
    
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def start_arc_altitude(self) -> float:
        """The altitude at the beginning of the arc."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_arc_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_arc_altitude.setter
    def start_arc_altitude(self, newVal:float) -> None:
        """The altitude at the beginning of the arc."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_arc_altitude"](arg_newVal.COM_val))

    @property
    def stop_arc_altitude(self) -> float:
        """The altitude at the end of the arc."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_arc_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_arc_altitude.setter
    def stop_arc_altitude(self, newVal:float) -> None:
        """The altitude at the end of the arc."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_arc_altitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5aa7a535-fbc0-49b5-99e7-c93309863a6d}", IArcAltitudeOptions)
agcls.AgTypeNameMap["IArcAltitudeOptions"] = IArcAltitudeOptions

class IArcAltitudeAndDelayOptions(object):
    """Interface used to access the altitude options for an Arc procedure."""
    _uuid = "{826dc7a9-7fad-46a9-8587-7b879ea6d53e}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_delay_arc_climb_descents"] = _raise_uninitialized_error
        self.__dict__["_set_delay_arc_climb_descents"] = _raise_uninitialized_error
        self.__dict__["_get_start_arc_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_start_arc_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_stop_arc_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_stop_arc_altitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IArcAltitudeAndDelayOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IArcAltitudeAndDelayOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IArcAltitudeAndDelayOptions = agcom.GUID(IArcAltitudeAndDelayOptions._uuid)
        vtable_offset_local = IArcAltitudeAndDelayOptions._vtable_offset - 1
        self.__dict__["_get_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_delay_arc_climb_descents"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_delay_arc_climb_descents"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_start_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_start_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_stop_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_arc_altitude"] = IAGFUNCTYPE(pUnk, IID_IArcAltitudeAndDelayOptions, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcAltitudeAndDelayOptions.__dict__ and type(IArcAltitudeAndDelayOptions.__dict__[attrname]) == property:
            return IArcAltitudeAndDelayOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcAltitudeAndDelayOptions.")
    
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def delay_arc_climb_descents(self) -> bool:
        """Delay the climb/descend such that the stop arc altitude will be achieved by the end of the procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delay_arc_climb_descents"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delay_arc_climb_descents.setter
    def delay_arc_climb_descents(self, newVal:bool) -> None:
        """Delay the climb/descend such that the stop arc altitude will be achieved by the end of the procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delay_arc_climb_descents"](arg_newVal.COM_val))

    @property
    def start_arc_altitude(self) -> float:
        """The altitude at the beginning of the arc."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_arc_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_arc_altitude.setter
    def start_arc_altitude(self, newVal:float) -> None:
        """The altitude at the beginning of the arc."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_arc_altitude"](arg_newVal.COM_val))

    @property
    def stop_arc_altitude(self) -> float:
        """The altitude at the end of the arc."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_arc_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_arc_altitude.setter
    def stop_arc_altitude(self, newVal:float) -> None:
        """The altitude at the end of the arc."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_arc_altitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{826dc7a9-7fad-46a9-8587-7b879ea6d53e}", IArcAltitudeAndDelayOptions)
agcls.AgTypeNameMap["IArcAltitudeAndDelayOptions"] = IArcAltitudeAndDelayOptions

class IArcOptions(object):
    """Interface used to access the arc options for a procedure."""
    _uuid = "{436c4ca7-5994-43bf-a975-a9c29c328ec0}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_start_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_start_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_radius"] = _raise_uninitialized_error
        self.__dict__["_set_radius"] = _raise_uninitialized_error
        self.__dict__["_get_turn_angle"] = _raise_uninitialized_error
        self.__dict__["_set_turn_angle"] = _raise_uninitialized_error
        self.__dict__["_get_join_arc"] = _raise_uninitialized_error
        self.__dict__["_set_join_arc"] = _raise_uninitialized_error
        self.__dict__["_get_exit_arc"] = _raise_uninitialized_error
        self.__dict__["_set_exit_arc"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IArcOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IArcOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IArcOptions = agcom.GUID(IArcOptions._uuid)
        vtable_offset_local = IArcOptions._vtable_offset - 1
        self.__dict__["_get_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_start_bearing"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_start_bearing"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_radius"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_turn_angle"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_turn_angle"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_join_arc"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_join_arc"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_exit_arc"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_exit_arc"] = IAGFUNCTYPE(pUnk, IID_IArcOptions, vtable_offset_local+14, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcOptions.__dict__ and type(IArcOptions.__dict__[attrname]) == property:
            return IArcOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcOptions.")
    
    @property
    def turn_direction(self) -> "AVTR_TURN_DIRECTION":
        """The turn direction to the arc."""
        with agmarshall.AgEnum_arg(AVTR_TURN_DIRECTION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_direction.setter
    def turn_direction(self, newVal:"AVTR_TURN_DIRECTION") -> None:
        """The turn direction to the arc."""
        with agmarshall.AgEnum_arg(AVTR_TURN_DIRECTION, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_direction"](arg_newVal.COM_val))

    @property
    def start_bearing(self) -> typing.Any:
        """The bearing from the site to the arc."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_bearing.setter
    def start_bearing(self, newVal:typing.Any) -> None:
        """The bearing from the site to the arc."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_bearing"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the start bearing."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading for the start bearing."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_heading"](arg_newVal.COM_val))

    @property
    def radius(self) -> float:
        """The radius of the arc."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius.setter
    def radius(self, newVal:float) -> None:
        """The radius of the arc."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius"](arg_newVal.COM_val))

    @property
    def turn_angle(self) -> typing.Any:
        """The length of the arc the aircraft will fly."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_angle.setter
    def turn_angle(self, newVal:typing.Any) -> None:
        """The length of the arc the aircraft will fly."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_angle"](arg_newVal.COM_val))

    @property
    def join_arc(self) -> "AVTR_JOIN_EXIT_ARC_METHOD":
        """The method to join the arc."""
        with agmarshall.AgEnum_arg(AVTR_JOIN_EXIT_ARC_METHOD) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_join_arc"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @join_arc.setter
    def join_arc(self, newVal:"AVTR_JOIN_EXIT_ARC_METHOD") -> None:
        """The method to join the arc."""
        with agmarshall.AgEnum_arg(AVTR_JOIN_EXIT_ARC_METHOD, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_join_arc"](arg_newVal.COM_val))

    @property
    def exit_arc(self) -> "AVTR_JOIN_EXIT_ARC_METHOD":
        """The method to exit the arc."""
        with agmarshall.AgEnum_arg(AVTR_JOIN_EXIT_ARC_METHOD) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_exit_arc"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @exit_arc.setter
    def exit_arc(self, newVal:"AVTR_JOIN_EXIT_ARC_METHOD") -> None:
        """The method to exit the arc."""
        with agmarshall.AgEnum_arg(AVTR_JOIN_EXIT_ARC_METHOD, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_exit_arc"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{436c4ca7-5994-43bf-a975-a9c29c328ec0}", IArcOptions)
agcls.AgTypeNameMap["IArcOptions"] = IArcOptions

class IVerticalPlaneOptions(object):
    """Interface used to access the Vertical Plane options for an Aviator procedure."""
    _uuid = "{2f4e9933-f0e0-4c9c-96ad-7b210faf7a05}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_min_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_min_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_max_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_max_vert_plane_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_vert_plane_radius_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVerticalPlaneOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVerticalPlaneOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVerticalPlaneOptions = agcom.GUID(IVerticalPlaneOptions._uuid)
        vtable_offset_local = IVerticalPlaneOptions._vtable_offset - 1
        self.__dict__["_get_min_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneOptions, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_min_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneOptions, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_max_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneOptions, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneOptions, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_max_vert_plane_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneOptions, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_vert_plane_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneOptions, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVerticalPlaneOptions.__dict__ and type(IVerticalPlaneOptions.__dict__[attrname]) == property:
            return IVerticalPlaneOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVerticalPlaneOptions.")
    
    @property
    def min_enroute_flight_path_angle(self) -> typing.Any:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_enroute_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_enroute_flight_path_angle.setter
    def min_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_enroute_flight_path_angle"](arg_newVal.COM_val))

    @property
    def max_enroute_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_enroute_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_enroute_flight_path_angle.setter
    def max_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_enroute_flight_path_angle"](arg_newVal.COM_val))

    @property
    def max_vert_plane_radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_vert_plane_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_vert_plane_radius_factor.setter
    def max_vert_plane_radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_vert_plane_radius_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2f4e9933-f0e0-4c9c-96ad-7b210faf7a05}", IVerticalPlaneOptions)
agcls.AgTypeNameMap["IVerticalPlaneOptions"] = IVerticalPlaneOptions

class IVerticalPlaneAndFlightPathOptions(object):
    """Interface used to access the Vertical Plane and Final Flight Path Angle options for an Aviator procedure."""
    _uuid = "{4a177d89-4a7d-4388-a5db-05a9b35ebece}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_final_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_final_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_min_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_min_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_max_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_max_vert_plane_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_vert_plane_radius_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVerticalPlaneAndFlightPathOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVerticalPlaneAndFlightPathOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVerticalPlaneAndFlightPathOptions = agcom.GUID(IVerticalPlaneAndFlightPathOptions._uuid)
        vtable_offset_local = IVerticalPlaneAndFlightPathOptions._vtable_offset - 1
        self.__dict__["_get_final_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_final_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_min_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_min_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_max_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_max_vert_plane_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_vert_plane_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IVerticalPlaneAndFlightPathOptions, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVerticalPlaneAndFlightPathOptions.__dict__ and type(IVerticalPlaneAndFlightPathOptions.__dict__[attrname]) == property:
            return IVerticalPlaneAndFlightPathOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVerticalPlaneAndFlightPathOptions.")
    
    @property
    def final_flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the end of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_flight_path_angle.setter
    def final_flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the end of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_flight_path_angle"](arg_newVal.COM_val))

    @property
    def min_enroute_flight_path_angle(self) -> typing.Any:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_enroute_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_enroute_flight_path_angle.setter
    def min_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_enroute_flight_path_angle"](arg_newVal.COM_val))

    @property
    def max_enroute_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_enroute_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_enroute_flight_path_angle.setter
    def max_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_enroute_flight_path_angle"](arg_newVal.COM_val))

    @property
    def max_vert_plane_radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_vert_plane_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_vert_plane_radius_factor.setter
    def max_vert_plane_radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_vert_plane_radius_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4a177d89-4a7d-4388-a5db-05a9b35ebece}", IVerticalPlaneAndFlightPathOptions)
agcls.AgTypeNameMap["IVerticalPlaneAndFlightPathOptions"] = IVerticalPlaneAndFlightPathOptions

class IArcVerticalPlaneOptions(object):
    """Interface used to access the Vertical Plane options for an arc procedure."""
    _uuid = "{402feacd-0f43-4af6-8c56-9aa61240e2b0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_start_arc_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_start_arc_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_stop_arc_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_stop_arc_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_min_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_min_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_max_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_enroute_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_max_vert_plane_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_vert_plane_radius_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IArcVerticalPlaneOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IArcVerticalPlaneOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IArcVerticalPlaneOptions = agcom.GUID(IArcVerticalPlaneOptions._uuid)
        vtable_offset_local = IArcVerticalPlaneOptions._vtable_offset - 1
        self.__dict__["_get_start_arc_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_start_arc_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_stop_arc_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_stop_arc_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_min_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_min_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_max_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_enroute_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_max_vert_plane_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_vert_plane_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IArcVerticalPlaneOptions, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcVerticalPlaneOptions.__dict__ and type(IArcVerticalPlaneOptions.__dict__[attrname]) == property:
            return IArcVerticalPlaneOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcVerticalPlaneOptions.")
    
    @property
    def start_arc_flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the start of the arc."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_arc_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_arc_flight_path_angle.setter
    def start_arc_flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the start of the arc."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_arc_flight_path_angle"](arg_newVal.COM_val))

    @property
    def stop_arc_flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the end of the arc."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_arc_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_arc_flight_path_angle.setter
    def stop_arc_flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the end of the arc."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_arc_flight_path_angle"](arg_newVal.COM_val))

    @property
    def min_enroute_flight_path_angle(self) -> typing.Any:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_enroute_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_enroute_flight_path_angle.setter
    def min_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_enroute_flight_path_angle"](arg_newVal.COM_val))

    @property
    def max_enroute_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_enroute_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_enroute_flight_path_angle.setter
    def max_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_enroute_flight_path_angle"](arg_newVal.COM_val))

    @property
    def max_vert_plane_radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_vert_plane_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_vert_plane_radius_factor.setter
    def max_vert_plane_radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_vert_plane_radius_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{402feacd-0f43-4af6-8c56-9aa61240e2b0}", IArcVerticalPlaneOptions)
agcls.AgTypeNameMap["IArcVerticalPlaneOptions"] = IArcVerticalPlaneOptions

class IEnrouteOptions(object):
    """Interface used to access the Enroute options for an Aviator procedure."""
    _uuid = "{cd8774fa-5dd0-4ac6-8292-0914fa1cff61}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_max_speed_turns"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_speed_turns"] = _raise_uninitialized_error
        self.__dict__["_get_max_turn_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_turn_radius_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEnrouteOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEnrouteOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEnrouteOptions = agcom.GUID(IEnrouteOptions._uuid)
        vtable_offset_local = IEnrouteOptions._vtable_offset - 1
        self.__dict__["_get_use_max_speed_turns"] = IAGFUNCTYPE(pUnk, IID_IEnrouteOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_speed_turns"] = IAGFUNCTYPE(pUnk, IID_IEnrouteOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IEnrouteOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IEnrouteOptions, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEnrouteOptions.__dict__ and type(IEnrouteOptions.__dict__[attrname]) == property:
            return IEnrouteOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEnrouteOptions.")
    
    @property
    def use_max_speed_turns(self) -> bool:
        """Opt whether to use the max speed turns."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_speed_turns"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_speed_turns.setter
    def use_max_speed_turns(self, newVal:bool) -> None:
        """Opt whether to use the max speed turns."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_speed_turns"](arg_newVal.COM_val))

    @property
    def max_turn_radius_factor(self) -> float:
        """The maximum turn radius factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_turn_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_turn_radius_factor.setter
    def max_turn_radius_factor(self, newVal:float) -> None:
        """The maximum turn radius factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_turn_radius_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{cd8774fa-5dd0-4ac6-8292-0914fa1cff61}", IEnrouteOptions)
agcls.AgTypeNameMap["IEnrouteOptions"] = IEnrouteOptions

class IEnrouteAndDelayOptions(object):
    """Interface used to access the Enroute options for an Aviator procedure."""
    _uuid = "{cabcbefb-211d-4657-a9eb-fec703b42b11}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_delay_enroute_climb_descents"] = _raise_uninitialized_error
        self.__dict__["_set_delay_enroute_climb_descents"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_speed_turns"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_speed_turns"] = _raise_uninitialized_error
        self.__dict__["_get_max_turn_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_max_turn_radius_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEnrouteAndDelayOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEnrouteAndDelayOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEnrouteAndDelayOptions = agcom.GUID(IEnrouteAndDelayOptions._uuid)
        vtable_offset_local = IEnrouteAndDelayOptions._vtable_offset - 1
        self.__dict__["_get_delay_enroute_climb_descents"] = IAGFUNCTYPE(pUnk, IID_IEnrouteAndDelayOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_delay_enroute_climb_descents"] = IAGFUNCTYPE(pUnk, IID_IEnrouteAndDelayOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_max_speed_turns"] = IAGFUNCTYPE(pUnk, IID_IEnrouteAndDelayOptions, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_speed_turns"] = IAGFUNCTYPE(pUnk, IID_IEnrouteAndDelayOptions, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IEnrouteAndDelayOptions, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IEnrouteAndDelayOptions, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEnrouteAndDelayOptions.__dict__ and type(IEnrouteAndDelayOptions.__dict__[attrname]) == property:
            return IEnrouteAndDelayOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEnrouteAndDelayOptions.")
    
    @property
    def delay_enroute_climb_descents(self) -> bool:
        """Opt whether to delay the enroute climb or descent."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delay_enroute_climb_descents"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delay_enroute_climb_descents.setter
    def delay_enroute_climb_descents(self, newVal:bool) -> None:
        """Opt whether to delay the enroute climb or descent."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delay_enroute_climb_descents"](arg_newVal.COM_val))

    @property
    def use_max_speed_turns(self) -> bool:
        """Opt whether to use the max speed turns."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_speed_turns"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_speed_turns.setter
    def use_max_speed_turns(self, newVal:bool) -> None:
        """Opt whether to use the max speed turns."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_speed_turns"](arg_newVal.COM_val))

    @property
    def max_turn_radius_factor(self) -> float:
        """The maximum turn radius factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_turn_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_turn_radius_factor.setter
    def max_turn_radius_factor(self, newVal:float) -> None:
        """The maximum turn radius factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_turn_radius_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{cabcbefb-211d-4657-a9eb-fec703b42b11}", IEnrouteAndDelayOptions)
agcls.AgTypeNameMap["IEnrouteAndDelayOptions"] = IEnrouteAndDelayOptions

class IEnrouteTurnDirectionOptions(object):
    """Interface used to access the Enroute Turn Direction options for an Aviator procedure."""
    _uuid = "{cfb34c54-d768-42f8-a7bc-1a079bdea24e}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enroute_first_turn"] = _raise_uninitialized_error
        self.__dict__["_set_enroute_first_turn"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_second_turn"] = _raise_uninitialized_error
        self.__dict__["_set_enroute_second_turn"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEnrouteTurnDirectionOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEnrouteTurnDirectionOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEnrouteTurnDirectionOptions = agcom.GUID(IEnrouteTurnDirectionOptions._uuid)
        vtable_offset_local = IEnrouteTurnDirectionOptions._vtable_offset - 1
        self.__dict__["_get_enroute_first_turn"] = IAGFUNCTYPE(pUnk, IID_IEnrouteTurnDirectionOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_enroute_first_turn"] = IAGFUNCTYPE(pUnk, IID_IEnrouteTurnDirectionOptions, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_enroute_second_turn"] = IAGFUNCTYPE(pUnk, IID_IEnrouteTurnDirectionOptions, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_enroute_second_turn"] = IAGFUNCTYPE(pUnk, IID_IEnrouteTurnDirectionOptions, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEnrouteTurnDirectionOptions.__dict__ and type(IEnrouteTurnDirectionOptions.__dict__[attrname]) == property:
            return IEnrouteTurnDirectionOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEnrouteTurnDirectionOptions.")
    
    @property
    def enroute_first_turn(self) -> "AVTR_NAVIGATOR_TURN_DIR":
        """Option for the first turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_first_turn"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enroute_first_turn.setter
    def enroute_first_turn(self, newVal:"AVTR_NAVIGATOR_TURN_DIR") -> None:
        """Option for the first turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enroute_first_turn"](arg_newVal.COM_val))

    @property
    def enroute_second_turn(self) -> "AVTR_NAVIGATOR_TURN_DIR":
        """Option for the second turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_second_turn"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enroute_second_turn.setter
    def enroute_second_turn(self, newVal:"AVTR_NAVIGATOR_TURN_DIR") -> None:
        """Option for the second turn."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enroute_second_turn"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{cfb34c54-d768-42f8-a7bc-1a079bdea24e}", IEnrouteTurnDirectionOptions)
agcls.AgTypeNameMap["IEnrouteTurnDirectionOptions"] = IEnrouteTurnDirectionOptions

class ICruiseAirspeedOptions(object):
    """Interface used to access the Cruise Airspeed options for an Aviator procedure."""
    _uuid = "{8c88b752-5739-4244-9db7-9fd404b3c0c6}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_cruise_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_cruise_speed_type"] = _raise_uninitialized_error
        self.__dict__["_get_other_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_other_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_other_airspeed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICruiseAirspeedOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICruiseAirspeedOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICruiseAirspeedOptions = agcom.GUID(ICruiseAirspeedOptions._uuid)
        vtable_offset_local = ICruiseAirspeedOptions._vtable_offset - 1
        self.__dict__["_get_cruise_speed_type"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_cruise_speed_type"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedOptions, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_other_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedOptions, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_other_airspeed"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedOptions, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_other_airspeed"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedOptions, vtable_offset_local+5, agcom.LONG, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICruiseAirspeedOptions.__dict__ and type(ICruiseAirspeedOptions.__dict__[attrname]) == property:
            return ICruiseAirspeedOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICruiseAirspeedOptions.")
    
    @property
    def cruise_speed_type(self) -> "AVTR_CRUISE_SPEED":
        """The method for determining the aircraft's airspeed."""
        with agmarshall.AgEnum_arg(AVTR_CRUISE_SPEED) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cruise_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cruise_speed_type.setter
    def cruise_speed_type(self, newVal:"AVTR_CRUISE_SPEED") -> None:
        """The method for determining the aircraft's airspeed."""
        with agmarshall.AgEnum_arg(AVTR_CRUISE_SPEED, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cruise_speed_type"](arg_newVal.COM_val))

    @property
    def other_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type for the other airspeed option."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def other_airspeed(self) -> float:
        """The airspeed for the other airspeed option."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_other_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the cruise airspeed. This option is only enabled if the cruise speed type is set to other."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_other_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8c88b752-5739-4244-9db7-9fd404b3c0c6}", ICruiseAirspeedOptions)
agcls.AgTypeNameMap["ICruiseAirspeedOptions"] = ICruiseAirspeedOptions

class ICruiseAirspeedProfile(object):
    """Interface used to access the Cruise Profile options for an Aviator procedure"""
    _uuid = "{fc8fb409-7067-4474-9c5e-4a77ac894426}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_set_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICruiseAirspeedProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICruiseAirspeedProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICruiseAirspeedProfile = agcom.GUID(ICruiseAirspeedProfile._uuid)
        vtable_offset_local = ICruiseAirspeedProfile._vtable_offset - 1
        self.__dict__["_get_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedProfile, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedProfile, vtable_offset_local+2, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICruiseAirspeedProfile.__dict__ and type(ICruiseAirspeedProfile.__dict__[attrname]) == property:
            return ICruiseAirspeedProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICruiseAirspeedProfile.")
    
    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fly_cruise_airspeed_profile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, newVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fly_cruise_airspeed_profile"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{fc8fb409-7067-4474-9c5e-4a77ac894426}", ICruiseAirspeedProfile)
agcls.AgTypeNameMap["ICruiseAirspeedProfile"] = ICruiseAirspeedProfile

class ICruiseAirspeedAndProfileOptions(object):
    """Interface used to access the cruise airspeed options that also include a profile field."""
    _uuid = "{639730b3-bc2b-4615-afd6-8184af1fb948}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_cruise_speed_type"] = _raise_uninitialized_error
        self.__dict__["_set_cruise_speed_type"] = _raise_uninitialized_error
        self.__dict__["_get_other_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_other_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_other_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_set_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICruiseAirspeedAndProfileOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICruiseAirspeedAndProfileOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICruiseAirspeedAndProfileOptions = agcom.GUID(ICruiseAirspeedAndProfileOptions._uuid)
        vtable_offset_local = ICruiseAirspeedAndProfileOptions._vtable_offset - 1
        self.__dict__["_get_cruise_speed_type"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedAndProfileOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_cruise_speed_type"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedAndProfileOptions, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_other_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedAndProfileOptions, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_other_airspeed"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedAndProfileOptions, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_other_airspeed"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedAndProfileOptions, vtable_offset_local+5, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedAndProfileOptions, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_ICruiseAirspeedAndProfileOptions, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICruiseAirspeedAndProfileOptions.__dict__ and type(ICruiseAirspeedAndProfileOptions.__dict__[attrname]) == property:
            return ICruiseAirspeedAndProfileOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICruiseAirspeedAndProfileOptions.")
    
    @property
    def cruise_speed_type(self) -> "AVTR_CRUISE_SPEED":
        """The method for determining the aircraft's airspeed."""
        with agmarshall.AgEnum_arg(AVTR_CRUISE_SPEED) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cruise_speed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cruise_speed_type.setter
    def cruise_speed_type(self, newVal:"AVTR_CRUISE_SPEED") -> None:
        """The method for determining the aircraft's airspeed."""
        with agmarshall.AgEnum_arg(AVTR_CRUISE_SPEED, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cruise_speed_type"](arg_newVal.COM_val))

    @property
    def other_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type for the other airspeed option."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def other_airspeed(self) -> float:
        """The airspeed for the other airspeed option."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_other_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the cruise airspeed. This option is only enabled if the cruise speed type is set to other."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_other_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fly_cruise_airspeed_profile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, newVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fly_cruise_airspeed_profile"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{639730b3-bc2b-4615-afd6-8184af1fb948}", ICruiseAirspeedAndProfileOptions)
agcls.AgTypeNameMap["ICruiseAirspeedAndProfileOptions"] = ICruiseAirspeedAndProfileOptions

class IAutomationStrategyFactory(object):
    """Interface used to send connect commands to Aviator objects."""
    _uuid = "{310e51d5-81bf-4fc5-8260-b2eb2de0e1ed}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_construct_strategy"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAutomationStrategyFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAutomationStrategyFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAutomationStrategyFactory = agcom.GUID(IAutomationStrategyFactory._uuid)
        vtable_offset_local = IAutomationStrategyFactory._vtable_offset - 1
        self.__dict__["_construct_strategy"] = IAGFUNCTYPE(pUnk, IID_IAutomationStrategyFactory, vtable_offset_local+1, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAutomationStrategyFactory.__dict__ and type(IAutomationStrategyFactory.__dict__[attrname]) == property:
            return IAutomationStrategyFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAutomationStrategyFactory.")
    
    def construct_strategy(self, pUnk:"IUnknown") -> "IBasicManeuverStrategy":
        """Construct the strategy."""
        with agmarshall.AgInterface_in_arg(pUnk, IUnknown) as arg_pUnk, \
             agmarshall.AgInterface_out_arg() as arg_ppBasicManeuverStrategy:
            agcls.evaluate_hresult(self.__dict__["_construct_strategy"](arg_pUnk.COM_val, byref(arg_ppBasicManeuverStrategy.COM_val)))
            return arg_ppBasicManeuverStrategy.python_val


agcls.AgClassCatalog.add_catalog_entry("{310e51d5-81bf-4fc5-8260-b2eb2de0e1ed}", IAutomationStrategyFactory)
agcls.AgTypeNameMap["IAutomationStrategyFactory"] = IAutomationStrategyFactory

class IConnect(object):
    """Interface used to send connect commands to Aviator objects."""
    _uuid = "{beb8d5ff-ae82-49d9-bff6-aa88fa3125ed}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_execute_command"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConnect._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConnect from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConnect = agcom.GUID(IConnect._uuid)
        vtable_offset_local = IConnect._vtable_offset - 1
        self.__dict__["_execute_command"] = IAGFUNCTYPE(pUnk, IID_IConnect, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConnect.__dict__ and type(IConnect.__dict__[attrname]) == property:
            return IConnect.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConnect.")
    
    def execute_command(self, command:str) -> typing.Any:
        """Send a connect command to an Aviator object."""
        with agmarshall.BSTR_arg(command) as arg_command, \
             agmarshall.AgInterface_out_arg() as arg_ppExecCmdRes:
            agcls.evaluate_hresult(self.__dict__["_execute_command"](arg_command.COM_val, byref(arg_ppExecCmdRes.COM_val)))
            return arg_ppExecCmdRes.python_val


agcls.AgClassCatalog.add_catalog_entry("{beb8d5ff-ae82-49d9-bff6-aa88fa3125ed}", IConnect)
agcls.AgTypeNameMap["IConnect"] = IConnect

class IRunwayHeadingOptions(object):
    """Interface for the Runway Heading Options found in a Takeoff or Landing procedure."""
    _uuid = "{8e456b0d-eb7a-423c-acc3-467bc13b6375}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_runway_mode"] = _raise_uninitialized_error
        self.__dict__["_set_runway_mode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRunwayHeadingOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRunwayHeadingOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRunwayHeadingOptions = agcom.GUID(IRunwayHeadingOptions._uuid)
        vtable_offset_local = IRunwayHeadingOptions._vtable_offset - 1
        self.__dict__["_get_runway_mode"] = IAGFUNCTYPE(pUnk, IID_IRunwayHeadingOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_runway_mode"] = IAGFUNCTYPE(pUnk, IID_IRunwayHeadingOptions, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRunwayHeadingOptions.__dict__ and type(IRunwayHeadingOptions.__dict__[attrname]) == property:
            return IRunwayHeadingOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRunwayHeadingOptions.")
    
    @property
    def runway_mode(self) -> "AVTR_RUNWAY_HIGH_LOW_END":
        """The runway heading that the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_RUNWAY_HIGH_LOW_END) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @runway_mode.setter
    def runway_mode(self, newVal:"AVTR_RUNWAY_HIGH_LOW_END") -> None:
        """The runway heading that the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_RUNWAY_HIGH_LOW_END, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_runway_mode"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8e456b0d-eb7a-423c-acc3-467bc13b6375}", IRunwayHeadingOptions)
agcls.AgTypeNameMap["IRunwayHeadingOptions"] = IRunwayHeadingOptions

class IProcedure(object):
    """Interface used to access the options for a procedure. Use this interface to get the Site and Get the time options for the current procedure."""
    _uuid = "{df1aaedb-6f1c-4a50-9fdb-9fda3d56d3db}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_site"] = _raise_uninitialized_error
        self.__dict__["_get_time_options"] = _raise_uninitialized_error
        self.__dict__["_get_wind_model"] = _raise_uninitialized_error
        self.__dict__["_get_atmosphere_model"] = _raise_uninitialized_error
        self.__dict__["_get_calculation_options"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_is_supported"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_properties"] = _raise_uninitialized_error
        self.__dict__["_get_fast_time_options"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedure._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedure from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedure = agcom.GUID(IProcedure._uuid)
        vtable_offset_local = IProcedure._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_site"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_time_options"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_wind_model"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_atmosphere_model"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_calculation_options"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_refuel_dump_is_supported"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_refuel_dump_properties"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_fast_time_options"] = IAGFUNCTYPE(pUnk, IID_IProcedure, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedure.__dict__ and type(IProcedure.__dict__[attrname]) == property:
            return IProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedure.")
    
    @property
    def name(self) -> str:
        """The name of the procedure."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the procedure."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def site(self) -> "ISite":
        """Get the site of the current procedure."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val

    @property
    def time_options(self) -> "IProcedureTimeOptions":
        """Get the time options for the current procedure."""
        with agmarshall.AgInterface_out_arg() as arg_ppTimeOptions:
            agcls.evaluate_hresult(self.__dict__["_get_time_options"](byref(arg_ppTimeOptions.COM_val)))
            return arg_ppTimeOptions.python_val

    @property
    def wind_model(self) -> "IWindModel":
        """Get the wind model for the current procedure."""
        with agmarshall.AgInterface_out_arg() as arg_ppWindModel:
            agcls.evaluate_hresult(self.__dict__["_get_wind_model"](byref(arg_ppWindModel.COM_val)))
            return arg_ppWindModel.python_val

    @property
    def atmosphere_model(self) -> "IAtmosphereModel":
        """Get the mission atmosphere model."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrAtmos:
            agcls.evaluate_hresult(self.__dict__["_get_atmosphere_model"](byref(arg_ppAvtrAtmos.COM_val)))
            return arg_ppAvtrAtmos.python_val

    @property
    def calculation_options(self) -> "ICalculationOptions":
        """Get the calculation options for the current procedure."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrCalcOptions:
            agcls.evaluate_hresult(self.__dict__["_get_calculation_options"](byref(arg_ppAvtrCalcOptions.COM_val)))
            return arg_ppAvtrCalcOptions.python_val

    @property
    def refuel_dump_is_supported(self) -> bool:
        """Refuel/dump is supported for the current procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRefuelDumpIsSupported:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_is_supported"](byref(arg_pRefuelDumpIsSupported.COM_val)))
            return arg_pRefuelDumpIsSupported.python_val

    @property
    def refuel_dump_properties(self) -> "IRefuelDumpProperties":
        """Get the refuel/dump properties for the current procedure."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrRefuelDumpProperties:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_properties"](byref(arg_ppAvtrRefuelDumpProperties.COM_val)))
            return arg_ppAvtrRefuelDumpProperties.python_val

    @property
    def fast_time_options(self) -> "IProcedureFastTimeOptions":
        """Get the fast time options (without validation or constraints) for the current procedure."""
        with agmarshall.AgInterface_out_arg() as arg_ppTimeOptions:
            agcls.evaluate_hresult(self.__dict__["_get_fast_time_options"](byref(arg_ppTimeOptions.COM_val)))
            return arg_ppTimeOptions.python_val


agcls.AgClassCatalog.add_catalog_entry("{df1aaedb-6f1c-4a50-9fdb-9fda3d56d3db}", IProcedure)
agcls.AgTypeNameMap["IProcedure"] = IProcedure

class IProcedureCollection(object):
    """Interface used to access the collection of procedures for a given phase in a mission. Use this interface to Get, Add, or Remove a procedure."""
    _uuid = "{27c58de8-b8f8-40d6-ae6d-4e31cbbd8a43}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_add_at_index"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_at_index"] = _raise_uninitialized_error
        self.__dict__["_enable_auto_propagate"] = _raise_uninitialized_error
        self.__dict__["_disable_auto_propagate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureCollection = agcom.GUID(IProcedureCollection._uuid)
        vtable_offset_local = IProcedureCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+4, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_add_at_index"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+5, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_remove_at_index"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_enable_auto_propagate"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+8, )
        self.__dict__["_disable_auto_propagate"] = IAGFUNCTYPE(pUnk, IID_IProcedureCollection, vtable_offset_local+9, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureCollection.__dict__ and type(IProcedureCollection.__dict__[attrname]) == property:
            return IProcedureCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IProcedure":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IProcedure":
        """Given an index, returns an element in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that can iterate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add(self, siteType:"AVTR_SITE_TYPE", procedureType:"AVTR_PROCEDURE_TYPE") -> "IProcedure":
        """Adds a procedure with the specified site at the end of the current phase."""
        with agmarshall.AgEnum_arg(AVTR_SITE_TYPE, siteType) as arg_siteType, \
             agmarshall.AgEnum_arg(AVTR_PROCEDURE_TYPE, procedureType) as arg_procedureType, \
             agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_siteType.COM_val, arg_procedureType.COM_val, byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    def add_at_index(self, index:int, siteType:"AVTR_SITE_TYPE", procedureType:"AVTR_PROCEDURE_TYPE") -> "IProcedure":
        """Adds a procedure with the specified site at the given index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgEnum_arg(AVTR_SITE_TYPE, siteType) as arg_siteType, \
             agmarshall.AgEnum_arg(AVTR_PROCEDURE_TYPE, procedureType) as arg_procedureType, \
             agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_add_at_index"](arg_index.COM_val, arg_siteType.COM_val, arg_procedureType.COM_val, byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    def remove(self, procedure:"IProcedure") -> None:
        """Remove given procedure."""
        with agmarshall.AgInterface_in_arg(procedure, IProcedure) as arg_procedure:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_procedure.COM_val))

    def remove_at_index(self, index:int) -> None:
        """Remove procedure at the given index."""
        with agmarshall.LONG_arg(index) as arg_index:
            agcls.evaluate_hresult(self.__dict__["_remove_at_index"](arg_index.COM_val))

    def enable_auto_propagate(self) -> None:
        """Enable automatically propagating the mission. Aviator will automatically propagate before adding a procedure, ensuring a valid initial state for the new procedure."""
        agcls.evaluate_hresult(self.__dict__["_enable_auto_propagate"]())

    def disable_auto_propagate(self) -> None:
        """Disable automatically propagating the mission. Use with caution. Aviator will not automatically propagate before adding new procedures."""
        agcls.evaluate_hresult(self.__dict__["_disable_auto_propagate"]())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{27c58de8-b8f8-40d6-ae6d-4e31cbbd8a43}", IProcedureCollection)
agcls.AgTypeNameMap["IProcedureCollection"] = IProcedureCollection

class IPhase(object):
    """Interface used to access the phase options for a mission."""
    _uuid = "{1979f1b5-fe60-464b-af70-eb47fd5c096b}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_procedures"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_performance_model_by_type"] = _raise_uninitialized_error
        self.__dict__["_set_default_perf_models"] = _raise_uninitialized_error
        self.__dict__["_copy_performance_models"] = _raise_uninitialized_error
        self.__dict__["_paste_performance_models"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPhase._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPhase from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPhase = agcom.GUID(IPhase._uuid)
        vtable_offset_local = IPhase._vtable_offset - 1
        self.__dict__["_get_procedures"] = IAGFUNCTYPE(pUnk, IID_IPhase, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IPhase, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IPhase, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_get_performance_model_by_type"] = IAGFUNCTYPE(pUnk, IID_IPhase, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_set_default_perf_models"] = IAGFUNCTYPE(pUnk, IID_IPhase, vtable_offset_local+5, )
        self.__dict__["_copy_performance_models"] = IAGFUNCTYPE(pUnk, IID_IPhase, vtable_offset_local+6, )
        self.__dict__["_paste_performance_models"] = IAGFUNCTYPE(pUnk, IID_IPhase, vtable_offset_local+7, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPhase.__dict__ and type(IPhase.__dict__[attrname]) == property:
            return IPhase.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPhase.")
    
    @property
    def procedures(self) -> "IProcedureCollection":
        """Returns the procedure collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrProcedureCollection:
            agcls.evaluate_hresult(self.__dict__["_get_procedures"](byref(arg_ppAvtrProcedureCollection.COM_val)))
            return arg_ppAvtrProcedureCollection.python_val

    @property
    def name(self) -> str:
        """The name of the phase."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the phase."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    def get_performance_model_by_type(self, type:str) -> "IPerformanceModelOptions":
        """Get the active performance model for the given category type."""
        with agmarshall.BSTR_arg(type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppPerformanceModel:
            agcls.evaluate_hresult(self.__dict__["_get_performance_model_by_type"](arg_type.COM_val, byref(arg_ppPerformanceModel.COM_val)))
            return arg_ppPerformanceModel.python_val

    def set_default_perf_models(self) -> None:
        """Set the phase to use the default performance models of the aircraft."""
        agcls.evaluate_hresult(self.__dict__["_set_default_perf_models"]())

    def copy_performance_models(self) -> None:
        """Create a copy of the active performance models for the current phase."""
        agcls.evaluate_hresult(self.__dict__["_copy_performance_models"]())

    def paste_performance_models(self) -> None:
        """Paste the performance models."""
        agcls.evaluate_hresult(self.__dict__["_paste_performance_models"]())


agcls.AgClassCatalog.add_catalog_entry("{1979f1b5-fe60-464b-af70-eb47fd5c096b}", IPhase)
agcls.AgTypeNameMap["IPhase"] = IPhase

class IPhaseCollection(object):
    """Interface used to access the collection of phases for a mission."""
    _uuid = "{d7309dde-9887-48e6-9a10-dfadfaa3c48b}"
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_add_at_index"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_at_index"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPhaseCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPhaseCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPhaseCollection = agcom.GUID(IPhaseCollection._uuid)
        vtable_offset_local = IPhaseCollection._vtable_offset - 1
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IPhaseCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IPhaseCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPhaseCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IPhaseCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_add_at_index"] = IAGFUNCTYPE(pUnk, IID_IPhaseCollection, vtable_offset_local+5, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IPhaseCollection, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_remove_at_index"] = IAGFUNCTYPE(pUnk, IID_IPhaseCollection, vtable_offset_local+7, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPhaseCollection.__dict__ and type(IPhaseCollection.__dict__[attrname]) == property:
            return IPhaseCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPhaseCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IPhase":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def item(self, index:int) -> "IPhase":
        """Given an index, returns an element in the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns an enumerator that can iterate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add(self) -> "IPhase":
        """Adds a phase at the end of the mission."""
        with agmarshall.AgInterface_out_arg() as arg_ppPhase:
            agcls.evaluate_hresult(self.__dict__["_add"](byref(arg_ppPhase.COM_val)))
            return arg_ppPhase.python_val

    def add_at_index(self, index:int) -> "IPhase":
        """Adds a phase at the given index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppPhase:
            agcls.evaluate_hresult(self.__dict__["_add_at_index"](arg_index.COM_val, byref(arg_ppPhase.COM_val)))
            return arg_ppPhase.python_val

    def remove(self, phase:"IPhase") -> None:
        """Remove given phase."""
        with agmarshall.AgInterface_in_arg(phase, IPhase) as arg_phase:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_phase.COM_val))

    def remove_at_index(self, index:int) -> None:
        """Remove phase at the given index."""
        with agmarshall.LONG_arg(index) as arg_index:
            agcls.evaluate_hresult(self.__dict__["_remove_at_index"](arg_index.COM_val))

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{d7309dde-9887-48e6-9a10-dfadfaa3c48b}", IPhaseCollection)
agcls.AgTypeNameMap["IPhaseCollection"] = IPhaseCollection

class IMission(object):
    """Interface for the mission of an aircraft using the Aviator propagator."""
    _uuid = "{e4467d52-6a09-47b2-943c-7e24ae375f6b}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_phases"] = _raise_uninitialized_error
        self.__dict__["_get_vehicle"] = _raise_uninitialized_error
        self.__dict__["_set_vehicle"] = _raise_uninitialized_error
        self.__dict__["_get_configuration"] = _raise_uninitialized_error
        self.__dict__["_get_wind_model"] = _raise_uninitialized_error
        self.__dict__["_get_atmosphere_model"] = _raise_uninitialized_error
        self.__dict__["_get_is_valid"] = _raise_uninitialized_error
        self.__dict__["_get_first_invalid_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMission._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMission from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMission = agcom.GUID(IMission._uuid)
        vtable_offset_local = IMission._vtable_offset - 1
        self.__dict__["_get_phases"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_vehicle"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_set_vehicle"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_get_configuration"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_wind_model"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_atmosphere_model"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_is_valid"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_first_invalid_procedure"] = IAGFUNCTYPE(pUnk, IID_IMission, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMission.__dict__ and type(IMission.__dict__[attrname]) == property:
            return IMission.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMission.")
    
    @property
    def phases(self) -> "IPhaseCollection":
        """Get the mission phases."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrPhaseCollection:
            agcls.evaluate_hresult(self.__dict__["_get_phases"](byref(arg_ppAvtrPhaseCollection.COM_val)))
            return arg_ppAvtrPhaseCollection.python_val

    @property
    def vehicle(self) -> "IAviatorVehicle":
        """The vehicle used in the mission."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrVehicle:
            agcls.evaluate_hresult(self.__dict__["_get_vehicle"](byref(arg_ppAvtrVehicle.COM_val)))
            return arg_ppAvtrVehicle.python_val

    @vehicle.setter
    def vehicle(self, pAvtrVehicle:"IAviatorVehicle") -> None:
        """The vehicle used in the mission."""
        with agmarshall.AgInterface_in_arg(pAvtrVehicle, IAviatorVehicle) as arg_pAvtrVehicle:
            agcls.evaluate_hresult(self.__dict__["_set_vehicle"](arg_pAvtrVehicle.COM_val))

    @property
    def configuration(self) -> "IConfiguration":
        """The aircraft's configuration for the mission."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrConfig:
            agcls.evaluate_hresult(self.__dict__["_get_configuration"](byref(arg_ppAvtrConfig.COM_val)))
            return arg_ppAvtrConfig.python_val

    @property
    def wind_model(self) -> "IWindModel":
        """Get the mission wind model."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrW:
            agcls.evaluate_hresult(self.__dict__["_get_wind_model"](byref(arg_ppAvtrW.COM_val)))
            return arg_ppAvtrW.python_val

    @property
    def atmosphere_model(self) -> "IAtmosphereModel":
        """Get the mission atmosphere model."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrAtmos:
            agcls.evaluate_hresult(self.__dict__["_get_atmosphere_model"](byref(arg_ppAvtrAtmos.COM_val)))
            return arg_ppAvtrAtmos.python_val

    @property
    def is_valid(self) -> bool:
        """Check whether the mission is valid. Calling this property will propagate the mission."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_valid"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_first_invalid_procedure(self) -> "IProcedure":
        """Get the first invalid procedure in the mission. Calling this method will propagate the mission."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_first_invalid_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{e4467d52-6a09-47b2-943c-7e24ae375f6b}", IMission)
agcls.AgTypeNameMap["IMission"] = IMission

class IAviatorPropagator(object):
    """Interface used to access the Aviator interface for an aircraft. Use this interface to get the mission or Aviator catalog."""
    _uuid = "{f7e3993a-52ed-4e91-8655-79063c0a3e94}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_avtr_mission"] = _raise_uninitialized_error
        self.__dict__["_propagate"] = _raise_uninitialized_error
        self.__dict__["_get_auto_recalculate"] = _raise_uninitialized_error
        self.__dict__["_set_auto_recalculate"] = _raise_uninitialized_error
        self.__dict__["_get_avtr_catalog"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAviatorPropagator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAviatorPropagator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAviatorPropagator = agcom.GUID(IAviatorPropagator._uuid)
        vtable_offset_local = IAviatorPropagator._vtable_offset - 1
        self.__dict__["_get_avtr_mission"] = IAGFUNCTYPE(pUnk, IID_IAviatorPropagator, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_propagate"] = IAGFUNCTYPE(pUnk, IID_IAviatorPropagator, vtable_offset_local+2, )
        self.__dict__["_get_auto_recalculate"] = IAGFUNCTYPE(pUnk, IID_IAviatorPropagator, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_auto_recalculate"] = IAGFUNCTYPE(pUnk, IID_IAviatorPropagator, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_avtr_catalog"] = IAGFUNCTYPE(pUnk, IID_IAviatorPropagator, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAviatorPropagator.__dict__ and type(IAviatorPropagator.__dict__[attrname]) == property:
            return IAviatorPropagator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAviatorPropagator.")
    
    @property
    def avtr_mission(self) -> "IMission":
        """The Aviator mission."""
        with agmarshall.AgInterface_out_arg() as arg_ppAvtrMission:
            agcls.evaluate_hresult(self.__dict__["_get_avtr_mission"](byref(arg_ppAvtrMission.COM_val)))
            return arg_ppAvtrMission.python_val

    def propagate(self) -> None:
        """Applies All Change."""
        agcls.evaluate_hresult(self.__dict__["_propagate"]())

    @property
    def auto_recalculate(self) -> bool:
        """Opt whether to have the propagator auto recalculate."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_auto_recalculate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @auto_recalculate.setter
    def auto_recalculate(self, vbAutoRecalc:bool) -> None:
        """Opt whether to have the propagator auto recalculate."""
        with agmarshall.VARIANT_BOOL_arg(vbAutoRecalc) as arg_vbAutoRecalc:
            agcls.evaluate_hresult(self.__dict__["_set_auto_recalculate"](arg_vbAutoRecalc.COM_val))

    @property
    def avtr_catalog(self) -> "ICatalog":
        """The Aviator catalog."""
        with agmarshall.AgInterface_out_arg() as arg_ppCatalog:
            agcls.evaluate_hresult(self.__dict__["_get_avtr_catalog"](byref(arg_ppCatalog.COM_val)))
            return arg_ppCatalog.python_val


agcls.AgClassCatalog.add_catalog_entry("{f7e3993a-52ed-4e91-8655-79063c0a3e94}", IAviatorPropagator)
agcls.AgTypeNameMap["IAviatorPropagator"] = IAviatorPropagator

class IPerformanceModel(object):
    """Interface for a performance model of an Aviator vehicle."""
    _uuid = "{8fb55502-c401-4188-adc9-7a889fdbe996}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPerformanceModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPerformanceModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPerformanceModel = agcom.GUID(IPerformanceModel._uuid)
        vtable_offset_local = IPerformanceModel._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPerformanceModel.__dict__ and type(IPerformanceModel.__dict__[attrname]) == property:
            return IPerformanceModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPerformanceModel.")
    

agcls.AgClassCatalog.add_catalog_entry("{8fb55502-c401-4188-adc9-7a889fdbe996}", IPerformanceModel)
agcls.AgTypeNameMap["IPerformanceModel"] = IPerformanceModel

class IAdvFixedWingGeometry(object):
    """Interface used to access the options for the wing geometry in the advanced fixed wing tool."""
    _uuid = "{d3b3af6e-7b5a-4491-aaca-c05eb901afa0}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingGeometry._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingGeometry from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingGeometry = agcom.GUID(IAdvFixedWingGeometry._uuid)
        vtable_offset_local = IAdvFixedWingGeometry._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingGeometry.__dict__ and type(IAdvFixedWingGeometry.__dict__[attrname]) == property:
            return IAdvFixedWingGeometry.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingGeometry.")
    

agcls.AgClassCatalog.add_catalog_entry("{d3b3af6e-7b5a-4491-aaca-c05eb901afa0}", IAdvFixedWingGeometry)
agcls.AgTypeNameMap["IAdvFixedWingGeometry"] = IAdvFixedWingGeometry

class IAdvFixedWingTurbofanBasicABPowerplant(object):
    """This interface is deprecated. Use IAdvFixedWingTurbofanBasicABProp instead."""
    _uuid = "{9bc7e978-48ec-487d-8460-014c8fe376bd}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingTurbofanBasicABPowerplant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbofanBasicABPowerplant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingTurbofanBasicABPowerplant = agcom.GUID(IAdvFixedWingTurbofanBasicABPowerplant._uuid)
        vtable_offset_local = IAdvFixedWingTurbofanBasicABPowerplant._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbofanBasicABPowerplant.__dict__ and type(IAdvFixedWingTurbofanBasicABPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingTurbofanBasicABPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbofanBasicABPowerplant.")
    

agcls.AgClassCatalog.add_catalog_entry("{9bc7e978-48ec-487d-8460-014c8fe376bd}", IAdvFixedWingTurbofanBasicABPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingTurbofanBasicABPowerplant"] = IAdvFixedWingTurbofanBasicABPowerplant

class IAdvFixedWingTurbojetBasicABPowerplant(object):
    """This interface is deprecated. Use IAdvFixedWingTurbojetBasicABProp instead."""
    _uuid = "{552db5f4-fe5d-4709-80b4-7ba074c673ff}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingTurbojetBasicABPowerplant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbojetBasicABPowerplant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingTurbojetBasicABPowerplant = agcom.GUID(IAdvFixedWingTurbojetBasicABPowerplant._uuid)
        vtable_offset_local = IAdvFixedWingTurbojetBasicABPowerplant._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbojetBasicABPowerplant.__dict__ and type(IAdvFixedWingTurbojetBasicABPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingTurbojetBasicABPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbojetBasicABPowerplant.")
    

agcls.AgClassCatalog.add_catalog_entry("{552db5f4-fe5d-4709-80b4-7ba074c673ff}", IAdvFixedWingTurbojetBasicABPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingTurbojetBasicABPowerplant"] = IAdvFixedWingTurbojetBasicABPowerplant

class IAdvFixedWingPowerplant(object):
    """Interface for a powerplant strategy in the advanced fixed wing tool."""
    _uuid = "{79824361-d702-4f4b-81ac-001876fb51ef}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAdvFixedWingPowerplant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingPowerplant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAdvFixedWingPowerplant = agcom.GUID(IAdvFixedWingPowerplant._uuid)
        vtable_offset_local = IAdvFixedWingPowerplant._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingPowerplant.__dict__ and type(IAdvFixedWingPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingPowerplant.")
    

agcls.AgClassCatalog.add_catalog_entry("{79824361-d702-4f4b-81ac-001876fb51ef}", IAdvFixedWingPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingPowerplant"] = IAdvFixedWingPowerplant

class ISiteUnknown(object):
    """Interface of an unknown site."""
    _uuid = "{0921dbaf-ee11-4460-8355-01fc207a6803}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteUnknown._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteUnknown from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteUnknown = agcom.GUID(ISiteUnknown._uuid)
        vtable_offset_local = ISiteUnknown._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteUnknown.__dict__ and type(ISiteUnknown.__dict__[attrname]) == property:
            return ISiteUnknown.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteUnknown.")
    

agcls.AgClassCatalog.add_catalog_entry("{0921dbaf-ee11-4460-8355-01fc207a6803}", ISiteUnknown)
agcls.AgTypeNameMap["ISiteUnknown"] = ISiteUnknown

class IAircraftTerrainFollowModel(object):
    """Interface used to access the options for a TerrainFollow performance model of an aircraft."""
    _uuid = "{34e47cb6-b418-468b-b5bf-df98428b7691}"
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_set_use_aero_prop_fuel"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_endurance_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_endurance_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_range_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_range_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_perf_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_perf_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_min_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_endurance_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_endurance_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_range_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_range_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_perf_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_max_perf_airspeed_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_max_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_set_max_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_window"] = _raise_uninitialized_error
        self.__dict__["_set_terrain_window"] = _raise_uninitialized_error
        self.__dict__["_get_max_load_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAircraftTerrainFollowModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAircraftTerrainFollowModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAircraftTerrainFollowModel = agcom.GUID(IAircraftTerrainFollowModel._uuid)
        vtable_offset_local = IAircraftTerrainFollowModel._vtable_offset - 1
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_aero_prop_fuel"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow_by_non_std_density"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_max_endurance_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_endurance_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_max_range_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_range_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_perf_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_perf_airspeed"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_min_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_max_endurance_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_endurance_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_max_range_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_range_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_max_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_max_perf_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_perf_airspeed_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_max_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+27, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+28, agcom.VARIANT)
        self.__dict__["_get_terrain_window"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_terrain_window"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_max_load_factor"] = IAGFUNCTYPE(pUnk, IID_IAircraftTerrainFollowModel, vtable_offset_local+31, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftTerrainFollowModel.__dict__ and type(IAircraftTerrainFollowModel.__dict__[attrname]) == property:
            return IAircraftTerrainFollowModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftTerrainFollowModel.")
    
    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @airspeed_type.setter
    def airspeed_type(self, newVal:"AVTR_AIRSPEED_TYPE") -> None:
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_type"](arg_newVal.COM_val))

    @property
    def use_aero_prop_fuel(self) -> bool:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_aero_prop_fuel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_aero_prop_fuel"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow_by_non_std_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow_by_non_std_density"](arg_newVal.COM_val))

    @property
    def min_airspeed(self) -> float:
        """The minimum airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_airspeed.setter
    def min_airspeed(self, newVal:float) -> None:
        """The minimum airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_airspeed"](arg_newVal.COM_val))

    @property
    def max_endurance_airspeed(self) -> float:
        """The airspeed that will provide the maximum flying time for the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_endurance_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_endurance_airspeed.setter
    def max_endurance_airspeed(self, newVal:float) -> None:
        """The airspeed that will provide the maximum flying time for the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_endurance_airspeed"](arg_newVal.COM_val))

    @property
    def max_range_airspeed(self) -> float:
        """The maximum range airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_range_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_range_airspeed.setter
    def max_range_airspeed(self, newVal:float) -> None:
        """The maximum range airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_range_airspeed"](arg_newVal.COM_val))

    @property
    def max_airspeed(self) -> float:
        """The maximum airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_airspeed.setter
    def max_airspeed(self, newVal:float) -> None:
        """The maximum airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_airspeed"](arg_newVal.COM_val))

    @property
    def max_perf_airspeed(self) -> float:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_perf_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_perf_airspeed.setter
    def max_perf_airspeed(self, newVal:float) -> None:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_perf_airspeed"](arg_newVal.COM_val))

    @property
    def min_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the minimum airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_airspeed_fuel_flow.setter
    def min_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the minimum airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_airspeed_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_endurance_fuel_flow(self) -> float:
        """The fuel flow for the maximum endurance airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_endurance_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_endurance_fuel_flow.setter
    def max_endurance_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum endurance airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_endurance_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_range_fuel_flow(self) -> float:
        """The fuel flow for the maximum range airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_range_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_range_fuel_flow.setter
    def max_range_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum range airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_range_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_airspeed_fuel_flow.setter
    def max_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_airspeed_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_perf_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum performance airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_perf_airspeed_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_perf_airspeed_fuel_flow.setter
    def max_perf_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum performance airspeed."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_perf_airspeed_fuel_flow"](arg_newVal.COM_val))

    @property
    def max_pitch_angle(self) -> typing.Any:
        """The maximum pitch angle the aircraft will be allowed to use."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_pitch_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_pitch_angle.setter
    def max_pitch_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle the aircraft will be allowed to use."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_pitch_angle"](arg_newVal.COM_val))

    @property
    def terrain_window(self) -> float:
        """The time interval over which terrain points are sampled."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_window"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @terrain_window.setter
    def terrain_window(self, newVal:float) -> None:
        """The time interval over which terrain points are sampled."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_terrain_window"](arg_newVal.COM_val))

    @property
    def max_load_factor(self) -> float:
        """The maximum load factor - during straight and level flight - that the aircraft can bear."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{34e47cb6-b418-468b-b5bf-df98428b7691}", IAircraftTerrainFollowModel)
agcls.AgTypeNameMap["IAircraftTerrainFollowModel"] = IAircraftTerrainFollowModel

class IPropulsionThrust(object):
    """Interface used to access propulsion thrust for basic maneuver strategies."""
    _uuid = "{fea63cff-6fa0-406e-ad12-8b17617cb34d}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_constant_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_use_constant_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_constant_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_constant_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_boost_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_boost_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_boost_thrust_time_limit"] = _raise_uninitialized_error
        self.__dict__["_set_boost_thrust_time_limit"] = _raise_uninitialized_error
        self.__dict__["_get_sustain_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_sustain_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_sustain_thrust_time_limit"] = _raise_uninitialized_error
        self.__dict__["_set_sustain_thrust_time_limit"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_max_airspeed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPropulsionThrust._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPropulsionThrust from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPropulsionThrust = agcom.GUID(IPropulsionThrust._uuid)
        vtable_offset_local = IPropulsionThrust._vtable_offset - 1
        self.__dict__["_get_use_constant_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_constant_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_constant_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_constant_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_boost_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_boost_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_boost_thrust_time_limit"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_boost_thrust_time_limit"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_sustain_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_sustain_thrust"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_sustain_thrust_time_limit"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_sustain_thrust_time_limit"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_min_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_get_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+15, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_max_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_get_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IPropulsionThrust, vtable_offset_local+18, agcom.LONG, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPropulsionThrust.__dict__ and type(IPropulsionThrust.__dict__[attrname]) == property:
            return IPropulsionThrust.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPropulsionThrust.")
    
    @property
    def use_constant_thrust(self) -> bool:
        """The option to use a constant thrust for a thrust model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_constant_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_constant_thrust.setter
    def use_constant_thrust(self, newVal:bool) -> None:
        """The option to use a constant thrust for a thrust model."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_constant_thrust"](arg_newVal.COM_val))

    @property
    def constant_thrust(self) -> float:
        """The constant thrust value for a thrust model set to Constant Thrust mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_constant_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @constant_thrust.setter
    def constant_thrust(self, newVal:float) -> None:
        """The constant thrust value for a thrust model set to Constant Thrust mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_constant_thrust"](arg_newVal.COM_val))

    @property
    def boost_thrust(self) -> float:
        """The boost thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_boost_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @boost_thrust.setter
    def boost_thrust(self, newVal:float) -> None:
        """The boost thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_boost_thrust"](arg_newVal.COM_val))

    @property
    def boost_thrust_time_limit(self) -> float:
        """The boost thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_boost_thrust_time_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @boost_thrust_time_limit.setter
    def boost_thrust_time_limit(self, newVal:float) -> None:
        """The boost thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_boost_thrust_time_limit"](arg_newVal.COM_val))

    @property
    def sustain_thrust(self) -> float:
        """The sustain thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sustain_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sustain_thrust.setter
    def sustain_thrust(self, newVal:float) -> None:
        """The sustain thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sustain_thrust"](arg_newVal.COM_val))

    @property
    def sustain_thrust_time_limit(self) -> float:
        """The sustain thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sustain_thrust_time_limit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sustain_thrust_time_limit.setter
    def sustain_thrust_time_limit(self, newVal:float) -> None:
        """The sustain thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sustain_thrust_time_limit"](arg_newVal.COM_val))

    @property
    def min_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The min airspeed type for a thrust model."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def min_airspeed(self) -> float:
        """The min airspeed for a thrust model."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_min_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the min airspeed type and value for a thrust model."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_min_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def max_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The max airspeed type for a thrust model."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_airspeed(self) -> float:
        """The max airspeed for a thrust model."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_max_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the max airspeed type and value for a thrust model."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_max_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{fea63cff-6fa0-406e-ad12-8b17617cb34d}", IPropulsionThrust)
agcls.AgTypeNameMap["IPropulsionThrust"] = IPropulsionThrust

class IBasicManeuverAirspeedOptions(object):
    """Interface used to access airspeed options for basic maneuver strategies."""
    _uuid = "{9c4162c8-e759-4bd7-abfa-05bf5dbe816c}"
    _num_methods = 35
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_airspeed_mode"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_mode"] = _raise_uninitialized_error
        self.__dict__["_get_min_speed_limits"] = _raise_uninitialized_error
        self.__dict__["_set_min_speed_limits"] = _raise_uninitialized_error
        self.__dict__["_get_max_speed_limits"] = _raise_uninitialized_error
        self.__dict__["_set_max_speed_limits"] = _raise_uninitialized_error
        self.__dict__["_get_maintain_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_maintain_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_specified_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_specified_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_specified_accel_decel_mode"] = _raise_uninitialized_error
        self.__dict__["_set_specified_accel_decel_mode"] = _raise_uninitialized_error
        self.__dict__["_get_specified_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_specified_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_specified_accel_decel_g"] = _raise_uninitialized_error
        self.__dict__["_set_specified_accel_decel_g"] = _raise_uninitialized_error
        self.__dict__["_get_accel_g"] = _raise_uninitialized_error
        self.__dict__["_set_accel_g"] = _raise_uninitialized_error
        self.__dict__["_get_decel_g"] = _raise_uninitialized_error
        self.__dict__["_set_decel_g"] = _raise_uninitialized_error
        self.__dict__["_get_accel_mode"] = _raise_uninitialized_error
        self.__dict__["_set_accel_mode"] = _raise_uninitialized_error
        self.__dict__["_get_decel_mode"] = _raise_uninitialized_error
        self.__dict__["_set_decel_mode"] = _raise_uninitialized_error
        self.__dict__["_get_throttle"] = _raise_uninitialized_error
        self.__dict__["_set_throttle"] = _raise_uninitialized_error
        self.__dict__["_get_interpolate_init_g"] = _raise_uninitialized_error
        self.__dict__["_set_interpolate_init_g"] = _raise_uninitialized_error
        self.__dict__["_get_interpolate_end_g"] = _raise_uninitialized_error
        self.__dict__["_set_interpolate_end_g"] = _raise_uninitialized_error
        self.__dict__["_get_interpolate_end_time"] = _raise_uninitialized_error
        self.__dict__["_set_interpolate_end_time"] = _raise_uninitialized_error
        self.__dict__["_get_interpolate_stop_at_end_time"] = _raise_uninitialized_error
        self.__dict__["_set_interpolate_stop_at_end_time"] = _raise_uninitialized_error
        self.__dict__["_get_thrust"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverAirspeedOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverAirspeedOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverAirspeedOptions = agcom.GUID(IBasicManeuverAirspeedOptions._uuid)
        vtable_offset_local = IBasicManeuverAirspeedOptions._vtable_offset - 1
        self.__dict__["_get_airspeed_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_airspeed_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_min_speed_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_min_speed_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_max_speed_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_max_speed_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_maintain_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_maintain_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_specified_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_specified_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_specified_accel_decel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_specified_accel_decel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_specified_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_specified_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_specified_accel_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_specified_accel_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_accel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_accel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_accel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_decel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_decel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_get_throttle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_throttle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_interpolate_init_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_interpolate_init_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_interpolate_end_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_interpolate_end_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_interpolate_end_time"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_interpolate_end_time"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_interpolate_stop_at_end_time"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+33, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_interpolate_stop_at_end_time"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+34, agcom.VARIANT_BOOL)
        self.__dict__["_get_thrust"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverAirspeedOptions, vtable_offset_local+35, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverAirspeedOptions.__dict__ and type(IBasicManeuverAirspeedOptions.__dict__[attrname]) == property:
            return IBasicManeuverAirspeedOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverAirspeedOptions.")
    
    @property
    def airspeed_mode(self) -> "AVTR_BASIC_MANEUVER_AIRSPEED_MODE":
        """The active airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_AIRSPEED_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @airspeed_mode.setter
    def airspeed_mode(self, newVal:"AVTR_BASIC_MANEUVER_AIRSPEED_MODE") -> None:
        """The active airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_AIRSPEED_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_mode"](arg_newVal.COM_val))

    @property
    def min_speed_limits(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS":
        """The minimum speed limit type to enforce."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_speed_limits"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_speed_limits.setter
    def min_speed_limits(self, newVal:"AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS") -> None:
        """The minimum speed limit type to enforce."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_speed_limits"](arg_newVal.COM_val))

    @property
    def max_speed_limits(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS":
        """The maximum speed limit type to enforce."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_speed_limits"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_speed_limits.setter
    def max_speed_limits(self, newVal:"AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS") -> None:
        """The maximum speed limit type to enforce."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_speed_limits"](arg_newVal.COM_val))

    @property
    def maintain_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type option in the Maintain Current Airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maintain_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maintain_airspeed_type.setter
    def maintain_airspeed_type(self, newVal:"AVTR_AIRSPEED_TYPE") -> None:
        """The airspeed type option in the Maintain Current Airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maintain_airspeed_type"](arg_newVal.COM_val))

    @property
    def specified_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type option in the Maintain Specified Airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specified_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specified_airspeed_type.setter
    def specified_airspeed_type(self, newVal:"AVTR_AIRSPEED_TYPE") -> None:
        """The airspeed type option in the Maintain Specified Airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specified_airspeed_type"](arg_newVal.COM_val))

    @property
    def specified_accel_decel_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The accel/decel mode for the Maintain Specified Airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specified_accel_decel_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specified_accel_decel_mode.setter
    def specified_accel_decel_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The accel/decel mode for the Maintain Specified Airspeed mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specified_accel_decel_mode"](arg_newVal.COM_val))

    @property
    def specified_airspeed(self) -> float:
        """The airspeed for the Maintain Specified Airspeed mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specified_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specified_airspeed.setter
    def specified_airspeed(self, newVal:float) -> None:
        """The airspeed for the Maintain Specified Airspeed mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specified_airspeed"](arg_newVal.COM_val))

    @property
    def specified_accel_decel_g(self) -> float:
        """The accel/decel G for the Maintain Specified Airspeed mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specified_accel_decel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specified_accel_decel_g.setter
    def specified_accel_decel_g(self, newVal:float) -> None:
        """The accel/decel G for the Maintain Specified Airspeed mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specified_accel_decel_g"](arg_newVal.COM_val))

    @property
    def accel_g(self) -> float:
        """The accel G for the Accelerate at mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The accel G for the Accelerate at mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_g"](arg_newVal.COM_val))

    @property
    def decel_g(self) -> float:
        """The decel G for the Decelerate at mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_decel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @decel_g.setter
    def decel_g(self, newVal:float) -> None:
        """The decel G for the Decelerate at mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_decel_g"](arg_newVal.COM_val))

    @property
    def accel_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The accel mode for the Accelerate at mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_mode.setter
    def accel_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The accel mode for the Accelerate at mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_mode"](arg_newVal.COM_val))

    @property
    def decel_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The accel mode for the Decelerate at mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_decel_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @decel_mode.setter
    def decel_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The accel mode for the Decelerate at mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_decel_mode"](arg_newVal.COM_val))

    @property
    def throttle(self) -> float:
        """The throttle setting for the Accel/Decel using Aero/Propulsion at mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_throttle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @throttle.setter
    def throttle(self, newVal:float) -> None:
        """The throttle setting for the Accel/Decel using Aero/Propulsion at mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_throttle"](arg_newVal.COM_val))

    @property
    def interpolate_init_g(self) -> float:
        """The initial G for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interpolate_init_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @interpolate_init_g.setter
    def interpolate_init_g(self, newVal:float) -> None:
        """The initial G for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_interpolate_init_g"](arg_newVal.COM_val))

    @property
    def interpolate_end_g(self) -> float:
        """The end G for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interpolate_end_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @interpolate_end_g.setter
    def interpolate_end_g(self, newVal:float) -> None:
        """The end G for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_interpolate_end_g"](arg_newVal.COM_val))

    @property
    def interpolate_end_time(self) -> float:
        """The end time for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interpolate_end_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @interpolate_end_time.setter
    def interpolate_end_time(self, newVal:float) -> None:
        """The end time for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_interpolate_end_time"](arg_newVal.COM_val))

    @property
    def interpolate_stop_at_end_time(self) -> bool:
        """The option to stop at the end time for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interpolate_stop_at_end_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @interpolate_stop_at_end_time.setter
    def interpolate_stop_at_end_time(self, newVal:bool) -> None:
        """The option to stop at the end time for the Interpolate Accel/Decel over Interval mode."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_interpolate_stop_at_end_time"](arg_newVal.COM_val))

    @property
    def thrust(self) -> "IPropulsionThrust":
        """Get the thrust options for the Specify Thrust mode."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9c4162c8-e759-4bd7-abfa-05bf5dbe816c}", IBasicManeuverAirspeedOptions)
agcls.AgTypeNameMap["IBasicManeuverAirspeedOptions"] = IBasicManeuverAirspeedOptions

class IBasicManeuverStrategyAileronRoll(object):
    """Interface used to access options for a Aileron Roll Strategy of a Basic Maneuver Procedure."""
    _uuid = "{75e11578-6c8f-4875-8b72-e678d80510d7}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_flight_path_option"] = _raise_uninitialized_error
        self.__dict__["_set_flight_path_option"] = _raise_uninitialized_error
        self.__dict__["_get_active_mode"] = _raise_uninitialized_error
        self.__dict__["_set_active_mode"] = _raise_uninitialized_error
        self.__dict__["_get_active_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_active_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_active_angle"] = _raise_uninitialized_error
        self.__dict__["_set_active_angle"] = _raise_uninitialized_error
        self.__dict__["_get_roll_orientation"] = _raise_uninitialized_error
        self.__dict__["_set_roll_orientation"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_get_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_set_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyAileronRoll._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyAileronRoll from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyAileronRoll = agcom.GUID(IBasicManeuverStrategyAileronRoll._uuid)
        vtable_offset_local = IBasicManeuverStrategyAileronRoll._vtable_offset - 1
        self.__dict__["_get_flight_path_option"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_flight_path_option"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_active_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_active_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_active_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_active_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_roll_orientation"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_roll_orientation"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAileronRoll, vtable_offset_local+15, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyAileronRoll.__dict__ and type(IBasicManeuverStrategyAileronRoll.__dict__[attrname]) == property:
            return IBasicManeuverStrategyAileronRoll.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyAileronRoll.")
    
    @property
    def flight_path_option(self) -> "AVTR_AILERON_ROLL_FLIGHT_PATH":
        """The flight path option."""
        with agmarshall.AgEnum_arg(AVTR_AILERON_ROLL_FLIGHT_PATH) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_path_option"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_path_option.setter
    def flight_path_option(self, newVal:"AVTR_AILERON_ROLL_FLIGHT_PATH") -> None:
        """The flight path option."""
        with agmarshall.AgEnum_arg(AVTR_AILERON_ROLL_FLIGHT_PATH, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_path_option"](arg_newVal.COM_val))

    @property
    def active_mode(self) -> "AVTR_AILERON_ROLL_MODE":
        """The aileron roll mode."""
        with agmarshall.AgEnum_arg(AVTR_AILERON_ROLL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_mode.setter
    def active_mode(self, newVal:"AVTR_AILERON_ROLL_MODE") -> None:
        """The aileron roll mode."""
        with agmarshall.AgEnum_arg(AVTR_AILERON_ROLL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_mode"](arg_newVal.COM_val))

    @property
    def active_turn_direction(self) -> "AVTR_ROLL_LEFT_RIGHT":
        """The roll turn direction for the active roll mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_LEFT_RIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_turn_direction.setter
    def active_turn_direction(self, newVal:"AVTR_ROLL_LEFT_RIGHT") -> None:
        """The roll turn direction for the active roll mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_LEFT_RIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_turn_direction"](arg_newVal.COM_val))

    @property
    def active_angle(self) -> typing.Any:
        """The roll angle for the active roll mode."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_angle.setter
    def active_angle(self, newVal:typing.Any) -> None:
        """The roll angle for the active roll mode."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_angle"](arg_newVal.COM_val))

    @property
    def roll_orientation(self) -> "AVTR_ROLL_UPRIGHT_INVERTED":
        """The orientation to roll to for the roll to orientation mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_UPRIGHT_INVERTED) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_orientation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_orientation.setter
    def roll_orientation(self, newVal:"AVTR_ROLL_UPRIGHT_INVERTED") -> None:
        """The orientation to roll to for the roll to orientation mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_UPRIGHT_INVERTED, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_orientation"](arg_newVal.COM_val))

    @property
    def roll_rate_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The roll rate mode for the aileron roll."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for the aileron roll."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate_mode"](arg_newVal.COM_val))

    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value for the aileron roll turn. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_roll_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override value for the aileron roll turn. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_roll_rate"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{75e11578-6c8f-4875-8b72-e678d80510d7}", IBasicManeuverStrategyAileronRoll)
agcls.AgTypeNameMap["IBasicManeuverStrategyAileronRoll"] = IBasicManeuverStrategyAileronRoll

class IBasicManeuverStrategyAutopilotNav(object):
    """Interface used to access options for the Autopilot - Horizontal Plane Strategy of a Basic Maneuver Procedure."""
    _uuid = "{80382b4b-412a-4c57-8685-7d88a0100cb6}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_active_mode"] = _raise_uninitialized_error
        self.__dict__["_set_active_mode"] = _raise_uninitialized_error
        self.__dict__["_get_active_heading_course_value"] = _raise_uninitialized_error
        self.__dict__["_set_active_heading_course_value"] = _raise_uninitialized_error
        self.__dict__["_get_damping_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_damping_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_radius"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_rate"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_horiz_accel"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyAutopilotNav._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyAutopilotNav from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyAutopilotNav = agcom.GUID(IBasicManeuverStrategyAutopilotNav._uuid)
        vtable_offset_local = IBasicManeuverStrategyAutopilotNav._vtable_offset - 1
        self.__dict__["_get_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_active_heading_course_value"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_active_heading_course_value"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_damping_ratio"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_damping_ratio"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_get_control_limit_turn_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_get_control_limit_turn_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_get_control_limit_horiz_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_limit"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+11, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotNav, vtable_offset_local+13, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyAutopilotNav.__dict__ and type(IBasicManeuverStrategyAutopilotNav.__dict__[attrname]) == property:
            return IBasicManeuverStrategyAutopilotNav.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyAutopilotNav.")
    
    @property
    def active_mode(self) -> "AVTR_AUTOPILOT_HORIZ_PLANE_MODE":
        """The autopilot - horizontal plane mode."""
        with agmarshall.AgEnum_arg(AVTR_AUTOPILOT_HORIZ_PLANE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_mode.setter
    def active_mode(self, newVal:"AVTR_AUTOPILOT_HORIZ_PLANE_MODE") -> None:
        """The autopilot - horizontal plane mode."""
        with agmarshall.AgEnum_arg(AVTR_AUTOPILOT_HORIZ_PLANE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_mode"](arg_newVal.COM_val))

    @property
    def active_heading_course_value(self) -> typing.Any:
        """The heading/course angle or rate for the active mode."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_heading_course_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_heading_course_value.setter
    def active_heading_course_value(self, newVal:typing.Any) -> None:
        """The heading/course angle or rate for the active mode."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_heading_course_value"](arg_newVal.COM_val))

    @property
    def damping_ratio(self) -> float:
        """The damping ratio of the control law."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_damping_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @damping_ratio.setter
    def damping_ratio(self, newVal:float) -> None:
        """The damping ratio of the control law."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_damping_ratio"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_horiz_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_control_limit(self, controlLimitMode:"AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT, controlLimitMode) as arg_controlLimitMode, \
             agmarshall.DOUBLE_arg(controlLimitValue) as arg_controlLimitValue:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit"](arg_controlLimitMode.COM_val, arg_controlLimitValue.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{80382b4b-412a-4c57-8685-7d88a0100cb6}", IBasicManeuverStrategyAutopilotNav)
agcls.AgTypeNameMap["IBasicManeuverStrategyAutopilotNav"] = IBasicManeuverStrategyAutopilotNav

class IBasicManeuverStrategyAutopilotProf(object):
    """Interface used to access options for the Autopilot - Vertical Plane Strategy of a Basic Maneuver Procedure."""
    _uuid = "{762406eb-338d-40c1-9ba5-44c38fb65456}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_get_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_relative_altitude_change"] = _raise_uninitialized_error
        self.__dict__["_set_relative_altitude_change"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_control_mode"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_control_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_altitude_rate_value"] = _raise_uninitialized_error
        self.__dict__["_set_control_altitude_rate_value"] = _raise_uninitialized_error
        self.__dict__["_get_control_fpa_value"] = _raise_uninitialized_error
        self.__dict__["_set_control_fpa_value"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_max_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_set_max_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_get_fly_ballistic"] = _raise_uninitialized_error
        self.__dict__["_set_fly_ballistic"] = _raise_uninitialized_error
        self.__dict__["_get_damping_ratio"] = _raise_uninitialized_error
        self.__dict__["_set_damping_ratio"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyAutopilotProf._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyAutopilotProf from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyAutopilotProf = agcom.GUID(IBasicManeuverStrategyAutopilotProf._uuid)
        vtable_offset_local = IBasicManeuverStrategyAutopilotProf._vtable_offset - 1
        self.__dict__["_get_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_relative_altitude_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_relative_altitude_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_fpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_fpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_altitude_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_control_altitude_rate_value"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_altitude_rate_value"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_control_fpa_value"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_set_control_fpa_value"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+16, agcom.VARIANT)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_max_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+19, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+20, agcom.VARIANT)
        self.__dict__["_get_fly_ballistic"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fly_ballistic"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+22, agcom.VARIANT_BOOL)
        self.__dict__["_get_damping_ratio"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_damping_ratio"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+26, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyAutopilotProf, vtable_offset_local+27, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyAutopilotProf.__dict__ and type(IBasicManeuverStrategyAutopilotProf.__dict__[attrname]) == property:
            return IBasicManeuverStrategyAutopilotProf.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyAutopilotProf.")
    
    @property
    def altitude_mode(self) -> "AVTR_AUTOPILOT_ALTITUDE_MODE":
        """The altitude mode of the autopilot - vertical plane strategy."""
        with agmarshall.AgEnum_arg(AVTR_AUTOPILOT_ALTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_mode.setter
    def altitude_mode(self, newVal:"AVTR_AUTOPILOT_ALTITUDE_MODE") -> None:
        """The altitude mode of the autopilot - vertical plane strategy."""
        with agmarshall.AgEnum_arg(AVTR_AUTOPILOT_ALTITUDE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_mode"](arg_newVal.COM_val))

    @property
    def absolute_altitude(self) -> float:
        """The absolute altitude for the specify altitude mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_absolute_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @absolute_altitude.setter
    def absolute_altitude(self, newVal:float) -> None:
        """The absolute altitude for the specify altitude mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_absolute_altitude"](arg_newVal.COM_val))

    @property
    def relative_altitude_change(self) -> float:
        """The relative altitude change for the specify altitude change mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_altitude_change"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_altitude_change.setter
    def relative_altitude_change(self, newVal:float) -> None:
        """The relative altitude change for the specify altitude change mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_altitude_change"](arg_newVal.COM_val))

    @property
    def altitude_rate(self) -> float:
        """The altitude rate for the specify altitude rate mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The altitude rate for the specify altitude rate mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def fpa(self) -> typing.Any:
        """The flight path angle for the specify wind frame flight path angle mode."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fpa.setter
    def fpa(self, newVal:typing.Any) -> None:
        """The flight path angle for the specify wind frame flight path angle mode."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fpa"](arg_newVal.COM_val))

    @property
    def altitude_control_mode(self) -> "AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE":
        """The altitude control mode for the hold initial altitude, specify altitude, and specify altitude change modes."""
        with agmarshall.AgEnum_arg(AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_control_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_control_mode.setter
    def altitude_control_mode(self, newVal:"AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE") -> None:
        """The altitude control mode for the hold initial altitude, specify altitude, and specify altitude change modes."""
        with agmarshall.AgEnum_arg(AVTR_AUTOPILOT_ALTITUDE_CONTROL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_control_mode"](arg_newVal.COM_val))

    @property
    def control_altitude_rate_value(self) -> float:
        """The altitude rate control value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_altitude_rate_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_altitude_rate_value.setter
    def control_altitude_rate_value(self, newVal:float) -> None:
        """The altitude rate control value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_altitude_rate_value"](arg_newVal.COM_val))

    @property
    def control_fpa_value(self) -> typing.Any:
        """The control flight path angle value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_fpa_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_fpa_value.setter
    def control_fpa_value(self, newVal:typing.Any) -> None:
        """The control flight path angle value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_fpa_value"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The control limits mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_limit_mode.setter
    def control_limit_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The control limits mode."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit_mode"](arg_newVal.COM_val))

    @property
    def max_pitch_rate(self) -> typing.Any:
        """The max pitch rate for the control limits."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_pitch_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_pitch_rate.setter
    def max_pitch_rate(self, newVal:typing.Any) -> None:
        """The max pitch rate for the control limits."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_pitch_rate"](arg_newVal.COM_val))

    @property
    def fly_ballistic(self) -> bool:
        """The option to fly a ballistic trajectory when the performance is insufficient."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fly_ballistic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fly_ballistic.setter
    def fly_ballistic(self, newVal:bool) -> None:
        """The option to fly a ballistic trajectory when the performance is insufficient."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fly_ballistic"](arg_newVal.COM_val))

    @property
    def damping_ratio(self) -> float:
        """The damping ratio of the control law."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_damping_ratio"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @damping_ratio.setter
    def damping_ratio(self, newVal:float) -> None:
        """The damping ratio of the control law."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_damping_ratio"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{762406eb-338d-40c1-9ba5-44c38fb65456}", IBasicManeuverStrategyAutopilotProf)
agcls.AgTypeNameMap["IBasicManeuverStrategyAutopilotProf"] = IBasicManeuverStrategyAutopilotProf

class IBasicManeuverStrategyBarrelRoll(object):
    """Interface used to access options for a Barrel Roll Strategy of a Basic Maneuver Procedure."""
    _uuid = "{7709326e-8835-4118-bf07-714c5983ec58}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_helix_angle"] = _raise_uninitialized_error
        self.__dict__["_set_helix_angle"] = _raise_uninitialized_error
        self.__dict__["_get_helix_angle_mode"] = _raise_uninitialized_error
        self.__dict__["_set_helix_angle_mode"] = _raise_uninitialized_error
        self.__dict__["_get_top_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_top_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_bottom_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_bottom_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_torsion_angle"] = _raise_uninitialized_error
        self.__dict__["_set_torsion_angle"] = _raise_uninitialized_error
        self.__dict__["_get_hold_init_tas"] = _raise_uninitialized_error
        self.__dict__["_set_hold_init_tas"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_top_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_bottom_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_airspeeds"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyBarrelRoll._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyBarrelRoll from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyBarrelRoll = agcom.GUID(IBasicManeuverStrategyBarrelRoll._uuid)
        vtable_offset_local = IBasicManeuverStrategyBarrelRoll._vtable_offset - 1
        self.__dict__["_get_helix_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_helix_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_helix_angle_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_helix_angle_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_top_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_top_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_bottom_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_bottom_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_torsion_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_torsion_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_hold_init_tas"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_hold_init_tas"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_get_top_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_get_bottom_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeeds"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBarrelRoll, vtable_offset_local+16, agcom.LONG, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyBarrelRoll.__dict__ and type(IBasicManeuverStrategyBarrelRoll.__dict__[attrname]) == property:
            return IBasicManeuverStrategyBarrelRoll.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyBarrelRoll.")
    
    @property
    def helix_angle(self) -> typing.Any:
        """The helix angle for the barrel roll. The angle that the aircraft travels around the velocity vector."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_helix_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @helix_angle.setter
    def helix_angle(self, newVal:typing.Any) -> None:
        """The helix angle for the barrel roll. The angle that the aircraft travels around the velocity vector."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_helix_angle"](arg_newVal.COM_val))

    @property
    def helix_angle_mode(self) -> "AVTR_ANGLE_MODE":
        """The helix angle mode for the barrel roll."""
        with agmarshall.AgEnum_arg(AVTR_ANGLE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_helix_angle_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @helix_angle_mode.setter
    def helix_angle_mode(self, newVal:"AVTR_ANGLE_MODE") -> None:
        """The helix angle mode for the barrel roll."""
        with agmarshall.AgEnum_arg(AVTR_ANGLE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_helix_angle_mode"](arg_newVal.COM_val))

    @property
    def top_load_factor(self) -> float:
        """The load factor at the top of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_top_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @top_load_factor.setter
    def top_load_factor(self, newVal:float) -> None:
        """The load factor at the top of the loop."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_top_load_factor"](arg_newVal.COM_val))

    @property
    def bottom_load_factor(self) -> float:
        """The load factor at the bottom of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bottom_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bottom_load_factor.setter
    def bottom_load_factor(self, newVal:float) -> None:
        """The load factor at the bottom of the loop."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bottom_load_factor"](arg_newVal.COM_val))

    @property
    def torsion_angle(self) -> typing.Any:
        """The torsion angle for the barrel roll. The angle of the turn from the aircraft's velocity vector."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_torsion_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @torsion_angle.setter
    def torsion_angle(self, newVal:typing.Any) -> None:
        """The torsion angle for the barrel roll. The angle of the turn from the aircraft's velocity vector."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_torsion_angle"](arg_newVal.COM_val))

    @property
    def hold_init_tas(self) -> bool:
        """The option to hold the initial true airspeed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_init_tas"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hold_init_tas.setter
    def hold_init_tas(self, newVal:bool) -> None:
        """The option to hold the initial true airspeed."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_init_tas"](arg_newVal.COM_val))

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def top_airspeed(self) -> float:
        """The speed at the top of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_top_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def bottom_airspeed(self) -> float:
        """The speed at the bottom of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bottom_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeeds(self, airspeedType:"AVTR_AIRSPEED_TYPE", topAirspeed:float, bottomAirspeed:float) -> None:
        """Set the speeds at the top and bottom of the loop."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(topAirspeed) as arg_topAirspeed, \
             agmarshall.DOUBLE_arg(bottomAirspeed) as arg_bottomAirspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeeds"](arg_airspeedType.COM_val, arg_topAirspeed.COM_val, arg_bottomAirspeed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7709326e-8835-4118-bf07-714c5983ec58}", IBasicManeuverStrategyBarrelRoll)
agcls.AgTypeNameMap["IBasicManeuverStrategyBarrelRoll"] = IBasicManeuverStrategyBarrelRoll

class IBasicManeuverStrategyLoop(object):
    """Interface used to access options for a Loop Strategy of a Basic Maneuver Procedure."""
    _uuid = "{812dd3a8-77ec-44eb-8a7d-e51b6e9e4942}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_loop_angle"] = _raise_uninitialized_error
        self.__dict__["_set_loop_angle"] = _raise_uninitialized_error
        self.__dict__["_get_loop_angle_mode"] = _raise_uninitialized_error
        self.__dict__["_set_loop_angle_mode"] = _raise_uninitialized_error
        self.__dict__["_get_top_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_top_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_bottom_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_bottom_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_hold_init_tas"] = _raise_uninitialized_error
        self.__dict__["_set_hold_init_tas"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_top_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_bottom_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_airspeeds"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyLoop._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyLoop from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyLoop = agcom.GUID(IBasicManeuverStrategyLoop._uuid)
        vtable_offset_local = IBasicManeuverStrategyLoop._vtable_offset - 1
        self.__dict__["_get_loop_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_loop_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_loop_angle_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_loop_angle_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_top_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_top_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_bottom_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_bottom_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_hold_init_tas"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_hold_init_tas"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_get_top_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_get_bottom_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeeds"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLoop, vtable_offset_local+14, agcom.LONG, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyLoop.__dict__ and type(IBasicManeuverStrategyLoop.__dict__[attrname]) == property:
            return IBasicManeuverStrategyLoop.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyLoop.")
    
    @property
    def loop_angle(self) -> typing.Any:
        """The loop angle for maneuver. The total change in pitch angle the aircraft flies."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_loop_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @loop_angle.setter
    def loop_angle(self, newVal:typing.Any) -> None:
        """The loop angle for maneuver. The total change in pitch angle the aircraft flies."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_loop_angle"](arg_newVal.COM_val))

    @property
    def loop_angle_mode(self) -> "AVTR_ANGLE_MODE":
        """The loop angle mode for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ANGLE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_loop_angle_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @loop_angle_mode.setter
    def loop_angle_mode(self, newVal:"AVTR_ANGLE_MODE") -> None:
        """The loop angle mode for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ANGLE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_loop_angle_mode"](arg_newVal.COM_val))

    @property
    def top_load_factor(self) -> float:
        """The load factor at the top of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_top_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @top_load_factor.setter
    def top_load_factor(self, newVal:float) -> None:
        """The load factor at the top of the loop."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_top_load_factor"](arg_newVal.COM_val))

    @property
    def bottom_load_factor(self) -> float:
        """The load factor at the bottom of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bottom_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bottom_load_factor.setter
    def bottom_load_factor(self, newVal:float) -> None:
        """The load factor at the bottom of the loop."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bottom_load_factor"](arg_newVal.COM_val))

    @property
    def hold_init_tas(self) -> bool:
        """The option to hold the initial true airspeed."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_init_tas"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hold_init_tas.setter
    def hold_init_tas(self, newVal:bool) -> None:
        """The option to hold the initial true airspeed."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_init_tas"](arg_newVal.COM_val))

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def top_airspeed(self) -> float:
        """The speed at the top of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_top_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def bottom_airspeed(self) -> float:
        """The speed at the bottom of the loop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bottom_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeeds(self, airspeedType:"AVTR_AIRSPEED_TYPE", topAirspeed:float, bottomAirspeed:float) -> None:
        """Set the speeds at the top and bottom of the loop."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(topAirspeed) as arg_topAirspeed, \
             agmarshall.DOUBLE_arg(bottomAirspeed) as arg_bottomAirspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeeds"](arg_airspeedType.COM_val, arg_topAirspeed.COM_val, arg_bottomAirspeed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{812dd3a8-77ec-44eb-8a7d-e51b6e9e4942}", IBasicManeuverStrategyLoop)
agcls.AgTypeNameMap["IBasicManeuverStrategyLoop"] = IBasicManeuverStrategyLoop

class IBasicManeuverStrategyLTAHover(object):
    """Interface used to access options for a Lighter than Air Hover Strategy of a Basic Maneuver Procedure."""
    _uuid = "{d3684b67-cb9c-4b8a-a774-226363c4f090}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_set_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_get_relative_heading"] = _raise_uninitialized_error
        self.__dict__["_set_relative_heading"] = _raise_uninitialized_error
        self.__dict__["_get_absolute_heading"] = _raise_uninitialized_error
        self.__dict__["_set_absolute_heading"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_set_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_get_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_relative_altitude_change"] = _raise_uninitialized_error
        self.__dict__["_set_relative_altitude_change"] = _raise_uninitialized_error
        self.__dict__["_get_control_alt_rate"] = _raise_uninitialized_error
        self.__dict__["_set_control_alt_rate"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_parachute_area"] = _raise_uninitialized_error
        self.__dict__["_set_parachute_area"] = _raise_uninitialized_error
        self.__dict__["_get_parachute_cd"] = _raise_uninitialized_error
        self.__dict__["_set_parachute_cd"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyLTAHover._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyLTAHover from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyLTAHover = agcom.GUID(IBasicManeuverStrategyLTAHover._uuid)
        vtable_offset_local = IBasicManeuverStrategyLTAHover._vtable_offset - 1
        self.__dict__["_get_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_relative_heading"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_relative_heading"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_absolute_heading"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_absolute_heading"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_relative_altitude_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_relative_altitude_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_control_alt_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_alt_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_parachute_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_parachute_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_parachute_cd"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_parachute_cd"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyLTAHover, vtable_offset_local+24, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyLTAHover.__dict__ and type(IBasicManeuverStrategyLTAHover.__dict__[attrname]) == property:
            return IBasicManeuverStrategyLTAHover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyLTAHover.")
    
    @property
    def heading_mode(self) -> "AVTR_HOVER_HEADING_MODE":
        """The heading mode for the lighter than air hover."""
        with agmarshall.AgEnum_arg(AVTR_HOVER_HEADING_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_mode.setter
    def heading_mode(self, newVal:"AVTR_HOVER_HEADING_MODE") -> None:
        """The heading mode for the lighter than air hover."""
        with agmarshall.AgEnum_arg(AVTR_HOVER_HEADING_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_mode"](arg_newVal.COM_val))

    @property
    def relative_heading(self) -> typing.Any:
        """The relative heading for the relative to start heading mode."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_heading.setter
    def relative_heading(self, newVal:typing.Any) -> None:
        """The relative heading for the relative to start heading mode."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_heading"](arg_newVal.COM_val))

    @property
    def absolute_heading(self) -> typing.Any:
        """The absolute heading for the absolute heading mode."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_absolute_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @absolute_heading.setter
    def absolute_heading(self, newVal:typing.Any) -> None:
        """The absolute heading for the absolute heading mode."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_absolute_heading"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magentic heading for the absolute heading mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magentic heading for the absolute heading mode."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_heading"](arg_newVal.COM_val))

    @property
    def heading_rate(self) -> typing.Any:
        """The maximum heading rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_rate.setter
    def heading_rate(self, newVal:typing.Any) -> None:
        """The maximum heading rate."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_rate"](arg_newVal.COM_val))

    @property
    def altitude_mode(self) -> "AVTR_HOVER_ALTITUDE_MODE":
        """The altitude mode for the lighter than air hover."""
        with agmarshall.AgEnum_arg(AVTR_HOVER_ALTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_mode.setter
    def altitude_mode(self, newVal:"AVTR_HOVER_ALTITUDE_MODE") -> None:
        """The altitude mode for the lighter than air hover."""
        with agmarshall.AgEnum_arg(AVTR_HOVER_ALTITUDE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_mode"](arg_newVal.COM_val))

    @property
    def absolute_altitude(self) -> float:
        """The absolute altitude for the Specify Altitude mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_absolute_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @absolute_altitude.setter
    def absolute_altitude(self, newVal:float) -> None:
        """The absolute altitude for the Specify Altitude mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_absolute_altitude"](arg_newVal.COM_val))

    @property
    def relative_altitude_change(self) -> float:
        """The relative altitude change for the Specify Altitude Change mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_altitude_change"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_altitude_change.setter
    def relative_altitude_change(self, newVal:float) -> None:
        """The relative altitude change for the Specify Altitude Change mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_altitude_change"](arg_newVal.COM_val))

    @property
    def control_alt_rate(self) -> float:
        """The controlled altitude rate for the Specify Altitude or Specify Altitude Change mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_alt_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_alt_rate.setter
    def control_alt_rate(self, newVal:float) -> None:
        """The controlled altitude rate for the Specify Altitude or Specify Altitude Change mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_alt_rate"](arg_newVal.COM_val))

    @property
    def altitude_rate(self) -> float:
        """The altitude rate for the Specify Altitude Rate mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The altitude rate for the Specify Altitude Rate mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def parachute_area(self) -> float:
        """The parachute area for the Parachute mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parachute_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @parachute_area.setter
    def parachute_area(self, newVal:float) -> None:
        """The parachute area for the Parachute mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_parachute_area"](arg_newVal.COM_val))

    @property
    def parachute_cd(self) -> float:
        """The parachute drag coefficient for the Parachute mode."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parachute_cd"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @parachute_cd.setter
    def parachute_cd(self, newVal:float) -> None:
        """The parachute drag coefficient for the Parachute mode."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_parachute_cd"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{d3684b67-cb9c-4b8a-a774-226363c4f090}", IBasicManeuverStrategyLTAHover)
agcls.AgTypeNameMap["IBasicManeuverStrategyLTAHover"] = IBasicManeuverStrategyLTAHover

class IBasicManeuverStrategyFlyAOA(object):
    """Interface used to access options for a Fly AOA Strategy of a Basic Maneuver Procedure."""
    _uuid = "{aac777b5-967c-4e54-b09a-2ec30898fc53}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_get_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_set_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate_dot"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate_dot"] = _raise_uninitialized_error
        self.__dict__["_get_control_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_control_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_stop_on_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_stop_on_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyFlyAOA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyFlyAOA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyFlyAOA = agcom.GUID(IBasicManeuverStrategyFlyAOA._uuid)
        vtable_offset_local = IBasicManeuverStrategyFlyAOA._vtable_offset - 1
        self.__dict__["_get_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_roll_rate_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_rate_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_control_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_control_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_stop_on_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_stop_on_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_aoa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_set_aoa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+16, agcom.VARIANT)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyFlyAOA, vtable_offset_local+17, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyFlyAOA.__dict__ and type(IBasicManeuverStrategyFlyAOA.__dict__[attrname]) == property:
            return IBasicManeuverStrategyFlyAOA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyFlyAOA.")
    
    @property
    def turn_direction(self) -> "AVTR_FLY_AOA_LEFT_RIGHT":
        """The roll turn direction for a Fly AOA basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_FLY_AOA_LEFT_RIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_direction.setter
    def turn_direction(self, newVal:"AVTR_FLY_AOA_LEFT_RIGHT") -> None:
        """The roll turn direction for a Fly AOA basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_FLY_AOA_LEFT_RIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_direction"](arg_newVal.COM_val))

    @property
    def roll_rate_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The roll rate mode for a Fly AOA basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for a Fly AOA basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate_mode"](arg_newVal.COM_val))

    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value for the Fly AOA basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_roll_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override value for the Fly AOA basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_roll_rate"](arg_newVal.COM_val))

    @property
    def roll_rate_dot(self) -> typing.Any:
        """The rate of change of the roll rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate_dot.setter
    def roll_rate_dot(self, newVal:typing.Any) -> None:
        """The rate of change of the roll rate."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate_dot"](arg_newVal.COM_val))

    @property
    def control_roll_angle(self) -> bool:
        """The option to define a goal value for the aircraft's roll angle."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_roll_angle.setter
    def control_roll_angle(self, newVal:bool) -> None:
        """The option to define a goal value for the aircraft's roll angle."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_roll_angle"](arg_newVal.COM_val))

    @property
    def roll_angle(self) -> typing.Any:
        """The goal value for the roll angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The goal value for the roll angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_angle"](arg_newVal.COM_val))

    @property
    def stop_on_roll_angle(self) -> bool:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_on_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_on_roll_angle.setter
    def stop_on_roll_angle(self, newVal:bool) -> None:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_on_roll_angle"](arg_newVal.COM_val))

    @property
    def aoa(self) -> typing.Any:
        """The angle of attack."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The angle of attack."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_aoa"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{aac777b5-967c-4e54-b09a-2ec30898fc53}", IBasicManeuverStrategyFlyAOA)
agcls.AgTypeNameMap["IBasicManeuverStrategyFlyAOA"] = IBasicManeuverStrategyFlyAOA

class IBasicManeuverStrategyPull(object):
    """Interface used to access options for a Pull Strategy of a Basic Maneuver Procedure."""
    _uuid = "{53ecb06b-3d2f-4e3b-b179-95686a71c7e1}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_active_mode"] = _raise_uninitialized_error
        self.__dict__["_set_active_mode"] = _raise_uninitialized_error
        self.__dict__["_get_active_angle"] = _raise_uninitialized_error
        self.__dict__["_set_active_angle"] = _raise_uninitialized_error
        self.__dict__["_get_pull_g_mode"] = _raise_uninitialized_error
        self.__dict__["_set_pull_g_mode"] = _raise_uninitialized_error
        self.__dict__["_get_override_pull_g"] = _raise_uninitialized_error
        self.__dict__["_set_override_pull_g"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyPull._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyPull from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyPull = agcom.GUID(IBasicManeuverStrategyPull._uuid)
        vtable_offset_local = IBasicManeuverStrategyPull._vtable_offset - 1
        self.__dict__["_get_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_active_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_active_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_pull_g_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_pull_g_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_override_pull_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_pull_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPull, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyPull.__dict__ and type(IBasicManeuverStrategyPull.__dict__[attrname]) == property:
            return IBasicManeuverStrategyPull.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyPull.")
    
    @property
    def active_mode(self) -> "AVTR_PULL_MODE":
        """The pull mode for the pull basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PULL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_mode.setter
    def active_mode(self, newVal:"AVTR_PULL_MODE") -> None:
        """The pull mode for the pull basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PULL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_mode"](arg_newVal.COM_val))

    @property
    def active_angle(self) -> typing.Any:
        """The pull angle for the active mode."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_angle.setter
    def active_angle(self, newVal:typing.Any) -> None:
        """The roll angle for the active mode."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_angle"](arg_newVal.COM_val))

    @property
    def pull_g_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The pull G mode for a pull basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pull_g_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pull_g_mode.setter
    def pull_g_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The pull G mode for a pull basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pull_g_mode"](arg_newVal.COM_val))

    @property
    def override_pull_g(self) -> float:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_pull_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_pull_g.setter
    def override_pull_g(self, newVal:float) -> None:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_pull_g"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{53ecb06b-3d2f-4e3b-b179-95686a71c7e1}", IBasicManeuverStrategyPull)
agcls.AgTypeNameMap["IBasicManeuverStrategyPull"] = IBasicManeuverStrategyPull

class IBasicManeuverStrategyRollingPull(object):
    """Interface used to access options for a Rolling Pull Strategy of a Basic Maneuver Procedure."""
    _uuid = "{1481380c-fbad-46f2-bab0-8bba39fb3edc}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_active_mode"] = _raise_uninitialized_error
        self.__dict__["_set_active_mode"] = _raise_uninitialized_error
        self.__dict__["_get_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_angle"] = _raise_uninitialized_error
        self.__dict__["_set_angle"] = _raise_uninitialized_error
        self.__dict__["_get_roll_orientation"] = _raise_uninitialized_error
        self.__dict__["_set_roll_orientation"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_get_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_set_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_get_pull_g_mode"] = _raise_uninitialized_error
        self.__dict__["_set_pull_g_mode"] = _raise_uninitialized_error
        self.__dict__["_get_override_pull_g"] = _raise_uninitialized_error
        self.__dict__["_set_override_pull_g"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyRollingPull._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRollingPull from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyRollingPull = agcom.GUID(IBasicManeuverStrategyRollingPull._uuid)
        vtable_offset_local = IBasicManeuverStrategyRollingPull._vtable_offset - 1
        self.__dict__["_get_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_active_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_roll_orientation"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_roll_orientation"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_pull_g_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_pull_g_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_override_pull_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_pull_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRollingPull, vtable_offset_local+17, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRollingPull.__dict__ and type(IBasicManeuverStrategyRollingPull.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRollingPull.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRollingPull.")
    
    @property
    def active_mode(self) -> "AVTR_ROLLING_PULL_MODE":
        """The active mode for the rolling pull basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_ROLLING_PULL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active_mode.setter
    def active_mode(self, newVal:"AVTR_ROLLING_PULL_MODE") -> None:
        """The active mode for the rolling pull basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_ROLLING_PULL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active_mode"](arg_newVal.COM_val))

    @property
    def turn_direction(self) -> "AVTR_ROLL_LEFT_RIGHT":
        """The turn direction for the active mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_LEFT_RIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_direction.setter
    def turn_direction(self, newVal:"AVTR_ROLL_LEFT_RIGHT") -> None:
        """The turn direction for the active mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_LEFT_RIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_direction"](arg_newVal.COM_val))

    @property
    def angle(self) -> typing.Any:
        """The angle value for the active mode."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @angle.setter
    def angle(self, newVal:typing.Any) -> None:
        """The angle value for the active mode"""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_angle"](arg_newVal.COM_val))

    @property
    def roll_orientation(self) -> "AVTR_ROLL_UPRIGHT_INVERTED":
        """The orientation to roll to for the roll to orientation mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_UPRIGHT_INVERTED) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_orientation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_orientation.setter
    def roll_orientation(self, newVal:"AVTR_ROLL_UPRIGHT_INVERTED") -> None:
        """The orientation to roll to for the roll to orientation mode."""
        with agmarshall.AgEnum_arg(AVTR_ROLL_UPRIGHT_INVERTED, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_orientation"](arg_newVal.COM_val))

    @property
    def roll_rate_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The roll rate mode for the rolling pull."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for the rolling pull."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate_mode"](arg_newVal.COM_val))

    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_roll_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_roll_rate"](arg_newVal.COM_val))

    @property
    def pull_g_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The pull G mode for a rolling pull."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pull_g_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pull_g_mode.setter
    def pull_g_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The pull G mode for a rolling pull."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pull_g_mode"](arg_newVal.COM_val))

    @property
    def override_pull_g(self) -> float:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_pull_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_pull_g.setter
    def override_pull_g(self, newVal:float) -> None:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_pull_g"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1481380c-fbad-46f2-bab0-8bba39fb3edc}", IBasicManeuverStrategyRollingPull)
agcls.AgTypeNameMap["IBasicManeuverStrategyRollingPull"] = IBasicManeuverStrategyRollingPull

class IBasicManeuverStrategySmoothAccel(object):
    """Interface used to access options for a Smooth Accel Strategy of a Basic Maneuver Procedure."""
    _uuid = "{b7dbc9ce-b749-4d60-bea1-d6f88415bc6e}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_get_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_set_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate_dot"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate_dot"] = _raise_uninitialized_error
        self.__dict__["_get_control_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_control_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_load_factor_mode"] = _raise_uninitialized_error
        self.__dict__["_set_load_factor_mode"] = _raise_uninitialized_error
        self.__dict__["_get_override_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_override_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_load_factor_dot"] = _raise_uninitialized_error
        self.__dict__["_set_load_factor_dot"] = _raise_uninitialized_error
        self.__dict__["_get_control_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_set_control_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_get_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_set_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_get_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_stop_on_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_stop_on_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_stop_on_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_set_stop_on_pitch_angle"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategySmoothAccel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategySmoothAccel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategySmoothAccel = agcom.GUID(IBasicManeuverStrategySmoothAccel._uuid)
        vtable_offset_local = IBasicManeuverStrategySmoothAccel._vtable_offset - 1
        self.__dict__["_get_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_roll_rate_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_rate_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_control_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_control_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_load_factor_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_load_factor_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_override_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_load_factor_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_load_factor_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_control_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_control_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_get_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+21, POINTER(agcom.VARIANT))
        self.__dict__["_set_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+22, agcom.VARIANT)
        self.__dict__["_get_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_get_stop_on_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+25, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_stop_on_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+26, agcom.VARIANT_BOOL)
        self.__dict__["_get_stop_on_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_stop_on_pitch_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+28, agcom.VARIANT_BOOL)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothAccel, vtable_offset_local+29, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategySmoothAccel.__dict__ and type(IBasicManeuverStrategySmoothAccel.__dict__[attrname]) == property:
            return IBasicManeuverStrategySmoothAccel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategySmoothAccel.")
    
    @property
    def turn_direction(self) -> "AVTR_SMOOTH_ACCEL_LEFT_RIGHT":
        """The roll turn direction for a Smooth Accel basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_ACCEL_LEFT_RIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_direction.setter
    def turn_direction(self, newVal:"AVTR_SMOOTH_ACCEL_LEFT_RIGHT") -> None:
        """The roll turn direction for a Smooth Accel  basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_ACCEL_LEFT_RIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_direction"](arg_newVal.COM_val))

    @property
    def roll_rate_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The roll rate mode for a Smooth Accel basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for a Smooth Accel basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate_mode"](arg_newVal.COM_val))

    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value for the Smooth Accel basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_roll_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override value for the Smooth Accel basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_roll_rate"](arg_newVal.COM_val))

    @property
    def roll_rate_dot(self) -> typing.Any:
        """The rate of change of the roll rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate_dot.setter
    def roll_rate_dot(self, newVal:typing.Any) -> None:
        """The rate of change of the roll rate."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate_dot"](arg_newVal.COM_val))

    @property
    def control_roll_angle(self) -> bool:
        """The option to define a goal value for the aircraft's roll angle."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_roll_angle.setter
    def control_roll_angle(self, newVal:bool) -> None:
        """The option to define a goal value for the aircraft's roll angle."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_roll_angle"](arg_newVal.COM_val))

    @property
    def roll_angle(self) -> typing.Any:
        """The goal value for the roll angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The goal value for the roll angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_angle"](arg_newVal.COM_val))

    @property
    def load_factor_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The load factor mode for the Smooth Accel basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_load_factor_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @load_factor_mode.setter
    def load_factor_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The load factormode for the Smooth Accel basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_load_factor_mode"](arg_newVal.COM_val))

    @property
    def override_load_factor(self) -> float:
        """The load factor override value for the smooth accel. The load factor mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_load_factor.setter
    def override_load_factor(self, newVal:float) -> None:
        """The load factor override value for the smooth accel. The load factor mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_load_factor"](arg_newVal.COM_val))

    @property
    def load_factor_dot(self) -> float:
        """The rate of change of the load factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_load_factor_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @load_factor_dot.setter
    def load_factor_dot(self, newVal:float) -> None:
        """The rate of change of the load factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_load_factor_dot"](arg_newVal.COM_val))

    @property
    def control_pitch_angle(self) -> bool:
        """The option to define a goal value for the aircraft's pitch angle."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_pitch_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_pitch_angle.setter
    def control_pitch_angle(self, newVal:bool) -> None:
        """The option to define a goal value for the aircraft's pitch angle."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_pitch_angle"](arg_newVal.COM_val))

    @property
    def pitch_angle(self) -> typing.Any:
        """The goal value for the pitch angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pitch_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pitch_angle.setter
    def pitch_angle(self, newVal:typing.Any) -> None:
        """The goal value for the pitch angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pitch_angle"](arg_newVal.COM_val))

    @property
    def stop_conditions(self) -> "AVTR_SMOOTH_ACCEL_STOP_CONDITIONS":
        """The stop condition for the Smooth Accel basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_ACCEL_STOP_CONDITIONS) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_conditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_conditions.setter
    def stop_conditions(self, newVal:"AVTR_SMOOTH_ACCEL_STOP_CONDITIONS") -> None:
        """The stop condition for the Smooth Accel  basic maneuver strategy."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_ACCEL_STOP_CONDITIONS, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_conditions"](arg_newVal.COM_val))

    @property
    def stop_on_roll_angle(self) -> bool:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_on_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_on_roll_angle.setter
    def stop_on_roll_angle(self, newVal:bool) -> None:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_on_roll_angle"](arg_newVal.COM_val))

    @property
    def stop_on_pitch_angle(self) -> bool:
        """The option to stop the maneuver if the specified pitch angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_on_pitch_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_on_pitch_angle.setter
    def stop_on_pitch_angle(self, newVal:bool) -> None:
        """The option to stop the maneuver if the specified pitch angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_on_pitch_angle"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{b7dbc9ce-b749-4d60-bea1-d6f88415bc6e}", IBasicManeuverStrategySmoothAccel)
agcls.AgTypeNameMap["IBasicManeuverStrategySmoothAccel"] = IBasicManeuverStrategySmoothAccel

class IBasicManeuverStrategySmoothTurn(object):
    """Interface used to access options for a Smooth Turn Strategy of a Basic Maneuver Procedure."""
    _uuid = "{888b4f4a-ffe2-4c3b-a8b0-5cdd45e4adcd}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_heading_change"] = _raise_uninitialized_error
        self.__dict__["_set_heading_change"] = _raise_uninitialized_error
        self.__dict__["_get_turn_mode"] = _raise_uninitialized_error
        self.__dict__["_set_turn_mode"] = _raise_uninitialized_error
        self.__dict__["_get_load_factor_mode"] = _raise_uninitialized_error
        self.__dict__["_set_load_factor_mode"] = _raise_uninitialized_error
        self.__dict__["_get_max_load_factor_rate"] = _raise_uninitialized_error
        self.__dict__["_set_max_load_factor_rate"] = _raise_uninitialized_error
        self.__dict__["_get_override_load_factor"] = _raise_uninitialized_error
        self.__dict__["_set_override_load_factor"] = _raise_uninitialized_error
        self.__dict__["_get_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_set_roll_rate_mode"] = _raise_uninitialized_error
        self.__dict__["_get_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_set_override_roll_rate"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_fpa_mode"] = _raise_uninitialized_error
        self.__dict__["_set_fpa_mode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategySmoothTurn._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategySmoothTurn from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategySmoothTurn = agcom.GUID(IBasicManeuverStrategySmoothTurn._uuid)
        vtable_offset_local = IBasicManeuverStrategySmoothTurn._vtable_offset - 1
        self.__dict__["_get_heading_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_turn_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_turn_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_load_factor_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_load_factor_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_max_load_factor_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_load_factor_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_override_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_load_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_roll_rate_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_set_override_roll_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+16, agcom.VARIANT)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_get_fpa_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_set_fpa_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySmoothTurn, vtable_offset_local+19, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategySmoothTurn.__dict__ and type(IBasicManeuverStrategySmoothTurn.__dict__[attrname]) == property:
            return IBasicManeuverStrategySmoothTurn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategySmoothTurn.")
    
    @property
    def heading_change(self) -> typing.Any:
        """The heading change for the smooth turn."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_change"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_change.setter
    def heading_change(self, newVal:typing.Any) -> None:
        """The heading change for the smooth turn."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_change"](arg_newVal.COM_val))

    @property
    def turn_mode(self) -> "AVTR_SMOOTH_TURN_MODE":
        """The turn mode for the smooth turn."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_TURN_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_mode.setter
    def turn_mode(self, newVal:"AVTR_SMOOTH_TURN_MODE") -> None:
        """The turn mode for the smooth turn."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_TURN_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_mode"](arg_newVal.COM_val))

    @property
    def load_factor_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The load factor mode for the smooth turn."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_load_factor_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @load_factor_mode.setter
    def load_factor_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The load factormode for the smooth turn."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_load_factor_mode"](arg_newVal.COM_val))

    @property
    def max_load_factor_rate(self) -> float:
        """The max load factor rate for the smooth turn."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_load_factor_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_load_factor_rate.setter
    def max_load_factor_rate(self, newVal:float) -> None:
        """The max load factor rate for the smooth turn."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_load_factor_rate"](arg_newVal.COM_val))

    @property
    def override_load_factor(self) -> float:
        """The max load factor override value for the smooth turn. The load factor mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_load_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_load_factor.setter
    def override_load_factor(self, newVal:float) -> None:
        """The max load factor override value for the smooth turn. The load factor mode must be set to override to access this property."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_load_factor"](arg_newVal.COM_val))

    @property
    def roll_rate_mode(self) -> "AVTR_PERF_MODEL_OVERRIDE":
        """The roll rate mode for the smooth turn."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_rate_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"AVTR_PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for the smooth turn."""
        with agmarshall.AgEnum_arg(AVTR_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_rate_mode"](arg_newVal.COM_val))

    @property
    def roll_angle(self) -> typing.Any:
        """The roll angle for the smooth turn."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The roll angle for the smooth turn."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_angle"](arg_newVal.COM_val))

    @property
    def override_roll_rate(self) -> typing.Any:
        """The max roll rate override value for the smooth turn. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_roll_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The max roll rate override value for the smooth turn. The roll rate mode must be set to override to access this property."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_roll_rate"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def fpa_mode(self) -> "AVTR_SMOOTH_TURN_FPA_MODE":
        """The flight path angle mode."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_TURN_FPA_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fpa_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fpa_mode.setter
    def fpa_mode(self, newVal:"AVTR_SMOOTH_TURN_FPA_MODE") -> None:
        """The flight path angle mode."""
        with agmarshall.AgEnum_arg(AVTR_SMOOTH_TURN_FPA_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fpa_mode"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{888b4f4a-ffe2-4c3b-a8b0-5cdd45e4adcd}", IBasicManeuverStrategySmoothTurn)
agcls.AgTypeNameMap["IBasicManeuverStrategySmoothTurn"] = IBasicManeuverStrategySmoothTurn

class IBasicManeuverStrategySimpleTurn(object):
    """Interface used to access options for a Simple Turn Strategy of a Basic Maneuver Procedure."""
    _uuid = "{3bae3110-3f6a-4c3d-914d-8592f3886f66}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_turn_angle"] = _raise_uninitialized_error
        self.__dict__["_set_turn_angle"] = _raise_uninitialized_error
        self.__dict__["_get_turn_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_turn_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategySimpleTurn._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategySimpleTurn from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategySimpleTurn = agcom.GUID(IBasicManeuverStrategySimpleTurn._uuid)
        vtable_offset_local = IBasicManeuverStrategySimpleTurn._vtable_offset - 1
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_turn_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_turn_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategySimpleTurn, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategySimpleTurn.__dict__ and type(IBasicManeuverStrategySimpleTurn.__dict__[attrname]) == property:
            return IBasicManeuverStrategySimpleTurn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategySimpleTurn.")
    
    @property
    def reference_frame(self) -> "AVTR_BASIC_MANEUVER_REF_FRAME":
        """The reference frame for the simple turn."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @reference_frame.setter
    def reference_frame(self, inVal:"AVTR_BASIC_MANEUVER_REF_FRAME") -> None:
        """The reference frame for the simple turn."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_inVal.COM_val))

    @property
    def turn_angle(self) -> typing.Any:
        """The turn angle for the simple turn."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_angle.setter
    def turn_angle(self, newVal:typing.Any) -> None:
        """The turn angle for the simple turn."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_angle"](arg_newVal.COM_val))

    @property
    def turn_radius_factor(self) -> float:
        """The turn radius factor for the simple turn."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_radius_factor.setter
    def turn_radius_factor(self, newVal:float) -> None:
        """The turn radius factor for the simple turn."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_radius_factor"](arg_newVal.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3bae3110-3f6a-4c3d-914d-8592f3886f66}", IBasicManeuverStrategySimpleTurn)
agcls.AgTypeNameMap["IBasicManeuverStrategySimpleTurn"] = IBasicManeuverStrategySimpleTurn

class IBasicManeuverStrategyIntercept(object):
    """Interface used to access options for an Intercept Strategy of a Basic Maneuver Procedure."""
    _uuid = "{ab1da5c8-fd9b-49bc-adfd-69754a5376f5}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_target_names"] = _raise_uninitialized_error
        self.__dict__["_get_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_set_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_time_to_go"] = _raise_uninitialized_error
        self.__dict__["_get_stop_time_to_go"] = _raise_uninitialized_error
        self.__dict__["_set_stop_time_to_go"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_slant_range"] = _raise_uninitialized_error
        self.__dict__["_get_stop_slant_range"] = _raise_uninitialized_error
        self.__dict__["_set_stop_slant_range"] = _raise_uninitialized_error
        self.__dict__["_get_intercept_mode"] = _raise_uninitialized_error
        self.__dict__["_set_intercept_mode"] = _raise_uninitialized_error
        self.__dict__["_get_target_aspect"] = _raise_uninitialized_error
        self.__dict__["_set_target_aspect"] = _raise_uninitialized_error
        self.__dict__["_get_lateral_separation"] = _raise_uninitialized_error
        self.__dict__["_set_lateral_separation"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_radius"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_rate"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_horiz_accel"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit"] = _raise_uninitialized_error
        self.__dict__["_get_closure_mode"] = _raise_uninitialized_error
        self.__dict__["_set_closure_mode"] = _raise_uninitialized_error
        self.__dict__["_get_hobs_max_angle"] = _raise_uninitialized_error
        self.__dict__["_set_hobs_max_angle"] = _raise_uninitialized_error
        self.__dict__["_get_hobs_angle_tol"] = _raise_uninitialized_error
        self.__dict__["_set_hobs_angle_tol"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyIntercept._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyIntercept from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyIntercept = agcom.GUID(IBasicManeuverStrategyIntercept._uuid)
        vtable_offset_local = IBasicManeuverStrategyIntercept._vtable_offset - 1
        self.__dict__["_get_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_target_names"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_use_stop_time_to_go"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_stop_time_to_go"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_time_to_go"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+8, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_use_stop_slant_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_stop_slant_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_slant_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+11, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_intercept_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_intercept_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_target_aspect"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_target_aspect"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+15, agcom.VARIANT)
        self.__dict__["_get_lateral_separation"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lateral_separation"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_get_control_limit_turn_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_get_control_limit_turn_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+22, POINTER(agcom.VARIANT))
        self.__dict__["_get_control_limit_horiz_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_limit"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+24, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_closure_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+25, POINTER(agcom.LONG))
        self.__dict__["_set_closure_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+26, agcom.LONG)
        self.__dict__["_get_hobs_max_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+27, POINTER(agcom.VARIANT))
        self.__dict__["_set_hobs_max_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+28, agcom.VARIANT)
        self.__dict__["_get_hobs_angle_tol"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+29, POINTER(agcom.VARIANT))
        self.__dict__["_set_hobs_angle_tol"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+30, agcom.VARIANT)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+31, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyIntercept, vtable_offset_local+32, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyIntercept.__dict__ and type(IBasicManeuverStrategyIntercept.__dict__[attrname]) == property:
            return IBasicManeuverStrategyIntercept.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyIntercept.")
    
    @property
    def target_name(self) -> str:
        """The target name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_name"](arg_newVal.COM_val))

    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_target_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_resolution"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_resolution"](arg_newVal.COM_val))

    @property
    def use_stop_time_to_go(self) -> bool:
        """The option to specify a time to go stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_time_to_go"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_time_to_go(self) -> float:
        """The stop time from the target at which the maneuver will stop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_time_to_go"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_time_to_go(self, enable:bool, time:float) -> None:
        """Set the option to use the stop time from target stopping condition and set the according value."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(time) as arg_time:
            agcls.evaluate_hresult(self.__dict__["_set_stop_time_to_go"](arg_enable.COM_val, arg_time.COM_val))

    @property
    def use_stop_slant_range(self) -> bool:
        """The option to specify a range from target stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_slant_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_slant_range(self) -> float:
        """The range from the target at which the maneuver will stop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_slant_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_slant_range(self, enable:bool, range:float) -> None:
        """Set the option to use the stop slant range stopping condition and set the according value."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(range) as arg_range:
            agcls.evaluate_hresult(self.__dict__["_set_stop_slant_range"](arg_enable.COM_val, arg_range.COM_val))

    @property
    def intercept_mode(self) -> "AVTR_INTERCEPT_MODE":
        """The intercept mode."""
        with agmarshall.AgEnum_arg(AVTR_INTERCEPT_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_intercept_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @intercept_mode.setter
    def intercept_mode(self, newVal:"AVTR_INTERCEPT_MODE") -> None:
        """The intercept mode."""
        with agmarshall.AgEnum_arg(AVTR_INTERCEPT_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_intercept_mode"](arg_newVal.COM_val))

    @property
    def target_aspect(self) -> typing.Any:
        """The angle relative to the target that the aircraft should maintain until intercept."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_aspect"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_aspect.setter
    def target_aspect(self, newVal:typing.Any) -> None:
        """The angle relative to the target that the aircraft should maintain until intercept."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_aspect"](arg_newVal.COM_val))

    @property
    def lateral_separation(self) -> float:
        """The distance from the target that the aircraft will guide to before intercepting."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lateral_separation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lateral_separation.setter
    def lateral_separation(self, newVal:float) -> None:
        """The distance from the target that the aircraft will guide to before intercepting."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lateral_separation"](arg_newVal.COM_val))

    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_factor"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_horiz_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_control_limit(self, controlLimitMode:"AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT, controlLimitMode) as arg_controlLimitMode, \
             agmarshall.DOUBLE_arg(controlLimitValue) as arg_controlLimitValue:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit"](arg_controlLimitMode.COM_val, arg_controlLimitValue.COM_val))

    @property
    def closure_mode(self) -> "AVTR_CLOSURE_MODE":
        """The closure mode for the guidance strategy."""
        with agmarshall.AgEnum_arg(AVTR_CLOSURE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_closure_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @closure_mode.setter
    def closure_mode(self, newVal:"AVTR_CLOSURE_MODE") -> None:
        """The closure mode for the guidance strategy."""
        with agmarshall.AgEnum_arg(AVTR_CLOSURE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_closure_mode"](arg_newVal.COM_val))

    @property
    def hobs_max_angle(self) -> typing.Any:
        """The closure high off boresight max angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hobs_max_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hobs_max_angle.setter
    def hobs_max_angle(self, newVal:typing.Any) -> None:
        """The closure high off boresight max angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hobs_max_angle"](arg_newVal.COM_val))

    @property
    def hobs_angle_tol(self) -> typing.Any:
        """The closure high off boresight angle tolerance."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hobs_angle_tol"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hobs_angle_tol.setter
    def hobs_angle_tol(self, newVal:typing.Any) -> None:
        """The closure high off boresight angle tolerance."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hobs_angle_tol"](arg_newVal.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ab1da5c8-fd9b-49bc-adfd-69754a5376f5}", IBasicManeuverStrategyIntercept)
agcls.AgTypeNameMap["IBasicManeuverStrategyIntercept"] = IBasicManeuverStrategyIntercept

class IBasicManeuverStrategyRelativeBearing(object):
    """Interface used to access options for a Relative Bearing Strategy of a Basic Maneuver Procedure."""
    _uuid = "{2fefbc0f-5a8a-4388-9bb9-0376305315c8}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_target_names"] = _raise_uninitialized_error
        self.__dict__["_get_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_set_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_get_rel_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_rel_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_min_range"] = _raise_uninitialized_error
        self.__dict__["_set_min_range"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_radius"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_rate"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_horiz_accel"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyRelativeBearing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelativeBearing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyRelativeBearing = agcom.GUID(IBasicManeuverStrategyRelativeBearing._uuid)
        vtable_offset_local = IBasicManeuverStrategyRelativeBearing._vtable_offset - 1
        self.__dict__["_get_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_target_names"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_rel_bearing"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_rel_bearing"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_min_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_get_control_limit_turn_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_control_limit_turn_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_get_control_limit_horiz_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_limit"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+14, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeBearing, vtable_offset_local+16, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelativeBearing.__dict__ and type(IBasicManeuverStrategyRelativeBearing.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelativeBearing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelativeBearing.")
    
    @property
    def target_name(self) -> str:
        """The target name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_name"](arg_newVal.COM_val))

    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_target_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_resolution"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_resolution"](arg_newVal.COM_val))

    @property
    def rel_bearing(self) -> typing.Any:
        """The relative bearing angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rel_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rel_bearing.setter
    def rel_bearing(self, newVal:typing.Any) -> None:
        """The relative bearing angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rel_bearing"](arg_newVal.COM_val))

    @property
    def min_range(self) -> float:
        """The range from the target at which the aircraft will stop."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_range.setter
    def min_range(self, newVal:float) -> None:
        """The range from the target at which the aircraft will stop."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_range"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_horiz_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_control_limit(self, controlLimitMode:"AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT, controlLimitMode) as arg_controlLimitMode, \
             agmarshall.DOUBLE_arg(controlLimitValue) as arg_controlLimitValue:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit"](arg_controlLimitMode.COM_val, arg_controlLimitValue.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2fefbc0f-5a8a-4388-9bb9-0376305315c8}", IBasicManeuverStrategyRelativeBearing)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelativeBearing"] = IBasicManeuverStrategyRelativeBearing

class IBasicManeuverStrategyRelativeCourse(object):
    """Interface used to access options for a Relative Course Strategy of a Basic Maneuver Procedure."""
    _uuid = "{3b0436c1-b6c4-4623-aeeb-db55f1fce56f}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_target_names"] = _raise_uninitialized_error
        self.__dict__["_get_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_set_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_get_use_relative_course"] = _raise_uninitialized_error
        self.__dict__["_set_use_relative_course"] = _raise_uninitialized_error
        self.__dict__["_get_course"] = _raise_uninitialized_error
        self.__dict__["_set_course"] = _raise_uninitialized_error
        self.__dict__["_get_in_track"] = _raise_uninitialized_error
        self.__dict__["_set_in_track"] = _raise_uninitialized_error
        self.__dict__["_get_cross_track"] = _raise_uninitialized_error
        self.__dict__["_set_cross_track"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_get_use_approach_turn_mode"] = _raise_uninitialized_error
        self.__dict__["_set_use_approach_turn_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_radius"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_rate"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_horiz_accel"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit"] = _raise_uninitialized_error
        self.__dict__["_get_closure_mode"] = _raise_uninitialized_error
        self.__dict__["_set_closure_mode"] = _raise_uninitialized_error
        self.__dict__["_get_downrange_offset"] = _raise_uninitialized_error
        self.__dict__["_set_downrange_offset"] = _raise_uninitialized_error
        self.__dict__["_get_hobs_max_angle"] = _raise_uninitialized_error
        self.__dict__["_set_hobs_max_angle"] = _raise_uninitialized_error
        self.__dict__["_get_hobs_angle_tol"] = _raise_uninitialized_error
        self.__dict__["_set_hobs_angle_tol"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyRelativeCourse._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelativeCourse from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyRelativeCourse = agcom.GUID(IBasicManeuverStrategyRelativeCourse._uuid)
        vtable_offset_local = IBasicManeuverStrategyRelativeCourse._vtable_offset - 1
        self.__dict__["_get_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_target_names"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_use_relative_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_relative_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_in_track"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_in_track"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_cross_track"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cross_track"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_use_approach_turn_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approach_turn_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_get_control_limit_turn_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_get_control_limit_turn_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+20, POINTER(agcom.VARIANT))
        self.__dict__["_get_control_limit_horiz_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_limit"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+22, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_closure_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_closure_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_get_downrange_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_downrange_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_hobs_max_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+27, POINTER(agcom.VARIANT))
        self.__dict__["_set_hobs_max_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+28, agcom.VARIANT)
        self.__dict__["_get_hobs_angle_tol"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+29, POINTER(agcom.VARIANT))
        self.__dict__["_set_hobs_angle_tol"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+30, agcom.VARIANT)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+31, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeCourse, vtable_offset_local+32, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelativeCourse.__dict__ and type(IBasicManeuverStrategyRelativeCourse.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelativeCourse.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelativeCourse.")
    
    @property
    def target_name(self) -> str:
        """The target name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_name"](arg_newVal.COM_val))

    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_target_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_resolution"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_resolution"](arg_newVal.COM_val))

    @property
    def use_relative_course(self) -> bool:
        """The option to specify a relative course as opposed to a true course."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_relative_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_relative_course.setter
    def use_relative_course(self, newVal:bool) -> None:
        """The option to specify a relative course as opposed to a true course."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_relative_course"](arg_newVal.COM_val))

    @property
    def course(self) -> typing.Any:
        """The course value."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The course value."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course"](arg_newVal.COM_val))

    @property
    def in_track(self) -> float:
        """The in track offset from the center of the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_in_track"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @in_track.setter
    def in_track(self, newVal:float) -> None:
        """The in track offset from the center of the target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_in_track"](arg_newVal.COM_val))

    @property
    def cross_track(self) -> float:
        """The cross track offset from the center of the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cross_track"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cross_track.setter
    def cross_track(self, newVal:float) -> None:
        """The cross track offset from the center of the target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cross_track"](arg_newVal.COM_val))

    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_factor"](arg_newVal.COM_val))

    @property
    def use_approach_turn_mode(self) -> bool:
        """The option to fly the base leg of the maneuver with a constant radius turn."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approach_turn_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approach_turn_mode.setter
    def use_approach_turn_mode(self, newVal:bool) -> None:
        """The option to fly the base leg of the maneuver with a constant radius turn."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approach_turn_mode"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_horiz_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_control_limit(self, controlLimitMode:"AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT, controlLimitMode) as arg_controlLimitMode, \
             agmarshall.DOUBLE_arg(controlLimitValue) as arg_controlLimitValue:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit"](arg_controlLimitMode.COM_val, arg_controlLimitValue.COM_val))

    @property
    def closure_mode(self) -> "AVTR_CLOSURE_MODE":
        """The closure mode for the guidance strategy."""
        with agmarshall.AgEnum_arg(AVTR_CLOSURE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_closure_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @closure_mode.setter
    def closure_mode(self, newVal:"AVTR_CLOSURE_MODE") -> None:
        """The closure mode for the guidance strategy."""
        with agmarshall.AgEnum_arg(AVTR_CLOSURE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_closure_mode"](arg_newVal.COM_val))

    @property
    def downrange_offset(self) -> float:
        """The downrange offset for the closure options."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_downrange_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @downrange_offset.setter
    def downrange_offset(self, newVal:float) -> None:
        """The downrange offset for the closure options."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_downrange_offset"](arg_newVal.COM_val))

    @property
    def hobs_max_angle(self) -> typing.Any:
        """The closure high off boresight max angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hobs_max_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hobs_max_angle.setter
    def hobs_max_angle(self, newVal:typing.Any) -> None:
        """The closure high off boresight max angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hobs_max_angle"](arg_newVal.COM_val))

    @property
    def hobs_angle_tol(self) -> typing.Any:
        """The closure high off boresight angle tolerance."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hobs_angle_tol"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hobs_angle_tol.setter
    def hobs_angle_tol(self, newVal:typing.Any) -> None:
        """The closure high off boresight angle tolerance."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hobs_angle_tol"](arg_newVal.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3b0436c1-b6c4-4623-aeeb-db55f1fce56f}", IBasicManeuverStrategyRelativeCourse)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelativeCourse"] = IBasicManeuverStrategyRelativeCourse

class IBasicManeuverStrategyRendezvous(object):
    """Interface used to access options for a Rendezvous Formation Strategy of a Basic Maneuver Procedure."""
    _uuid = "{49b4a1d7-e2dd-4956-892e-e3d042b5c3ae}"
    _num_methods = 37
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_target_names"] = _raise_uninitialized_error
        self.__dict__["_get_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_set_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_get_use_counter_turn_logic"] = _raise_uninitialized_error
        self.__dict__["_set_use_counter_turn_logic"] = _raise_uninitialized_error
        self.__dict__["_get_enable_collision_avoidance"] = _raise_uninitialized_error
        self.__dict__["_get_cpa"] = _raise_uninitialized_error
        self.__dict__["_set_cpa"] = _raise_uninitialized_error
        self.__dict__["_get_relative_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_relative_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_relative_range"] = _raise_uninitialized_error
        self.__dict__["_set_relative_range"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_split"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_split"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_get_use_perf_model_limits"] = _raise_uninitialized_error
        self.__dict__["_set_use_perf_model_limits"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate_control"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate_control"] = _raise_uninitialized_error
        self.__dict__["_get_min_load_factor_g"] = _raise_uninitialized_error
        self.__dict__["_set_min_load_factor_g"] = _raise_uninitialized_error
        self.__dict__["_get_max_load_factor_g"] = _raise_uninitialized_error
        self.__dict__["_set_max_load_factor_g"] = _raise_uninitialized_error
        self.__dict__["_get_max_speed_advantage"] = _raise_uninitialized_error
        self.__dict__["_set_max_speed_advantage"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_control_mode"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_control_mode"] = _raise_uninitialized_error
        self.__dict__["_get_accel_decel_g"] = _raise_uninitialized_error
        self.__dict__["_set_accel_decel_g"] = _raise_uninitialized_error
        self.__dict__["_get_use_separate_airspeed_control"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_factor"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_factor"] = _raise_uninitialized_error
        self.__dict__["_get_stop_condition"] = _raise_uninitialized_error
        self.__dict__["_set_stop_condition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyRendezvous._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRendezvous from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyRendezvous = agcom.GUID(IBasicManeuverStrategyRendezvous._uuid)
        vtable_offset_local = IBasicManeuverStrategyRendezvous._vtable_offset - 1
        self.__dict__["_get_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_target_names"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_use_counter_turn_logic"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_counter_turn_logic"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_collision_avoidance"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_cpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+10, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_relative_bearing"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_relative_bearing"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_relative_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_relative_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_altitude_split"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_split"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_use_perf_model_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_perf_model_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_rate_control"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate_control"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_min_load_factor_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_load_factor_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_max_load_factor_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_load_factor_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_max_speed_advantage"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_speed_advantage"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_airspeed_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+29, POINTER(agcom.LONG))
        self.__dict__["_set_airspeed_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+30, agcom.LONG)
        self.__dict__["_get_accel_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_use_separate_airspeed_control"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+33, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_airspeed_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+34, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+35, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+36, POINTER(agcom.LONG))
        self.__dict__["_set_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRendezvous, vtable_offset_local+37, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRendezvous.__dict__ and type(IBasicManeuverStrategyRendezvous.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRendezvous.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRendezvous.")
    
    @property
    def target_name(self) -> str:
        """The target name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_name"](arg_newVal.COM_val))

    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_target_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_resolution"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_resolution"](arg_newVal.COM_val))

    @property
    def use_counter_turn_logic(self) -> bool:
        """The option to improve performance when flying with a target on a straight and level flight path."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_counter_turn_logic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_counter_turn_logic.setter
    def use_counter_turn_logic(self, newVal:bool) -> None:
        """The option to improve performance when flying with a target on a straight and level flight path."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_counter_turn_logic"](arg_newVal.COM_val))

    @property
    def enable_collision_avoidance(self) -> bool:
        """The option to enable collision avoidance."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_collision_avoidance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def cpa(self) -> float:
        """The minimum distance between this aircraft and the target aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_cpa(self, enable:bool, cPA:float) -> None:
        """Set whether to enable collision avoidance and the corresponding minimum distance between this aircraft and the target aircraft."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(cPA) as arg_cPA:
            agcls.evaluate_hresult(self.__dict__["_set_cpa"](arg_enable.COM_val, arg_cPA.COM_val))

    @property
    def relative_bearing(self) -> typing.Any:
        """The bearing relative to the target the aircraft will achieve and maintain."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_bearing.setter
    def relative_bearing(self, newVal:typing.Any) -> None:
        """The bearing relative to the target the aircraft will achieve and maintain."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_bearing"](arg_newVal.COM_val))

    @property
    def relative_range(self) -> float:
        """The range to the target the aircraft will achieve and maintain."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_range.setter
    def relative_range(self, newVal:float) -> None:
        """The range to the target the aircraft will achieve and maintain."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_range"](arg_newVal.COM_val))

    @property
    def altitude_split(self) -> float:
        """The altitude difference between the aircraft and target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_split"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_split.setter
    def altitude_split(self, newVal:float) -> None:
        """The altitude difference between the aircraft and target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_split"](arg_newVal.COM_val))

    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_factor"](arg_newVal.COM_val))

    @property
    def use_perf_model_limits(self) -> bool:
        """The option to derive the control limits of the aircraft from the applicable performance model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_perf_model_limits"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_perf_model_limits.setter
    def use_perf_model_limits(self, newVal:bool) -> None:
        """The option to derive the control limits of the aircraft from the applicable performance model."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_perf_model_limits"](arg_newVal.COM_val))

    @property
    def altitude_rate_control(self) -> float:
        """The rate at which the aircraft will change altitude to achieve or maintain the ALtitude Split."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate_control"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate_control.setter
    def altitude_rate_control(self, newVal:float) -> None:
        """The rate at which the aircraft will change altitude to achieve or maintain the ALtitude Split."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate_control"](arg_newVal.COM_val))

    @property
    def min_load_factor_g(self) -> float:
        """The minimum load factor the aircraft can bear while maneuvering in formation."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_load_factor_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_load_factor_g.setter
    def min_load_factor_g(self, newVal:float) -> None:
        """The minimum load factor the aircraft can bear while maneuvering in formation."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_load_factor_g"](arg_newVal.COM_val))

    @property
    def max_load_factor_g(self) -> float:
        """The maximum load factor the aircraft can bear while maneuvering in formation."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_load_factor_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_load_factor_g.setter
    def max_load_factor_g(self, newVal:float) -> None:
        """The maximum load factor the aircraft can bear while maneuvering in formation."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_load_factor_g"](arg_newVal.COM_val))

    @property
    def max_speed_advantage(self) -> float:
        """The limit to the airspeed difference between the aircraft and target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_speed_advantage"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_speed_advantage.setter
    def max_speed_advantage(self, newVal:float) -> None:
        """The limit to the airspeed difference between the aircraft and target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_speed_advantage"](arg_newVal.COM_val))

    @property
    def airspeed_control_mode(self) -> "AVTR_ACCEL_PERF_MODEL_OVERRIDE":
        """The method to define the aircraft's acceleration performance in formation."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_PERF_MODEL_OVERRIDE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_control_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @airspeed_control_mode.setter
    def airspeed_control_mode(self, newVal:"AVTR_ACCEL_PERF_MODEL_OVERRIDE") -> None:
        """The method to define the aircraft's acceleration performance in formation."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_PERF_MODEL_OVERRIDE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_control_mode"](arg_newVal.COM_val))

    @property
    def accel_decel_g(self) -> float:
        """The aircraft's specified acceleration rate for an airspeed control mode set to override."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_decel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_decel_g.setter
    def accel_decel_g(self, newVal:float) -> None:
        """The aircraft's specified acceleration rate for an airspeed control mode set to override."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_decel_g"](arg_newVal.COM_val))

    @property
    def use_separate_airspeed_control(self) -> bool:
        """The option to control how fine the control is over the airspeed adjustments in formation flight."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_separate_airspeed_control"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_factor(self) -> float:
        """A dimensionless factor defining how fine the control is over airspeed adjustments in formation flight."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed_factor(self, enable:bool, airspeedFactor:float) -> None:
        """Set whether to enable the option to control how fine the control is and the corresponding dimensionless factor."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(airspeedFactor) as arg_airspeedFactor:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_factor"](arg_enable.COM_val, arg_airspeedFactor.COM_val))

    @property
    def stop_condition(self) -> "AVTR_RENDEZVOUS_STOP_CONDITION":
        """The stopping condition for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_RENDEZVOUS_STOP_CONDITION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_condition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_condition.setter
    def stop_condition(self, newVal:"AVTR_RENDEZVOUS_STOP_CONDITION") -> None:
        """The stopping condition for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_RENDEZVOUS_STOP_CONDITION, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_condition"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{49b4a1d7-e2dd-4956-892e-e3d042b5c3ae}", IBasicManeuverStrategyRendezvous)
agcls.AgTypeNameMap["IBasicManeuverStrategyRendezvous"] = IBasicManeuverStrategyRendezvous

class IBasicManeuverStrategyStationkeeping(object):
    """Interface used to access options for a Stationkeeping Strategy of a Basic Maneuver Procedure."""
    _uuid = "{b6ab25a8-fcef-49c4-a804-c55471f61f76}"
    _num_methods = 36
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_target_names"] = _raise_uninitialized_error
        self.__dict__["_get_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_set_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_get_max_target_speed_fraction"] = _raise_uninitialized_error
        self.__dict__["_set_max_target_speed_fraction"] = _raise_uninitialized_error
        self.__dict__["_get_rel_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_rel_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_rel_range"] = _raise_uninitialized_error
        self.__dict__["_set_rel_range"] = _raise_uninitialized_error
        self.__dict__["_get_desired_radius"] = _raise_uninitialized_error
        self.__dict__["_set_desired_radius"] = _raise_uninitialized_error
        self.__dict__["_get_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_get_stop_condition"] = _raise_uninitialized_error
        self.__dict__["_set_stop_condition"] = _raise_uninitialized_error
        self.__dict__["_get_use_relative_course"] = _raise_uninitialized_error
        self.__dict__["_set_use_relative_course"] = _raise_uninitialized_error
        self.__dict__["_get_stop_course"] = _raise_uninitialized_error
        self.__dict__["_set_stop_course"] = _raise_uninitialized_error
        self.__dict__["_get_stop_after_turn_count"] = _raise_uninitialized_error
        self.__dict__["_set_stop_after_turn_count"] = _raise_uninitialized_error
        self.__dict__["_get_stop_after_duration"] = _raise_uninitialized_error
        self.__dict__["_set_stop_after_duration"] = _raise_uninitialized_error
        self.__dict__["_get_stop_after_time"] = _raise_uninitialized_error
        self.__dict__["_set_stop_after_time"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_radius"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_rate"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_horiz_accel"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyStationkeeping._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyStationkeeping from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyStationkeeping = agcom.GUID(IBasicManeuverStrategyStationkeeping._uuid)
        vtable_offset_local = IBasicManeuverStrategyStationkeeping._vtable_offset - 1
        self.__dict__["_get_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_target_names"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_max_target_speed_fraction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_target_speed_fraction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_rel_bearing"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_rel_bearing"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_rel_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rel_range"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_desired_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_desired_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_get_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_set_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+19, agcom.LONG)
        self.__dict__["_get_use_relative_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_relative_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+21, agcom.VARIANT_BOOL)
        self.__dict__["_get_stop_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+22, POINTER(agcom.VARIANT))
        self.__dict__["_set_stop_course"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+23, agcom.VARIANT)
        self.__dict__["_get_stop_after_turn_count"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_stop_after_turn_count"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_get_stop_after_duration"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_after_duration"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+27, agcom.DOUBLE)
        self.__dict__["_get_stop_after_time"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+28, POINTER(agcom.VARIANT))
        self.__dict__["_set_stop_after_time"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+29, agcom.VARIANT)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+30, POINTER(agcom.LONG))
        self.__dict__["_get_control_limit_turn_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_get_control_limit_turn_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+32, POINTER(agcom.VARIANT))
        self.__dict__["_get_control_limit_horiz_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_limit"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+34, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+35, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStationkeeping, vtable_offset_local+36, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyStationkeeping.__dict__ and type(IBasicManeuverStrategyStationkeeping.__dict__[attrname]) == property:
            return IBasicManeuverStrategyStationkeeping.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyStationkeeping.")
    
    @property
    def target_name(self) -> str:
        """The target name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_name"](arg_newVal.COM_val))

    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_target_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_resolution"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_resolution"](arg_newVal.COM_val))

    @property
    def max_target_speed_fraction(self) -> float:
        """The maximum speed relative to the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_target_speed_fraction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_target_speed_fraction.setter
    def max_target_speed_fraction(self, newVal:float) -> None:
        """The maximum speed relative to the target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_target_speed_fraction"](arg_newVal.COM_val))

    @property
    def rel_bearing(self) -> typing.Any:
        """The bearing relative to the target that the aircraft will hold."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rel_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rel_bearing.setter
    def rel_bearing(self, newVal:typing.Any) -> None:
        """The bearing relative to the target that the aircraft will hold."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rel_bearing"](arg_newVal.COM_val))

    @property
    def rel_range(self) -> float:
        """The range from the target where the aircraft will hold."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rel_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rel_range.setter
    def rel_range(self, newVal:float) -> None:
        """The range from the target where the aircraft will hold."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rel_range"](arg_newVal.COM_val))

    @property
    def desired_radius(self) -> float:
        """The goal radius of the holding circle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_desired_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @desired_radius.setter
    def desired_radius(self, newVal:float) -> None:
        """The goal radius of the holding circle."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_desired_radius"](arg_newVal.COM_val))

    @property
    def turn_direction(self) -> "AVTR_TURN_DIRECTION":
        """Define if the aircraft turns left or right into the holding circle."""
        with agmarshall.AgEnum_arg(AVTR_TURN_DIRECTION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_direction.setter
    def turn_direction(self, newVal:"AVTR_TURN_DIRECTION") -> None:
        """Define if the aircraft turns left or right into the holding circle."""
        with agmarshall.AgEnum_arg(AVTR_TURN_DIRECTION, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_direction"](arg_newVal.COM_val))

    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_factor"](arg_newVal.COM_val))

    @property
    def stop_condition(self) -> "AVTR_STATIONKEEPING_STOP_CONDITION":
        """The stopping condition for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_STATIONKEEPING_STOP_CONDITION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_condition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_condition.setter
    def stop_condition(self, newVal:"AVTR_STATIONKEEPING_STOP_CONDITION") -> None:
        """The stopping condition for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_STATIONKEEPING_STOP_CONDITION, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_condition"](arg_newVal.COM_val))

    @property
    def use_relative_course(self) -> bool:
        """Option to use a relative course as opposed to an absolute course."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_relative_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_relative_course.setter
    def use_relative_course(self, newVal:bool) -> None:
        """Option to use a relative course as opposed to an absolute course."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_relative_course"](arg_newVal.COM_val))

    @property
    def stop_course(self) -> typing.Any:
        """The course stop condition."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_course.setter
    def stop_course(self, newVal:typing.Any) -> None:
        """The course stop condition."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_course"](arg_newVal.COM_val))

    @property
    def stop_after_turn_count(self) -> int:
        """The number of turns stop condition."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_after_turn_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_after_turn_count.setter
    def stop_after_turn_count(self, newVal:int) -> None:
        """The number of turns stop condition."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_after_turn_count"](arg_newVal.COM_val))

    @property
    def stop_after_duration(self) -> float:
        """The duration stop condition."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_after_duration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_after_duration.setter
    def stop_after_duration(self, newVal:float) -> None:
        """The duration stop condition."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_after_duration"](arg_newVal.COM_val))

    @property
    def stop_after_time(self) -> typing.Any:
        """The time stop condition."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_after_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_after_time.setter
    def stop_after_time(self, newVal:typing.Any) -> None:
        """The time stop condition."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_after_time"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_horiz_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_control_limit(self, controlLimitMode:"AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT, controlLimitMode) as arg_controlLimitMode, \
             agmarshall.DOUBLE_arg(controlLimitValue) as arg_controlLimitValue:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit"](arg_controlLimitMode.COM_val, arg_controlLimitValue.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b6ab25a8-fcef-49c4-a804-c55471f61f76}", IBasicManeuverStrategyStationkeeping)
agcls.AgTypeNameMap["IBasicManeuverStrategyStationkeeping"] = IBasicManeuverStrategyStationkeeping

class IBasicManeuverStrategyRelativeFPA(object):
    """Interface used to access options for the Relative Flight Path Angle Strategy of a Basic Maneuver Procedure."""
    _uuid = "{d2066432-a9ef-48f0-aeb2-e75f6b4323e2}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_anchor_alt_offset"] = _raise_uninitialized_error
        self.__dict__["_set_anchor_alt_offset"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_factor"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_min_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_min_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_max_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_max_absolute_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_min_altitude_rel_anchor"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_altitude_rel_anchor"] = _raise_uninitialized_error
        self.__dict__["_set_min_altitude_rel_anchor"] = _raise_uninitialized_error
        self.__dict__["_get_max_altitude_rel_anchor"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_altitude_rel_anchor"] = _raise_uninitialized_error
        self.__dict__["_set_max_altitude_rel_anchor"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyRelativeFPA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelativeFPA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyRelativeFPA = agcom.GUID(IBasicManeuverStrategyRelativeFPA._uuid)
        vtable_offset_local = IBasicManeuverStrategyRelativeFPA._vtable_offset - 1
        self.__dict__["_get_fpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_fpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_anchor_alt_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_anchor_alt_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maneuver_factor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_get_control_limit_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_control_limit"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+9, agcom.LONG, agcom.VARIANT)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_min_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_use_min_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_min_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+13, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_max_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_get_use_max_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_max_absolute_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+16, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_min_altitude_rel_anchor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_get_use_min_altitude_rel_anchor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_min_altitude_rel_anchor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+19, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_max_altitude_rel_anchor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_get_use_max_altitude_rel_anchor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_max_altitude_rel_anchor"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+22, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelativeFPA, vtable_offset_local+24, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelativeFPA.__dict__ and type(IBasicManeuverStrategyRelativeFPA.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelativeFPA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelativeFPA.")
    
    @property
    def fpa(self) -> typing.Any:
        """The flight path angle for the maneuver."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fpa.setter
    def fpa(self, newVal:typing.Any) -> None:
        """The flight path angle for the maneuver."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fpa"](arg_newVal.COM_val))

    @property
    def anchor_alt_offset(self) -> float:
        """The goal height above or below the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_anchor_alt_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @anchor_alt_offset.setter
    def anchor_alt_offset(self, newVal:float) -> None:
        """The goal height above or below the target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_anchor_alt_offset"](arg_newVal.COM_val))

    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_factor"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_PROFILE_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PROFILE_CONTROL_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_pitch_rate(self) -> typing.Any:
        """The specified pitch rate for a control limit mode of specify max pitch rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_pitch_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_control_limit(self, controlLimitMode:"AVTR_PROFILE_CONTROL_LIMIT", controlLimitValue:typing.Any) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PROFILE_CONTROL_LIMIT, controlLimitMode) as arg_controlLimitMode, \
             agmarshall.VARIANT_arg(controlLimitValue) as arg_controlLimitValue:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit"](arg_controlLimitMode.COM_val, arg_controlLimitValue.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def min_absolute_altitude(self) -> float:
        """The minimum absolute altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_absolute_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_min_absolute_altitude(self) -> bool:
        """The option to specify a minimum absolute altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_absolute_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_min_absolute_altitude(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the minimum absolute altitude."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_set_min_absolute_altitude"](arg_enable.COM_val, arg_altitude.COM_val))

    @property
    def max_absolute_altitude(self) -> float:
        """The maximum absolute altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_absolute_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_max_absolute_altitude(self) -> bool:
        """The option to specify a maximum absolute altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_absolute_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_max_absolute_altitude(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the maximum absolute altitude."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_set_max_absolute_altitude"](arg_enable.COM_val, arg_altitude.COM_val))

    @property
    def min_altitude_rel_anchor(self) -> float:
        """The minimum altitude offset from the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_altitude_rel_anchor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_min_altitude_rel_anchor(self) -> bool:
        """The option to specify a minimum altitude offset from the target."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_altitude_rel_anchor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_min_altitude_rel_anchor(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the minimum altitude offset from the target."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_set_min_altitude_rel_anchor"](arg_enable.COM_val, arg_altitude.COM_val))

    @property
    def max_altitude_rel_anchor(self) -> float:
        """The maximum altitude offset from the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_altitude_rel_anchor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_max_altitude_rel_anchor(self) -> bool:
        """The option to specify a maximum altitude offset from the target."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_altitude_rel_anchor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_max_altitude_rel_anchor(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the maximum altitude offset from the target."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_set_max_altitude_rel_anchor"](arg_enable.COM_val, arg_altitude.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{d2066432-a9ef-48f0-aeb2-e75f6b4323e2}", IBasicManeuverStrategyRelativeFPA)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelativeFPA"] = IBasicManeuverStrategyRelativeFPA

class IBasicManeuverStrategyRelSpeedAltitude(object):
    """Interface used to access options for a Relative Speed/Altitude Strategy of a Basic Maneuver Procedure."""
    _uuid = "{1770600b-1329-4efb-8836-200a0d8ed802}"
    _num_methods = 36
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_target_names"] = _raise_uninitialized_error
        self.__dict__["_get_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_set_target_resolution"] = _raise_uninitialized_error
        self.__dict__["_get_relative_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_set_relative_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_get_elevation_angle"] = _raise_uninitialized_error
        self.__dict__["_set_elevation_angle"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_offset_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_offset"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed_offset"] = _raise_uninitialized_error
        self.__dict__["_get_use_tgt_aspect_for_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_use_tgt_aspect_for_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_use_perf_model_limits"] = _raise_uninitialized_error
        self.__dict__["_set_use_perf_model_limits"] = _raise_uninitialized_error
        self.__dict__["_get_range_for_equal_speed"] = _raise_uninitialized_error
        self.__dict__["_set_range_for_equal_speed"] = _raise_uninitialized_error
        self.__dict__["_get_range_to_transition_speed"] = _raise_uninitialized_error
        self.__dict__["_set_range_to_transition_speed"] = _raise_uninitialized_error
        self.__dict__["_get_min_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_min_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_max_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_max_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_min_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_min_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_max_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_max_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_stop_condition"] = _raise_uninitialized_error
        self.__dict__["_set_stop_condition"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyRelSpeedAltitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelSpeedAltitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyRelSpeedAltitude = agcom.GUID(IBasicManeuverStrategyRelSpeedAltitude._uuid)
        vtable_offset_local = IBasicManeuverStrategyRelSpeedAltitude._vtable_offset - 1
        self.__dict__["_get_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_name"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_target_names"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_resolution"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_relative_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_relative_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_elevation_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_elevation_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_airspeed_offset_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed_offset"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+14, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_use_tgt_aspect_for_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_tgt_aspect_for_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_perf_model_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_perf_model_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_get_range_for_equal_speed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range_for_equal_speed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_range_to_transition_speed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range_to_transition_speed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_min_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_max_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_get_min_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+28, POINTER(agcom.LONG))
        self.__dict__["_set_min_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+29, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+30, POINTER(agcom.DOUBLE))
        self.__dict__["_get_max_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+31, POINTER(agcom.LONG))
        self.__dict__["_set_max_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+32, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+33, POINTER(agcom.LONG))
        self.__dict__["_set_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+34, agcom.LONG)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+35, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyRelSpeedAltitude, vtable_offset_local+36, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelSpeedAltitude.__dict__ and type(IBasicManeuverStrategyRelSpeedAltitude.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelSpeedAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelSpeedAltitude.")
    
    @property
    def target_name(self) -> str:
        """The target name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_name"](arg_newVal.COM_val))

    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_target_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_resolution"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_resolution"](arg_newVal.COM_val))

    @property
    def relative_altitude_mode(self) -> "AVTR_RELATIVE_ALTITUDE_MODE":
        """The mode to define the hold objective for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_RELATIVE_ALTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_altitude_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_altitude_mode.setter
    def relative_altitude_mode(self, newVal:"AVTR_RELATIVE_ALTITUDE_MODE") -> None:
        """The mode to define the hold objective for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_RELATIVE_ALTITUDE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_altitude_mode"](arg_newVal.COM_val))

    @property
    def elevation_angle(self) -> typing.Any:
        """The goal elevation angle from the target to the aircraft."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_elevation_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @elevation_angle.setter
    def elevation_angle(self, newVal:typing.Any) -> None:
        """The goal elevation angle from the target to the aircraft."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_elevation_angle"](arg_newVal.COM_val))

    @property
    def altitude_offset(self) -> float:
        """The goal altitude offset from the target to the aircraft."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The goal altitude offset from the target to the aircraft."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_offset"](arg_newVal.COM_val))

    @property
    def airspeed_offset_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_offset_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_offset(self) -> float:
        """The airspeed offset from the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed_offset(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the airspeed offset value and type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed_offset"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def use_tgt_aspect_for_airspeed(self) -> bool:
        """The option to use the target aspect to compute the enforced airspeed difference."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_tgt_aspect_for_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_tgt_aspect_for_airspeed.setter
    def use_tgt_aspect_for_airspeed(self, newVal:bool) -> None:
        """The option to use the target aspect to compute the enforced airspeed difference."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_tgt_aspect_for_airspeed"](arg_newVal.COM_val))

    @property
    def use_perf_model_limits(self) -> bool:
        """The option to use the performance model limits for the aircraft."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_perf_model_limits"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_perf_model_limits.setter
    def use_perf_model_limits(self, newVal:bool) -> None:
        """The option to use the performance model limits for the aircraft."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_perf_model_limits"](arg_newVal.COM_val))

    @property
    def range_for_equal_speed(self) -> float:
        """The range at which the aircraft will achieve the same airspeed as the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range_for_equal_speed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range_for_equal_speed.setter
    def range_for_equal_speed(self, newVal:float) -> None:
        """The range at which the aircraft will achieve the same airspeed as the target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range_for_equal_speed"](arg_newVal.COM_val))

    @property
    def range_to_transition_speed(self) -> float:
        """The range at which the aircraft will begin to slow down to match the speed of the target."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range_to_transition_speed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range_to_transition_speed.setter
    def range_to_transition_speed(self, newVal:float) -> None:
        """The range at which the aircraft will begin to slow down to match the speed of the target."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range_to_transition_speed"](arg_newVal.COM_val))

    @property
    def min_altitude(self) -> float:
        """The minimum altitude boundary for the maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_altitude.setter
    def min_altitude(self, newVal:float) -> None:
        """The minimum altitude boundary for the maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_altitude"](arg_newVal.COM_val))

    @property
    def max_altitude(self) -> float:
        """The maximum altitude boundary for the maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_altitude.setter
    def max_altitude(self, newVal:float) -> None:
        """The maximum altitude boundary for the maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_altitude"](arg_newVal.COM_val))

    @property
    def min_airspeed(self) -> float:
        """The minimum airspeed limit for the maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def min_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_min_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the minimum airspeed value and type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_min_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def max_airspeed(self) -> float:
        """The maximum airspeed limit for the maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_max_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the maximum airspeed value and type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_max_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def stop_condition(self) -> "AVTR_REL_SPEED_ALT_STOP_CONDITION":
        """The stopping condition for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_REL_SPEED_ALT_STOP_CONDITION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_condition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_condition.setter
    def stop_condition(self, newVal:"AVTR_REL_SPEED_ALT_STOP_CONDITION") -> None:
        """The stopping condition for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_REL_SPEED_ALT_STOP_CONDITION, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_condition"](arg_newVal.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1770600b-1329-4efb-8836-200a0d8ed802}", IBasicManeuverStrategyRelSpeedAltitude)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelSpeedAltitude"] = IBasicManeuverStrategyRelSpeedAltitude

class IBasicManeuverStrategyBezier(object):
    """Interface used to access options for a Bezier Strategy of a Basic Maneuver Procedure."""
    _uuid = "{fe815e13-cfab-4da7-8beb-9d8efd93d9f3}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_downrange"] = _raise_uninitialized_error
        self.__dict__["_set_downrange"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_velocity_mode"] = _raise_uninitialized_error
        self.__dict__["_get_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_vertical_velocity"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_at_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_stop_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_stop_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_at_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_stop_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_stop_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_stop_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyBezier._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyBezier from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyBezier = agcom.GUID(IBasicManeuverStrategyBezier._uuid)
        vtable_offset_local = IBasicManeuverStrategyBezier._vtable_offset - 1
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_downrange"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_downrange"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+9, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_vertical_velocity_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_get_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_vertical_velocity"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+13, agcom.LONG, agcom.VARIANT)
        self.__dict__["_get_use_stop_at_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_stop_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+16, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_use_stop_at_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_stop_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_get_stop_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_stop_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+20, agcom.VARIANT_BOOL, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBezier, vtable_offset_local+22, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyBezier.__dict__ and type(IBasicManeuverStrategyBezier.__dict__[attrname]) == property:
            return IBasicManeuverStrategyBezier.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyBezier.")
    
    @property
    def reference_frame(self) -> "AVTR_BASIC_MANEUVER_REF_FRAME":
        """The reference frame the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_frame.setter
    def reference_frame(self, newVal:"AVTR_BASIC_MANEUVER_REF_FRAME") -> None:
        """The reference frame the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The aircraft's altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The aircraft's altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def downrange(self) -> float:
        """The ground distance from the beginning of the maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_downrange"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @downrange.setter
    def downrange(self, newVal:float) -> None:
        """The ground distance from the beginning of the maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_downrange"](arg_newVal.COM_val))

    @property
    def airspeed(self) -> float:
        """The aircraft's airspeed."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the fly to airspeed value and type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def vertical_velocity_mode(self) -> "AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE":
        """The option to specify the flight path angle or the altitude rate."""
        with agmarshall.AgEnum_arg(AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_velocity_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def flight_path_angle(self) -> typing.Any:
        """The initial pitch angle of the flight path."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def altitude_rate(self) -> float:
        """The constant rate at which the aircraft will climb or descend."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_vertical_velocity(self, mode:"AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE", value:typing.Any) -> None:
        """Set the flight path angle or altitude rate."""
        with agmarshall.AgEnum_arg(AVTR_FLY_TO_FLIGHT_PATH_ANGLE_MODE, mode) as arg_mode, \
             agmarshall.VARIANT_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_vertical_velocity"](arg_mode.COM_val, arg_value.COM_val))

    @property
    def use_stop_at_altitude_rate(self) -> bool:
        """The option to stop the maneuver if a specified altitude rate is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_at_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_altitude_rate(self) -> float:
        """The altitude rate stopping condition."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_altitude_rate(self, enable:bool, altitudeRate:float) -> None:
        """Set whether to enable the altitude rate stopping condition and the corresponding value."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(altitudeRate) as arg_altitudeRate:
            agcls.evaluate_hresult(self.__dict__["_set_stop_altitude_rate"](arg_enable.COM_val, arg_altitudeRate.COM_val))

    @property
    def use_stop_at_airspeed(self) -> bool:
        """The option to stop the maneuver if a specified airspeed is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_at_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_airspeed(self) -> float:
        """The airspeed stopping condition."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type for the airspeed stopping condition."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_airspeed(self, enable:bool, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set whether to enable the airspeed stopping condition and the corresponding value."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_stop_airspeed"](arg_enable.COM_val, arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{fe815e13-cfab-4da7-8beb-9d8efd93d9f3}", IBasicManeuverStrategyBezier)
agcls.AgTypeNameMap["IBasicManeuverStrategyBezier"] = IBasicManeuverStrategyBezier

class IBasicManeuverStrategyPushPull(object):
    """Interface used to access options for a Push/Pull Strategy of a Basic Maneuver Procedure."""
    _uuid = "{8000621a-e9ce-4aa7-bf8e-565f579a4675}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_push_pull"] = _raise_uninitialized_error
        self.__dict__["_set_push_pull"] = _raise_uninitialized_error
        self.__dict__["_get_push_pull_g"] = _raise_uninitialized_error
        self.__dict__["_set_push_pull_g"] = _raise_uninitialized_error
        self.__dict__["_get_accel_mode"] = _raise_uninitialized_error
        self.__dict__["_set_accel_mode"] = _raise_uninitialized_error
        self.__dict__["_get_accel_decel_g"] = _raise_uninitialized_error
        self.__dict__["_set_accel_decel_g"] = _raise_uninitialized_error
        self.__dict__["_get_maintain_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_maintain_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_maintain_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_stop_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_stop_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_at_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_stop_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_stop_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_at_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_stop_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_stop_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_at_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_stop_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_stop_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_set_stop_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyPushPull._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyPushPull from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyPushPull = agcom.GUID(IBasicManeuverStrategyPushPull._uuid)
        vtable_offset_local = IBasicManeuverStrategyPushPull._vtable_offset - 1
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_push_pull"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_push_pull"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_push_pull_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_push_pull_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_accel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_accel_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_accel_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_decel_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_maintain_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_maintain_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_maintain_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_get_stop_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_stop_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+15, agcom.VARIANT)
        self.__dict__["_get_use_stop_at_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_stop_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+18, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_use_stop_at_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_stop_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+21, agcom.VARIANT_BOOL, agcom.DOUBLE)
        self.__dict__["_get_use_stop_at_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_stop_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_get_stop_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_stop_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+25, agcom.VARIANT_BOOL, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+26, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPushPull, vtable_offset_local+27, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyPushPull.__dict__ and type(IBasicManeuverStrategyPushPull.__dict__[attrname]) == property:
            return IBasicManeuverStrategyPushPull.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyPushPull.")
    
    @property
    def reference_frame(self) -> "AVTR_BASIC_MANEUVER_REF_FRAME":
        """The reference frame the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_frame.setter
    def reference_frame(self, newVal:"AVTR_BASIC_MANEUVER_REF_FRAME") -> None:
        """The reference frame the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_newVal.COM_val))

    @property
    def push_pull(self) -> "AVTR_PUSH_PULL":
        """The option to push over or pull up."""
        with agmarshall.AgEnum_arg(AVTR_PUSH_PULL) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_push_pull"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @push_pull.setter
    def push_pull(self, newVal:"AVTR_PUSH_PULL") -> None:
        """The option to push over or pull up."""
        with agmarshall.AgEnum_arg(AVTR_PUSH_PULL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_push_pull"](arg_newVal.COM_val))

    @property
    def push_pull_g(self) -> float:
        """The G force of the maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_push_pull_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @push_pull_g.setter
    def push_pull_g(self, newVal:float) -> None:
        """The G force of the maneuver."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_push_pull_g"](arg_newVal.COM_val))

    @property
    def accel_mode(self) -> "AVTR_ACCEL_MODE":
        """The option to accelerate, decelerate, or maintain the current airspeed."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_mode.setter
    def accel_mode(self, newVal:"AVTR_ACCEL_MODE") -> None:
        """The option to accelerate, decelerate, or maintain the current airspeed."""
        with agmarshall.AgEnum_arg(AVTR_ACCEL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_mode"](arg_newVal.COM_val))

    @property
    def accel_decel_g(self) -> float:
        """The specific G force rate to accelerate/decelerate at."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_decel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_decel_g.setter
    def accel_decel_g(self, newVal:float) -> None:
        """The specific G force rate to accelerate/decelerate at."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_decel_g"](arg_newVal.COM_val))

    @property
    def maintain_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type for the maintain airspeed."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maintain_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maintain_airspeed_type.setter
    def maintain_airspeed_type(self, newVal:"AVTR_AIRSPEED_TYPE") -> None:
        """The airspeed type for the maintain airspeed."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maintain_airspeed_type"](arg_newVal.COM_val))

    @property
    def maintain_airspeed(self) -> float:
        """The airspeed to maintain."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maintain_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_flight_path_angle(self) -> typing.Any:
        """The flight path angle the maneuver will stop at if achieved."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_flight_path_angle.setter
    def stop_flight_path_angle(self, newVal:typing.Any) -> None:
        """The flight path angle the maneuver will stop at if achieved."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_flight_path_angle"](arg_newVal.COM_val))

    @property
    def use_stop_at_altitude(self) -> bool:
        """The option to stop the maneuver if a specified altitude is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_at_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_altitude(self) -> float:
        """The altitude stopping condition"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_altitude(self, enable:bool, altitudeRate:float) -> None:
        """Set whether to enable the altitude stopping condition and the corresponding value."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(altitudeRate) as arg_altitudeRate:
            agcls.evaluate_hresult(self.__dict__["_set_stop_altitude"](arg_enable.COM_val, arg_altitudeRate.COM_val))

    @property
    def use_stop_at_altitude_rate(self) -> bool:
        """The option to stop the maneuver if a specified altitude rate is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_at_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_altitude_rate(self) -> float:
        """The altitude rate stopping condition."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_altitude_rate(self, enable:bool, altitudeRate:float) -> None:
        """Set whether to enable the altitude rate stopping condition and the corresponding value."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.DOUBLE_arg(altitudeRate) as arg_altitudeRate:
            agcls.evaluate_hresult(self.__dict__["_set_stop_altitude_rate"](arg_enable.COM_val, arg_altitudeRate.COM_val))

    @property
    def use_stop_at_airspeed(self) -> bool:
        """The option to stop the maneuver if a specified airspeed is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_at_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_airspeed(self) -> float:
        """The airspeed stopping condition."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def stop_airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type for the airspeed stopping condition."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_stop_airspeed(self, enable:bool, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set whether to enable the airspeed stopping condition and the corresponding value."""
        with agmarshall.VARIANT_BOOL_arg(enable) as arg_enable, \
             agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_stop_airspeed"](arg_enable.COM_val, arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8000621a-e9ce-4aa7-bf8e-565f579a4675}", IBasicManeuverStrategyPushPull)
agcls.AgTypeNameMap["IBasicManeuverStrategyPushPull"] = IBasicManeuverStrategyPushPull

class IBasicManeuverStrategyGlideProfile(object):
    """Interface used to access options for a Glide Profile Strategy of a Basic Maneuver Procedure."""
    _uuid = "{7c0a4dd8-59ed-403d-96bb-8f45d3e71ca6}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_hold_initial_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_hold_initial_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_min_g"] = _raise_uninitialized_error
        self.__dict__["_set_min_g"] = _raise_uninitialized_error
        self.__dict__["_get_max_g"] = _raise_uninitialized_error
        self.__dict__["_set_max_g"] = _raise_uninitialized_error
        self.__dict__["_get_max_speed_limits"] = _raise_uninitialized_error
        self.__dict__["_set_max_speed_limits"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_get_powered_cruise_mode"] = _raise_uninitialized_error
        self.__dict__["_set_powered_cruise_mode"] = _raise_uninitialized_error
        self.__dict__["_get_powered_cruise_throttle"] = _raise_uninitialized_error
        self.__dict__["_set_powered_cruise_throttle"] = _raise_uninitialized_error
        self.__dict__["_get_powered_cruise_thrust_model"] = _raise_uninitialized_error
        self.__dict__["_get_glide_speed_control_mode"] = _raise_uninitialized_error
        self.__dict__["_get_glide_speed_control_alt"] = _raise_uninitialized_error
        self.__dict__["_set_glide_speed_control_mode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyGlideProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyGlideProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyGlideProfile = agcom.GUID(IBasicManeuverStrategyGlideProfile._uuid)
        vtable_offset_local = IBasicManeuverStrategyGlideProfile._vtable_offset - 1
        self.__dict__["_get_hold_initial_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_hold_initial_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_min_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_max_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_g"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_max_speed_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_max_speed_limits"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+11, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_get_powered_cruise_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_powered_cruise_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_get_powered_cruise_throttle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_powered_cruise_throttle"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_powered_cruise_thrust_model"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_get_glide_speed_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_get_glide_speed_control_alt"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_glide_speed_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyGlideProfile, vtable_offset_local+21, agcom.LONG, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyGlideProfile.__dict__ and type(IBasicManeuverStrategyGlideProfile.__dict__[attrname]) == property:
            return IBasicManeuverStrategyGlideProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyGlideProfile.")
    
    @property
    def hold_initial_airspeed(self) -> bool:
        """Select whether to maintain the airspeed of the aircraft at the beginning of the procedure throughout the maneuver."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_initial_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hold_initial_airspeed.setter
    def hold_initial_airspeed(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_initial_airspeed"](arg_pVal.COM_val))

    @property
    def airspeed(self) -> float:
        """Get the airspeed the aircraft will attempt to achieve and maintain if the hold initial airspeed option is not enabled."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """Get the airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def min_g(self) -> float:
        """The minimum load factor the aircraft can withstand."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_g.setter
    def min_g(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_g"](arg_pVal.COM_val))

    @property
    def max_g(self) -> float:
        """The maximum load factor the aircraft can withstand."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_g.setter
    def max_g(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_g"](arg_pVal.COM_val))

    @property
    def max_speed_limits(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS":
        """The options of what the procedure will do if the aircraft has exceeded the maximum speed limits."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_speed_limits"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_speed_limits.setter
    def max_speed_limits(self, pVal:"AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS") -> None:
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_speed_limits"](arg_pVal.COM_val))

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the airspeed and airspeed type that the aircraft will attempt to achieve and maintain if the hold initial airspeed option is not enabled."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))

    @property
    def powered_cruise_mode(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE":
        """The powered cruise mode"""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_powered_cruise_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @powered_cruise_mode.setter
    def powered_cruise_mode(self, newVal:"AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE") -> None:
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_powered_cruise_mode"](arg_newVal.COM_val))

    @property
    def powered_cruise_throttle(self) -> float:
        """The powered cruise throttle"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_powered_cruise_throttle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @powered_cruise_throttle.setter
    def powered_cruise_throttle(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_powered_cruise_throttle"](arg_newVal.COM_val))

    @property
    def powered_cruise_thrust_model(self) -> "IPropulsionThrust":
        """The powered cruise thrust model"""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_powered_cruise_thrust_model"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def glide_speed_control_mode(self) -> "AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE":
        """The glide speed control mode"""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_glide_speed_control_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def glide_speed_control_alt(self) -> float:
        """The glide speed altitude when using the altitude control mode"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_glide_speed_control_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_glide_speed_control_mode(self, eGSMode:"AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE", dControlAlt:float) -> None:
        """Set the glide speed control mode and altitude"""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE, eGSMode) as arg_eGSMode, \
             agmarshall.DOUBLE_arg(dControlAlt) as arg_dControlAlt:
            agcls.evaluate_hresult(self.__dict__["_set_glide_speed_control_mode"](arg_eGSMode.COM_val, arg_dControlAlt.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7c0a4dd8-59ed-403d-96bb-8f45d3e71ca6}", IBasicManeuverStrategyGlideProfile)
agcls.AgTypeNameMap["IBasicManeuverStrategyGlideProfile"] = IBasicManeuverStrategyGlideProfile

class IBasicManeuverStrategyCruiseProfile(object):
    """Interface used to access options for a Cruise Profile Strategy of a Basic Maneuver Procedure."""
    _uuid = "{bd2d3a58-6602-4909-bb0f-98fa9c84d535}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_level_off"] = _raise_uninitialized_error
        self.__dict__["_set_level_off"] = _raise_uninitialized_error
        self.__dict__["_get_requested_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_requested_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_stop_after_level_off"] = _raise_uninitialized_error
        self.__dict__["_set_stop_after_level_off"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyCruiseProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyCruiseProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyCruiseProfile = agcom.GUID(IBasicManeuverStrategyCruiseProfile._uuid)
        vtable_offset_local = IBasicManeuverStrategyCruiseProfile._vtable_offset - 1
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_level_off"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_level_off"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_requested_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_requested_altitude"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_stop_after_level_off"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_stop_after_level_off"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyCruiseProfile, vtable_offset_local+13, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyCruiseProfile.__dict__ and type(IBasicManeuverStrategyCruiseProfile.__dict__[attrname]) == property:
            return IBasicManeuverStrategyCruiseProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyCruiseProfile.")
    
    @property
    def reference_frame(self) -> "AVTR_BASIC_MANEUVER_REF_FRAME":
        """The reference frame the aircraft will use. Earth Frame will force the aircraft to overcome wind effects. Wind frame will allow the maneuver to be perturbed by wind."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_frame.setter
    def reference_frame(self, pVal:"AVTR_BASIC_MANEUVER_REF_FRAME") -> None:
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_pVal.COM_val))

    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the aircraft's default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_default_cruise_altitude"](arg_pVal.COM_val))

    @property
    def level_off(self) -> bool:
        """Opt whether to require the aircraft to level off at the specified altitude. This altitude is only enabled of the Default Cruise Altitude option is not selected."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off.setter
    def level_off(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off"](arg_pVal.COM_val))

    @property
    def requested_altitude(self) -> float:
        """The desired MSL Altitude for the maneuver. This altitude is only enabled of the Default Cruise Altitude option is not selected."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_requested_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @requested_altitude.setter
    def requested_altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_requested_altitude"](arg_newVal.COM_val))

    @property
    def cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the interface for the cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def stop_after_level_off(self) -> bool:
        """Select to stop the maneuver as soon as the aircraft achieves its goal altitude and levels off, regardless if any basic stopping conditions have been triggered."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_after_level_off"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_after_level_off.setter
    def stop_after_level_off(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_after_level_off"](arg_pVal.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{bd2d3a58-6602-4909-bb0f-98fa9c84d535}", IBasicManeuverStrategyCruiseProfile)
agcls.AgTypeNameMap["IBasicManeuverStrategyCruiseProfile"] = IBasicManeuverStrategyCruiseProfile

class IBasicManeuverStrategyStraightAhead(object):
    """Interface used to access options for a Straight Ahead Strategy of a Basic Maneuver Procedure."""
    _uuid = "{b20bf35c-8f9c-4a09-9b2c-b57124e657aa}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyStraightAhead._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyStraightAhead from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyStraightAhead = agcom.GUID(IBasicManeuverStrategyStraightAhead._uuid)
        vtable_offset_local = IBasicManeuverStrategyStraightAhead._vtable_offset - 1
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStraightAhead, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStraightAhead, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStraightAhead, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyStraightAhead, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyStraightAhead.__dict__ and type(IBasicManeuverStrategyStraightAhead.__dict__[attrname]) == property:
            return IBasicManeuverStrategyStraightAhead.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyStraightAhead.")
    
    @property
    def reference_frame(self) -> "AVTR_STRAIGHT_AHEAD_REF_FRAME":
        """The reference frame the aircraft will use to fly straight ahead."""
        with agmarshall.AgEnum_arg(AVTR_STRAIGHT_AHEAD_REF_FRAME) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_frame.setter
    def reference_frame(self, pVal:"AVTR_STRAIGHT_AHEAD_REF_FRAME") -> None:
        with agmarshall.AgEnum_arg(AVTR_STRAIGHT_AHEAD_REF_FRAME, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_pVal.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b20bf35c-8f9c-4a09-9b2c-b57124e657aa}", IBasicManeuverStrategyStraightAhead)
agcls.AgTypeNameMap["IBasicManeuverStrategyStraightAhead"] = IBasicManeuverStrategyStraightAhead

class IBasicManeuverStrategyWeave(object):
    """Interface used to access options for a weave strategy of a basic maneuver procedure."""
    _uuid = "{3ec446e4-6454-4c4d-936c-7094ec85ddd0}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_heading_change"] = _raise_uninitialized_error
        self.__dict__["_set_heading_change"] = _raise_uninitialized_error
        self.__dict__["_get_max_num_cycles"] = _raise_uninitialized_error
        self.__dict__["_set_max_num_cycles"] = _raise_uninitialized_error
        self.__dict__["_get_max_distance"] = _raise_uninitialized_error
        self.__dict__["_set_max_distance"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_radius"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_turn_rate"] = _raise_uninitialized_error
        self.__dict__["_get_control_limit_horiz_accel"] = _raise_uninitialized_error
        self.__dict__["_set_control_limit"] = _raise_uninitialized_error
        self.__dict__["_get_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        self.__dict__["_set_compensate_for_coriolis_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyWeave._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyWeave from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyWeave = agcom.GUID(IBasicManeuverStrategyWeave._uuid)
        vtable_offset_local = IBasicManeuverStrategyWeave._vtable_offset - 1
        self.__dict__["_get_heading_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading_change"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_max_num_cycles"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_num_cycles"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_max_distance"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_distance"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_control_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_get_control_limit_turn_radius"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_get_control_limit_turn_rate"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_get_control_limit_horiz_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_limit"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+11, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compensate_for_coriolis_accel"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyWeave, vtable_offset_local+13, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyWeave.__dict__ and type(IBasicManeuverStrategyWeave.__dict__[attrname]) == property:
            return IBasicManeuverStrategyWeave.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyWeave.")
    
    @property
    def heading_change(self) -> typing.Any:
        """The direction in which the aircraft will begin the weave pattern."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_change"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_change.setter
    def heading_change(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_change"](arg_newVal.COM_val))

    @property
    def max_num_cycles(self) -> float:
        """The number of times the aircraft will fly the pattern."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_num_cycles"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_num_cycles.setter
    def max_num_cycles(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_num_cycles"](arg_newVal.COM_val))

    @property
    def max_distance(self) -> float:
        """The maximum ground distance the aircraft will travel while performing the weave cyces."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_distance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_distance.setter
    def max_distance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_distance"](arg_newVal.COM_val))

    @property
    def control_limit_mode(self) -> "AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_turn_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_limit_horiz_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_control_limit(self, controlLimitMode:"AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT, controlLimitMode) as arg_controlLimitMode, \
             agmarshall.DOUBLE_arg(controlLimitValue) as arg_controlLimitValue:
            agcls.evaluate_hresult(self.__dict__["_set_control_limit"](arg_controlLimitMode.COM_val, arg_controlLimitValue.COM_val))

    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compensate_for_coriolis_accel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compensate_for_coriolis_accel"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3ec446e4-6454-4c4d-936c-7094ec85ddd0}", IBasicManeuverStrategyWeave)
agcls.AgTypeNameMap["IBasicManeuverStrategyWeave"] = IBasicManeuverStrategyWeave

class IBasicManeuverStrategyBallistic3D(object):
    """Interface used to access options for a balistic 3D strategy of a basic maneuver procedure."""
    _uuid = "{49C1E15C-785F-4C84-AA50-2B29256811A6}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_control_mode"] = _raise_uninitialized_error
        self.__dict__["_set_control_mode"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_parachute_area"] = _raise_uninitialized_error
        self.__dict__["_set_parachute_area"] = _raise_uninitialized_error
        self.__dict__["_get_parachute_cd"] = _raise_uninitialized_error
        self.__dict__["_set_parachute_cd"] = _raise_uninitialized_error
        self.__dict__["_get_wind_force_effective_area"] = _raise_uninitialized_error
        self.__dict__["_set_wind_force_effective_area"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyBallistic3D._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyBallistic3D from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyBallistic3D = agcom.GUID(IBasicManeuverStrategyBallistic3D._uuid)
        vtable_offset_local = IBasicManeuverStrategyBallistic3D._vtable_offset - 1
        self.__dict__["_get_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_parachute_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_parachute_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_parachute_cd"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_parachute_cd"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_wind_force_effective_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wind_force_effective_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyBallistic3D, vtable_offset_local+9, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyBallistic3D.__dict__ and type(IBasicManeuverStrategyBallistic3D.__dict__[attrname]) == property:
            return IBasicManeuverStrategyBallistic3D.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyBallistic3D.")
    
    @property
    def control_mode(self) -> "AVTR_BALLISTIC3_D_CONTROL_MODE":
        """The control mode for the ballistic 3D strategy."""
        with agmarshall.AgEnum_arg(AVTR_BALLISTIC3_D_CONTROL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_mode.setter
    def control_mode(self, newVal:"AVTR_BALLISTIC3_D_CONTROL_MODE") -> None:
        """The control mode for the ballistic 3D strategy."""
        with agmarshall.AgEnum_arg(AVTR_BALLISTIC3_D_CONTROL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_mode"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def parachute_area(self) -> float:
        """The parachute area used as part of the Parachute control mode for the ballistic 3D strategy."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parachute_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @parachute_area.setter
    def parachute_area(self, newVal:float) -> None:
        """The parachute area used as part of the Parachute control mode for the ballistic 3D strategy."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_parachute_area"](arg_newVal.COM_val))

    @property
    def parachute_cd(self) -> float:
        """The parachute coefficient of drag used as part of the Parachute control mode for the ballistic 3D strategy."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parachute_cd"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @parachute_cd.setter
    def parachute_cd(self, newVal:float) -> None:
        """The parachute coefficient of drag used as part of the Parachute control mode for the ballistic 3D strategy."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_parachute_cd"](arg_newVal.COM_val))

    @property
    def wind_force_effective_area(self) -> float:
        """The vehicle's wind force effective area."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wind_force_effective_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wind_force_effective_area.setter
    def wind_force_effective_area(self, newVal:float) -> None:
        """The vehicle's wind force effective area."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wind_force_effective_area"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{49C1E15C-785F-4C84-AA50-2B29256811A6}", IBasicManeuverStrategyBallistic3D)
agcls.AgTypeNameMap["IBasicManeuverStrategyBallistic3D"] = IBasicManeuverStrategyBallistic3D

class IBasicManeuverStrategyPitch3D(object):
    """Interface used to access options for a pitch 3D strategy of a basic maneuver procedure."""
    _uuid = "{FF7B545D-B15A-46D9-BFB3-204C38672231}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_control_mode"] = _raise_uninitialized_error
        self.__dict__["_set_control_mode"] = _raise_uninitialized_error
        self.__dict__["_get_command_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_command_fpa"] = _raise_uninitialized_error
        self.__dict__["_get_control_fpa_dot"] = _raise_uninitialized_error
        self.__dict__["_set_control_fpa_dot"] = _raise_uninitialized_error
        self.__dict__["_get_stop_when_fpa_achieved"] = _raise_uninitialized_error
        self.__dict__["_set_stop_when_fpa_achieved"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_wind_force_effective_area"] = _raise_uninitialized_error
        self.__dict__["_set_wind_force_effective_area"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBasicManeuverStrategyPitch3D._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyPitch3D from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBasicManeuverStrategyPitch3D = agcom.GUID(IBasicManeuverStrategyPitch3D._uuid)
        vtable_offset_local = IBasicManeuverStrategyPitch3D._vtable_offset - 1
        self.__dict__["_get_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_control_mode"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_command_fpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_command_fpa"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_control_fpa_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_control_fpa_dot"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_stop_when_fpa_achieved"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_stop_when_fpa_achieved"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_wind_force_effective_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_wind_force_effective_area"] = IAGFUNCTYPE(pUnk, IID_IBasicManeuverStrategyPitch3D, vtable_offset_local+11, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyPitch3D.__dict__ and type(IBasicManeuverStrategyPitch3D.__dict__[attrname]) == property:
            return IBasicManeuverStrategyPitch3D.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyPitch3D.")
    
    @property
    def control_mode(self) -> "AVTR_PITCH3_D_CONTROL_MODE":
        """The control mode for the pitch 3D strategy."""
        with agmarshall.AgEnum_arg(AVTR_PITCH3_D_CONTROL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_mode.setter
    def control_mode(self, newVal:"AVTR_PITCH3_D_CONTROL_MODE") -> None:
        """The control mode for the pitch 3D strategy."""
        with agmarshall.AgEnum_arg(AVTR_PITCH3_D_CONTROL_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_mode"](arg_newVal.COM_val))

    @property
    def command_fpa(self) -> typing.Any:
        """The commanded flight path angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_command_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @command_fpa.setter
    def command_fpa(self, newVal:typing.Any) -> None:
        """The commanded flight path angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_command_fpa"](arg_newVal.COM_val))

    @property
    def control_fpa_dot(self) -> typing.Any:
        """The flight path angle rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_fpa_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_fpa_dot.setter
    def control_fpa_dot(self, newVal:typing.Any) -> None:
        """The flight path angle rate."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_fpa_dot"](arg_newVal.COM_val))

    @property
    def stop_when_fpa_achieved(self) -> bool:
        """Stop when the commanded flight path angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_when_fpa_achieved"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_when_fpa_achieved.setter
    def stop_when_fpa_achieved(self, newVal:bool) -> None:
        """Stop when the commanded flight path angle is achieved."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_when_fpa_achieved"](arg_newVal.COM_val))

    @property
    def airspeed_options(self) -> "IBasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_options"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def wind_force_effective_area(self) -> float:
        """The vehicle's wind force effective area."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_wind_force_effective_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @wind_force_effective_area.setter
    def wind_force_effective_area(self, newVal:float) -> None:
        """The vehicle's wind force effective area."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_wind_force_effective_area"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FF7B545D-B15A-46D9-BFB3-204C38672231}", IBasicManeuverStrategyPitch3D)
agcls.AgTypeNameMap["IBasicManeuverStrategyPitch3D"] = IBasicManeuverStrategyPitch3D

class ITakeoffNormal(object):
    """The interface used to access the options for a Normal takeoff mode. The mode must be set to Normal to access this interface."""
    _uuid = "{0a373629-d29b-4c4f-a59f-54fc567022cb}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_takeoff_climb_angle"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_climb_angle"] = _raise_uninitialized_error
        self.__dict__["_get_departure_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_departure_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_set_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_get_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_hold_on_deck"] = _raise_uninitialized_error
        self.__dict__["_set_hold_on_deck"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITakeoffNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITakeoffNormal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITakeoffNormal = agcom.GUID(ITakeoffNormal._uuid)
        vtable_offset_local = ITakeoffNormal._vtable_offset - 1
        self.__dict__["_get_takeoff_climb_angle"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_takeoff_climb_angle"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_departure_altitude"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_departure_altitude"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_ITakeoffNormal, vtable_offset_local+10, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITakeoffNormal.__dict__ and type(ITakeoffNormal.__dict__[attrname]) == property:
            return ITakeoffNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITakeoffNormal.")
    
    @property
    def takeoff_climb_angle(self) -> typing.Any:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_climb_angle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @takeoff_climb_angle.setter
    def takeoff_climb_angle(self, inVal:typing.Any) -> None:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_climb_angle"](arg_inVal.COM_val))

    @property
    def departure_altitude(self) -> float:
        """The aircraft's altitude when it departs the runway."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @departure_altitude.setter
    def departure_altitude(self, inVal:float) -> None:
        """The aircraft's altitude when it departs the runway."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_departure_altitude"](arg_inVal.COM_val))

    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_runway_terrain"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_runway_terrain"](arg_inVal.COM_val))

    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_runway_altitude_offset"](arg_inVal.COM_val))

    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_on_deck"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_on_deck"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0a373629-d29b-4c4f-a59f-54fc567022cb}", ITakeoffNormal)
agcls.AgTypeNameMap["ITakeoffNormal"] = ITakeoffNormal

class ITakeoffDeparturePoint(object):
    """The interface used to access the options for a Departure Point takeoff mode. The mode must be set to Departure Point to access this interface."""
    _uuid = "{24e5949d-456b-4abb-9d46-7095d8ad0fb3}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_takeoff_climb_angle"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_climb_angle"] = _raise_uninitialized_error
        self.__dict__["_get_departure_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_departure_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_departure_point_range"] = _raise_uninitialized_error
        self.__dict__["_set_departure_point_range"] = _raise_uninitialized_error
        self.__dict__["_get_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_set_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_get_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_hold_on_deck"] = _raise_uninitialized_error
        self.__dict__["_set_hold_on_deck"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITakeoffDeparturePoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITakeoffDeparturePoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITakeoffDeparturePoint = agcom.GUID(ITakeoffDeparturePoint._uuid)
        vtable_offset_local = ITakeoffDeparturePoint._vtable_offset - 1
        self.__dict__["_get_takeoff_climb_angle"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_takeoff_climb_angle"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_departure_altitude"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_departure_altitude"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_departure_point_range"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_departure_point_range"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_ITakeoffDeparturePoint, vtable_offset_local+12, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITakeoffDeparturePoint.__dict__ and type(ITakeoffDeparturePoint.__dict__[attrname]) == property:
            return ITakeoffDeparturePoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITakeoffDeparturePoint.")
    
    @property
    def takeoff_climb_angle(self) -> typing.Any:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_climb_angle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @takeoff_climb_angle.setter
    def takeoff_climb_angle(self, inVal:typing.Any) -> None:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_climb_angle"](arg_inVal.COM_val))

    @property
    def departure_altitude(self) -> float:
        """The aircraft's altitude when it departs the runway."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @departure_altitude.setter
    def departure_altitude(self, inVal:float) -> None:
        """The aircraft's altitude when it departs the runway."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_departure_altitude"](arg_inVal.COM_val))

    @property
    def departure_point_range(self) -> float:
        """The downrange distance the aircraft will travel when departing the runway."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_departure_point_range"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @departure_point_range.setter
    def departure_point_range(self, inVal:float) -> None:
        """The downrange distance the aircraft will travel when departing the runway."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_departure_point_range"](arg_inVal.COM_val))

    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_runway_terrain"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_runway_terrain"](arg_inVal.COM_val))

    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_runway_altitude_offset"](arg_inVal.COM_val))

    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_on_deck"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_on_deck"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{24e5949d-456b-4abb-9d46-7095d8ad0fb3}", ITakeoffDeparturePoint)
agcls.AgTypeNameMap["ITakeoffDeparturePoint"] = ITakeoffDeparturePoint

class ITakeoffLowTransition(object):
    """The interface used to access the options for a Low Transition takeoff mode. The mode must be set to Low Transition to access this interface."""
    _uuid = "{f205a7c2-5797-4e9f-aac6-7dfe110bcec0}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_set_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_get_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_hold_on_deck"] = _raise_uninitialized_error
        self.__dict__["_set_hold_on_deck"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITakeoffLowTransition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITakeoffLowTransition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITakeoffLowTransition = agcom.GUID(ITakeoffLowTransition._uuid)
        vtable_offset_local = ITakeoffLowTransition._vtable_offset - 1
        self.__dict__["_get_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ITakeoffLowTransition, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ITakeoffLowTransition, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITakeoffLowTransition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ITakeoffLowTransition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_ITakeoffLowTransition, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_ITakeoffLowTransition, vtable_offset_local+6, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITakeoffLowTransition.__dict__ and type(ITakeoffLowTransition.__dict__[attrname]) == property:
            return ITakeoffLowTransition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITakeoffLowTransition.")
    
    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_runway_terrain"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_runway_terrain"](arg_inVal.COM_val))

    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_runway_altitude_offset"](arg_inVal.COM_val))

    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_on_deck"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_on_deck"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{f205a7c2-5797-4e9f-aac6-7dfe110bcec0}", ITakeoffLowTransition)
agcls.AgTypeNameMap["ITakeoffLowTransition"] = ITakeoffLowTransition

class IReferenceStateForwardFlightOptions(object):
    """Interface used to access the forward flight options for a reference state procedure."""
    _uuid = "{f5baa380-d776-4591-a9c6-4836d6919165}"
    _num_methods = 33
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_tas_dot"] = _raise_uninitialized_error
        self.__dict__["_get_groundspeed_dot"] = _raise_uninitialized_error
        self.__dict__["_get_longitudinal_accel_type"] = _raise_uninitialized_error
        self.__dict__["_set_longitudinal_accel"] = _raise_uninitialized_error
        self.__dict__["_get_heading"] = _raise_uninitialized_error
        self.__dict__["_set_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_get_course"] = _raise_uninitialized_error
        self.__dict__["_set_course"] = _raise_uninitialized_error
        self.__dict__["_get_course_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_course_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_get_heading_dot"] = _raise_uninitialized_error
        self.__dict__["_get_course_dot"] = _raise_uninitialized_error
        self.__dict__["_get_lateral_accel_type"] = _raise_uninitialized_error
        self.__dict__["_set_lateral_accel"] = _raise_uninitialized_error
        self.__dict__["_get_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_sideslip"] = _raise_uninitialized_error
        self.__dict__["_set_sideslip"] = _raise_uninitialized_error
        self.__dict__["_get_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_get_push_pull_g"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_rate_type"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IReferenceStateForwardFlightOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateForwardFlightOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IReferenceStateForwardFlightOptions = agcom.GUID(IReferenceStateForwardFlightOptions._uuid)
        vtable_offset_local = IReferenceStateForwardFlightOptions._vtable_offset - 1
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+3, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_tas_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_get_groundspeed_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_get_longitudinal_accel_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_longitudinal_accel"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+11, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_course"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+16, POINTER(agcom.VARIANT))
        self.__dict__["_set_course"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+17, agcom.VARIANT)
        self.__dict__["_get_course_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_course_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_heading_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+20, POINTER(agcom.VARIANT))
        self.__dict__["_get_course_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+21, POINTER(agcom.VARIANT))
        self.__dict__["_get_lateral_accel_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_lateral_accel"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+23, agcom.LONG, agcom.VARIANT)
        self.__dict__["_get_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+24, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+25, agcom.VARIANT)
        self.__dict__["_get_aoa"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+26, POINTER(agcom.VARIANT))
        self.__dict__["_set_aoa"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+27, agcom.VARIANT)
        self.__dict__["_get_sideslip"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+28, POINTER(agcom.VARIANT))
        self.__dict__["_set_sideslip"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+29, agcom.VARIANT)
        self.__dict__["_get_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+30, POINTER(agcom.VARIANT))
        self.__dict__["_get_push_pull_g"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_get_attitude_rate_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+32, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateForwardFlightOptions, vtable_offset_local+33, agcom.LONG, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateForwardFlightOptions.__dict__ and type(IReferenceStateForwardFlightOptions.__dict__[attrname]) == property:
            return IReferenceStateForwardFlightOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateForwardFlightOptions.")
    
    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def altitude_rate(self) -> float:
        """The rate at which the aircraft will climb or descend."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The rate at which the aircraft will climb or descend."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def flight_path_angle(self) -> typing.Any:
        """The initial pitch angle of the flight path."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The initial pitch angle of the flight path."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_path_angle"](arg_newVal.COM_val))

    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tas_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_groundspeed_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def longitudinal_accel_type(self) -> "AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitudinal_accel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_longitudinal_accel(self, accelType:"AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE, accelType) as arg_accelType, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_longitudinal_accel"](arg_accelType.COM_val, arg_value.COM_val))

    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading"](arg_newVal.COM_val))

    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_is_magnetic"](arg_newVal.COM_val))

    @property
    def course(self) -> typing.Any:
        """The direction the aircraft is traveling."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The direction the aircraft is traveling."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course"](arg_newVal.COM_val))

    @property
    def course_is_magnetic(self) -> bool:
        """Opt whether to specify the course using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course_is_magnetic.setter
    def course_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the course using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course_is_magnetic"](arg_newVal.COM_val))

    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def lateral_accel_type(self) -> "AVTR_REF_STATE_LATERAL_ACCEL_MODE":
        """The mode to specify the lateral acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LATERAL_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lateral_accel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_lateral_accel(self, accelType:"AVTR_REF_STATE_LATERAL_ACCEL_MODE", value:typing.Any) -> None:
        """Set the lateral acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LATERAL_ACCEL_MODE, accelType) as arg_accelType, \
             agmarshall.VARIANT_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_lateral_accel"](arg_accelType.COM_val, arg_value.COM_val))

    @property
    def roll_angle(self) -> typing.Any:
        """The aircraft's bank angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The aircraft's bank angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_angle"](arg_newVal.COM_val))

    @property
    def aoa(self) -> typing.Any:
        """The aircraft's angle of attack."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The aircraft's angle of attack."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_aoa"](arg_newVal.COM_val))

    @property
    def sideslip(self) -> typing.Any:
        """The aircraft's yaw angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sideslip"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sideslip.setter
    def sideslip(self, newVal:typing.Any) -> None:
        """The aircraft's yaw angle"""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sideslip"](arg_newVal.COM_val))

    @property
    def pitch_rate(self) -> typing.Any:
        """The aircraft's pitch rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pitch_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def push_pull_g(self) -> float:
        """The G force on the aircraft resulting from its attitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_push_pull_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def attitude_rate_type(self) -> "AVTR_REF_STATE_ATTITUDE_MODE":
        """The mode to specify the vertical attitude rate."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_ATTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_rate_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_attitude_rate(self, attitudeRateType:"AVTR_REF_STATE_ATTITUDE_MODE", value:typing.Any) -> None:
        """Set the vertical attitude rate."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_ATTITUDE_MODE, attitudeRateType) as arg_attitudeRateType, \
             agmarshall.VARIANT_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_rate"](arg_attitudeRateType.COM_val, arg_value.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{f5baa380-d776-4591-a9c6-4836d6919165}", IReferenceStateForwardFlightOptions)
agcls.AgTypeNameMap["IReferenceStateForwardFlightOptions"] = IReferenceStateForwardFlightOptions

class IReferenceStateHoverOptions(object):
    """Interface used to access the hover options for a reference state procedure."""
    _uuid = "{42eb7689-e629-44f0-b832-44dcbecbeb3e}"
    _num_methods = 28
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_groundspeed"] = _raise_uninitialized_error
        self.__dict__["_set_groundspeed"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_tas_dot"] = _raise_uninitialized_error
        self.__dict__["_get_groundspeed_dot"] = _raise_uninitialized_error
        self.__dict__["_get_longitudinal_accel_type"] = _raise_uninitialized_error
        self.__dict__["_set_longitudinal_accel"] = _raise_uninitialized_error
        self.__dict__["_get_heading"] = _raise_uninitialized_error
        self.__dict__["_set_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_get_course"] = _raise_uninitialized_error
        self.__dict__["_set_course"] = _raise_uninitialized_error
        self.__dict__["_get_course_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_course_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_get_heading_dot"] = _raise_uninitialized_error
        self.__dict__["_set_heading_dot"] = _raise_uninitialized_error
        self.__dict__["_get_course_dot"] = _raise_uninitialized_error
        self.__dict__["_set_course_dot"] = _raise_uninitialized_error
        self.__dict__["_get_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_get_push_pull_g"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_rate_type"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IReferenceStateHoverOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateHoverOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IReferenceStateHoverOptions = agcom.GUID(IReferenceStateHoverOptions._uuid)
        vtable_offset_local = IReferenceStateHoverOptions._vtable_offset - 1
        self.__dict__["_get_groundspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_groundspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_tas_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_get_groundspeed_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_get_longitudinal_accel_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_longitudinal_accel"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+8, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_course"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_course"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_course_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_course_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_heading_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+17, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+18, agcom.VARIANT)
        self.__dict__["_get_course_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+19, POINTER(agcom.VARIANT))
        self.__dict__["_set_course_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+20, agcom.VARIANT)
        self.__dict__["_get_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+21, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+22, agcom.VARIANT)
        self.__dict__["_get_aoa"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+23, POINTER(agcom.VARIANT))
        self.__dict__["_set_aoa"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+24, agcom.VARIANT)
        self.__dict__["_get_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+25, POINTER(agcom.VARIANT))
        self.__dict__["_get_push_pull_g"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_get_attitude_rate_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+27, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateHoverOptions, vtable_offset_local+28, agcom.LONG, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateHoverOptions.__dict__ and type(IReferenceStateHoverOptions.__dict__[attrname]) == property:
            return IReferenceStateHoverOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateHoverOptions.")
    
    @property
    def groundspeed(self) -> float:
        """The aircraft's speed relative to the ground."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_groundspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @groundspeed.setter
    def groundspeed(self, newVal:float) -> None:
        """The aircraft's speed relative to the ground."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_groundspeed"](arg_newVal.COM_val))

    @property
    def altitude_rate(self) -> float:
        """The rate at which the aircraft will climb or descend."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The rate at which the aircraft will climb or descend."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tas_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_groundspeed_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def longitudinal_accel_type(self) -> "AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitudinal_accel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_longitudinal_accel(self, accelType:"AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE, accelType) as arg_accelType, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_longitudinal_accel"](arg_accelType.COM_val, arg_value.COM_val))

    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading"](arg_newVal.COM_val))

    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_is_magnetic"](arg_newVal.COM_val))

    @property
    def course(self) -> typing.Any:
        """The direction the aircraft is traveling."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The direction the aircraft is traveling."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course"](arg_newVal.COM_val))

    @property
    def course_is_magnetic(self) -> bool:
        """Opt whether to specify the course using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course_is_magnetic.setter
    def course_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the course using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course_is_magnetic"](arg_newVal.COM_val))

    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_dot.setter
    def heading_dot(self, newVal:typing.Any) -> None:
        """The heading rate of change."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_dot"](arg_newVal.COM_val))

    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course_dot.setter
    def course_dot(self, newVal:typing.Any) -> None:
        """The course rate of change."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course_dot"](arg_newVal.COM_val))

    @property
    def roll_angle(self) -> typing.Any:
        """The aircraft's bank angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The aircraft's bank angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_angle"](arg_newVal.COM_val))

    @property
    def aoa(self) -> typing.Any:
        """The aircraft's angle of attack."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The aircraft's angle of attack."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_aoa"](arg_newVal.COM_val))

    @property
    def pitch_rate(self) -> typing.Any:
        """The aircraft's pitch rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pitch_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def push_pull_g(self) -> float:
        """The G force on the aircraft resulting from its attitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_push_pull_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def attitude_rate_type(self) -> "AVTR_REF_STATE_ATTITUDE_MODE":
        """The mode to specify the vertical attitude rate."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_ATTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_rate_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_attitude_rate(self, attitudeRateType:"AVTR_REF_STATE_ATTITUDE_MODE", value:typing.Any) -> None:
        """Set the vertical attitude rate."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_ATTITUDE_MODE, attitudeRateType) as arg_attitudeRateType, \
             agmarshall.VARIANT_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_rate"](arg_attitudeRateType.COM_val, arg_value.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{42eb7689-e629-44f0-b832-44dcbecbeb3e}", IReferenceStateHoverOptions)
agcls.AgTypeNameMap["IReferenceStateHoverOptions"] = IReferenceStateHoverOptions

class IReferenceStateWeightOnWheelsOptions(object):
    """Interface used to access the weight on wheels options for a reference state procedure."""
    _uuid = "{14db8803-47cd-4009-b496-13caaa53babe}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_groundspeed"] = _raise_uninitialized_error
        self.__dict__["_set_groundspeed"] = _raise_uninitialized_error
        self.__dict__["_get_tas_dot"] = _raise_uninitialized_error
        self.__dict__["_get_groundspeed_dot"] = _raise_uninitialized_error
        self.__dict__["_get_longitudinal_accel_type"] = _raise_uninitialized_error
        self.__dict__["_set_longitudinal_accel"] = _raise_uninitialized_error
        self.__dict__["_get_heading"] = _raise_uninitialized_error
        self.__dict__["_set_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_get_heading_dot"] = _raise_uninitialized_error
        self.__dict__["_get_course_dot"] = _raise_uninitialized_error
        self.__dict__["_get_lateral_accel_type"] = _raise_uninitialized_error
        self.__dict__["_set_lateral_accel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IReferenceStateWeightOnWheelsOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateWeightOnWheelsOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IReferenceStateWeightOnWheelsOptions = agcom.GUID(IReferenceStateWeightOnWheelsOptions._uuid)
        vtable_offset_local = IReferenceStateWeightOnWheelsOptions._vtable_offset - 1
        self.__dict__["_get_groundspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_groundspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_tas_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_groundspeed_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_get_longitudinal_accel_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_longitudinal_accel"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+6, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_heading_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_get_course_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_get_lateral_accel_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_lateral_accel"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateWeightOnWheelsOptions, vtable_offset_local+14, agcom.LONG, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateWeightOnWheelsOptions.__dict__ and type(IReferenceStateWeightOnWheelsOptions.__dict__[attrname]) == property:
            return IReferenceStateWeightOnWheelsOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateWeightOnWheelsOptions.")
    
    @property
    def groundspeed(self) -> float:
        """The aircraft's speed relative to the ground."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_groundspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @groundspeed.setter
    def groundspeed(self, newVal:float) -> None:
        """The aircraft's speed relative to the ground."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_groundspeed"](arg_newVal.COM_val))

    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tas_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_groundspeed_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def longitudinal_accel_type(self) -> "AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitudinal_accel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_longitudinal_accel(self, accelType:"AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE, accelType) as arg_accelType, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_longitudinal_accel"](arg_accelType.COM_val, arg_value.COM_val))

    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading"](arg_newVal.COM_val))

    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_is_magnetic"](arg_newVal.COM_val))

    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def lateral_accel_type(self) -> "AVTR_REF_STATE_LATERAL_ACCEL_MODE":
        """The mode to specify the lateral acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LATERAL_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lateral_accel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_lateral_accel(self, accelType:"AVTR_REF_STATE_LATERAL_ACCEL_MODE", value:typing.Any) -> None:
        """Set the lateral acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LATERAL_ACCEL_MODE, accelType) as arg_accelType, \
             agmarshall.VARIANT_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_lateral_accel"](arg_accelType.COM_val, arg_value.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{14db8803-47cd-4009-b496-13caaa53babe}", IReferenceStateWeightOnWheelsOptions)
agcls.AgTypeNameMap["IReferenceStateWeightOnWheelsOptions"] = IReferenceStateWeightOnWheelsOptions

class IReferenceStateTakeoffLandingOptions(object):
    """Interface used to access the takeoff or landing options for a reference state procedure."""
    _uuid = "{b510a16b-3a33-408e-bed8-33dd61b76617}"
    _num_methods = 33
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_tas_dot"] = _raise_uninitialized_error
        self.__dict__["_get_groundspeed_dot"] = _raise_uninitialized_error
        self.__dict__["_get_longitudinal_accel_type"] = _raise_uninitialized_error
        self.__dict__["_set_longitudinal_accel"] = _raise_uninitialized_error
        self.__dict__["_get_heading"] = _raise_uninitialized_error
        self.__dict__["_set_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_heading_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_get_course"] = _raise_uninitialized_error
        self.__dict__["_set_course"] = _raise_uninitialized_error
        self.__dict__["_get_course_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_course_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_get_heading_dot"] = _raise_uninitialized_error
        self.__dict__["_get_course_dot"] = _raise_uninitialized_error
        self.__dict__["_get_lateral_accel_type"] = _raise_uninitialized_error
        self.__dict__["_set_lateral_accel"] = _raise_uninitialized_error
        self.__dict__["_get_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_set_roll_angle"] = _raise_uninitialized_error
        self.__dict__["_get_aoa"] = _raise_uninitialized_error
        self.__dict__["_set_aoa"] = _raise_uninitialized_error
        self.__dict__["_get_sideslip"] = _raise_uninitialized_error
        self.__dict__["_set_sideslip"] = _raise_uninitialized_error
        self.__dict__["_get_pitch_rate"] = _raise_uninitialized_error
        self.__dict__["_get_push_pull_g"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_rate_type"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IReferenceStateTakeoffLandingOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateTakeoffLandingOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IReferenceStateTakeoffLandingOptions = agcom.GUID(IReferenceStateTakeoffLandingOptions._uuid)
        vtable_offset_local = IReferenceStateTakeoffLandingOptions._vtable_offset - 1
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+3, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_tas_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_get_groundspeed_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_get_longitudinal_accel_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_longitudinal_accel"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+11, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_heading"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_heading_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_course"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+16, POINTER(agcom.VARIANT))
        self.__dict__["_set_course"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+17, agcom.VARIANT)
        self.__dict__["_get_course_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_course_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_heading_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+20, POINTER(agcom.VARIANT))
        self.__dict__["_get_course_dot"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+21, POINTER(agcom.VARIANT))
        self.__dict__["_get_lateral_accel_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_lateral_accel"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+23, agcom.LONG, agcom.VARIANT)
        self.__dict__["_get_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+24, POINTER(agcom.VARIANT))
        self.__dict__["_set_roll_angle"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+25, agcom.VARIANT)
        self.__dict__["_get_aoa"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+26, POINTER(agcom.VARIANT))
        self.__dict__["_set_aoa"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+27, agcom.VARIANT)
        self.__dict__["_get_sideslip"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+28, POINTER(agcom.VARIANT))
        self.__dict__["_set_sideslip"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+29, agcom.VARIANT)
        self.__dict__["_get_pitch_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+30, POINTER(agcom.VARIANT))
        self.__dict__["_get_push_pull_g"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_get_attitude_rate_type"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+32, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_rate"] = IAGFUNCTYPE(pUnk, IID_IReferenceStateTakeoffLandingOptions, vtable_offset_local+33, agcom.LONG, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateTakeoffLandingOptions.__dict__ and type(IReferenceStateTakeoffLandingOptions.__dict__[attrname]) == property:
            return IReferenceStateTakeoffLandingOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateTakeoffLandingOptions.")
    
    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def altitude_rate(self) -> float:
        """The rate at which the aircraft will climb or descend."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The rate at which the aircraft will climb or descend."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def flight_path_angle(self) -> typing.Any:
        """The initial pitch angle of the flight path."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The initial pitch angle of the flight path."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_path_angle"](arg_newVal.COM_val))

    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tas_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_groundspeed_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def longitudinal_accel_type(self) -> "AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitudinal_accel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_longitudinal_accel(self, accelType:"AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LONGITUDINAL_ACCEL_MODE, accelType) as arg_accelType, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_longitudinal_accel"](arg_accelType.COM_val, arg_value.COM_val))

    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading"](arg_newVal.COM_val))

    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_is_magnetic"](arg_newVal.COM_val))

    @property
    def course(self) -> typing.Any:
        """The direction the aircraft is traveling."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The direction the aircraft is traveling."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course"](arg_newVal.COM_val))

    @property
    def course_is_magnetic(self) -> bool:
        """Opt whether to specify the course using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course_is_magnetic.setter
    def course_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the course using magnetic North."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course_is_magnetic"](arg_newVal.COM_val))

    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_dot"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def lateral_accel_type(self) -> "AVTR_REF_STATE_LATERAL_ACCEL_MODE":
        """The mode to specify the lateral acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LATERAL_ACCEL_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lateral_accel_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_lateral_accel(self, accelType:"AVTR_REF_STATE_LATERAL_ACCEL_MODE", value:typing.Any) -> None:
        """Set the lateral acceleration."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_LATERAL_ACCEL_MODE, accelType) as arg_accelType, \
             agmarshall.VARIANT_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_lateral_accel"](arg_accelType.COM_val, arg_value.COM_val))

    @property
    def roll_angle(self) -> typing.Any:
        """The aircraft's bank angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_roll_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The aircraft's bank angle."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_roll_angle"](arg_newVal.COM_val))

    @property
    def aoa(self) -> typing.Any:
        """The aircraft's angle of attack."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aoa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The aircraft's angle of attack."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_aoa"](arg_newVal.COM_val))

    @property
    def sideslip(self) -> typing.Any:
        """The aircraft's yaw angle."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sideslip"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sideslip.setter
    def sideslip(self, newVal:typing.Any) -> None:
        """The aircraft's yaw angle"""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sideslip"](arg_newVal.COM_val))

    @property
    def pitch_rate(self) -> typing.Any:
        """The aircraft's pitch rate."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pitch_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def push_pull_g(self) -> float:
        """The G force on the aircraft resulting from its attitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_push_pull_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def attitude_rate_type(self) -> "AVTR_REF_STATE_ATTITUDE_MODE":
        """The mode to specify the vertical attitude rate."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_ATTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_rate_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_attitude_rate(self, attitudeRateType:"AVTR_REF_STATE_ATTITUDE_MODE", value:typing.Any) -> None:
        """Set the vertical attitude rate."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_ATTITUDE_MODE, attitudeRateType) as arg_attitudeRateType, \
             agmarshall.VARIANT_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_rate"](arg_attitudeRateType.COM_val, arg_value.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b510a16b-3a33-408e-bed8-33dd61b76617}", IReferenceStateTakeoffLandingOptions)
agcls.AgTypeNameMap["IReferenceStateTakeoffLandingOptions"] = IReferenceStateTakeoffLandingOptions

class ILandingEnterDownwindPattern(object):
    """The interface used to access the options for a Downwind Pattern approach mode for a landing procedure. The approach mode must be set to Downwind Pattern to access this interface."""
    _uuid = "{6206fdbf-5eb3-41b4-8792-d562bb2ec92a}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_approach_fix_range"] = _raise_uninitialized_error
        self.__dict__["_set_approach_fix_range"] = _raise_uninitialized_error
        self.__dict__["_get_approach_fix_range_mode"] = _raise_uninitialized_error
        self.__dict__["_set_approach_fix_range_mode"] = _raise_uninitialized_error
        self.__dict__["_get_abeam_distance"] = _raise_uninitialized_error
        self.__dict__["_set_abeam_distance"] = _raise_uninitialized_error
        self.__dict__["_get_abeam_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_abeam_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_final_turn"] = _raise_uninitialized_error
        self.__dict__["_set_final_turn"] = _raise_uninitialized_error
        self.__dict__["_get_glideslope"] = _raise_uninitialized_error
        self.__dict__["_set_glideslope"] = _raise_uninitialized_error
        self.__dict__["_get_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_set_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_get_touch_and_go"] = _raise_uninitialized_error
        self.__dict__["_set_touch_and_go"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILandingEnterDownwindPattern._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILandingEnterDownwindPattern from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILandingEnterDownwindPattern = agcom.GUID(ILandingEnterDownwindPattern._uuid)
        vtable_offset_local = ILandingEnterDownwindPattern._vtable_offset - 1
        self.__dict__["_get_approach_fix_range"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_approach_fix_range"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_approach_fix_range_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_approach_fix_range_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_abeam_distance"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_abeam_distance"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_abeam_altitude"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_abeam_altitude"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_final_turn"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_final_turn"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_glideslope"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_glideslope"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_touch_and_go"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_touch_and_go"] = IAGFUNCTYPE(pUnk, IID_ILandingEnterDownwindPattern, vtable_offset_local+18, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILandingEnterDownwindPattern.__dict__ and type(ILandingEnterDownwindPattern.__dict__[attrname]) == property:
            return ILandingEnterDownwindPattern.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILandingEnterDownwindPattern.")
    
    @property
    def approach_fix_range(self) -> float:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_fix_range"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @approach_fix_range.setter
    def approach_fix_range(self, inVal:float) -> None:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_fix_range"](arg_inVal.COM_val))

    @property
    def approach_fix_range_mode(self) -> "AVTR_LANDING_APPROACH_FIX_RANGE_MODE":
        """The reference point on the runway for the Approach Fix Range."""
        with agmarshall.AgEnum_arg(AVTR_LANDING_APPROACH_FIX_RANGE_MODE) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_fix_range_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @approach_fix_range_mode.setter
    def approach_fix_range_mode(self, inVal:"AVTR_LANDING_APPROACH_FIX_RANGE_MODE") -> None:
        """The reference point on the runway for the Approach Fix Range."""
        with agmarshall.AgEnum_arg(AVTR_LANDING_APPROACH_FIX_RANGE_MODE, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_fix_range_mode"](arg_inVal.COM_val))

    @property
    def abeam_distance(self) -> float:
        """The distance from the runway that the aircraft will fly the parallel leg of the landing pattern."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_abeam_distance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @abeam_distance.setter
    def abeam_distance(self, inVal:float) -> None:
        """The distance from the runway that the aircraft will fly the parallel leg of the landing pattern."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_abeam_distance"](arg_inVal.COM_val))

    @property
    def abeam_altitude(self) -> float:
        """The altitude at which the aircraft will fly the parallel leg of the landing pattern."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_abeam_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @abeam_altitude.setter
    def abeam_altitude(self, inVal:float) -> None:
        """The altitude at which the aircraft will fly the parallel leg of the landing pattern."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_abeam_altitude"](arg_inVal.COM_val))

    @property
    def final_turn(self) -> "AVTR_NAVIGATOR_TURN_DIR":
        """The direction of the turn that the aircraft will make when it lines up over the runway to land."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_turn"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @final_turn.setter
    def final_turn(self, inVal:"AVTR_NAVIGATOR_TURN_DIR") -> None:
        """The direction of the turn that the aircraft will make when it lines up over the runway to land."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_turn"](arg_inVal.COM_val))

    @property
    def glideslope(self) -> typing.Any:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_glideslope"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @glideslope.setter
    def glideslope(self, inVal:typing.Any) -> None:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_glideslope"](arg_inVal.COM_val))

    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_runway_altitude_offset"](arg_inVal.COM_val))

    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_runway_terrain"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_runway_terrain"](arg_inVal.COM_val))

    @property
    def touch_and_go(self) -> bool:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_touch_and_go"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @touch_and_go.setter
    def touch_and_go(self, inVal:bool) -> None:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_touch_and_go"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6206fdbf-5eb3-41b4-8792-d562bb2ec92a}", ILandingEnterDownwindPattern)
agcls.AgTypeNameMap["ILandingEnterDownwindPattern"] = ILandingEnterDownwindPattern

class ILandingInterceptGlideslope(object):
    """The interface used to access the options for an Intercept Glideslope approach mode for a landing procedure. The approach mode must be set to Intercept Glideslope to access this interface."""
    _uuid = "{534bfa1e-99e8-4188-a66a-53166e8d6536}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_approach_fix_range"] = _raise_uninitialized_error
        self.__dict__["_set_approach_fix_range"] = _raise_uninitialized_error
        self.__dict__["_get_approach_fix_range_mode"] = _raise_uninitialized_error
        self.__dict__["_set_approach_fix_range_mode"] = _raise_uninitialized_error
        self.__dict__["_get_glideslope"] = _raise_uninitialized_error
        self.__dict__["_set_glideslope"] = _raise_uninitialized_error
        self.__dict__["_get_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_set_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_get_touch_and_go"] = _raise_uninitialized_error
        self.__dict__["_set_touch_and_go"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILandingInterceptGlideslope._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILandingInterceptGlideslope from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILandingInterceptGlideslope = agcom.GUID(ILandingInterceptGlideslope._uuid)
        vtable_offset_local = ILandingInterceptGlideslope._vtable_offset - 1
        self.__dict__["_get_approach_fix_range"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_approach_fix_range"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_approach_fix_range_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_approach_fix_range_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_glideslope"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_glideslope"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_touch_and_go"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_touch_and_go"] = IAGFUNCTYPE(pUnk, IID_ILandingInterceptGlideslope, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILandingInterceptGlideslope.__dict__ and type(ILandingInterceptGlideslope.__dict__[attrname]) == property:
            return ILandingInterceptGlideslope.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILandingInterceptGlideslope.")
    
    @property
    def approach_fix_range(self) -> float:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_fix_range"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @approach_fix_range.setter
    def approach_fix_range(self, inVal:float) -> None:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_fix_range"](arg_inVal.COM_val))

    @property
    def approach_fix_range_mode(self) -> "AVTR_LANDING_APPROACH_FIX_RANGE_MODE":
        """The reference point on the runway for the Approach Fix Range."""
        with agmarshall.AgEnum_arg(AVTR_LANDING_APPROACH_FIX_RANGE_MODE) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_fix_range_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @approach_fix_range_mode.setter
    def approach_fix_range_mode(self, inVal:"AVTR_LANDING_APPROACH_FIX_RANGE_MODE") -> None:
        """The reference point on the runway for the Approach Fix Range."""
        with agmarshall.AgEnum_arg(AVTR_LANDING_APPROACH_FIX_RANGE_MODE, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_fix_range_mode"](arg_inVal.COM_val))

    @property
    def glideslope(self) -> typing.Any:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_glideslope"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @glideslope.setter
    def glideslope(self, inVal:typing.Any) -> None:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_glideslope"](arg_inVal.COM_val))

    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_runway_altitude_offset"](arg_inVal.COM_val))

    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_runway_terrain"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_runway_terrain"](arg_inVal.COM_val))

    @property
    def touch_and_go(self) -> bool:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_touch_and_go"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @touch_and_go.setter
    def touch_and_go(self, inVal:bool) -> None:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_touch_and_go"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{534bfa1e-99e8-4188-a66a-53166e8d6536}", ILandingInterceptGlideslope)
agcls.AgTypeNameMap["ILandingInterceptGlideslope"] = ILandingInterceptGlideslope

class ILandingStandardInstrumentApproach(object):
    """The interface used to access the options for a Standard Instrument Approach mode for a landing procedure. The approach mode must be set to Standard Instrument Approach to access this interface."""
    _uuid = "{28c196c4-2768-49ce-a384-d0c37394be0f}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_approach_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_approach_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_get_approach_fix_range"] = _raise_uninitialized_error
        self.__dict__["_set_approach_fix_range"] = _raise_uninitialized_error
        self.__dict__["_get_approach_fix_range_mode"] = _raise_uninitialized_error
        self.__dict__["_set_approach_fix_range_mode"] = _raise_uninitialized_error
        self.__dict__["_get_glideslope"] = _raise_uninitialized_error
        self.__dict__["_set_glideslope"] = _raise_uninitialized_error
        self.__dict__["_get_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_runway_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_set_use_runway_terrain"] = _raise_uninitialized_error
        self.__dict__["_get_touch_and_go"] = _raise_uninitialized_error
        self.__dict__["_set_touch_and_go"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILandingStandardInstrumentApproach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILandingStandardInstrumentApproach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ILandingStandardInstrumentApproach = agcom.GUID(ILandingStandardInstrumentApproach._uuid)
        vtable_offset_local = ILandingStandardInstrumentApproach._vtable_offset - 1
        self.__dict__["_get_approach_altitude"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_approach_altitude"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_approach_fix_range"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_approach_fix_range"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_approach_fix_range_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_approach_fix_range_mode"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_glideslope"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_glideslope"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_runway_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_runway_terrain"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_touch_and_go"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_touch_and_go"] = IAGFUNCTYPE(pUnk, IID_ILandingStandardInstrumentApproach, vtable_offset_local+16, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILandingStandardInstrumentApproach.__dict__ and type(ILandingStandardInstrumentApproach.__dict__[attrname]) == property:
            return ILandingStandardInstrumentApproach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILandingStandardInstrumentApproach.")
    
    @property
    def approach_altitude(self) -> float:
        """The aircraft's altitude at the Initial Approach Fix Range."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_altitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @approach_altitude.setter
    def approach_altitude(self, inVal:float) -> None:
        """The aircraft's altitude at the Initial Approach Fix Range."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_altitude"](arg_inVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, inVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_inVal.COM_val))

    @property
    def approach_fix_range(self) -> float:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_fix_range"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @approach_fix_range.setter
    def approach_fix_range(self, inVal:float) -> None:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_fix_range"](arg_inVal.COM_val))

    @property
    def approach_fix_range_mode(self) -> "AVTR_LANDING_APPROACH_FIX_RANGE_MODE":
        """The reference point on the runway for the Approach Fix Range."""
        with agmarshall.AgEnum_arg(AVTR_LANDING_APPROACH_FIX_RANGE_MODE) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_fix_range_mode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @approach_fix_range_mode.setter
    def approach_fix_range_mode(self, inVal:"AVTR_LANDING_APPROACH_FIX_RANGE_MODE") -> None:
        """The reference point on the runway for the Approach Fix Range."""
        with agmarshall.AgEnum_arg(AVTR_LANDING_APPROACH_FIX_RANGE_MODE, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_fix_range_mode"](arg_inVal.COM_val))

    @property
    def glideslope(self) -> typing.Any:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_glideslope"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @glideslope.setter
    def glideslope(self, inVal:typing.Any) -> None:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_glideslope"](arg_inVal.COM_val))

    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_altitude_offset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_runway_altitude_offset"](arg_inVal.COM_val))

    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_runway_terrain"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_runway_terrain"](arg_inVal.COM_val))

    @property
    def touch_and_go(self) -> bool:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_touch_and_go"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @touch_and_go.setter
    def touch_and_go(self, inVal:bool) -> None:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_touch_and_go"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{28c196c4-2768-49ce-a384-d0c37394be0f}", ILandingStandardInstrumentApproach)
agcls.AgTypeNameMap["ILandingStandardInstrumentApproach"] = ILandingStandardInstrumentApproach

class IProcedureBasicManeuver(object):
    """Interface used to access the options for a Basic Maneuver procedure"""
    _uuid = "{7cf58344-514c-44a6-aaf0-a45c4472e299}"
    _num_methods = 37
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_set_max_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_get_stop_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_set_stop_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_get_use_stop_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_set_use_stop_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_get_max_downrange"] = _raise_uninitialized_error
        self.__dict__["_set_max_downrange"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_downrange"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_downrange"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_limit_mode"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_impact_mode"] = _raise_uninitialized_error
        self.__dict__["_set_terrain_impact_mode"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_impact_time_offset"] = _raise_uninitialized_error
        self.__dict__["_set_terrain_impact_time_offset"] = _raise_uninitialized_error
        self.__dict__["_get_navigation_strategy_type"] = _raise_uninitialized_error
        self.__dict__["_set_navigation_strategy_type"] = _raise_uninitialized_error
        self.__dict__["_get_navigation"] = _raise_uninitialized_error
        self.__dict__["_get_profile_strategy_type"] = _raise_uninitialized_error
        self.__dict__["_set_profile_strategy_type"] = _raise_uninitialized_error
        self.__dict__["_get_profile"] = _raise_uninitialized_error
        self.__dict__["_get_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_set_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_get_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_set_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_get_scale_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_scale_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_blend_time"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_blend_time"] = _raise_uninitialized_error
        self.__dict__["_get_control_time_constant"] = _raise_uninitialized_error
        self.__dict__["_set_control_time_constant"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureBasicManeuver._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureBasicManeuver from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureBasicManeuver = agcom.GUID(IProcedureBasicManeuver._uuid)
        vtable_offset_local = IProcedureBasicManeuver._vtable_offset - 1
        self.__dict__["_get_max_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_use_max_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_stop_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_use_stop_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_stop_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_downrange"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_downrange"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_use_max_downrange"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_downrange"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_limit_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_terrain_impact_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_terrain_impact_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_terrain_impact_time_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_terrain_impact_time_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_navigation_strategy_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_navigation_strategy_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_navigation"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_get_profile_strategy_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+22, POINTER(agcom.BSTR))
        self.__dict__["_set_profile_strategy_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+23, agcom.BSTR)
        self.__dict__["_get_profile"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+25, POINTER(agcom.LONG))
        self.__dict__["_set_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+26, agcom.LONG)
        self.__dict__["_get_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+27, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+28, agcom.LONG)
        self.__dict__["_get_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_scale_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+31, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_scale_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+32, agcom.VARIANT_BOOL)
        self.__dict__["_get_attitude_blend_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_set_attitude_blend_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_get_control_time_constant"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+35, POINTER(agcom.DOUBLE))
        self.__dict__["_set_control_time_constant"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+36, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicManeuver, vtable_offset_local+37, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureBasicManeuver.__dict__ and type(IProcedureBasicManeuver.__dict__[attrname]) == property:
            return IProcedureBasicManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureBasicManeuver.")
    
    @property
    def max_time_of_flight(self) -> typing.Any:
        """Get the max time of flight."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_time_of_flight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_time_of_flight.setter
    def max_time_of_flight(self, newVal:typing.Any) -> None:
        """Set the max time of flight."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_time_of_flight"](arg_newVal.COM_val))

    @property
    def use_max_time_of_flight(self) -> bool:
        """Get whether to use max time of flight."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_time_of_flight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_time_of_flight.setter
    def use_max_time_of_flight(self, newVal:bool) -> None:
        """Set whether to use max time of flight."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_time_of_flight"](arg_newVal.COM_val))

    @property
    def stop_fuel_state(self) -> float:
        """Get the stop fuel state value."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_fuel_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_fuel_state.setter
    def stop_fuel_state(self, newVal:float) -> None:
        """Set the stop fuel state value."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_fuel_state"](arg_newVal.COM_val))

    @property
    def use_stop_fuel_state(self) -> bool:
        """Get whether to use stop fuel state."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_stop_fuel_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_stop_fuel_state.setter
    def use_stop_fuel_state(self, newVal:bool) -> None:
        """Set whether to use stop fuel state."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_stop_fuel_state"](arg_newVal.COM_val))

    @property
    def max_downrange(self) -> float:
        """Get the max down range."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_downrange"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_downrange.setter
    def max_downrange(self, newVal:float) -> None:
        """Set the max down range."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_downrange"](arg_newVal.COM_val))

    @property
    def use_max_downrange(self) -> bool:
        """Get whether to use max down range."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_downrange"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_downrange.setter
    def use_max_downrange(self, newVal:bool) -> None:
        """Set whether to use max down range."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_downrange"](arg_newVal.COM_val))

    @property
    def altitude_limit_mode(self) -> "AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT":
        """Get the altitude limit mode."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_limit_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_limit_mode.setter
    def altitude_limit_mode(self, newVal:"AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT") -> None:
        """Set the altitude limit mode."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_limit_mode"](arg_newVal.COM_val))

    @property
    def terrain_impact_mode(self) -> "AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT":
        """Get the terrain impact mode."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_impact_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @terrain_impact_mode.setter
    def terrain_impact_mode(self, newVal:"AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT") -> None:
        """Set the terrain impact mode."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_ALTITUDE_LIMIT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_terrain_impact_mode"](arg_newVal.COM_val))

    @property
    def terrain_impact_time_offset(self) -> float:
        """Get the terrain impact time offset."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_impact_time_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @terrain_impact_time_offset.setter
    def terrain_impact_time_offset(self, newVal:float) -> None:
        """Set the terrain impact time offset."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_terrain_impact_time_offset"](arg_newVal.COM_val))

    @property
    def navigation_strategy_type(self) -> str:
        """Get the navigation strategy type."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_navigation_strategy_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @navigation_strategy_type.setter
    def navigation_strategy_type(self, newVal:str) -> None:
        """Set the navigation strategy type."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_navigation_strategy_type"](arg_newVal.COM_val))

    @property
    def navigation(self) -> "IBasicManeuverStrategy":
        """Get the interface for the navigation strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_navigation"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def profile_strategy_type(self) -> str:
        """Get the profile strategy type."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_profile_strategy_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @profile_strategy_type.setter
    def profile_strategy_type(self, newVal:str) -> None:
        """Set the profile strategy type."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_profile_strategy_type"](arg_newVal.COM_val))

    @property
    def profile(self) -> "IBasicManeuverStrategy":
        """Get the interface for the profile strategy."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_profile"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def flight_mode(self) -> "AVTR_PHASE_OF_FLIGHT":
        """The type of performance model  that the aircraft will use to fly the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_mode.setter
    def flight_mode(self, newVal:"AVTR_PHASE_OF_FLIGHT") -> None:
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_mode"](arg_newVal.COM_val))

    @property
    def fuel_flow_type(self) -> "AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE") -> None:
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_FUEL_FLOW_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow_type"](arg_newVal.COM_val))

    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_fuel_flow_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_fuel_flow_value"](arg_newVal.COM_val))

    @property
    def scale_fuel_flow(self) -> bool:
        """Opt whether to scale the fuel flow based on the aircraft's actual attitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_fuel_flow.setter
    def scale_fuel_flow(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_fuel_flow"](arg_pVal.COM_val))

    @property
    def attitude_blend_time(self) -> float:
        """The amount of time that the aircraft will spend transitioning from the attitude of the previous maneuver to the attitude at the beginning of the current maneuver."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_blend_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attitude_blend_time.setter
    def attitude_blend_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_blend_time"](arg_newVal.COM_val))

    @property
    def control_time_constant(self) -> float:
        """A smoothing constant for the performance of control surfaces."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_time_constant"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @control_time_constant.setter
    def control_time_constant(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_control_time_constant"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{7cf58344-514c-44a6-aaf0-a45c4472e299}", IProcedureBasicManeuver)
agcls.AgTypeNameMap["IProcedureBasicManeuver"] = IProcedureBasicManeuver

class ISiteWaypoint(object):
    """Interface used to access the options for a waypoint site."""
    _uuid = "{caca5c56-6c49-4de7-ae28-8361d3f8cdee}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteWaypoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteWaypoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteWaypoint = agcom.GUID(ISiteWaypoint._uuid)
        vtable_offset_local = ISiteWaypoint._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypoint, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypoint, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypoint, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypoint, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypoint, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteWaypoint.__dict__ and type(ISiteWaypoint.__dict__[attrname]) == property:
            return ISiteWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteWaypoint.")
    
    @property
    def latitude(self) -> typing.Any:
        """The waypoint latitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The waypoint latitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The waypoint longitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The waypoint longitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{caca5c56-6c49-4de7-ae28-8361d3f8cdee}", ISiteWaypoint)
agcls.AgTypeNameMap["ISiteWaypoint"] = ISiteWaypoint

class ISiteEndOfPrevProcedure(object):
    """Interface used to access the options for an End of Previous Procedure site type."""
    _uuid = "{338fad56-1c3d-4572-97e4-24e01b1d7e65}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteEndOfPrevProcedure._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteEndOfPrevProcedure from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteEndOfPrevProcedure = agcom.GUID(ISiteEndOfPrevProcedure._uuid)
        vtable_offset_local = ISiteEndOfPrevProcedure._vtable_offset - 1
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteEndOfPrevProcedure, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteEndOfPrevProcedure.__dict__ and type(ISiteEndOfPrevProcedure.__dict__[attrname]) == property:
            return ISiteEndOfPrevProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteEndOfPrevProcedure.")
    
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{338fad56-1c3d-4572-97e4-24e01b1d7e65}", ISiteEndOfPrevProcedure)
agcls.AgTypeNameMap["ISiteEndOfPrevProcedure"] = ISiteEndOfPrevProcedure

class ISiteVTOLPoint(object):
    """Interface used to access the options for a VTOL Point site."""
    _uuid = "{168a5693-2f2c-4db8-822e-dd3571fe8fac}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteVTOLPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteVTOLPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteVTOLPoint = agcom.GUID(ISiteVTOLPoint._uuid)
        vtable_offset_local = ISiteVTOLPoint._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPoint, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteVTOLPoint.__dict__ and type(ISiteVTOLPoint.__dict__[attrname]) == property:
            return ISiteVTOLPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteVTOLPoint.")
    
    @property
    def latitude(self) -> typing.Any:
        """The VTOL Point latitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The VTOL Point latitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The VTOL Point longitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The VTOL Point longitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The altitude for the site."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the site."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def altitude_reference(self) -> "AVTR_AGLMSL":
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_reference"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_reference.setter
    def altitude_reference(self, newVal:"AVTR_AGLMSL") -> None:
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_reference"](arg_newVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{168a5693-2f2c-4db8-822e-dd3571fe8fac}", ISiteVTOLPoint)
agcls.AgTypeNameMap["ISiteVTOLPoint"] = ISiteVTOLPoint

class ISiteSTKVehicle(object):
    """Interface used to access the options for a STK Vehicle site."""
    _uuid = "{a0260a3b-b3fc-48e8-8708-01c1d9edc6c5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_object_names"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteSTKVehicle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKVehicle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteSTKVehicle = agcom.GUID(ISiteSTKVehicle._uuid)
        vtable_offset_local = ISiteSTKVehicle._vtable_offset - 1
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKVehicle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKVehicle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_object_names"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKVehicle, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKVehicle, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKVehicle.__dict__ and type(ISiteSTKVehicle.__dict__[attrname]) == property:
            return ISiteSTKVehicle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKVehicle.")
    
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_object_name"](arg_newVal.COM_val))

    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_object_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{a0260a3b-b3fc-48e8-8708-01c1d9edc6c5}", ISiteSTKVehicle)
agcls.AgTypeNameMap["ISiteSTKVehicle"] = ISiteSTKVehicle

class ISiteReferenceState(object):
    """Interface used to access the options for a Reference State site."""
    _uuid = "{3366da2b-74d8-47ef-8578-a304409e9401}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteReferenceState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteReferenceState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteReferenceState = agcom.GUID(ISiteReferenceState._uuid)
        vtable_offset_local = ISiteReferenceState._vtable_offset - 1
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteReferenceState, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteReferenceState.__dict__ and type(ISiteReferenceState.__dict__[attrname]) == property:
            return ISiteReferenceState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteReferenceState.")
    
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{3366da2b-74d8-47ef-8578-a304409e9401}", ISiteReferenceState)
agcls.AgTypeNameMap["ISiteReferenceState"] = ISiteReferenceState

class ISiteSuperProcedure(object):
    """Interface used to access the options for a Super Procedure site."""
    _uuid = "{0f56f3fe-b661-4d53-84f6-14df85184626}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteSuperProcedure._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteSuperProcedure from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteSuperProcedure = agcom.GUID(ISiteSuperProcedure._uuid)
        vtable_offset_local = ISiteSuperProcedure._vtable_offset - 1
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteSuperProcedure, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSuperProcedure.__dict__ and type(ISiteSuperProcedure.__dict__[attrname]) == property:
            return ISiteSuperProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSuperProcedure.")
    
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{0f56f3fe-b661-4d53-84f6-14df85184626}", ISiteSuperProcedure)
agcls.AgTypeNameMap["ISiteSuperProcedure"] = ISiteSuperProcedure

class ISiteRelToPrevProcedure(object):
    """Interface used to access the options for a Relative to Previous Procedure site."""
    _uuid = "{5875fefc-17f1-4fed-a7d8-cde213515f2b}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_bearing_mode"] = _raise_uninitialized_error
        self.__dict__["_set_bearing_mode"] = _raise_uninitialized_error
        self.__dict__["_get_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_set_range"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteRelToPrevProcedure._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteRelToPrevProcedure from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteRelToPrevProcedure = agcom.GUID(ISiteRelToPrevProcedure._uuid)
        vtable_offset_local = ISiteRelToPrevProcedure._vtable_offset - 1
        self.__dict__["_get_bearing_mode"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToPrevProcedure, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_bearing_mode"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToPrevProcedure, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToPrevProcedure, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToPrevProcedure, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToPrevProcedure, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToPrevProcedure, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToPrevProcedure, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRelToPrevProcedure.__dict__ and type(ISiteRelToPrevProcedure.__dict__[attrname]) == property:
            return ISiteRelToPrevProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRelToPrevProcedure.")
    
    @property
    def bearing_mode(self) -> "AVTR_REL_ABS_BEARING":
        """The bearing reference."""
        with agmarshall.AgEnum_arg(AVTR_REL_ABS_BEARING) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing_mode.setter
    def bearing_mode(self, newVal:"AVTR_REL_ABS_BEARING") -> None:
        """The bearing reference."""
        with agmarshall.AgEnum_arg(AVTR_REL_ABS_BEARING, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing_mode"](arg_newVal.COM_val))

    @property
    def bearing(self) -> typing.Any:
        """The bearing to define the site."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing to define the site."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing"](arg_newVal.COM_val))

    @property
    def range(self) -> float:
        """The range from the previous procedure."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range.setter
    def range(self, newVal:float) -> None:
        """The range from the previous procedure."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range"](arg_newVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{5875fefc-17f1-4fed-a7d8-cde213515f2b}", ISiteRelToPrevProcedure)
agcls.AgTypeNameMap["ISiteRelToPrevProcedure"] = ISiteRelToPrevProcedure

class ISiteSTKObjectWaypoint(object):
    """Interface used to access the options for a STK Object Waypoint site."""
    _uuid = "{b6021d54-bf89-41b2-a5bc-0ee0c064a0f3}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_object_names"] = _raise_uninitialized_error
        self.__dict__["_get_min_time"] = _raise_uninitialized_error
        self.__dict__["_get_waypoint_time"] = _raise_uninitialized_error
        self.__dict__["_set_waypoint_time"] = _raise_uninitialized_error
        self.__dict__["_get_minimize_site_proc_time_diff"] = _raise_uninitialized_error
        self.__dict__["_set_minimize_site_proc_time_diff"] = _raise_uninitialized_error
        self.__dict__["_get_max_time"] = _raise_uninitialized_error
        self.__dict__["_get_offset_mode"] = _raise_uninitialized_error
        self.__dict__["_set_offset_mode"] = _raise_uninitialized_error
        self.__dict__["_get_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_set_range"] = _raise_uninitialized_error
        self.__dict__["_get_vgt_point"] = _raise_uninitialized_error
        self.__dict__["_set_vgt_point"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteSTKObjectWaypoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKObjectWaypoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteSTKObjectWaypoint = agcom.GUID(ISiteSTKObjectWaypoint._uuid)
        vtable_offset_local = ISiteSTKObjectWaypoint._vtable_offset - 1
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_object_names"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_min_time"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_get_waypoint_time"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_waypoint_time"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_minimize_site_proc_time_diff"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_minimize_site_proc_time_diff"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_max_time"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_get_offset_mode"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_offset_mode"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_vgt_point"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_set_vgt_point"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+19, agcom.BSTR)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKObjectWaypoint, vtable_offset_local+20, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKObjectWaypoint.__dict__ and type(ISiteSTKObjectWaypoint.__dict__[attrname]) == property:
            return ISiteSTKObjectWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKObjectWaypoint.")
    
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_object_name"](arg_newVal.COM_val))

    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_object_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def min_time(self) -> typing.Any:
        """The earliest time that the object is available as a site."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def waypoint_time(self) -> typing.Any:
        """The time at which the object's position will be used as a waypoint."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_waypoint_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @waypoint_time.setter
    def waypoint_time(self, newVal:typing.Any) -> None:
        """The time at which the object's position will be used as a waypoint."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_waypoint_time"](arg_newVal.COM_val))

    @property
    def minimize_site_proc_time_diff(self) -> "AVTR_MINIMIZE_SITE_PROC_TIME_DIFF":
        """The mode to minimize the time difference between the procedure and site times."""
        with agmarshall.AgEnum_arg(AVTR_MINIMIZE_SITE_PROC_TIME_DIFF) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimize_site_proc_time_diff"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @minimize_site_proc_time_diff.setter
    def minimize_site_proc_time_diff(self, newVal:"AVTR_MINIMIZE_SITE_PROC_TIME_DIFF") -> None:
        """The mode to minimize the time difference between the procedure and site times."""
        with agmarshall.AgEnum_arg(AVTR_MINIMIZE_SITE_PROC_TIME_DIFF, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_minimize_site_proc_time_diff"](arg_newVal.COM_val))

    @property
    def max_time(self) -> typing.Any:
        """The latest time that the object is available as a site."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def offset_mode(self) -> "AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE":
        """The mode to offset the site location relative from the STK Object."""
        with agmarshall.AgEnum_arg(AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_offset_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @offset_mode.setter
    def offset_mode(self, newVal:"AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE") -> None:
        """The mode to offset the site location relative from the STK Object."""
        with agmarshall.AgEnum_arg(AVTR_STK_OBJECT_WAYPOINT_OFFSET_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_offset_mode"](arg_newVal.COM_val))

    @property
    def bearing(self) -> typing.Any:
        """The bearing offset of the site location relative to the object's position."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing offset of the site location relative to the object's position."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing"](arg_newVal.COM_val))

    @property
    def use_magnetic_bearing(self) -> bool:
        """The option to use a magnetic heading for the bearing."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_bearing.setter
    def use_magnetic_bearing(self, newVal:bool) -> None:
        """The option to use a magnetic heading for the bearing."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_bearing"](arg_newVal.COM_val))

    @property
    def range(self) -> float:
        """The range offset of the site location relative to the object's position."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range.setter
    def range(self, newVal:float) -> None:
        """The range offset of the site location relative to the object's position."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range"](arg_newVal.COM_val))

    @property
    def vgt_point(self) -> str:
        """The reference VGT Point."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vgt_point"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vgt_point.setter
    def vgt_point(self, newVal:str) -> None:
        """The reference VGT Point."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vgt_point"](arg_newVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{b6021d54-bf89-41b2-a5bc-0ee0c064a0f3}", ISiteSTKObjectWaypoint)
agcls.AgTypeNameMap["ISiteSTKObjectWaypoint"] = ISiteSTKObjectWaypoint

class ISiteSTKStaticObject(object):
    """Interface used to access the options for a STK Static Object site."""
    _uuid = "{b9b132d7-25a7-49c2-8f68-945ef572a4fe}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_object_names"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteSTKStaticObject._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKStaticObject from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteSTKStaticObject = agcom.GUID(ISiteSTKStaticObject._uuid)
        vtable_offset_local = ISiteSTKStaticObject._vtable_offset - 1
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKStaticObject, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKStaticObject, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_object_names"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKStaticObject, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKStaticObject, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKStaticObject.__dict__ and type(ISiteSTKStaticObject.__dict__[attrname]) == property:
            return ISiteSTKStaticObject.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKStaticObject.")
    
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_object_name"](arg_newVal.COM_val))

    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_object_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{b9b132d7-25a7-49c2-8f68-945ef572a4fe}", ISiteSTKStaticObject)
agcls.AgTypeNameMap["ISiteSTKStaticObject"] = ISiteSTKStaticObject

class ISiteRelToSTKObject(object):
    """Interface used to access the options for a Relative to Stationary STK Object site."""
    _uuid = "{b0257931-faca-477d-a0a1-9f36cbbb5c7f}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_object_names"] = _raise_uninitialized_error
        self.__dict__["_get_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_set_range"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteRelToSTKObject._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteRelToSTKObject from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteRelToSTKObject = agcom.GUID(ISiteRelToSTKObject._uuid)
        vtable_offset_local = ISiteRelToSTKObject._vtable_offset - 1
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_object_names"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_bearing"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteRelToSTKObject, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRelToSTKObject.__dict__ and type(ISiteRelToSTKObject.__dict__[attrname]) == property:
            return ISiteRelToSTKObject.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRelToSTKObject.")
    
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_object_name"](arg_newVal.COM_val))

    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_object_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def bearing(self) -> typing.Any:
        """The bearing from the STK object."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing from the STK object."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing"](arg_newVal.COM_val))

    @property
    def use_magnetic_bearing(self) -> bool:
        """The option to use a magnetic bearing."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_bearing.setter
    def use_magnetic_bearing(self, newVal:bool) -> None:
        """The option to use a magnetic bearing."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_bearing"](arg_newVal.COM_val))

    @property
    def range(self) -> float:
        """The range from the STK object."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range.setter
    def range(self, newVal:float) -> None:
        """The range from the STK object."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range"](arg_newVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{b0257931-faca-477d-a0a1-9f36cbbb5c7f}", ISiteRelToSTKObject)
agcls.AgTypeNameMap["ISiteRelToSTKObject"] = ISiteRelToSTKObject

class ISiteSTKAreaTarget(object):
    """Interface used to access the options for a STK Area Target site."""
    _uuid = "{38dbad68-357f-4129-b8fb-3fbecd506e23}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_object_names"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteSTKAreaTarget._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKAreaTarget from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteSTKAreaTarget = agcom.GUID(ISiteSTKAreaTarget._uuid)
        vtable_offset_local = ISiteSTKAreaTarget._vtable_offset - 1
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKAreaTarget, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKAreaTarget, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_object_names"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKAreaTarget, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteSTKAreaTarget, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKAreaTarget.__dict__ and type(ISiteSTKAreaTarget.__dict__[attrname]) == property:
            return ISiteSTKAreaTarget.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKAreaTarget.")
    
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_object_name"](arg_newVal.COM_val))

    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_object_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{38dbad68-357f-4129-b8fb-3fbecd506e23}", ISiteSTKAreaTarget)
agcls.AgTypeNameMap["ISiteSTKAreaTarget"] = ISiteSTKAreaTarget

class ISiteRunway(object):
    """Interface used to access the options for a Runway site type."""
    _uuid = "{5b6661c4-9722-49ab-9236-ffbfe2821e86}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_length"] = _raise_uninitialized_error
        self.__dict__["_set_length"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_ref"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_ref"] = _raise_uninitialized_error
        self.__dict__["_get_low_end_heading"] = _raise_uninitialized_error
        self.__dict__["_set_low_end_heading"] = _raise_uninitialized_error
        self.__dict__["_get_high_end_heading"] = _raise_uninitialized_error
        self.__dict__["_set_high_end_heading"] = _raise_uninitialized_error
        self.__dict__["_get_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_set_is_magnetic"] = _raise_uninitialized_error
        self.__dict__["_add_to_catalog"] = _raise_uninitialized_error
        self.__dict__["_copy_from_catalog"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteRunway._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteRunway from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteRunway = agcom.GUID(ISiteRunway._uuid)
        vtable_offset_local = ISiteRunway._vtable_offset - 1
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_length"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_length"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_altitude_ref"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_ref"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_low_end_heading"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_low_end_heading"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_high_end_heading"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_high_end_heading"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_is_magnetic"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_add_to_catalog"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_copy_from_catalog"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+18, agcom.PVOID)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteRunway, vtable_offset_local+19, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRunway.__dict__ and type(ISiteRunway.__dict__[attrname]) == property:
            return ISiteRunway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRunway.")
    
    @property
    def altitude(self) -> float:
        """The runway altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The runway altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def latitude(self) -> typing.Any:
        """The runway latitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The runway latitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The runway longitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The runway longitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def length(self) -> float:
        """The length of the runway"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @length.setter
    def length(self, newVal:float) -> None:
        """The length of the runway"""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_length"](arg_newVal.COM_val))

    @property
    def altitude_ref(self) -> "AVTR_AGLMSL":
        """The altitude reference for the runway."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_ref"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_ref.setter
    def altitude_ref(self, newVal:"AVTR_AGLMSL") -> None:
        """The altitude reference for the runway."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_ref"](arg_newVal.COM_val))

    @property
    def low_end_heading(self) -> typing.Any:
        """The low end heading of the runway."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_end_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @low_end_heading.setter
    def low_end_heading(self, newVal:typing.Any) -> None:
        """The low end heading of the runway."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_low_end_heading"](arg_newVal.COM_val))

    @property
    def high_end_heading(self) -> typing.Any:
        """The high end heading of the runway."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_high_end_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @high_end_heading.setter
    def high_end_heading(self, newVal:typing.Any) -> None:
        """The high end heading of the runway."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_high_end_heading"](arg_newVal.COM_val))

    @property
    def is_magnetic(self) -> bool:
        """Opt whether to use a magnetic heading for the runway heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_is_magnetic"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @is_magnetic.setter
    def is_magnetic(self, newVal:bool) -> None:
        """Opt whether to use a magnetic heading for the runway heading."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_is_magnetic"](arg_newVal.COM_val))

    def add_to_catalog(self, overwrite:bool) -> None:
        """Add the runway to the catalog."""
        with agmarshall.VARIANT_BOOL_arg(overwrite) as arg_overwrite:
            agcls.evaluate_hresult(self.__dict__["_add_to_catalog"](arg_overwrite.COM_val))

    def copy_from_catalog(self, runway:"ICatalogRunway") -> None:
        """Copy the information from the runway stored in the catalog."""
        with agmarshall.AgInterface_in_arg(runway, ICatalogRunway) as arg_runway:
            agcls.evaluate_hresult(self.__dict__["_copy_from_catalog"](arg_runway.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{5b6661c4-9722-49ab-9236-ffbfe2821e86}", ISiteRunway)
agcls.AgTypeNameMap["ISiteRunway"] = ISiteRunway

class IProcedureLanding(object):
    """Interface used to access the options for a landing procedure."""
    _uuid = "{b3541a24-1ba3-47cd-86a9-4dc90b7d0c14}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_mode_as_standard_instrument_approach"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_intercept_glideslope"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_enter_downwind_pattern"] = _raise_uninitialized_error
        self.__dict__["_get_runway_heading_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_plane_options"] = _raise_uninitialized_error
        self.__dict__["_get_approach_mode"] = _raise_uninitialized_error
        self.__dict__["_set_approach_mode"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureLanding._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLanding from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureLanding = agcom.GUID(IProcedureLanding._uuid)
        vtable_offset_local = IProcedureLanding._vtable_offset - 1
        self.__dict__["_get_mode_as_standard_instrument_approach"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_intercept_glideslope"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_enter_downwind_pattern"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_runway_heading_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_vertical_plane_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_approach_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_approach_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureLanding, vtable_offset_local+11, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLanding.__dict__ and type(IProcedureLanding.__dict__[attrname]) == property:
            return IProcedureLanding.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLanding.")
    
    @property
    def mode_as_standard_instrument_approach(self) -> "ILandingStandardInstrumentApproach":
        """Get the interface for a standard instrument approach landing."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_standard_instrument_approach"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def mode_as_intercept_glideslope(self) -> "ILandingInterceptGlideslope":
        """Get the interface for an intercept glideslope landing."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_intercept_glideslope"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def mode_as_enter_downwind_pattern(self) -> "ILandingEnterDownwindPattern":
        """Get the interface for a downwind pattern landing."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_enter_downwind_pattern"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def runway_heading_options(self) -> "IRunwayHeadingOptions":
        """Get the runway heading options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_heading_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedAndProfileOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def vertical_plane_options(self) -> "IVerticalPlaneOptions":
        """Get the vertical plane options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_plane_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def approach_mode(self) -> "AVTR_APPROACH_MODE":
        """The type of landing the aircraft will perform."""
        with agmarshall.AgEnum_arg(AVTR_APPROACH_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_approach_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @approach_mode.setter
    def approach_mode(self, newVal:"AVTR_APPROACH_MODE") -> None:
        """The type of landing the aircraft will perform."""
        with agmarshall.AgEnum_arg(AVTR_APPROACH_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_approach_mode"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{b3541a24-1ba3-47cd-86a9-4dc90b7d0c14}", IProcedureLanding)
agcls.AgTypeNameMap["IProcedureLanding"] = IProcedureLanding

class IProcedureEnroute(object):
    """Interface used to access the options for an enroute procedure."""
    _uuid = "{a35c59ac-496b-4b6c-aa8a-fd55e9992a97}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_msl_options"] = _raise_uninitialized_error
        self.__dict__["_get_navigation_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureEnroute._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureEnroute from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureEnroute = agcom.GUID(IProcedureEnroute._uuid)
        vtable_offset_local = IProcedureEnroute._vtable_offset - 1
        self.__dict__["_get_altitude_msl_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureEnroute, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_navigation_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureEnroute, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureEnroute, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureEnroute, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureEnroute, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureEnroute.__dict__ and type(IProcedureEnroute.__dict__[attrname]) == property:
            return IProcedureEnroute.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureEnroute.")
    
    @property
    def altitude_msl_options(self) -> "IAltitudeMSLAndLevelOffOptions":
        """Get the altitude MSL options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_msl_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def navigation_options(self) -> "INavigationOptions":
        """Get the navigation options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_navigation_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{a35c59ac-496b-4b6c-aa8a-fd55e9992a97}", IProcedureEnroute)
agcls.AgTypeNameMap["IProcedureEnroute"] = IProcedureEnroute

class IProcedureExtEphem(object):
    """Interface used to access the options for an ExtEphem procedure."""
    _uuid = "{7A4CFB91-336F-4150-AD2C-C861410FB496}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_ephemeris_file"] = _raise_uninitialized_error
        self.__dict__["_get_ephemeris_file"] = _raise_uninitialized_error
        self.__dict__["_get_ephemeris_file_duration"] = _raise_uninitialized_error
        self.__dict__["_set_use_start_duration"] = _raise_uninitialized_error
        self.__dict__["_get_use_start_duration"] = _raise_uninitialized_error
        self.__dict__["_set_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_duration"] = _raise_uninitialized_error
        self.__dict__["_get_duration"] = _raise_uninitialized_error
        self.__dict__["_get_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_set_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureExtEphem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureExtEphem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureExtEphem = agcom.GUID(IProcedureExtEphem._uuid)
        vtable_offset_local = IProcedureExtEphem._vtable_offset - 1
        self.__dict__["_set_ephemeris_file"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_get_ephemeris_file"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_get_ephemeris_file_duration"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_use_start_duration"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_start_duration"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_duration"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_duration"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_get_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureExtEphem, vtable_offset_local+12, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureExtEphem.__dict__ and type(IProcedureExtEphem.__dict__[attrname]) == property:
            return IProcedureExtEphem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureExtEphem.")
    
    @property
    def ephemeris_file(self) -> str:
        """Get the ephemeris filename."""
        with agmarshall.BSTR_arg() as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_get_ephemeris_file"](byref(arg_newVal.COM_val)))
            return arg_newVal.python_val

    @ephemeris_file.setter
    def ephemeris_file(self, newVal:str) -> None:
        """Set the ephemeris filename."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ephemeris_file"](arg_newVal.COM_val))

    @property
    def ephemeris_file_duration(self) -> float:
        """Get the ephemeris file duration."""
        with agmarshall.DOUBLE_arg() as arg_dDuration:
            agcls.evaluate_hresult(self.__dict__["_get_ephemeris_file_duration"](byref(arg_dDuration.COM_val)))
            return arg_dDuration.python_val

    @property
    def use_start_duration(self) -> bool:
        """Get whether to use Start and Duration"""
        with agmarshall.VARIANT_BOOL_arg() as arg_useSD:
            agcls.evaluate_hresult(self.__dict__["_get_use_start_duration"](byref(arg_useSD.COM_val)))
            return arg_useSD.python_val

    @use_start_duration.setter
    def use_start_duration(self, useSD:bool) -> None:
        """Set whether to use Start and Duration"""
        with agmarshall.VARIANT_BOOL_arg(useSD) as arg_useSD:
            agcls.evaluate_hresult(self.__dict__["_set_use_start_duration"](arg_useSD.COM_val))

    @property
    def start_time(self) -> float:
        """Get the start time"""
        with agmarshall.DOUBLE_arg() as arg_start:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_start.COM_val)))
            return arg_start.python_val

    @start_time.setter
    def start_time(self, start:float) -> None:
        """Set the start time"""
        with agmarshall.DOUBLE_arg(start) as arg_start:
            agcls.evaluate_hresult(self.__dict__["_set_start_time"](arg_start.COM_val))

    @property
    def duration(self) -> float:
        """Get the duration"""
        with agmarshall.DOUBLE_arg() as arg_start:
            agcls.evaluate_hresult(self.__dict__["_get_duration"](byref(arg_start.COM_val)))
            return arg_start.python_val

    @duration.setter
    def duration(self, start:float) -> None:
        """Set the duration"""
        with agmarshall.DOUBLE_arg(start) as arg_start:
            agcls.evaluate_hresult(self.__dict__["_set_duration"](arg_start.COM_val))

    @property
    def flight_mode(self) -> "AVTR_EXT_EPHEM_FLIGHT_MODE":
        """Get the flight mode"""
        with agmarshall.AgEnum_arg(AVTR_EXT_EPHEM_FLIGHT_MODE) as arg_mode:
            agcls.evaluate_hresult(self.__dict__["_get_flight_mode"](byref(arg_mode.COM_val)))
            return arg_mode.python_val

    @flight_mode.setter
    def flight_mode(self, mode:"AVTR_EXT_EPHEM_FLIGHT_MODE") -> None:
        """Set the flight mode"""
        with agmarshall.AgEnum_arg(AVTR_EXT_EPHEM_FLIGHT_MODE, mode) as arg_mode:
            agcls.evaluate_hresult(self.__dict__["_set_flight_mode"](arg_mode.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{7A4CFB91-336F-4150-AD2C-C861410FB496}", IProcedureExtEphem)
agcls.AgTypeNameMap["IProcedureExtEphem"] = IProcedureExtEphem

class IProcedureFormationFlyer(object):
    """Interface used to access the options for an enroute procedure."""
    _uuid = "{A8EF3889-1443-405A-AFC6-5072D53F9AC4}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_min_time_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_time_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_time_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_time_step"] = _raise_uninitialized_error
        self.__dict__["_get_cross_range_close_rate"] = _raise_uninitialized_error
        self.__dict__["_set_cross_range_close_rate"] = _raise_uninitialized_error
        self.__dict__["_get_initial_close_max_speed_advantage"] = _raise_uninitialized_error
        self.__dict__["_set_initial_close_max_speed_advantage"] = _raise_uninitialized_error
        self.__dict__["_get_stop_condition"] = _raise_uninitialized_error
        self.__dict__["_set_stop_condition"] = _raise_uninitialized_error
        self.__dict__["_get_stop_time"] = _raise_uninitialized_error
        self.__dict__["_set_stop_time"] = _raise_uninitialized_error
        self.__dict__["_get_stop_down_range"] = _raise_uninitialized_error
        self.__dict__["_set_stop_down_range"] = _raise_uninitialized_error
        self.__dict__["_get_stop_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_set_stop_fuel_state"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureFormationFlyer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFormationFlyer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureFormationFlyer = agcom.GUID(IProcedureFormationFlyer._uuid)
        vtable_offset_local = IProcedureFormationFlyer._vtable_offset - 1
        self.__dict__["_get_min_time_step"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_time_step"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_max_time_step"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_time_step"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_cross_range_close_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cross_range_close_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_initial_close_max_speed_advantage"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_close_max_speed_advantage"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_stop_condition"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_stop_down_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_down_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_stop_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stop_fuel_state"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationFlyer, vtable_offset_local+17, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFormationFlyer.__dict__ and type(IProcedureFormationFlyer.__dict__[attrname]) == property:
            return IProcedureFormationFlyer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFormationFlyer.")
    
    @property
    def min_time_step(self) -> float:
        """Get Min time Step"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_time_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_time_step.setter
    def min_time_step(self, pVal:float) -> None:
        """Set Min time Step"""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_time_step"](arg_pVal.COM_val))

    @property
    def max_time_step(self) -> float:
        """Get Max time Step"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_time_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_time_step.setter
    def max_time_step(self, pVal:float) -> None:
        """Set Max time Step"""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_time_step"](arg_pVal.COM_val))

    @property
    def cross_range_close_rate(self) -> float:
        """Get Cross Range close rate"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cross_range_close_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cross_range_close_rate.setter
    def cross_range_close_rate(self, pVal:float) -> None:
        """Set Cross Range close rate"""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_cross_range_close_rate"](arg_pVal.COM_val))

    @property
    def initial_close_max_speed_advantage(self) -> float:
        """Get Initial Close Max Speed Advantage"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_close_max_speed_advantage"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_close_max_speed_advantage.setter
    def initial_close_max_speed_advantage(self, pVal:float) -> None:
        """Set Initial Close Max Speed Advantage"""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_close_max_speed_advantage"](arg_pVal.COM_val))

    @property
    def stop_condition(self) -> "AVTR_FORMATION_FLYER_STOP_CONDITION":
        """Get Stop condition"""
        with agmarshall.AgEnum_arg(AVTR_FORMATION_FLYER_STOP_CONDITION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_condition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_condition.setter
    def stop_condition(self, pVal:"AVTR_FORMATION_FLYER_STOP_CONDITION") -> None:
        """Set Stop condition"""
        with agmarshall.AgEnum_arg(AVTR_FORMATION_FLYER_STOP_CONDITION, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_condition"](arg_pVal.COM_val))

    @property
    def stop_time(self) -> float:
        """Get stop time"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_time.setter
    def stop_time(self, pVal:float) -> None:
        """Set stop time"""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_time"](arg_pVal.COM_val))

    @property
    def stop_down_range(self) -> float:
        """Get stop downrange"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_down_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_down_range.setter
    def stop_down_range(self, pVal:float) -> None:
        """Set stop downrange"""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_down_range"](arg_pVal.COM_val))

    @property
    def stop_fuel_state(self) -> float:
        """Get stop fuel state"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_fuel_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_fuel_state.setter
    def stop_fuel_state(self, pVal:float) -> None:
        """Set stop fuel state"""
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_fuel_state"](arg_pVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{A8EF3889-1443-405A-AFC6-5072D53F9AC4}", IProcedureFormationFlyer)
agcls.AgTypeNameMap["IProcedureFormationFlyer"] = IProcedureFormationFlyer

class IProcedureBasicPointToPoint(object):
    """Interface used to access the options for a basic point to point procedure."""
    _uuid = "{e6e53440-4d07-4808-be87-ed2bf3908208}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_navigation_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_plane_options"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureBasicPointToPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureBasicPointToPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureBasicPointToPoint = agcom.GUID(IProcedureBasicPointToPoint._uuid)
        vtable_offset_local = IProcedureBasicPointToPoint._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicPointToPoint, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_navigation_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicPointToPoint, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicPointToPoint, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicPointToPoint, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_vertical_plane_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicPointToPoint, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureBasicPointToPoint, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureBasicPointToPoint.__dict__ and type(IProcedureBasicPointToPoint.__dict__[attrname]) == property:
            return IProcedureBasicPointToPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureBasicPointToPoint.")
    
    @property
    def altitude_options(self) -> "IAltitudeOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def navigation_options(self) -> "INavigationOptions":
        """Get the navigation options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_navigation_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedAndProfileOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def vertical_plane_options(self) -> "IVerticalPlaneAndFlightPathOptions":
        """Get the vertical plane options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_plane_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{e6e53440-4d07-4808-be87-ed2bf3908208}", IProcedureBasicPointToPoint)
agcls.AgTypeNameMap["IProcedureBasicPointToPoint"] = IProcedureBasicPointToPoint

class IProcedureDelay(object):
    """Interface used to access the options for a delay procedure."""
    _uuid = "{0196f260-017d-4f54-af50-7ca1ed1056b0}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_mode"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_turn_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_turn_radius_factor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureDelay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureDelay = agcom.GUID(IProcedureDelay._uuid)
        vtable_offset_local = IProcedureDelay._vtable_offset - 1
        self.__dict__["_get_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_turn_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureDelay, vtable_offset_local+9, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureDelay.__dict__ and type(IProcedureDelay.__dict__[attrname]) == property:
            return IProcedureDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureDelay.")
    
    @property
    def altitude_mode(self) -> "AVTR_DELAY_ALT_MODE":
        """The mode for handling the altitude of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_DELAY_ALT_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_mode.setter
    def altitude_mode(self, newVal:"AVTR_DELAY_ALT_MODE") -> None:
        """The mode for handling the altitude of the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_DELAY_ALT_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_mode"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The requested altitude of the procedure."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The requested altitude of the procedure."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the interface for the cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def turn_direction(self) -> "AVTR_NAVIGATOR_TURN_DIR":
        """The turn direction of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_direction.setter
    def turn_direction(self, newVal:"AVTR_NAVIGATOR_TURN_DIR") -> None:
        """The turn direction of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_NAVIGATOR_TURN_DIR, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_direction"](arg_newVal.COM_val))

    @property
    def turn_radius_factor(self) -> float:
        """The turn radius factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_radius_factor.setter
    def turn_radius_factor(self, newVal:float) -> None:
        """The turn radius factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_radius_factor"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0196f260-017d-4f54-af50-7ca1ed1056b0}", IProcedureDelay)
agcls.AgTypeNameMap["IProcedureDelay"] = IProcedureDelay

class IProcedureTakeoff(object):
    """Interface used to access the options for a takeoff procedure."""
    _uuid = "{2f8f0f66-d7ea-41df-ad48-bcd5bfcd90b7}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_runway_heading_options"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_normal"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_departure_point"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_low_transition"] = _raise_uninitialized_error
        self.__dict__["_get_takeoff_mode"] = _raise_uninitialized_error
        self.__dict__["_set_takeoff_mode"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureTakeoff._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTakeoff from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureTakeoff = agcom.GUID(IProcedureTakeoff._uuid)
        vtable_offset_local = IProcedureTakeoff._vtable_offset - 1
        self.__dict__["_get_runway_heading_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureTakeoff, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_normal"] = IAGFUNCTYPE(pUnk, IID_IProcedureTakeoff, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_departure_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureTakeoff, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_low_transition"] = IAGFUNCTYPE(pUnk, IID_IProcedureTakeoff, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_takeoff_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureTakeoff, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_takeoff_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureTakeoff, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureTakeoff, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTakeoff.__dict__ and type(IProcedureTakeoff.__dict__[attrname]) == property:
            return IProcedureTakeoff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTakeoff.")
    
    @property
    def runway_heading_options(self) -> "IRunwayHeadingOptions":
        """Get the runway heading options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_runway_heading_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def mode_as_normal(self) -> "ITakeoffNormal":
        """Get the interface for a normal takeoff."""
        with agmarshall.AgInterface_out_arg() as arg_ppTakeoffNormal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_normal"](byref(arg_ppTakeoffNormal.COM_val)))
            return arg_ppTakeoffNormal.python_val

    @property
    def mode_as_departure_point(self) -> "ITakeoffDeparturePoint":
        """Get the interface for a departure point takeoff."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_departure_point"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def mode_as_low_transition(self) -> "ITakeoffLowTransition":
        """Get the interface for a low transition takeoff."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_low_transition"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def takeoff_mode(self) -> "AVTR_TAKEOFF_MODE":
        """The type of takeoff the aircraft will perform."""
        with agmarshall.AgEnum_arg(AVTR_TAKEOFF_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_takeoff_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @takeoff_mode.setter
    def takeoff_mode(self, newVal:"AVTR_TAKEOFF_MODE") -> None:
        """The type of takeoff the aircraft will perform."""
        with agmarshall.AgEnum_arg(AVTR_TAKEOFF_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_takeoff_mode"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{2f8f0f66-d7ea-41df-ad48-bcd5bfcd90b7}", IProcedureTakeoff)
agcls.AgTypeNameMap["IProcedureTakeoff"] = IProcedureTakeoff

class IProcedureArcEnroute(object):
    """Interface used to access the options for an arc enroute procedure."""
    _uuid = "{e4073986-cdc3-47de-994d-e731e309f7a2}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_arc_options"] = _raise_uninitialized_error
        self.__dict__["_get_arc_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureArcEnroute._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureArcEnroute from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureArcEnroute = agcom.GUID(IProcedureArcEnroute._uuid)
        vtable_offset_local = IProcedureArcEnroute._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcEnroute, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_arc_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcEnroute, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_arc_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcEnroute, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcEnroute, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcEnroute, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcEnroute, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcEnroute, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureArcEnroute.__dict__ and type(IProcedureArcEnroute.__dict__[attrname]) == property:
            return IProcedureArcEnroute.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureArcEnroute.")
    
    @property
    def altitude_options(self) -> "IArcAltitudeAndDelayOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def arc_options(self) -> "IArcOptions":
        """Get the arc options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_arc_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def arc_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the arc cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_arc_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{e4073986-cdc3-47de-994d-e731e309f7a2}", IProcedureArcEnroute)
agcls.AgTypeNameMap["IProcedureArcEnroute"] = IProcedureArcEnroute

class IProcedureArcPointToPoint(object):
    """Interface used to access the options for an arc point to point procedure."""
    _uuid = "{0b5eaf53-8f72-4039-b469-18cfccedc1ef}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_arc_options"] = _raise_uninitialized_error
        self.__dict__["_get_arc_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_set_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_plane_options"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureArcPointToPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureArcPointToPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureArcPointToPoint = agcom.GUID(IProcedureArcPointToPoint._uuid)
        vtable_offset_local = IProcedureArcPointToPoint._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_arc_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_arc_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_vertical_plane_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureArcPointToPoint, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureArcPointToPoint.__dict__ and type(IProcedureArcPointToPoint.__dict__[attrname]) == property:
            return IProcedureArcPointToPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureArcPointToPoint.")
    
    @property
    def altitude_options(self) -> "IArcAltitudeOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def arc_options(self) -> "IArcOptions":
        """Get the arc options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_arc_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def arc_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the arc cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_arc_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fly_cruise_airspeed_profile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, pVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_fly_cruise_airspeed_profile"](arg_pVal.COM_val))

    @property
    def vertical_plane_options(self) -> "IArcVerticalPlaneOptions":
        """Get the vertical plane options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_plane_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{0b5eaf53-8f72-4039-b469-18cfccedc1ef}", IProcedureArcPointToPoint)
agcls.AgTypeNameMap["IProcedureArcPointToPoint"] = IProcedureArcPointToPoint

class IProcedureFlightLine(object):
    """Interface used to access the options for a flight line procedure."""
    _uuid = "{cfa301c6-3326-4e4b-8973-5e74d00b7553}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_set_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_get_flight_line_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_procedure_type"] = _raise_uninitialized_error
        self.__dict__["_set_procedure_type"] = _raise_uninitialized_error
        self.__dict__["_get_outbound_course"] = _raise_uninitialized_error
        self.__dict__["_set_outbound_course"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_leg_length"] = _raise_uninitialized_error
        self.__dict__["_set_leg_length"] = _raise_uninitialized_error
        self.__dict__["_get_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_set_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureFlightLine._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFlightLine from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureFlightLine = agcom.GUID(IProcedureFlightLine._uuid)
        vtable_offset_local = IProcedureFlightLine._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__["_get_flight_line_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_procedure_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_procedure_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_get_outbound_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_set_outbound_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_get_leg_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_leg_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+19, agcom.LONG)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureFlightLine, vtable_offset_local+20, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFlightLine.__dict__ and type(IProcedureFlightLine.__dict__[attrname]) == property:
            return IProcedureFlightLine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFlightLine.")
    
    @property
    def altitude_options(self) -> "IAltitudeOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fly_cruise_airspeed_profile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, pVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_fly_cruise_airspeed_profile"](arg_pVal.COM_val))

    @property
    def flight_line_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the flight line airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_line_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def procedure_type(self) -> "AVTR_FLIGHT_LINE_PROC_TYPE":
        """The procedure methodology used to calculate the flight line."""
        with agmarshall.AgEnum_arg(AVTR_FLIGHT_LINE_PROC_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_procedure_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @procedure_type.setter
    def procedure_type(self, newVal:"AVTR_FLIGHT_LINE_PROC_TYPE") -> None:
        """The procedure methodology used to calculate the flight line."""
        with agmarshall.AgEnum_arg(AVTR_FLIGHT_LINE_PROC_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_procedure_type"](arg_newVal.COM_val))

    @property
    def outbound_course(self) -> typing.Any:
        """The outbound course."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_outbound_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @outbound_course.setter
    def outbound_course(self, newVal:typing.Any) -> None:
        """The outbound course."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_outbound_course"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_heading"](arg_newVal.COM_val))

    @property
    def leg_length(self) -> float:
        """The length of the flight line."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_leg_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @leg_length.setter
    def leg_length(self, newVal:float) -> None:
        """The length of the flight line."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_leg_length"](arg_newVal.COM_val))

    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_must_level_off"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_must_level_off"](arg_newVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, newVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{cfa301c6-3326-4e4b-8973-5e74d00b7553}", IProcedureFlightLine)
agcls.AgTypeNameMap["IProcedureFlightLine"] = IProcedureFlightLine

class IProcedureHoldingCircular(object):
    """Interface used to access the options for a holding circular procedure."""
    _uuid = "{ecb689b1-ebcb-45f2-832a-ed36734601ae}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_profile_mode"] = _raise_uninitialized_error
        self.__dict__["_set_profile_mode"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_get_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_set_range"] = _raise_uninitialized_error
        self.__dict__["_get_diameter"] = _raise_uninitialized_error
        self.__dict__["_set_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_use_alternate_entry_points"] = _raise_uninitialized_error
        self.__dict__["_set_use_alternate_entry_points"] = _raise_uninitialized_error
        self.__dict__["_get_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_set_turn_direction"] = _raise_uninitialized_error
        self.__dict__["_get_turns"] = _raise_uninitialized_error
        self.__dict__["_set_turns"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_set_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_get_hold_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_diameter"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureHoldingCircular._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoldingCircular from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureHoldingCircular = agcom.GUID(IProcedureHoldingCircular._uuid)
        vtable_offset_local = IProcedureHoldingCircular._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_profile_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_profile_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_get_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_diameter"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_diameter"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_use_alternate_entry_points"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_alternate_entry_points"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_set_turn_direction"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_get_turns"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_set_turns"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+19, agcom.LONG)
        self.__dict__["_get_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_hold_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+22, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_diameter"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingCircular, vtable_offset_local+27, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoldingCircular.__dict__ and type(IProcedureHoldingCircular.__dict__[attrname]) == property:
            return IProcedureHoldingCircular.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoldingCircular.")
    
    @property
    def altitude_options(self) -> "IAltitudeMSLOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def profile_mode(self) -> "AVTR_HOLDING_PROFILE_MODE":
        """The mode defines how the aircraft will perform the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_PROFILE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_profile_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @profile_mode.setter
    def profile_mode(self, newVal:"AVTR_HOLDING_PROFILE_MODE") -> None:
        """The mode defines how the aircraft will perform the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_PROFILE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_profile_mode"](arg_newVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The mode for the level off maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, newVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The mode for the level off maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_newVal.COM_val))

    @property
    def bearing(self) -> typing.Any:
        """The bearing of the holding point from the site."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the holding point from the site."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_heading"](arg_newVal.COM_val))

    @property
    def range(self) -> float:
        """The distance to the holding point from the site."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range.setter
    def range(self, newVal:float) -> None:
        """The distance to the holding point from the site."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range"](arg_newVal.COM_val))

    @property
    def diameter(self) -> float:
        """The diameter of the holding pattern."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @diameter.setter
    def diameter(self, newVal:float) -> None:
        """The diameter of the holding pattern."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_diameter"](arg_newVal.COM_val))

    @property
    def use_alternate_entry_points(self) -> bool:
        """The option to enter the holding pattern from an alternate point."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_alternate_entry_points"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_alternate_entry_points.setter
    def use_alternate_entry_points(self, newVal:bool) -> None:
        """The option to enter the holding pattern from an alternate point."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_alternate_entry_points"](arg_newVal.COM_val))

    @property
    def turn_direction(self) -> "AVTR_HOLDING_DIRECTION":
        """The turn direction to enter the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_DIRECTION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_direction.setter
    def turn_direction(self, newVal:"AVTR_HOLDING_DIRECTION") -> None:
        """The turn direction to enter the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_DIRECTION, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_direction"](arg_newVal.COM_val))

    @property
    def turns(self) -> int:
        """The number of full turns."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turns"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turns.setter
    def turns(self, newVal:int) -> None:
        """The number of full turns."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turns"](arg_newVal.COM_val))

    @property
    def refuel_dump_mode(self) -> "AVTR_HOLD_REFUEL_DUMP_MODE":
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        with agmarshall.AgEnum_arg(AVTR_HOLD_REFUEL_DUMP_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @refuel_dump_mode.setter
    def refuel_dump_mode(self, newVal:"AVTR_HOLD_REFUEL_DUMP_MODE") -> None:
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        with agmarshall.AgEnum_arg(AVTR_HOLD_REFUEL_DUMP_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_refuel_dump_mode"](arg_newVal.COM_val))

    @property
    def hold_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the hold cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_minimum_diameter(self) -> float:
        """The aircraft's minimum diameter at this altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_diameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{ecb689b1-ebcb-45f2-832a-ed36734601ae}", IProcedureHoldingCircular)
agcls.AgTypeNameMap["IProcedureHoldingCircular"] = IProcedureHoldingCircular

class IProcedureHoldingFigure8(object):
    """Interface used to access the options for a holding figure 8 procedure."""
    _uuid = "{5b4e19a2-dd75-462f-b4da-ed23c6c16de3}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_profile_mode"] = _raise_uninitialized_error
        self.__dict__["_set_profile_mode"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_get_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_set_range"] = _raise_uninitialized_error
        self.__dict__["_get_length"] = _raise_uninitialized_error
        self.__dict__["_set_length"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_set_width"] = _raise_uninitialized_error
        self.__dict__["_get_use_alternate_entry_points"] = _raise_uninitialized_error
        self.__dict__["_set_use_alternate_entry_points"] = _raise_uninitialized_error
        self.__dict__["_get_turns"] = _raise_uninitialized_error
        self.__dict__["_set_turns"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_set_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_get_hold_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_width"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureHoldingFigure8._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoldingFigure8 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureHoldingFigure8 = agcom.GUID(IProcedureHoldingFigure8._uuid)
        vtable_offset_local = IProcedureHoldingFigure8._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_profile_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_profile_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_get_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_width"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_use_alternate_entry_points"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_alternate_entry_points"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_turns"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_set_turns"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+19, agcom.LONG)
        self.__dict__["_get_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_hold_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+22, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_width"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingFigure8, vtable_offset_local+27, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoldingFigure8.__dict__ and type(IProcedureHoldingFigure8.__dict__[attrname]) == property:
            return IProcedureHoldingFigure8.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoldingFigure8.")
    
    @property
    def altitude_options(self) -> "IAltitudeMSLOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def profile_mode(self) -> "AVTR_HOLDING_PROFILE_MODE":
        """The mode defines how the aircraft will perform the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_PROFILE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_profile_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @profile_mode.setter
    def profile_mode(self, newVal:"AVTR_HOLDING_PROFILE_MODE") -> None:
        """The mode defines how the aircraft will perform the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_PROFILE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_profile_mode"](arg_newVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The mode for the level off maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, newVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The mode for the level off maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_newVal.COM_val))

    @property
    def bearing(self) -> typing.Any:
        """The bearing of the holding point from the site."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the holding point from the site."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_heading"](arg_newVal.COM_val))

    @property
    def range(self) -> float:
        """The distance to the holding point from the site."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range.setter
    def range(self, newVal:float) -> None:
        """The distance to the holding point from the site."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range"](arg_newVal.COM_val))

    @property
    def length(self) -> float:
        """The distance between the centers of the pattern's arcs."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @length.setter
    def length(self, newVal:float) -> None:
        """The distance between the centers of the pattern's arcs."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_length"](arg_newVal.COM_val))

    @property
    def width(self) -> float:
        """The width of the holding pattern."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @width.setter
    def width(self, newVal:float) -> None:
        """The width of the holding pattern."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_width"](arg_newVal.COM_val))

    @property
    def use_alternate_entry_points(self) -> bool:
        """The option to enter the holding pattern from an alternate point."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_alternate_entry_points"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_alternate_entry_points.setter
    def use_alternate_entry_points(self, newVal:bool) -> None:
        """The option to enter the holding pattern from an alternate point."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_alternate_entry_points"](arg_newVal.COM_val))

    @property
    def turns(self) -> int:
        """The number of full turns."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turns"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turns.setter
    def turns(self, newVal:int) -> None:
        """The number of full turns."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turns"](arg_newVal.COM_val))

    @property
    def refuel_dump_mode(self) -> "AVTR_HOLD_REFUEL_DUMP_MODE":
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        with agmarshall.AgEnum_arg(AVTR_HOLD_REFUEL_DUMP_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @refuel_dump_mode.setter
    def refuel_dump_mode(self, newVal:"AVTR_HOLD_REFUEL_DUMP_MODE") -> None:
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        with agmarshall.AgEnum_arg(AVTR_HOLD_REFUEL_DUMP_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_refuel_dump_mode"](arg_newVal.COM_val))

    @property
    def hold_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the hold cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_minimum_width(self) -> float:
        """The minimum allowable width based on the aircraft's minimum diameter at this altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_width"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{5b4e19a2-dd75-462f-b4da-ed23c6c16de3}", IProcedureHoldingFigure8)
agcls.AgTypeNameMap["IProcedureHoldingFigure8"] = IProcedureHoldingFigure8

class IProcedureHoldingRacetrack(object):
    """Interface used to access the options for a holding racetrack procedure."""
    _uuid = "{f4b0bbae-3a2b-4333-949c-ab5fc5a232b4}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_profile_mode"] = _raise_uninitialized_error
        self.__dict__["_set_profile_mode"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_get_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_set_range"] = _raise_uninitialized_error
        self.__dict__["_get_length"] = _raise_uninitialized_error
        self.__dict__["_set_length"] = _raise_uninitialized_error
        self.__dict__["_get_width"] = _raise_uninitialized_error
        self.__dict__["_set_width"] = _raise_uninitialized_error
        self.__dict__["_get_entry_maneuver"] = _raise_uninitialized_error
        self.__dict__["_set_entry_maneuver"] = _raise_uninitialized_error
        self.__dict__["_get_turns"] = _raise_uninitialized_error
        self.__dict__["_set_turns"] = _raise_uninitialized_error
        self.__dict__["_get_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_set_refuel_dump_mode"] = _raise_uninitialized_error
        self.__dict__["_get_hold_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_width"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureHoldingRacetrack._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoldingRacetrack from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureHoldingRacetrack = agcom.GUID(IProcedureHoldingRacetrack._uuid)
        vtable_offset_local = IProcedureHoldingRacetrack._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_profile_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_profile_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_get_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_width"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_width"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_entry_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_set_entry_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_get_turns"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_set_turns"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+19, agcom.LONG)
        self.__dict__["_get_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_refuel_dump_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_hold_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+22, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_width"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoldingRacetrack, vtable_offset_local+27, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoldingRacetrack.__dict__ and type(IProcedureHoldingRacetrack.__dict__[attrname]) == property:
            return IProcedureHoldingRacetrack.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoldingRacetrack.")
    
    @property
    def altitude_options(self) -> "IAltitudeMSLOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def profile_mode(self) -> "AVTR_HOLDING_PROFILE_MODE":
        """The mode defines how the aircraft will perform the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_PROFILE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_profile_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @profile_mode.setter
    def profile_mode(self, newVal:"AVTR_HOLDING_PROFILE_MODE") -> None:
        """The mode defines how the aircraft will perform the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_PROFILE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_profile_mode"](arg_newVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The mode for the level off maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, newVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The mode for the level off maneuver."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_newVal.COM_val))

    @property
    def bearing(self) -> typing.Any:
        """The bearing of the holding point from the site."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the holding point from the site."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_heading"](arg_newVal.COM_val))

    @property
    def range(self) -> float:
        """The distance to the holding point from the site."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range.setter
    def range(self, newVal:float) -> None:
        """The distance to the holding point from the site."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range"](arg_newVal.COM_val))

    @property
    def length(self) -> float:
        """The distance between the centers of the pattern's arcs."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @length.setter
    def length(self, newVal:float) -> None:
        """The distance between the centers of the pattern's arcs."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_length"](arg_newVal.COM_val))

    @property
    def width(self) -> float:
        """The width of the holding pattern."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_width"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @width.setter
    def width(self, newVal:float) -> None:
        """The width of the holding pattern."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_width"](arg_newVal.COM_val))

    @property
    def entry_maneuver(self) -> "AVTR_HOLDING_ENTRY_MANEUVER":
        """Defines how the aircraft will enter the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_ENTRY_MANEUVER) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_entry_maneuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @entry_maneuver.setter
    def entry_maneuver(self, newVal:"AVTR_HOLDING_ENTRY_MANEUVER") -> None:
        """Defines how the aircraft will enter the holding pattern."""
        with agmarshall.AgEnum_arg(AVTR_HOLDING_ENTRY_MANEUVER, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_entry_maneuver"](arg_newVal.COM_val))

    @property
    def turns(self) -> int:
        """The number of full turns."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turns"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turns.setter
    def turns(self, newVal:int) -> None:
        """The number of full turns."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turns"](arg_newVal.COM_val))

    @property
    def refuel_dump_mode(self) -> "AVTR_HOLD_REFUEL_DUMP_MODE":
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        with agmarshall.AgEnum_arg(AVTR_HOLD_REFUEL_DUMP_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_refuel_dump_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @refuel_dump_mode.setter
    def refuel_dump_mode(self, newVal:"AVTR_HOLD_REFUEL_DUMP_MODE") -> None:
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        with agmarshall.AgEnum_arg(AVTR_HOLD_REFUEL_DUMP_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_refuel_dump_mode"](arg_newVal.COM_val))

    @property
    def hold_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the hold cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_minimum_width(self) -> float:
        """The minimum allowable width based on the aircraft's minimum diameter at this altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_width"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{f4b0bbae-3a2b-4333-949c-ab5fc5a232b4}", IProcedureHoldingRacetrack)
agcls.AgTypeNameMap["IProcedureHoldingRacetrack"] = IProcedureHoldingRacetrack

class IProcedureTransitionToHover(object):
    """Interface used to access the options for a transition to hover procedure."""
    _uuid = "{06667f6e-68d3-4a3f-b285-64c556aac5c0}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_reference"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_course"] = _raise_uninitialized_error
        self.__dict__["_get_transition_into_wind"] = _raise_uninitialized_error
        self.__dict__["_set_transition_course"] = _raise_uninitialized_error
        self.__dict__["_set_transition_into_wind"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_plane_options"] = _raise_uninitialized_error
        self.__dict__["_get_smooth_transition_mode"] = _raise_uninitialized_error
        self.__dict__["_set_smooth_transition_mode"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureTransitionToHover._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTransitionToHover from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureTransitionToHover = agcom.GUID(IProcedureTransitionToHover._uuid)
        vtable_offset_local = IProcedureTransitionToHover._vtable_offset - 1
        self.__dict__["_get_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_reference"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_get_transition_into_wind"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_transition_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+8, agcom.VARIANT, agcom.VARIANT_BOOL)
        self.__dict__["_set_transition_into_wind"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+9, )
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_vertical_plane_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_get_smooth_transition_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_smooth_transition_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToHover, vtable_offset_local+15, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTransitionToHover.__dict__ and type(IProcedureTransitionToHover.__dict__[attrname]) == property:
            return IProcedureTransitionToHover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTransitionToHover.")
    
    @property
    def altitude_reference(self) -> "AVTR_AGLMSL":
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_reference"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_reference.setter
    def altitude_reference(self, newVal:"AVTR_AGLMSL") -> None:
        """The altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_AGLMSL, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_reference"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The altitude for the procedure."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the procedure."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the course."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def course(self) -> typing.Any:
        """The course for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def transition_into_wind(self) -> bool:
        """The option to transition into the wind."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transition_into_wind"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_transition_course(self, course:typing.Any, useMagneticCourse:bool) -> None:
        """Set the course and heading reference."""
        with agmarshall.VARIANT_arg(course) as arg_course, \
             agmarshall.VARIANT_BOOL_arg(useMagneticCourse) as arg_useMagneticCourse:
            agcls.evaluate_hresult(self.__dict__["_set_transition_course"](arg_course.COM_val, arg_useMagneticCourse.COM_val))

    def set_transition_into_wind(self) -> None:
        """Set the option to transition into the wind to true."""
        agcls.evaluate_hresult(self.__dict__["_set_transition_into_wind"]())

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def vertical_plane_options(self) -> "IVerticalPlaneAndFlightPathOptions":
        """Get the vertical plane options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_plane_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def smooth_transition_mode(self) -> "AVTR_TRANSITION_TO_HOVER_MODE":
        """The transition mode of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_TRANSITION_TO_HOVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_smooth_transition_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @smooth_transition_mode.setter
    def smooth_transition_mode(self, newVal:"AVTR_TRANSITION_TO_HOVER_MODE") -> None:
        """The transition mode of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_TRANSITION_TO_HOVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_smooth_transition_mode"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{06667f6e-68d3-4a3f-b285-64c556aac5c0}", IProcedureTransitionToHover)
agcls.AgTypeNameMap["IProcedureTransitionToHover"] = IProcedureTransitionToHover

class IProcedureTerrainFollow(object):
    """Interface used to access the options for a terrain following procedure."""
    _uuid = "{4c79076e-a174-469f-8370-0cb2271446ec}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_agl"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_agl"] = _raise_uninitialized_error
        self.__dict__["_get_navigation_options"] = _raise_uninitialized_error
        self.__dict__["_get_terrain_following_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_reduce_turn_radii"] = _raise_uninitialized_error
        self.__dict__["_set_reduce_turn_radii"] = _raise_uninitialized_error
        self.__dict__["_get_turn_factor"] = _raise_uninitialized_error
        self.__dict__["_set_turn_factor"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureTerrainFollow._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTerrainFollow from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureTerrainFollow = agcom.GUID(IProcedureTerrainFollow._uuid)
        vtable_offset_local = IProcedureTerrainFollow._vtable_offset - 1
        self.__dict__["_get_altitude_agl"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_agl"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_navigation_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_terrain_following_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_reduce_turn_radii"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_reduce_turn_radii"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_turn_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_turn_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureTerrainFollow, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTerrainFollow.__dict__ and type(IProcedureTerrainFollow.__dict__[attrname]) == property:
            return IProcedureTerrainFollow.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTerrainFollow.")
    
    @property
    def altitude_agl(self) -> float:
        """The altitude above ground level the aircraft will fly."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_agl"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_agl.setter
    def altitude_agl(self, newVal:float) -> None:
        """The altitude above ground level the aircraft will fly."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_agl"](arg_newVal.COM_val))

    @property
    def navigation_options(self) -> "INavigationOptions":
        """Get the navigation options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_navigation_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def terrain_following_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the terrain following airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_terrain_following_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def reduce_turn_radii(self) -> bool:
        """Option to use the minimum speed to compute the turn radius."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reduce_turn_radii"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reduce_turn_radii.setter
    def reduce_turn_radii(self, newVal:bool) -> None:
        """Option to use the minimum speed to compute the turn radius."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reduce_turn_radii"](arg_newVal.COM_val))

    @property
    def turn_factor(self) -> float:
        """The maximum turn radius factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_turn_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @turn_factor.setter
    def turn_factor(self, newVal:float) -> None:
        """The maximum turn radius factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_turn_factor"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{4c79076e-a174-469f-8370-0cb2271446ec}", IProcedureTerrainFollow)
agcls.AgTypeNameMap["IProcedureTerrainFollow"] = IProcedureTerrainFollow

class IProcedureHover(object):
    """Interface used to access the options for a hover procedure."""
    _uuid = "{9e58b1a4-ae09-41dd-aadb-fd1886d01fff}"
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_hover_mode"] = _raise_uninitialized_error
        self.__dict__["_set_hover_mode"] = _raise_uninitialized_error
        self.__dict__["_get_fixed_time"] = _raise_uninitialized_error
        self.__dict__["_set_fixed_time"] = _raise_uninitialized_error
        self.__dict__["_get_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_set_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_get_final_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_set_relative_course"] = _raise_uninitialized_error
        self.__dict__["_set_absolute_course"] = _raise_uninitialized_error
        self.__dict__["_set_final_translation_course"] = _raise_uninitialized_error
        self.__dict__["_get_absolute_course"] = _raise_uninitialized_error
        self.__dict__["_get_relative_course"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_final_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_set_final_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_get_translation_mode"] = _raise_uninitialized_error
        self.__dict__["_set_translation_mode"] = _raise_uninitialized_error
        self.__dict__["_get_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_use_magnetic_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_range"] = _raise_uninitialized_error
        self.__dict__["_set_range"] = _raise_uninitialized_error
        self.__dict__["_get_final_course_mode"] = _raise_uninitialized_error
        self.__dict__["_set_final_course_mode"] = _raise_uninitialized_error
        self.__dict__["_get_smooth_translation_mode"] = _raise_uninitialized_error
        self.__dict__["_set_smooth_translation_mode"] = _raise_uninitialized_error
        self.__dict__["_get_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureHover._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHover from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureHover = agcom.GUID(IProcedureHover._uuid)
        vtable_offset_local = IProcedureHover._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_hover_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_hover_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_fixed_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_fixed_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_final_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_relative_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_set_absolute_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+10, agcom.VARIANT, agcom.VARIANT_BOOL)
        self.__dict__["_set_final_translation_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+11, )
        self.__dict__["_get_absolute_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_get_relative_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_final_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_final_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_translation_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_translation_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+19, POINTER(agcom.VARIANT))
        self.__dict__["_set_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+20, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_magnetic_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+22, agcom.VARIANT_BOOL)
        self.__dict__["_get_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_final_course_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+25, POINTER(agcom.LONG))
        self.__dict__["_set_final_course_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+26, agcom.LONG)
        self.__dict__["_get_smooth_translation_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+27, POINTER(agcom.LONG))
        self.__dict__["_set_smooth_translation_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+28, agcom.LONG)
        self.__dict__["_get_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureHover, vtable_offset_local+31, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHover.__dict__ and type(IProcedureHover.__dict__[attrname]) == property:
            return IProcedureHover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHover.")
    
    @property
    def altitude_options(self) -> "IHoverAltitudeOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def hover_mode(self) -> "AVTR_HOVER_MODE":
        """The option to have the aircraft hover in place for a fixed time or to perform a hovering maneuver."""
        with agmarshall.AgEnum_arg(AVTR_HOVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hover_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hover_mode.setter
    def hover_mode(self, newVal:"AVTR_HOVER_MODE") -> None:
        """The option to have the aircraft hover in place for a fixed time or to perform a hovering maneuver."""
        with agmarshall.AgEnum_arg(AVTR_HOVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hover_mode"](arg_newVal.COM_val))

    @property
    def fixed_time(self) -> typing.Any:
        """The time to hover in place."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fixed_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fixed_time.setter
    def fixed_time(self, newVal:typing.Any) -> None:
        """The time to hover in place."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fixed_time"](arg_newVal.COM_val))

    @property
    def heading_mode(self) -> "AVTR_VTOL_HEADING_MODE":
        """The heading mode for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_HEADING_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_mode.setter
    def heading_mode(self, newVal:"AVTR_VTOL_HEADING_MODE") -> None:
        """The heading mode for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_HEADING_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_mode"](arg_newVal.COM_val))

    @property
    def final_heading_mode(self) -> "AVTR_VTOL_FINAL_HEADING_MODE":
        """The mode to define the heading at the end of the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_FINAL_HEADING_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_heading_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_relative_course(self, headingChange:typing.Any) -> None:
        """Set the relative heading change."""
        with agmarshall.VARIANT_arg(headingChange) as arg_headingChange:
            agcls.evaluate_hresult(self.__dict__["_set_relative_course"](arg_headingChange.COM_val))

    def set_absolute_course(self, course:typing.Any, isMagnetic:bool) -> None:
        """Set the absolute heading and reference."""
        with agmarshall.VARIANT_arg(course) as arg_course, \
             agmarshall.VARIANT_BOOL_arg(isMagnetic) as arg_isMagnetic:
            agcls.evaluate_hresult(self.__dict__["_set_absolute_course"](arg_course.COM_val, arg_isMagnetic.COM_val))

    def set_final_translation_course(self) -> None:
        """The option to have the final heading to match the translation bearing."""
        agcls.evaluate_hresult(self.__dict__["_set_final_translation_course"]())

    @property
    def absolute_course(self) -> typing.Any:
        """The absolute course for the heading."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_absolute_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def relative_course(self) -> typing.Any:
        """The relative heading change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the heading course."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def final_heading_rate(self) -> "AVTR_VTOL_RATE_MODE":
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_heading_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_heading_rate.setter
    def final_heading_rate(self, newVal:"AVTR_VTOL_RATE_MODE") -> None:
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_heading_rate"](arg_newVal.COM_val))

    @property
    def translation_mode(self) -> "AVTR_VTOL_TRANSLATION_MODE":
        """Define how the aircraft will translate during the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_TRANSLATION_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_translation_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @translation_mode.setter
    def translation_mode(self, newVal:"AVTR_VTOL_TRANSLATION_MODE") -> None:
        """Define how the aircraft will translate during the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_TRANSLATION_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_translation_mode"](arg_newVal.COM_val))

    @property
    def bearing(self) -> typing.Any:
        """The bearing of the translation during the hover."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the translation during the hover."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing"](arg_newVal.COM_val))

    @property
    def use_magnetic_bearing(self) -> bool:
        """The option to use a magnetic heading for the translation bearing."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_magnetic_bearing.setter
    def use_magnetic_bearing(self, newVal:bool) -> None:
        """The option to use a magnetic heading for the translation bearing."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_magnetic_bearing"](arg_newVal.COM_val))

    @property
    def range(self) -> float:
        """The range to translate during the hover."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @range.setter
    def range(self, newVal:float) -> None:
        """The range to translate during the hover."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_range"](arg_newVal.COM_val))

    @property
    def final_course_mode(self) -> "AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE":
        """The mode to specify the final course at the end of the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_course_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_course_mode.setter
    def final_course_mode(self, newVal:"AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE") -> None:
        """The mode to specify the final course at the end of the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_course_mode"](arg_newVal.COM_val))

    @property
    def smooth_translation_mode(self) -> "AVTR_VTOL_RATE_MODE":
        """The translation mode of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_smooth_translation_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @smooth_translation_mode.setter
    def smooth_translation_mode(self, newVal:"AVTR_VTOL_RATE_MODE") -> None:
        """The translation mode of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_smooth_translation_mode"](arg_newVal.COM_val))

    @property
    def radius_factor(self) -> float:
        """The turn radius factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The turn radius factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_factor"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{9e58b1a4-ae09-41dd-aadb-fd1886d01fff}", IProcedureHover)
agcls.AgTypeNameMap["IProcedureHover"] = IProcedureHover

class IProcedureHoverTranslate(object):
    """Interface used to access the options for a hover translate procedure."""
    _uuid = "{7c58df50-e3d1-4e96-bb3c-8cc2b2c58343}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_set_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_get_final_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_set_relative_course"] = _raise_uninitialized_error
        self.__dict__["_set_absolute_course"] = _raise_uninitialized_error
        self.__dict__["_set_final_translation_course"] = _raise_uninitialized_error
        self.__dict__["_get_absolute_course"] = _raise_uninitialized_error
        self.__dict__["_get_relative_course"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_final_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_set_final_heading_rate"] = _raise_uninitialized_error
        self.__dict__["_get_final_course_mode"] = _raise_uninitialized_error
        self.__dict__["_set_final_course_mode"] = _raise_uninitialized_error
        self.__dict__["_get_smooth_translation_mode"] = _raise_uninitialized_error
        self.__dict__["_set_smooth_translation_mode"] = _raise_uninitialized_error
        self.__dict__["_get_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureHoverTranslate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoverTranslate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureHoverTranslate = agcom.GUID(IProcedureHoverTranslate._uuid)
        vtable_offset_local = IProcedureHoverTranslate._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_final_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_relative_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_set_absolute_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+6, agcom.VARIANT, agcom.VARIANT_BOOL)
        self.__dict__["_set_final_translation_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+7, )
        self.__dict__["_get_absolute_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_get_relative_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_final_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_final_heading_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_final_course_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_final_course_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_smooth_translation_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_smooth_translation_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureHoverTranslate, vtable_offset_local+19, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoverTranslate.__dict__ and type(IProcedureHoverTranslate.__dict__[attrname]) == property:
            return IProcedureHoverTranslate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoverTranslate.")
    
    @property
    def altitude_options(self) -> "IHoverAltitudeOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def heading_mode(self) -> "AVTR_VTOL_HEADING_MODE":
        """The heading mode for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_HEADING_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_mode.setter
    def heading_mode(self, newVal:"AVTR_VTOL_HEADING_MODE") -> None:
        """The heading mode for the aircraft."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_HEADING_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_mode"](arg_newVal.COM_val))

    @property
    def final_heading_mode(self) -> "AVTR_VTOL_FINAL_HEADING_MODE":
        """The mode to define the heading at the end of the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_FINAL_HEADING_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_heading_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_relative_course(self, headingChange:typing.Any) -> None:
        """Set the relative heading change."""
        with agmarshall.VARIANT_arg(headingChange) as arg_headingChange:
            agcls.evaluate_hresult(self.__dict__["_set_relative_course"](arg_headingChange.COM_val))

    def set_absolute_course(self, course:typing.Any, isMagnetic:bool) -> None:
        """Set the absolute heading and reference."""
        with agmarshall.VARIANT_arg(course) as arg_course, \
             agmarshall.VARIANT_BOOL_arg(isMagnetic) as arg_isMagnetic:
            agcls.evaluate_hresult(self.__dict__["_set_absolute_course"](arg_course.COM_val, arg_isMagnetic.COM_val))

    def set_final_translation_course(self) -> None:
        """The option to have the final heading to match the translation bearing."""
        agcls.evaluate_hresult(self.__dict__["_set_final_translation_course"]())

    @property
    def absolute_course(self) -> typing.Any:
        """The absolute course for the heading."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_absolute_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def relative_course(self) -> typing.Any:
        """The relative heading change."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the heading course."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def final_heading_rate(self) -> "AVTR_VTOL_RATE_MODE":
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_heading_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_heading_rate.setter
    def final_heading_rate(self, newVal:"AVTR_VTOL_RATE_MODE") -> None:
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_heading_rate"](arg_newVal.COM_val))

    @property
    def final_course_mode(self) -> "AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE":
        """The mode to specify the final course at the end of the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_course_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_course_mode.setter
    def final_course_mode(self, newVal:"AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE") -> None:
        """The mode to specify the final course at the end of the hover."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_TRANSLATION_FINAL_COURSE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_course_mode"](arg_newVal.COM_val))

    @property
    def smooth_translation_mode(self) -> "AVTR_VTOL_RATE_MODE":
        """The translation mode of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_smooth_translation_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @smooth_translation_mode.setter
    def smooth_translation_mode(self, newVal:"AVTR_VTOL_RATE_MODE") -> None:
        """The translation mode of the aircraft at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_smooth_translation_mode"](arg_newVal.COM_val))

    @property
    def radius_factor(self) -> float:
        """The turn radius factor."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The turn radius factor."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_factor"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{7c58df50-e3d1-4e96-bb3c-8cc2b2c58343}", IProcedureHoverTranslate)
agcls.AgTypeNameMap["IProcedureHoverTranslate"] = IProcedureHoverTranslate

class IProcedureTransitionToForwardFlight(object):
    """Interface used to access the options for a transition to forward flight procedure."""
    _uuid = "{5dbdb660-3320-47c7-ac2b-f1ebd3b0eeae}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_transition_course_mode"] = _raise_uninitialized_error
        self.__dict__["_set_transition_into_wind"] = _raise_uninitialized_error
        self.__dict__["_set_absolute_course"] = _raise_uninitialized_error
        self.__dict__["_set_relative_course"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_absolute_course"] = _raise_uninitialized_error
        self.__dict__["_get_relative_course"] = _raise_uninitialized_error
        self.__dict__["_get_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureTransitionToForwardFlight._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTransitionToForwardFlight from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureTransitionToForwardFlight = agcom.GUID(IProcedureTransitionToForwardFlight._uuid)
        vtable_offset_local = IProcedureTransitionToForwardFlight._vtable_offset - 1
        self.__dict__["_get_transition_course_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_transition_into_wind"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+2, )
        self.__dict__["_set_absolute_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+3, agcom.VARIANT, agcom.VARIANT_BOOL)
        self.__dict__["_set_relative_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_absolute_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_get_relative_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_get_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureTransitionToForwardFlight, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTransitionToForwardFlight.__dict__ and type(IProcedureTransitionToForwardFlight.__dict__[attrname]) == property:
            return IProcedureTransitionToForwardFlight.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTransitionToForwardFlight.")
    
    @property
    def transition_course_mode(self) -> "AVTR_VTOL_TRANSITION_MODE":
        """The mode to specify the course of the transition maneuver."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_TRANSITION_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transition_course_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_transition_into_wind(self) -> None:
        """Set the option to transition into the wind to true."""
        agcls.evaluate_hresult(self.__dict__["_set_transition_into_wind"]())

    def set_absolute_course(self, course:typing.Any, useMagneticCourse:bool) -> None:
        """Set the mode to absolute and specify the course and heading reference."""
        with agmarshall.VARIANT_arg(course) as arg_course, \
             agmarshall.VARIANT_BOOL_arg(useMagneticCourse) as arg_useMagneticCourse:
            agcls.evaluate_hresult(self.__dict__["_set_absolute_course"](arg_course.COM_val, arg_useMagneticCourse.COM_val))

    def set_relative_course(self, headingChange:typing.Any) -> None:
        """Set the mode to relative and specify the heading change."""
        with agmarshall.VARIANT_arg(headingChange) as arg_headingChange:
            agcls.evaluate_hresult(self.__dict__["_set_relative_course"](arg_headingChange.COM_val))

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the course."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def absolute_course(self) -> typing.Any:
        """The absolute course for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_absolute_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def relative_course(self) -> typing.Any:
        """The relative course for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the end of the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the end of the procedure."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_path_angle"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{5dbdb660-3320-47c7-ac2b-f1ebd3b0eeae}", IProcedureTransitionToForwardFlight)
agcls.AgTypeNameMap["IProcedureTransitionToForwardFlight"] = IProcedureTransitionToForwardFlight

class IProcedureVerticalTakeoff(object):
    """Interface used to access the options for a vertical takeoff procedure."""
    _uuid = "{1d8d4dbd-b18b-4fc7-862f-0afbdff5054c}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_above_point"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_above_point"] = _raise_uninitialized_error
        self.__dict__["_get_final_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_final_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading_into_wind"] = _raise_uninitialized_error
        self.__dict__["_set_heading_into_wind"] = _raise_uninitialized_error
        self.__dict__["_get_hold_on_deck"] = _raise_uninitialized_error
        self.__dict__["_set_hold_on_deck"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureVerticalTakeoff._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureVerticalTakeoff from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureVerticalTakeoff = agcom.GUID(IProcedureVerticalTakeoff._uuid)
        vtable_offset_local = IProcedureVerticalTakeoff._vtable_offset - 1
        self.__dict__["_get_altitude_above_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_above_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_final_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_final_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_set_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+7, agcom.VARIANT, agcom.VARIANT_BOOL)
        self.__dict__["_get_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_heading_into_wind"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_heading_into_wind"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_hold_on_deck"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalTakeoff, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureVerticalTakeoff.__dict__ and type(IProcedureVerticalTakeoff.__dict__[attrname]) == property:
            return IProcedureVerticalTakeoff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureVerticalTakeoff.")
    
    @property
    def altitude_above_point(self) -> float:
        """The altitude the aircraft will takeoff to."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_above_point"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_above_point.setter
    def altitude_above_point(self, newVal:float) -> None:
        """The altitude the aircraft will takeoff to."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_above_point"](arg_newVal.COM_val))

    @property
    def final_altitude_rate(self) -> "AVTR_VTOL_RATE_MODE":
        """The altitude rate at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_altitude_rate.setter
    def final_altitude_rate(self, newVal:"AVTR_VTOL_RATE_MODE") -> None:
        """The altitude rate at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_altitude_rate"](arg_newVal.COM_val))

    @property
    def altitude_offset(self) -> float:
        """The altitude offset from the site to begin the vertical takeoff."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The altitude offset from the site to begin the vertical takeoff."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_offset"](arg_newVal.COM_val))

    def set_heading(self, heading:typing.Any, isMagnetic:bool) -> None:
        """Set the heading and heading reference."""
        with agmarshall.VARIANT_arg(heading) as arg_heading, \
             agmarshall.VARIANT_BOOL_arg(isMagnetic) as arg_isMagnetic:
            agcls.evaluate_hresult(self.__dict__["_set_heading"](arg_heading.COM_val, arg_isMagnetic.COM_val))

    @property
    def heading(self) -> typing.Any:
        """The heading for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def heading_into_wind(self) -> bool:
        """The option to define the heading according to the wind direction."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_into_wind"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_into_wind.setter
    def heading_into_wind(self, pVal:bool) -> None:
        """The option to define the heading according to the wind direction."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_into_wind"](arg_pVal.COM_val))

    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_on_deck"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_on_deck"](arg_inVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{1d8d4dbd-b18b-4fc7-862f-0afbdff5054c}", IProcedureVerticalTakeoff)
agcls.AgTypeNameMap["IProcedureVerticalTakeoff"] = IProcedureVerticalTakeoff

class IProcedureVerticalLanding(object):
    """Interface used to access the options for a vertical landing procedure."""
    _uuid = "{22009a25-626b-4677-aac4-668cc62a6d9f}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_above_point"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_above_point"] = _raise_uninitialized_error
        self.__dict__["_get_final_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_final_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_set_heading_mode"] = _raise_uninitialized_error
        self.__dict__["_set_heading"] = _raise_uninitialized_error
        self.__dict__["_get_heading"] = _raise_uninitialized_error
        self.__dict__["_get_use_magnetic_heading"] = _raise_uninitialized_error
        self.__dict__["_get_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureVerticalLanding._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureVerticalLanding from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureVerticalLanding = agcom.GUID(IProcedureVerticalLanding._uuid)
        vtable_offset_local = IProcedureVerticalLanding._vtable_offset - 1
        self.__dict__["_get_altitude_above_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_above_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_final_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_final_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_heading_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_set_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+9, agcom.VARIANT, agcom.VARIANT_BOOL)
        self.__dict__["_get_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_get_use_magnetic_heading"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureVerticalLanding, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureVerticalLanding.__dict__ and type(IProcedureVerticalLanding.__dict__[attrname]) == property:
            return IProcedureVerticalLanding.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureVerticalLanding.")
    
    @property
    def altitude_above_point(self) -> float:
        """The altitude the aircraft will takeoff to."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_above_point"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_above_point.setter
    def altitude_above_point(self, newVal:float) -> None:
        """The altitude the aircraft will takeoff to."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_above_point"](arg_newVal.COM_val))

    @property
    def final_altitude_rate(self) -> "AVTR_VTOL_RATE_MODE":
        """The altitude rate at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_altitude_rate.setter
    def final_altitude_rate(self, newVal:"AVTR_VTOL_RATE_MODE") -> None:
        """The altitude rate at the end of the procedure."""
        with agmarshall.AgEnum_arg(AVTR_VTOL_RATE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_altitude_rate"](arg_newVal.COM_val))

    @property
    def altitude_offset(self) -> float:
        """The altitude offset from the site to begin the vertical takeoff."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The altitude offset from the site to begin the vertical takeoff."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_offset"](arg_newVal.COM_val))

    @property
    def heading_mode(self) -> "AVTR_VERT_LANDING_MODE":
        """The mode to define the heading during the landing."""
        with agmarshall.AgEnum_arg(AVTR_VERT_LANDING_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @heading_mode.setter
    def heading_mode(self, newVal:"AVTR_VERT_LANDING_MODE") -> None:
        """The mode to define the heading during the landing."""
        with agmarshall.AgEnum_arg(AVTR_VERT_LANDING_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_heading_mode"](arg_newVal.COM_val))

    def set_heading(self, heading:typing.Any, isMagnetic:bool) -> None:
        """Set the heading and heading reference."""
        with agmarshall.VARIANT_arg(heading) as arg_heading, \
             agmarshall.VARIANT_BOOL_arg(isMagnetic) as arg_isMagnetic:
            agcls.evaluate_hresult(self.__dict__["_set_heading"](arg_heading.COM_val, arg_isMagnetic.COM_val))

    @property
    def heading(self) -> typing.Any:
        """The heading for the procedure."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_magnetic_heading"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def radius_factor(self) -> float:
        """The radius factor for turns performed while translating to the hover point."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The radius factor for turns performed while translating to the hover point."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_factor"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{22009a25-626b-4677-aac4-668cc62a6d9f}", IProcedureVerticalLanding)
agcls.AgTypeNameMap["IProcedureVerticalLanding"] = IProcedureVerticalLanding

class IProcedureReferenceState(object):
    """Interface used to access the options for a reference state procedure."""
    _uuid = "{729bb865-8651-4e35-beac-db80804116bb}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_default_cruise_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_msl_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_msl_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_performance_mode"] = _raise_uninitialized_error
        self.__dict__["_set_performance_mode"] = _raise_uninitialized_error
        self.__dict__["_get_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_set_reference_frame"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_forward_flight"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_takeoff_landing"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_hover"] = _raise_uninitialized_error
        self.__dict__["_get_mode_as_weight_on_wheels"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureReferenceState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureReferenceState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureReferenceState = agcom.GUID(IProcedureReferenceState._uuid)
        vtable_offset_local = IProcedureReferenceState._vtable_offset - 1
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_default_cruise_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_msl_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_msl_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_performance_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_performance_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_reference_frame"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_get_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_mode_as_forward_flight"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_takeoff_landing"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_hover"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+20, POINTER(agcom.PVOID))
        self.__dict__["_get_mode_as_weight_on_wheels"] = IAGFUNCTYPE(pUnk, IID_IProcedureReferenceState, vtable_offset_local+21, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureReferenceState.__dict__ and type(IProcedureReferenceState.__dict__[attrname]) == property:
            return IProcedureReferenceState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureReferenceState.")
    
    @property
    def start_time(self) -> typing.Any:
        """The start time of the reference state."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_time.setter
    def start_time(self, newVal:typing.Any) -> None:
        """The start time of the reference state."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_time"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def latitude(self) -> typing.Any:
        """The waypoint latitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The waypoint latitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The waypoint longitude."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The waypoint longitude."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_default_cruise_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_default_cruise_altitude"](arg_newVal.COM_val))

    @property
    def msl_altitude(self) -> float:
        """The MSL altitude. Can only be used when the option to use the default cruise altitude is off."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_msl_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @msl_altitude.setter
    def msl_altitude(self, newVal:float) -> None:
        """Set the MSLAltitude"""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_msl_altitude"](arg_newVal.COM_val))

    @property
    def performance_mode(self) -> "AVTR_REF_STATE_PERF_MODE":
        """The type of motion the aircraft is engaged in."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_PERF_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_performance_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @performance_mode.setter
    def performance_mode(self, newVal:"AVTR_REF_STATE_PERF_MODE") -> None:
        """The type of motion the aircraft is engaged in."""
        with agmarshall.AgEnum_arg(AVTR_REF_STATE_PERF_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_performance_mode"](arg_newVal.COM_val))

    @property
    def reference_frame(self) -> "AVTR_BASIC_MANEUVER_REF_FRAME":
        """The reference frame the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_frame"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_frame.setter
    def reference_frame(self, newVal:"AVTR_BASIC_MANEUVER_REF_FRAME") -> None:
        """The reference frame the aircraft will use."""
        with agmarshall.AgEnum_arg(AVTR_BASIC_MANEUVER_REF_FRAME, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_frame"](arg_newVal.COM_val))

    @property
    def fuel_flow(self) -> float:
        """The rate of fuel consumption."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The rate of fuel consumption."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow"](arg_newVal.COM_val))

    @property
    def mode_as_forward_flight(self) -> "IReferenceStateForwardFlightOptions":
        """Get the forward flight options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_forward_flight"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def mode_as_takeoff_landing(self) -> "IReferenceStateTakeoffLandingOptions":
        """Get the takeoff and landing options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_takeoff_landing"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def mode_as_hover(self) -> "IReferenceStateHoverOptions":
        """Get the hover options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_hover"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def mode_as_weight_on_wheels(self) -> "IReferenceStateWeightOnWheelsOptions":
        """Get the weight on wheels options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_as_weight_on_wheels"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{729bb865-8651-4e35-beac-db80804116bb}", IProcedureReferenceState)
agcls.AgTypeNameMap["IProcedureReferenceState"] = IProcedureReferenceState

class IProcedureSuperProcedure(object):
    """Interface used to access the options for a super procedure."""
    _uuid = "{47fee7c5-8e6d-4510-b70d-6d234b4db640}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_load_procedures_from_clipboard"] = _raise_uninitialized_error
        self.__dict__["_load_procedures_from_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureSuperProcedure._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureSuperProcedure from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureSuperProcedure = agcom.GUID(IProcedureSuperProcedure._uuid)
        vtable_offset_local = IProcedureSuperProcedure._vtable_offset - 1
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureSuperProcedure, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_load_procedures_from_clipboard"] = IAGFUNCTYPE(pUnk, IID_IProcedureSuperProcedure, vtable_offset_local+2, )
        self.__dict__["_load_procedures_from_file"] = IAGFUNCTYPE(pUnk, IID_IProcedureSuperProcedure, vtable_offset_local+3, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureSuperProcedure.__dict__ and type(IProcedureSuperProcedure.__dict__[attrname]) == property:
            return IProcedureSuperProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureSuperProcedure.")
    
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    def load_procedures_from_clipboard(self) -> None:
        """Load procedures from the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_load_procedures_from_clipboard"]())

    def load_procedures_from_file(self, filepath:str) -> None:
        """Load procedures from a file."""
        with agmarshall.BSTR_arg(filepath) as arg_filepath:
            agcls.evaluate_hresult(self.__dict__["_load_procedures_from_file"](arg_filepath.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{47fee7c5-8e6d-4510-b70d-6d234b4db640}", IProcedureSuperProcedure)
agcls.AgTypeNameMap["IProcedureSuperProcedure"] = IProcedureSuperProcedure

class IProcedureLaunch(object):
    """Interface used to access the options for a launch procedure."""
    _uuid = "{f74d4c55-51c8-4559-ad0f-3236b5764f12}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_launch_time"] = _raise_uninitialized_error
        self.__dict__["_set_launch_time"] = _raise_uninitialized_error
        self.__dict__["_get_position_point_name"] = _raise_uninitialized_error
        self.__dict__["_set_position_point_name"] = _raise_uninitialized_error
        self.__dict__["_get_direction_vec_name"] = _raise_uninitialized_error
        self.__dict__["_set_direction_vec_name"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_mode"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_mode"] = _raise_uninitialized_error
        self.__dict__["_get_specify_launch_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_specify_launch_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_accel_g"] = _raise_uninitialized_error
        self.__dict__["_set_accel_g"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_get_override_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_override_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_true_course_hint"] = _raise_uninitialized_error
        self.__dict__["_set_true_course_hint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureLaunch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLaunch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureLaunch = agcom.GUID(IProcedureLaunch._uuid)
        vtable_offset_local = IProcedureLaunch._vtable_offset - 1
        self.__dict__["_get_launch_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_launch_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_position_point_name"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_position_point_name"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_direction_vec_name"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_direction_vec_name"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_attitude_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_specify_launch_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_specify_launch_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_accel_g"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_g"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+15, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_get_override_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+20, POINTER(agcom.PVOID))
        self.__dict__["_get_true_course_hint"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+21, POINTER(agcom.VARIANT))
        self.__dict__["_set_true_course_hint"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunch, vtable_offset_local+22, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLaunch.__dict__ and type(IProcedureLaunch.__dict__[attrname]) == property:
            return IProcedureLaunch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLaunch.")
    
    @property
    def launch_time(self) -> typing.Any:
        """The launch time of the aircraft."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_time.setter
    def launch_time(self, newVal:typing.Any) -> None:
        """The launch time of the aircraft."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_time"](arg_newVal.COM_val))

    @property
    def position_point_name(self) -> str:
        """The name of the point used for the launch position."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_position_point_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @position_point_name.setter
    def position_point_name(self, pVal:str) -> None:
        """The name of the point used for the launch position."""
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_position_point_name"](arg_pVal.COM_val))

    @property
    def direction_vec_name(self) -> str:
        """The name of the vector used for the launch direction."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_direction_vec_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @direction_vec_name.setter
    def direction_vec_name(self, pVal:str) -> None:
        """The name of the vector used for the launch direction."""
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_direction_vec_name"](arg_pVal.COM_val))

    @property
    def attitude_mode(self) -> "AVTR_LAUNCH_ATTITUDE_MODE":
        """The attitude mode during the launch."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_ATTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attitude_mode.setter
    def attitude_mode(self, newVal:"AVTR_LAUNCH_ATTITUDE_MODE") -> None:
        """The attitude mode during the launch."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_ATTITUDE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_mode"](arg_newVal.COM_val))

    @property
    def specify_launch_airspeed(self) -> bool:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specify_launch_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specify_launch_airspeed.setter
    def specify_launch_airspeed(self, newVal:bool) -> None:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specify_launch_airspeed"](arg_newVal.COM_val))

    @property
    def accel_g(self) -> float:
        """The acceleration of the aircraft during the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The acceleration of the aircraft during the launch."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_g"](arg_newVal.COM_val))

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def fuel_flow_type(self) -> "AVTR_FUEL_FLOW_TYPE":
        """The fuel flow type of the aircraft during the launch."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"AVTR_FUEL_FLOW_TYPE") -> None:
        """The fuel flow type of the aircraft during the launch."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow_type"](arg_newVal.COM_val))

    @property
    def override_fuel_flow(self) -> float:
        """The fuel flow value for a fuel flow type set to Override."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_fuel_flow.setter
    def override_fuel_flow(self, newVal:float) -> None:
        """The fuel flow value for a fuel flow type set to Override."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_fuel_flow"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def true_course_hint(self) -> typing.Any:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_true_course_hint"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @true_course_hint.setter
    def true_course_hint(self, newVal:typing.Any) -> None:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_true_course_hint"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{f74d4c55-51c8-4559-ad0f-3236b5764f12}", IProcedureLaunch)
agcls.AgTypeNameMap["IProcedureLaunch"] = IProcedureLaunch

class IProcedureAirway(object):
    """Interface used to access the options for an Airway procedure."""
    _uuid = "{49483b87-39de-46f6-b61b-633ada0c7970}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_router"] = _raise_uninitialized_error
        self.__dict__["_set_router"] = _raise_uninitialized_error
        self.__dict__["_get_airway_id"] = _raise_uninitialized_error
        self.__dict__["_set_airway_id"] = _raise_uninitialized_error
        self.__dict__["_get_airway_names"] = _raise_uninitialized_error
        self.__dict__["_get_sequence"] = _raise_uninitialized_error
        self.__dict__["_set_sequence"] = _raise_uninitialized_error
        self.__dict__["_get_sequences"] = _raise_uninitialized_error
        self.__dict__["_get_entry_id"] = _raise_uninitialized_error
        self.__dict__["_set_entry_id"] = _raise_uninitialized_error
        self.__dict__["_get_exit_id"] = _raise_uninitialized_error
        self.__dict__["_set_exit_id"] = _raise_uninitialized_error
        self.__dict__["_get_waypoints"] = _raise_uninitialized_error
        self.__dict__["_copy_procedures"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureAirway._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureAirway from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureAirway = agcom.GUID(IProcedureAirway._uuid)
        vtable_offset_local = IProcedureAirway._vtable_offset - 1
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_router"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_router"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_airway_id"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_airway_id"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_airway_names"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+9, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_sequence"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_set_sequence"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+11, agcom.BSTR)
        self.__dict__["_get_sequences"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+12, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_entry_id"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_set_entry_id"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_get_exit_id"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_set_exit_id"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_get_waypoints"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__["_copy_procedures"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirway, vtable_offset_local+18, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureAirway.__dict__ and type(IProcedureAirway.__dict__[attrname]) == property:
            return IProcedureAirway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureAirway.")
    
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def altitude_options(self) -> "IAltitudeMSLOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def router(self) -> str:
        """The router used to provide available airways."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_router"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @router.setter
    def router(self, newVal:str) -> None:
        """The router used to provide available airways."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_router"](arg_newVal.COM_val))

    @property
    def airway_id(self) -> str:
        """The airway ID."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airway_id"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @airway_id.setter
    def airway_id(self, newVal:str) -> None:
        """The airway ID."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_airway_id"](arg_newVal.COM_val))

    def get_airway_names(self) -> list:
        """Get the a list of names of the available airways."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_airway_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def sequence(self) -> str:
        """The direction the aircraft will fly the route."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sequence.setter
    def sequence(self, newVal:str) -> None:
        """The direction the aircraft will fly the route."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sequence"](arg_newVal.COM_val))

    def get_sequences(self) -> list:
        """Get a list of sequence options."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequences"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def entry_id(self) -> str:
        """The ID of the entry waypoint."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_entry_id"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @entry_id.setter
    def entry_id(self, newVal:str) -> None:
        """The ID of the entry waypoint."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_entry_id"](arg_newVal.COM_val))

    @property
    def exit_id(self) -> str:
        """The ID of the exit waypoint."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_exit_id"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @exit_id.setter
    def exit_id(self, newVal:str) -> None:
        """The ID of the exit waypoint."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_exit_id"](arg_newVal.COM_val))

    def get_waypoints(self) -> list:
        """Get a list of available waypoints for the airway."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_waypoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def copy_procedures(self) -> None:
        """Copy the airway route as a set of procedures to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_procedures"]())


agcls.AgClassCatalog.add_catalog_entry("{49483b87-39de-46f6-b61b-633ada0c7970}", IProcedureAirway)
agcls.AgTypeNameMap["IProcedureAirway"] = IProcedureAirway

class IProcedureAirwayRouter(object):
    """Interface used to access the options for an Airway Router procedure."""
    _uuid = "{5f3240be-4a51-4580-976b-f8ca68855608}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_router"] = _raise_uninitialized_error
        self.__dict__["_get_optimize_for_wind"] = _raise_uninitialized_error
        self.__dict__["_set_optimize_for_wind"] = _raise_uninitialized_error
        self.__dict__["_get_bounding_box_pad"] = _raise_uninitialized_error
        self.__dict__["_set_bounding_box_pad"] = _raise_uninitialized_error
        self.__dict__["_get_max_waypoint_range"] = _raise_uninitialized_error
        self.__dict__["_set_max_waypoint_range"] = _raise_uninitialized_error
        self.__dict__["_get_entry_exit_and_or"] = _raise_uninitialized_error
        self.__dict__["_set_entry_exit_and_or"] = _raise_uninitialized_error
        self.__dict__["_get_max_waypoint_count"] = _raise_uninitialized_error
        self.__dict__["_set_max_waypoint_count"] = _raise_uninitialized_error
        self.__dict__["_update_route"] = _raise_uninitialized_error
        self.__dict__["_get_waypoints"] = _raise_uninitialized_error
        self.__dict__["_get_segments"] = _raise_uninitialized_error
        self.__dict__["_copy_procedures"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureAirwayRouter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureAirwayRouter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureAirwayRouter = agcom.GUID(IProcedureAirwayRouter._uuid)
        vtable_offset_local = IProcedureAirwayRouter._vtable_offset - 1
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_router"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_optimize_for_wind"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_optimize_for_wind"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_bounding_box_pad"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_bounding_box_pad"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_max_waypoint_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_waypoint_range"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_entry_exit_and_or"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_entry_exit_and_or"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_max_waypoint_count"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_max_waypoint_count"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_update_route"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+16, )
        self.__dict__["_get_waypoints"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_segments"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+18, POINTER(agcom.SAFEARRAY))
        self.__dict__["_copy_procedures"] = IAGFUNCTYPE(pUnk, IID_IProcedureAirwayRouter, vtable_offset_local+19, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureAirwayRouter.__dict__ and type(IProcedureAirwayRouter.__dict__[attrname]) == property:
            return IProcedureAirwayRouter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureAirwayRouter.")
    
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def altitude_options(self) -> "IAltitudeMSLOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def router(self) -> str:
        """The router used to provide available airways."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_router"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def optimize_for_wind(self) -> bool:
        """Opt to account for the wind when calculating the most efficient route."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_optimize_for_wind"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @optimize_for_wind.setter
    def optimize_for_wind(self, newVal:bool) -> None:
        """Opt to account for the wind when calculating the most efficient route."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_optimize_for_wind"](arg_newVal.COM_val))

    @property
    def bounding_box_pad(self) -> float:
        """The maximum distance beyond the bounding box that a waypoint will be considered for the final route."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bounding_box_pad"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bounding_box_pad.setter
    def bounding_box_pad(self, newVal:float) -> None:
        """The maximum distance beyond the bounding box that a waypoint will be considered for the final route."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bounding_box_pad"](arg_newVal.COM_val))

    @property
    def max_waypoint_range(self) -> float:
        """The maximum distance from the end of the previous procedure that an airway waypoint will be considered."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_waypoint_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_waypoint_range.setter
    def max_waypoint_range(self, newVal:float) -> None:
        """The maximum distance from the end of the previous procedure that an airway waypoint will be considered."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_waypoint_range"](arg_newVal.COM_val))

    @property
    def entry_exit_and_or(self) -> "AVTR_AND_OR":
        """Define how the two Entry/Exit Waypoint constraints will be considered."""
        with agmarshall.AgEnum_arg(AVTR_AND_OR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_entry_exit_and_or"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @entry_exit_and_or.setter
    def entry_exit_and_or(self, newVal:"AVTR_AND_OR") -> None:
        """Define how the two Entry/Exit Waypoint constraints will be considered."""
        with agmarshall.AgEnum_arg(AVTR_AND_OR, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_entry_exit_and_or"](arg_newVal.COM_val))

    @property
    def max_waypoint_count(self) -> int:
        """The maximum number of airway waypoints that the procedure will consider for each segment."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_waypoint_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_waypoint_count.setter
    def max_waypoint_count(self, newVal:int) -> None:
        """The maximum number of airway waypoints that the procedure will consider for each segment."""
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_waypoint_count"](arg_newVal.COM_val))

    def update_route(self) -> None:
        """Recalculate the route."""
        agcls.evaluate_hresult(self.__dict__["_update_route"]())

    def get_waypoints(self) -> list:
        """Get a list of the current route's waypoints."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_waypoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_segments(self) -> list:
        """Get a list of the current route's individual procedures."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_segments"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def copy_procedures(self) -> None:
        """Copy the route as a set of procedures to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_procedures"]())


agcls.AgClassCatalog.add_catalog_entry("{5f3240be-4a51-4580-976b-f8ca68855608}", IProcedureAirwayRouter)
agcls.AgTypeNameMap["IProcedureAirwayRouter"] = IProcedureAirwayRouter

class IProcedureAreaTargetSearch(object):
    """Interface used to access the options for an Area Target Search procedure."""
    _uuid = "{ad0dc4ce-a6b1-499b-9a60-54dd5b6266ac}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_procedure_type"] = _raise_uninitialized_error
        self.__dict__["_set_procedure_type"] = _raise_uninitialized_error
        self.__dict__["_get_max_separation"] = _raise_uninitialized_error
        self.__dict__["_set_max_separation"] = _raise_uninitialized_error
        self.__dict__["_get_course_mode"] = _raise_uninitialized_error
        self.__dict__["_set_course_mode"] = _raise_uninitialized_error
        self.__dict__["_get_first_leg_retrograde"] = _raise_uninitialized_error
        self.__dict__["_set_first_leg_retrograde"] = _raise_uninitialized_error
        self.__dict__["_get_centroid_true_course"] = _raise_uninitialized_error
        self.__dict__["_set_centroid_true_course"] = _raise_uninitialized_error
        self.__dict__["_get_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_set_fly_cruise_airspeed_profile"] = _raise_uninitialized_error
        self.__dict__["_get_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_set_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_copy_procedures"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureAreaTargetSearch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureAreaTargetSearch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureAreaTargetSearch = agcom.GUID(IProcedureAreaTargetSearch._uuid)
        vtable_offset_local = IProcedureAreaTargetSearch._vtable_offset - 1
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_procedure_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_procedure_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_max_separation"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_separation"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_course_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_course_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_first_leg_retrograde"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_first_leg_retrograde"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_centroid_true_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_centroid_true_course"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_fly_cruise_airspeed_profile"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_copy_procedures"] = IAGFUNCTYPE(pUnk, IID_IProcedureAreaTargetSearch, vtable_offset_local+21, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureAreaTargetSearch.__dict__ and type(IProcedureAreaTargetSearch.__dict__[attrname]) == property:
            return IProcedureAreaTargetSearch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureAreaTargetSearch.")
    
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def altitude_options(self) -> "IAltitudeOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def procedure_type(self) -> "AVTR_FLIGHT_LINE_PROC_TYPE":
        """The procedure methodology used to calculate the flight line."""
        with agmarshall.AgEnum_arg(AVTR_FLIGHT_LINE_PROC_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_procedure_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @procedure_type.setter
    def procedure_type(self, newVal:"AVTR_FLIGHT_LINE_PROC_TYPE") -> None:
        """The procedure methodology used to calculate the flight line."""
        with agmarshall.AgEnum_arg(AVTR_FLIGHT_LINE_PROC_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_procedure_type"](arg_newVal.COM_val))

    @property
    def max_separation(self) -> float:
        """The maximum distance between the parallel flight lines of the search pattern."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_separation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_separation.setter
    def max_separation(self, newVal:float) -> None:
        """The maximum distance between the parallel flight lines of the search pattern."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_separation"](arg_newVal.COM_val))

    @property
    def course_mode(self) -> "AVTR_SEARCH_PATTERN_COURSE_MODE":
        """The mode to determine the course of the search pattern."""
        with agmarshall.AgEnum_arg(AVTR_SEARCH_PATTERN_COURSE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_course_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @course_mode.setter
    def course_mode(self, newVal:"AVTR_SEARCH_PATTERN_COURSE_MODE") -> None:
        """The mode to determine the course of the search pattern."""
        with agmarshall.AgEnum_arg(AVTR_SEARCH_PATTERN_COURSE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_course_mode"](arg_newVal.COM_val))

    @property
    def first_leg_retrograde(self) -> bool:
        """The option to fly the first leg of the search pattern on the reverse heading."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_first_leg_retrograde"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @first_leg_retrograde.setter
    def first_leg_retrograde(self, newVal:bool) -> None:
        """The option to fly the first leg of the search pattern on the reverse heading."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_first_leg_retrograde"](arg_newVal.COM_val))

    @property
    def centroid_true_course(self) -> typing.Any:
        """The specific course of the search pattern."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_centroid_true_course"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @centroid_true_course.setter
    def centroid_true_course(self, newVal:typing.Any) -> None:
        """The specific course of the search pattern."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_centroid_true_course"](arg_newVal.COM_val))

    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fly_cruise_airspeed_profile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, pVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_fly_cruise_airspeed_profile"](arg_pVal.COM_val))

    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_must_level_off"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_must_level_off"](arg_newVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, newVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_newVal.COM_val))

    def copy_procedures(self) -> None:
        """Copy the search pattern maneuvers as a set of procedures to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_procedures"]())


agcls.AgClassCatalog.add_catalog_entry("{ad0dc4ce-a6b1-499b-9a60-54dd5b6266ac}", IProcedureAreaTargetSearch)
agcls.AgTypeNameMap["IProcedureAreaTargetSearch"] = IProcedureAreaTargetSearch

class IProcedureFormationRecover(object):
    """Interface used to access the options for a Formation Recover procedure."""
    _uuid = "{d96375bc-d2b6-4397-81bc-35a923b5b883}"
    _num_methods = 38
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_delay_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_time"] = _raise_uninitialized_error
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_start_time"] = _raise_uninitialized_error
        self.__dict__["_find_first_valid_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_time"] = _raise_uninitialized_error
        self.__dict__["_get_formation_point"] = _raise_uninitialized_error
        self.__dict__["_set_formation_point"] = _raise_uninitialized_error
        self.__dict__["_get_interpolate_point_pos_vel"] = _raise_uninitialized_error
        self.__dict__["_set_interpolate_point_pos_vel"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_offset"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_get_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_set_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_get_consider_accel_for_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_consider_accel_for_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_first_pause"] = _raise_uninitialized_error
        self.__dict__["_set_first_pause"] = _raise_uninitialized_error
        self.__dict__["_get_transition_time"] = _raise_uninitialized_error
        self.__dict__["_set_transition_time"] = _raise_uninitialized_error
        self.__dict__["_get_second_pause"] = _raise_uninitialized_error
        self.__dict__["_set_second_pause"] = _raise_uninitialized_error
        self.__dict__["_get_display_step_time"] = _raise_uninitialized_error
        self.__dict__["_set_display_step_time"] = _raise_uninitialized_error
        self.__dict__["_get_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_set_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_get_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_set_radius_factor"] = _raise_uninitialized_error
        self.__dict__["_get_use_delay"] = _raise_uninitialized_error
        self.__dict__["_set_use_delay"] = _raise_uninitialized_error
        self.__dict__["_get_delay_turn_dir"] = _raise_uninitialized_error
        self.__dict__["_set_delay_turn_dir"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureFormationRecover._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFormationRecover from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureFormationRecover = agcom.GUID(IProcedureFormationRecover._uuid)
        vtable_offset_local = IProcedureFormationRecover._vtable_offset - 1
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_delay_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+4, agcom.VARIANT_BOOL, POINTER(agcom.VARIANT))
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_find_first_valid_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+7, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.VARIANT))
        self.__dict__["_get_maximum_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_get_formation_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_formation_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_interpolate_point_pos_vel"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_interpolate_point_pos_vel"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_consider_accel_for_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_consider_accel_for_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_get_first_pause"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+21, POINTER(agcom.VARIANT))
        self.__dict__["_set_first_pause"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+22, agcom.VARIANT)
        self.__dict__["_get_transition_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transition_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_second_pause"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+25, POINTER(agcom.VARIANT))
        self.__dict__["_set_second_pause"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+26, agcom.VARIANT)
        self.__dict__["_get_display_step_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_display_step_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+29, POINTER(agcom.LONG))
        self.__dict__["_set_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+30, agcom.LONG)
        self.__dict__["_get_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+31, POINTER(agcom.VARIANT))
        self.__dict__["_set_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+32, agcom.VARIANT)
        self.__dict__["_get_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_factor"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_get_use_delay"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+35, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_delay"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+36, agcom.VARIANT_BOOL)
        self.__dict__["_get_delay_turn_dir"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_set_delay_turn_dir"] = IAGFUNCTYPE(pUnk, IID_IProcedureFormationRecover, vtable_offset_local+38, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFormationRecover.__dict__ and type(IProcedureFormationRecover.__dict__[attrname]) == property:
            return IProcedureFormationRecover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFormationRecover.")
    
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def delay_cruise_airspeed_options(self) -> "ICruiseAirspeedOptions":
        """Get the delay cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_delay_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def get_minimum_time(self, considerPrevProc:bool) -> typing.Any:
        """Get the minimum time at which formation might be possible. Opt whether to consider previous procedure(s) for the minimum time."""
        with agmarshall.VARIANT_BOOL_arg(considerPrevProc) as arg_considerPrevProc, \
             agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_time"](arg_considerPrevProc.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def start_time(self) -> typing.Any:
        """The time at which the formation begins."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_time.setter
    def start_time(self, newVal:typing.Any) -> None:
        """The time at which the formation begins."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_time"](arg_newVal.COM_val))

    def find_first_valid_start_time(self, minTime:typing.Any, maxTime:typing.Any, stepTime:float) -> typing.Any:
        """Have Aviator calculate the earliest valid formation time."""
        with agmarshall.VARIANT_arg(minTime) as arg_minTime, \
             agmarshall.VARIANT_arg(maxTime) as arg_maxTime, \
             agmarshall.DOUBLE_arg(stepTime) as arg_stepTime, \
             agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_find_first_valid_start_time"](arg_minTime.COM_val, arg_maxTime.COM_val, arg_stepTime.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def maximum_time(self) -> typing.Any:
        """The maximum time at which formation might be possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def formation_point(self) -> str:
        """The position that the aircraft will be locked onto while in formation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_formation_point"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @formation_point.setter
    def formation_point(self, newVal:str) -> None:
        """The position that the aircraft will be locked onto while in formation."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_formation_point"](arg_newVal.COM_val))

    @property
    def interpolate_point_pos_vel(self) -> bool:
        """The option to use interpolation to determine the formation point's speed and position."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interpolate_point_pos_vel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @interpolate_point_pos_vel.setter
    def interpolate_point_pos_vel(self, newVal:bool) -> None:
        """The option to use interpolation to determine the formation point's speed and position."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_interpolate_point_pos_vel"](arg_newVal.COM_val))

    @property
    def altitude_offset(self) -> float:
        """The altitude distance between the aircraft and the formation point during the first or second pause."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The altitude distance between the aircraft and the formation point during the first or second pause."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_offset"](arg_newVal.COM_val))

    @property
    def fuel_flow_type(self) -> "AVTR_FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"AVTR_FUEL_FLOW_TYPE") -> None:
        """The source used to calculate the fuel flow for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow_type"](arg_newVal.COM_val))

    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_fuel_flow_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_fuel_flow_value"](arg_newVal.COM_val))

    @property
    def consider_accel_for_fuel_flow(self) -> bool:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_consider_accel_for_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @consider_accel_for_fuel_flow.setter
    def consider_accel_for_fuel_flow(self, newVal:bool) -> None:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_consider_accel_for_fuel_flow"](arg_newVal.COM_val))

    @property
    def first_pause(self) -> typing.Any:
        """The amount of time that the aircraft will pause at the specified altitude offset."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_first_pause"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @first_pause.setter
    def first_pause(self, newVal:typing.Any) -> None:
        """The amount of time that the aircraft will pause at the specified altitude offset."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_first_pause"](arg_newVal.COM_val))

    @property
    def transition_time(self) -> float:
        """The amount of time that the aircraft will spend transitioning from the specified altitude offset to a zero altitude offset."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transition_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transition_time.setter
    def transition_time(self, newVal:float) -> None:
        """The amount of time that the aircraft will spend transitioning from the specified altitude offset to a zero altitude offset."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transition_time"](arg_newVal.COM_val))

    @property
    def second_pause(self) -> typing.Any:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_second_pause"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @second_pause.setter
    def second_pause(self, newVal:typing.Any) -> None:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_second_pause"](arg_newVal.COM_val))

    @property
    def display_step_time(self) -> float:
        """The time interval at which ephemeris is generated for display purposes."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_step_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @display_step_time.setter
    def display_step_time(self, newVal:float) -> None:
        """The time interval at which ephemeris is generated for display purposes."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_display_step_time"](arg_newVal.COM_val))

    @property
    def flight_mode(self) -> "AVTR_PHASE_OF_FLIGHT":
        """The type of performance model that the aircraft will use to fly the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_mode.setter
    def flight_mode(self, newVal:"AVTR_PHASE_OF_FLIGHT") -> None:
        """The type of performance model that the aircraft will use to fly the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_mode"](arg_newVal.COM_val))

    @property
    def flight_path_angle(self) -> typing.Any:
        """The flight path angle at the beginning of the first pause."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The flight path angle at the beginning of the first pause."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_path_angle"](arg_newVal.COM_val))

    @property
    def radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_factor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_factor"](arg_newVal.COM_val))

    @property
    def use_delay(self) -> bool:
        """The option to insert a delay at the beginning of the procedure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_delay"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_delay.setter
    def use_delay(self, newVal:bool) -> None:
        """The option to insert a delay at the beginning of the procedure."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_delay"](arg_newVal.COM_val))

    @property
    def delay_turn_dir(self) -> "AVTR_DELAY_TURN_DIR":
        """The turn direction of the delay."""
        with agmarshall.AgEnum_arg(AVTR_DELAY_TURN_DIR) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delay_turn_dir"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delay_turn_dir.setter
    def delay_turn_dir(self, newVal:"AVTR_DELAY_TURN_DIR") -> None:
        """The turn direction of the delay."""
        with agmarshall.AgEnum_arg(AVTR_DELAY_TURN_DIR, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delay_turn_dir"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{d96375bc-d2b6-4397-81bc-35a923b5b883}", IProcedureFormationRecover)
agcls.AgTypeNameMap["IProcedureFormationRecover"] = IProcedureFormationRecover

class IProcedureInFormation(object):
    """Interface used to access the options for an In Formation procedure."""
    _uuid = "{7d5aa09b-b2d4-4984-b930-f4b55acf3219}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_set_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_get_formation_point"] = _raise_uninitialized_error
        self.__dict__["_set_formation_point"] = _raise_uninitialized_error
        self.__dict__["_get_transition_time"] = _raise_uninitialized_error
        self.__dict__["_set_transition_time"] = _raise_uninitialized_error
        self.__dict__["_get_hold_time"] = _raise_uninitialized_error
        self.__dict__["_set_hold_time"] = _raise_uninitialized_error
        self.__dict__["_get_display_step_time"] = _raise_uninitialized_error
        self.__dict__["_set_display_step_time"] = _raise_uninitialized_error
        self.__dict__["_get_trajectory_blending"] = _raise_uninitialized_error
        self.__dict__["_set_trajectory_blending"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_get_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_set_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_get_consider_accel_for_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_consider_accel_for_fuel_flow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureInFormation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureInFormation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureInFormation = agcom.GUID(IProcedureInFormation._uuid)
        vtable_offset_local = IProcedureInFormation._vtable_offset - 1
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_set_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_formation_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_set_formation_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+5, agcom.BSTR)
        self.__dict__["_get_transition_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_transition_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_hold_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_hold_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_display_step_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_display_step_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_trajectory_blending"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_trajectory_blending"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_get_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_consider_accel_for_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_consider_accel_for_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureInFormation, vtable_offset_local+19, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureInFormation.__dict__ and type(IProcedureInFormation.__dict__[attrname]) == property:
            return IProcedureInFormation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureInFormation.")
    
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def flight_mode(self) -> "AVTR_PHASE_OF_FLIGHT":
        """The type of performance model that the aircraft will use to fly the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_mode.setter
    def flight_mode(self, newVal:"AVTR_PHASE_OF_FLIGHT") -> None:
        """The type of performance model that the aircraft will use to fly the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_mode"](arg_newVal.COM_val))

    @property
    def formation_point(self) -> str:
        """The position that the aircraft will be locked onto while in formation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_formation_point"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @formation_point.setter
    def formation_point(self, newVal:str) -> None:
        """The position that the aircraft will be locked onto while in formation."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_formation_point"](arg_newVal.COM_val))

    @property
    def transition_time(self) -> float:
        """The amount of time that the aircraft will spend transitioning from the altitude offset to a zero altitude offset."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_transition_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @transition_time.setter
    def transition_time(self, newVal:float) -> None:
        """The amount of time that the aircraft will spend transitioning from the altitude offset to a zero altitude offset."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_transition_time"](arg_newVal.COM_val))

    @property
    def hold_time(self) -> typing.Any:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hold_time.setter
    def hold_time(self, newVal:typing.Any) -> None:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_time"](arg_newVal.COM_val))

    @property
    def display_step_time(self) -> float:
        """The time interval at which ephemeris is generated for display purposes."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_step_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @display_step_time.setter
    def display_step_time(self, newVal:float) -> None:
        """The time interval at which ephemeris is generated for display purposes."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_display_step_time"](arg_newVal.COM_val))

    @property
    def trajectory_blending(self) -> "AVTR_TRAJECTORY_BLEND_MODE":
        """The interpolation mode to determine the aircraft's position and velocity."""
        with agmarshall.AgEnum_arg(AVTR_TRAJECTORY_BLEND_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_trajectory_blending"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @trajectory_blending.setter
    def trajectory_blending(self, newVal:"AVTR_TRAJECTORY_BLEND_MODE") -> None:
        """The interpolation mode to determine the aircraft's position and velocity."""
        with agmarshall.AgEnum_arg(AVTR_TRAJECTORY_BLEND_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_trajectory_blending"](arg_newVal.COM_val))

    @property
    def fuel_flow_type(self) -> "AVTR_FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"AVTR_FUEL_FLOW_TYPE") -> None:
        """The source used to calculate the fuel flow for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow_type"](arg_newVal.COM_val))

    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_fuel_flow_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_fuel_flow_value"](arg_newVal.COM_val))

    @property
    def consider_accel_for_fuel_flow(self) -> bool:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_consider_accel_for_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @consider_accel_for_fuel_flow.setter
    def consider_accel_for_fuel_flow(self, newVal:bool) -> None:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_consider_accel_for_fuel_flow"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7d5aa09b-b2d4-4984-b930-f4b55acf3219}", IProcedureInFormation)
agcls.AgTypeNameMap["IProcedureInFormation"] = IProcedureInFormation

class IProcedureParallelFlightLine(object):
    """Interface used to access the options for a Parallel Flight Line procedure."""
    _uuid = "{4c911a89-bad8-457e-9dca-64c1adf59603}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_altitude_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_cruise_airspeed_options"] = _raise_uninitialized_error
        self.__dict__["_get_enroute_turn_direction_options"] = _raise_uninitialized_error
        self.__dict__["_get_procedure_type"] = _raise_uninitialized_error
        self.__dict__["_set_procedure_type"] = _raise_uninitialized_error
        self.__dict__["_get_orientation"] = _raise_uninitialized_error
        self.__dict__["_set_orientation"] = _raise_uninitialized_error
        self.__dict__["_get_separation"] = _raise_uninitialized_error
        self.__dict__["_set_separation"] = _raise_uninitialized_error
        self.__dict__["_get_offset"] = _raise_uninitialized_error
        self.__dict__["_set_offset"] = _raise_uninitialized_error
        self.__dict__["_get_leg_length"] = _raise_uninitialized_error
        self.__dict__["_set_leg_length"] = _raise_uninitialized_error
        self.__dict__["_get_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_set_must_level_off"] = _raise_uninitialized_error
        self.__dict__["_get_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_set_level_off_mode"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureParallelFlightLine._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureParallelFlightLine from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureParallelFlightLine = agcom.GUID(IProcedureParallelFlightLine._uuid)
        vtable_offset_local = IProcedureParallelFlightLine._vtable_offset - 1
        self.__dict__["_get_altitude_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_cruise_airspeed_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_enroute_turn_direction_options"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_procedure_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_procedure_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_orientation"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_orientation"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_separation"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_separation"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_offset"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_leg_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_leg_length"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_must_level_off"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_level_off_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureParallelFlightLine, vtable_offset_local+19, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureParallelFlightLine.__dict__ and type(IProcedureParallelFlightLine.__dict__[attrname]) == property:
            return IProcedureParallelFlightLine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureParallelFlightLine.")
    
    @property
    def altitude_options(self) -> "IAltitudeOptions":
        """Get the altitude options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_options(self) -> "IEnrouteOptions":
        """Get the enroute options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedAndProfileOptions":
        """Get the enroute cruise airspeed options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_cruise_airspeed_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def enroute_turn_direction_options(self) -> "IEnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_enroute_turn_direction_options"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def procedure_type(self) -> "AVTR_FLIGHT_LINE_PROC_TYPE":
        """The procedure methodology used to calculate the flight line."""
        with agmarshall.AgEnum_arg(AVTR_FLIGHT_LINE_PROC_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_procedure_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @procedure_type.setter
    def procedure_type(self, newVal:"AVTR_FLIGHT_LINE_PROC_TYPE") -> None:
        """The procedure methodology used to calculate the flight line."""
        with agmarshall.AgEnum_arg(AVTR_FLIGHT_LINE_PROC_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_procedure_type"](arg_newVal.COM_val))

    @property
    def orientation(self) -> "AVTR_LINE_ORIENTATION":
        """The placement of the procedure with respect to the previous flight line."""
        with agmarshall.AgEnum_arg(AVTR_LINE_ORIENTATION) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orientation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orientation.setter
    def orientation(self, newVal:"AVTR_LINE_ORIENTATION") -> None:
        """The placement of the procedure with respect to the previous flight line."""
        with agmarshall.AgEnum_arg(AVTR_LINE_ORIENTATION, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_orientation"](arg_newVal.COM_val))

    @property
    def separation(self) -> float:
        """The distance between the flight line and the previous flight line."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_separation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @separation.setter
    def separation(self, newVal:float) -> None:
        """The distance between the flight line and the previous flight line."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_separation"](arg_newVal.COM_val))

    @property
    def offset(self) -> float:
        """The distance from the end of the previous procedure to the beginning of the flight line."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @offset.setter
    def offset(self, newVal:float) -> None:
        """The distance from the end of the previous procedure to the beginning of the flight line."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_offset"](arg_newVal.COM_val))

    @property
    def leg_length(self) -> float:
        """The length of the flight line."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_leg_length"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @leg_length.setter
    def leg_length(self, newVal:float) -> None:
        """The length of the flight line."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_leg_length"](arg_newVal.COM_val))

    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_must_level_off"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_must_level_off"](arg_newVal.COM_val))

    @property
    def level_off_mode(self) -> "AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_level_off_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @level_off_mode.setter
    def level_off_mode(self, newVal:"AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_CONSTRAINT_MANEUVER_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_level_off_mode"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{4c911a89-bad8-457e-9dca-64c1adf59603}", IProcedureParallelFlightLine)
agcls.AgTypeNameMap["IProcedureParallelFlightLine"] = IProcedureParallelFlightLine

class IProcedureVGTPoint(object):
    """Interface used to access the options for a VGT Point procedure."""
    _uuid = "{36159f4d-5c80-4a49-bdf8-ccfdda28100b}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        self.__dict__["_get_minimum_time"] = _raise_uninitialized_error
        self.__dict__["_get_start_time"] = _raise_uninitialized_error
        self.__dict__["_set_start_time"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_time"] = _raise_uninitialized_error
        self.__dict__["_get_formation_point"] = _raise_uninitialized_error
        self.__dict__["_set_formation_point"] = _raise_uninitialized_error
        self.__dict__["_get_interpolate_point_pos_vel"] = _raise_uninitialized_error
        self.__dict__["_set_interpolate_point_pos_vel"] = _raise_uninitialized_error
        self.__dict__["_get_duration"] = _raise_uninitialized_error
        self.__dict__["_set_duration"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_point_stop_time"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_point_stop_time"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_get_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_set_override_fuel_flow_value"] = _raise_uninitialized_error
        self.__dict__["_get_consider_accel_for_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_consider_accel_for_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_set_flight_mode"] = _raise_uninitialized_error
        self.__dict__["_get_display_step_time"] = _raise_uninitialized_error
        self.__dict__["_set_display_step_time"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureVGTPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureVGTPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureVGTPoint = agcom.GUID(IProcedureVGTPoint._uuid)
        vtable_offset_local = IProcedureVGTPoint._vtable_offset - 1
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_minimum_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_get_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_start_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_maximum_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_formation_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_set_formation_point"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_get_interpolate_point_pos_vel"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_interpolate_point_pos_vel"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_duration"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_duration"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_use_max_point_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_point_stop_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_get_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_get_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_fuel_flow_value"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_consider_accel_for_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_consider_accel_for_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_flight_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_display_step_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_display_step_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureVGTPoint, vtable_offset_local+23, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureVGTPoint.__dict__ and type(IProcedureVGTPoint.__dict__[attrname]) == property:
            return IProcedureVGTPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureVGTPoint.")
    
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val

    @property
    def minimum_time(self) -> typing.Any:
        """The minimum time at which formation might be possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_minimum_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def start_time(self) -> typing.Any:
        """The time at which the formation begins."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_start_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @start_time.setter
    def start_time(self, newVal:typing.Any) -> None:
        """The time at which the formation begins."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_start_time"](arg_newVal.COM_val))

    @property
    def maximum_time(self) -> typing.Any:
        """The maximum time at which formation might be possible."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def formation_point(self) -> str:
        """The position that the aircraft will be locked onto while in formation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_formation_point"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @formation_point.setter
    def formation_point(self, newVal:str) -> None:
        """The position that the aircraft will be locked onto while in formation."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_formation_point"](arg_newVal.COM_val))

    @property
    def interpolate_point_pos_vel(self) -> bool:
        """The option to use interpolation to determine the formation point's speed and position."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interpolate_point_pos_vel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @interpolate_point_pos_vel.setter
    def interpolate_point_pos_vel(self, newVal:bool) -> None:
        """The option to use interpolation to determine the formation point's speed and position."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_interpolate_point_pos_vel"](arg_newVal.COM_val))

    @property
    def duration(self) -> float:
        """The duration of the procedure."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_duration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @duration.setter
    def duration(self, newVal:float) -> None:
        """The duration of the procedure."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_duration"](arg_newVal.COM_val))

    @property
    def use_max_point_stop_time(self) -> bool:
        """Opt to limit the duration to the maximum possible time if the duration exceeds the time limit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_point_stop_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_point_stop_time.setter
    def use_max_point_stop_time(self, newVal:bool) -> None:
        """Opt to limit the duration to the maximum possible time if the duration exceeds the time limit."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_point_stop_time"](arg_newVal.COM_val))

    @property
    def fuel_flow_type(self) -> "AVTR_FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"AVTR_FUEL_FLOW_TYPE") -> None:
        """The source used to calculate the fuel flow for the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow_type"](arg_newVal.COM_val))

    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_fuel_flow_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_fuel_flow_value"](arg_newVal.COM_val))

    @property
    def consider_accel_for_fuel_flow(self) -> bool:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_consider_accel_for_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @consider_accel_for_fuel_flow.setter
    def consider_accel_for_fuel_flow(self, newVal:bool) -> None:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_consider_accel_for_fuel_flow"](arg_newVal.COM_val))

    @property
    def flight_mode(self) -> "AVTR_PHASE_OF_FLIGHT":
        """The type of performance model that the aircraft will use to fly the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flight_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @flight_mode.setter
    def flight_mode(self, newVal:"AVTR_PHASE_OF_FLIGHT") -> None:
        """The type of performance model that the aircraft will use to fly the maneuver."""
        with agmarshall.AgEnum_arg(AVTR_PHASE_OF_FLIGHT, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_flight_mode"](arg_newVal.COM_val))

    @property
    def display_step_time(self) -> float:
        """The time interval at which ephemeris is generated for display purposes."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_step_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @display_step_time.setter
    def display_step_time(self, newVal:float) -> None:
        """The time interval at which ephemeris is generated for display purposes."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_display_step_time"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{36159f4d-5c80-4a49-bdf8-ccfdda28100b}", IProcedureVGTPoint)
agcls.AgTypeNameMap["IProcedureVGTPoint"] = IProcedureVGTPoint

class ISiteRunwayFromCatalog(object):
    """Interface used to access the options for a Runway From Catalog site type."""
    _uuid = "{56a06eb2-be85-4e31-b850-7c0485566739}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_catalog_runway"] = _raise_uninitialized_error
        self.__dict__["_set_catalog_runway"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteRunwayFromCatalog._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteRunwayFromCatalog from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteRunwayFromCatalog = agcom.GUID(ISiteRunwayFromCatalog._uuid)
        vtable_offset_local = ISiteRunwayFromCatalog._vtable_offset - 1
        self.__dict__["_get_catalog_runway"] = IAGFUNCTYPE(pUnk, IID_ISiteRunwayFromCatalog, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_catalog_runway"] = IAGFUNCTYPE(pUnk, IID_ISiteRunwayFromCatalog, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteRunwayFromCatalog, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRunwayFromCatalog.__dict__ and type(ISiteRunwayFromCatalog.__dict__[attrname]) == property:
            return ISiteRunwayFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRunwayFromCatalog.")
    
    def get_catalog_runway(self) -> "ICatalogRunway":
        """Get the catalog runway."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_catalog_runway"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def set_catalog_runway(self, pVal:"ICatalogRunway") -> None:
        """Set the catalog runway."""
        with agmarshall.AgInterface_in_arg(pVal, ICatalogRunway) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_catalog_runway"](arg_pVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{56a06eb2-be85-4e31-b850-7c0485566739}", ISiteRunwayFromCatalog)
agcls.AgTypeNameMap["ISiteRunwayFromCatalog"] = ISiteRunwayFromCatalog

class ISiteAirportFromCatalog(object):
    """Interface used to access the options for a airport From Catalog site type."""
    _uuid = "{8cf3e110-d619-4769-894a-b23cb32baa7f}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_catalog_airport"] = _raise_uninitialized_error
        self.__dict__["_set_catalog_airport"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteAirportFromCatalog._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteAirportFromCatalog from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteAirportFromCatalog = agcom.GUID(ISiteAirportFromCatalog._uuid)
        vtable_offset_local = ISiteAirportFromCatalog._vtable_offset - 1
        self.__dict__["_get_catalog_airport"] = IAGFUNCTYPE(pUnk, IID_ISiteAirportFromCatalog, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_catalog_airport"] = IAGFUNCTYPE(pUnk, IID_ISiteAirportFromCatalog, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteAirportFromCatalog, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteAirportFromCatalog.__dict__ and type(ISiteAirportFromCatalog.__dict__[attrname]) == property:
            return ISiteAirportFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteAirportFromCatalog.")
    
    def get_catalog_airport(self) -> "ICatalogAirport":
        """Get the catalog airport."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_catalog_airport"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def set_catalog_airport(self, pVal:"ICatalogAirport") -> None:
        """Set the catalog airport."""
        with agmarshall.AgInterface_in_arg(pVal, ICatalogAirport) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_catalog_airport"](arg_pVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{8cf3e110-d619-4769-894a-b23cb32baa7f}", ISiteAirportFromCatalog)
agcls.AgTypeNameMap["ISiteAirportFromCatalog"] = ISiteAirportFromCatalog

class ISiteNavaidFromCatalog(object):
    """Interface used to access the options for a navaid From Catalog site type."""
    _uuid = "{960e8584-5349-44cc-8b49-9a00c209f9a5}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_catalog_navaid"] = _raise_uninitialized_error
        self.__dict__["_set_catalog_navaid"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteNavaidFromCatalog._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteNavaidFromCatalog from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteNavaidFromCatalog = agcom.GUID(ISiteNavaidFromCatalog._uuid)
        vtable_offset_local = ISiteNavaidFromCatalog._vtable_offset - 1
        self.__dict__["_get_catalog_navaid"] = IAGFUNCTYPE(pUnk, IID_ISiteNavaidFromCatalog, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_catalog_navaid"] = IAGFUNCTYPE(pUnk, IID_ISiteNavaidFromCatalog, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteNavaidFromCatalog, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteNavaidFromCatalog.__dict__ and type(ISiteNavaidFromCatalog.__dict__[attrname]) == property:
            return ISiteNavaidFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteNavaidFromCatalog.")
    
    def get_catalog_navaid(self) -> "ICatalogNavaid":
        """Get the catalog navaid."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_catalog_navaid"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def set_catalog_navaid(self, pVal:"ICatalogNavaid") -> None:
        """Set the catalog navaid."""
        with agmarshall.AgInterface_in_arg(pVal, ICatalogNavaid) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_catalog_navaid"](arg_pVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{960e8584-5349-44cc-8b49-9a00c209f9a5}", ISiteNavaidFromCatalog)
agcls.AgTypeNameMap["ISiteNavaidFromCatalog"] = ISiteNavaidFromCatalog

class ISiteVTOLPointFromCatalog(object):
    """Interface used to access the options for a VTOL Point From Catalog site type."""
    _uuid = "{f0556822-9ba9-45ca-9cd2-e965d442d997}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_catalog_vtol_point"] = _raise_uninitialized_error
        self.__dict__["_set_catalog_vtol_point"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteVTOLPointFromCatalog._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteVTOLPointFromCatalog from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteVTOLPointFromCatalog = agcom.GUID(ISiteVTOLPointFromCatalog._uuid)
        vtable_offset_local = ISiteVTOLPointFromCatalog._vtable_offset - 1
        self.__dict__["_get_catalog_vtol_point"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPointFromCatalog, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_catalog_vtol_point"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPointFromCatalog, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteVTOLPointFromCatalog, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteVTOLPointFromCatalog.__dict__ and type(ISiteVTOLPointFromCatalog.__dict__[attrname]) == property:
            return ISiteVTOLPointFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteVTOLPointFromCatalog.")
    
    def get_catalog_vtol_point(self) -> "ICatalogVTOLPoint":
        """Get the catalog VTOL point."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_catalog_vtol_point"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def set_catalog_vtol_point(self, pVal:"ICatalogVTOLPoint") -> None:
        """Set the catalog VTOL point."""
        with agmarshall.AgInterface_in_arg(pVal, ICatalogVTOLPoint) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_catalog_vtol_point"](arg_pVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{f0556822-9ba9-45ca-9cd2-e965d442d997}", ISiteVTOLPointFromCatalog)
agcls.AgTypeNameMap["ISiteVTOLPointFromCatalog"] = ISiteVTOLPointFromCatalog

class ISiteWaypointFromCatalog(object):
    """Interface used to access the options for a waypoint From Catalog site type."""
    _uuid = "{89b1a048-7b22-45ab-bd5c-34584de7b2b7}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_catalog_waypoint"] = _raise_uninitialized_error
        self.__dict__["_set_catalog_waypoint"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteWaypointFromCatalog._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteWaypointFromCatalog from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteWaypointFromCatalog = agcom.GUID(ISiteWaypointFromCatalog._uuid)
        vtable_offset_local = ISiteWaypointFromCatalog._vtable_offset - 1
        self.__dict__["_get_catalog_waypoint"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypointFromCatalog, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_catalog_waypoint"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypointFromCatalog, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteWaypointFromCatalog, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteWaypointFromCatalog.__dict__ and type(ISiteWaypointFromCatalog.__dict__[attrname]) == property:
            return ISiteWaypointFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteWaypointFromCatalog.")
    
    def get_catalog_waypoint(self) -> "ICatalogWaypoint":
        """Get the catalog waypoint."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_catalog_waypoint"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    def set_catalog_waypoint(self, pVal:"ICatalogWaypoint") -> None:
        """Set the catalog waypoint."""
        with agmarshall.AgInterface_in_arg(pVal, ICatalogWaypoint) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_catalog_waypoint"](arg_pVal.COM_val))

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{89b1a048-7b22-45ab-bd5c-34584de7b2b7}", ISiteWaypointFromCatalog)
agcls.AgTypeNameMap["ISiteWaypointFromCatalog"] = ISiteWaypointFromCatalog

class IProcedureLaunchDynState(object):
    """Interface used to access the options for a dyn state launch procedure."""
    _uuid = "{BC0541E2-248E-4B42-8A7F-E9C411E40073}"
    _num_methods = 26
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_launch_time"] = _raise_uninitialized_error
        self.__dict__["_set_launch_time"] = _raise_uninitialized_error
        self.__dict__["_get_coord_frame"] = _raise_uninitialized_error
        self.__dict__["_set_coord_frame"] = _raise_uninitialized_error
        self.__dict__["_get_bearing_ref"] = _raise_uninitialized_error
        self.__dict__["_set_bearing_ref"] = _raise_uninitialized_error
        self.__dict__["_get_launch_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_launch_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_launch_elevation"] = _raise_uninitialized_error
        self.__dict__["_set_launch_elevation"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_mode"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_mode"] = _raise_uninitialized_error
        self.__dict__["_get_specify_launch_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_specify_launch_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_accel_g"] = _raise_uninitialized_error
        self.__dict__["_set_accel_g"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_get_override_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_override_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_true_course_hint"] = _raise_uninitialized_error
        self.__dict__["_set_true_course_hint"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureLaunchDynState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLaunchDynState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureLaunchDynState = agcom.GUID(IProcedureLaunchDynState._uuid)
        vtable_offset_local = IProcedureLaunchDynState._vtable_offset - 1
        self.__dict__["_get_launch_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_launch_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_coord_frame"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_coord_frame"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_bearing_ref"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_bearing_ref"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_launch_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_launch_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_launch_elevation"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_launch_elevation"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_attitude_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_mode"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_specify_launch_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_specify_launch_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_accel_g"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_g"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+19, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_override_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_get_true_course_hint"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+24, POINTER(agcom.VARIANT))
        self.__dict__["_set_true_course_hint"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+25, agcom.VARIANT)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchDynState, vtable_offset_local+26, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLaunchDynState.__dict__ and type(IProcedureLaunchDynState.__dict__[attrname]) == property:
            return IProcedureLaunchDynState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLaunchDynState.")
    
    @property
    def launch_time(self) -> typing.Any:
        """The launch time of the aircraft."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_time.setter
    def launch_time(self, newVal:typing.Any) -> None:
        """The launch time of the aircraft."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_time"](arg_newVal.COM_val))

    @property
    def coord_frame(self) -> "AVTR_LAUNCH_DYN_STATE_COORD_FRAME":
        """The reference coordinate frame for the dyn state launch procedure."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_DYN_STATE_COORD_FRAME) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_frame"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_frame.setter
    def coord_frame(self, pVal:"AVTR_LAUNCH_DYN_STATE_COORD_FRAME") -> None:
        """The reference coordinate frame for the dyn state launch procedure."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_DYN_STATE_COORD_FRAME, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_frame"](arg_pVal.COM_val))

    @property
    def bearing_ref(self) -> "AVTR_LAUNCH_DYN_STATE_BEARING_REF":
        """The bearing reference for the dyn state launch procedure."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_DYN_STATE_BEARING_REF) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bearing_ref"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bearing_ref.setter
    def bearing_ref(self, pVal:"AVTR_LAUNCH_DYN_STATE_BEARING_REF") -> None:
        """The bearing reference for the dyn state launch procedure."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_DYN_STATE_BEARING_REF, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_bearing_ref"](arg_pVal.COM_val))

    @property
    def launch_bearing(self) -> typing.Any:
        """The launch direction bearing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_bearing.setter
    def launch_bearing(self, newVal:typing.Any) -> None:
        """The launch direction bearing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_bearing"](arg_newVal.COM_val))

    @property
    def launch_elevation(self) -> typing.Any:
        """The launch direction elevation."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_elevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_elevation.setter
    def launch_elevation(self, newVal:typing.Any) -> None:
        """The launch direction elevation."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_elevation"](arg_newVal.COM_val))

    @property
    def attitude_mode(self) -> "AVTR_LAUNCH_ATTITUDE_MODE":
        """The attitude mode during the launch."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_ATTITUDE_MODE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attitude_mode.setter
    def attitude_mode(self, newVal:"AVTR_LAUNCH_ATTITUDE_MODE") -> None:
        """The attitude mode during the launch."""
        with agmarshall.AgEnum_arg(AVTR_LAUNCH_ATTITUDE_MODE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_mode"](arg_newVal.COM_val))

    @property
    def specify_launch_airspeed(self) -> bool:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_specify_launch_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @specify_launch_airspeed.setter
    def specify_launch_airspeed(self, newVal:bool) -> None:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_specify_launch_airspeed"](arg_newVal.COM_val))

    @property
    def accel_g(self) -> float:
        """The acceleration of the aircraft during the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The acceleration of the aircraft during the launch."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_g"](arg_newVal.COM_val))

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def fuel_flow_type(self) -> "AVTR_FUEL_FLOW_TYPE":
        """The fuel flow type of the aircraft during the launch."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"AVTR_FUEL_FLOW_TYPE") -> None:
        """The fuel flow type of the aircraft during the launch."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow_type"](arg_newVal.COM_val))

    @property
    def override_fuel_flow(self) -> float:
        """The fuel flow value for a fuel flow type set to Override."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_fuel_flow.setter
    def override_fuel_flow(self, newVal:float) -> None:
        """The fuel flow value for a fuel flow type set to Override."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_fuel_flow"](arg_newVal.COM_val))

    @property
    def true_course_hint(self) -> typing.Any:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_true_course_hint"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @true_course_hint.setter
    def true_course_hint(self, newVal:typing.Any) -> None:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_true_course_hint"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{BC0541E2-248E-4B42-8A7F-E9C411E40073}", IProcedureLaunchDynState)
agcls.AgTypeNameMap["IProcedureLaunchDynState"] = IProcedureLaunchDynState

class IProcedureLaunchWaypoint(object):
    """Interface used to access the options for a waypoint launch procedure."""
    _uuid = "{6154839D-55D1-4A31-9B03-330411C54D24}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_launch_time"] = _raise_uninitialized_error
        self.__dict__["_set_launch_time"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_ref"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_ref"] = _raise_uninitialized_error
        self.__dict__["_get_launch_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_launch_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_launch_true_bearing"] = _raise_uninitialized_error
        self.__dict__["_set_launch_true_bearing"] = _raise_uninitialized_error
        self.__dict__["_get_launch_elevation"] = _raise_uninitialized_error
        self.__dict__["_set_launch_elevation"] = _raise_uninitialized_error
        self.__dict__["_get_accel_g"] = _raise_uninitialized_error
        self.__dict__["_set_accel_g"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed_type"] = _raise_uninitialized_error
        self.__dict__["_get_airspeed"] = _raise_uninitialized_error
        self.__dict__["_set_airspeed"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_flow_type"] = _raise_uninitialized_error
        self.__dict__["_get_override_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_set_override_fuel_flow"] = _raise_uninitialized_error
        self.__dict__["_get_as_procedure"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProcedureLaunchWaypoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLaunchWaypoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProcedureLaunchWaypoint = agcom.GUID(IProcedureLaunchWaypoint._uuid)
        vtable_offset_local = IProcedureLaunchWaypoint._vtable_offset - 1
        self.__dict__["_get_launch_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_launch_time"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_altitude_ref"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_altitude_ref"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_launch_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_launch_altitude"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_launch_true_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_launch_true_bearing"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_launch_elevation"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_launch_elevation"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_accel_g"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_accel_g"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_airspeed_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_get_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_airspeed"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+15, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_set_fuel_flow_type"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_get_override_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_override_fuel_flow"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_as_procedure"] = IAGFUNCTYPE(pUnk, IID_IProcedureLaunchWaypoint, vtable_offset_local+20, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLaunchWaypoint.__dict__ and type(IProcedureLaunchWaypoint.__dict__[attrname]) == property:
            return IProcedureLaunchWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLaunchWaypoint.")
    
    @property
    def launch_time(self) -> typing.Any:
        """The launch time of the aircraft."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_time.setter
    def launch_time(self, newVal:typing.Any) -> None:
        """The launch time of the aircraft."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_time"](arg_newVal.COM_val))

    @property
    def altitude_ref(self) -> "AVTR_ALTITUDE_REF":
        """The launch altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_REF) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_ref"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_ref.setter
    def altitude_ref(self, newVal:"AVTR_ALTITUDE_REF") -> None:
        """The launch altitude reference."""
        with agmarshall.AgEnum_arg(AVTR_ALTITUDE_REF, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_ref"](arg_newVal.COM_val))

    @property
    def launch_altitude(self) -> float:
        """The launch altitude."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_altitude.setter
    def launch_altitude(self, newVal:float) -> None:
        """The launch altitude."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_altitude"](arg_newVal.COM_val))

    @property
    def launch_true_bearing(self) -> typing.Any:
        """The launch direction bearing."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_true_bearing"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_true_bearing.setter
    def launch_true_bearing(self, newVal:typing.Any) -> None:
        """The launch direction bearing."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_true_bearing"](arg_newVal.COM_val))

    @property
    def launch_elevation(self) -> typing.Any:
        """The launch direction elevation."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_launch_elevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @launch_elevation.setter
    def launch_elevation(self, newVal:typing.Any) -> None:
        """The launch direction elevation."""
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_launch_elevation"](arg_newVal.COM_val))

    @property
    def accel_g(self) -> float:
        """The acceleration of the aircraft during the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_accel_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The acceleration of the aircraft during the launch."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_accel_g"](arg_newVal.COM_val))

    @property
    def airspeed_type(self) -> "AVTR_AIRSPEED_TYPE":
        """The airspeed type."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_airspeed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_airspeed(self, airspeedType:"AVTR_AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        with agmarshall.AgEnum_arg(AVTR_AIRSPEED_TYPE, airspeedType) as arg_airspeedType, \
             agmarshall.DOUBLE_arg(airspeed) as arg_airspeed:
            agcls.evaluate_hresult(self.__dict__["_set_airspeed"](arg_airspeedType.COM_val, arg_airspeed.COM_val))

    @property
    def fuel_flow_type(self) -> "AVTR_FUEL_FLOW_TYPE":
        """The fuel flow type of the aircraft during the launch."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_flow_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"AVTR_FUEL_FLOW_TYPE") -> None:
        """The fuel flow type of the aircraft during the launch."""
        with agmarshall.AgEnum_arg(AVTR_FUEL_FLOW_TYPE, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_flow_type"](arg_newVal.COM_val))

    @property
    def override_fuel_flow(self) -> float:
        """The fuel flow value for a fuel flow type set to Override."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_fuel_flow"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_fuel_flow.setter
    def override_fuel_flow(self, newVal:float) -> None:
        """The fuel flow value for a fuel flow type set to Override."""
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_fuel_flow"](arg_newVal.COM_val))

    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppProcedure:
            agcls.evaluate_hresult(self.__dict__["_get_as_procedure"](byref(arg_ppProcedure.COM_val)))
            return arg_ppProcedure.python_val


agcls.AgClassCatalog.add_catalog_entry("{6154839D-55D1-4A31-9B03-330411C54D24}", IProcedureLaunchWaypoint)
agcls.AgTypeNameMap["IProcedureLaunchWaypoint"] = IProcedureLaunchWaypoint

class ISiteDynState(object):
    """Interface used to access the options for a dyn state site type."""
    _uuid = "{06485268-3338-46D7-8F0C-7BCA35CE9589}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_valid_object_names"] = _raise_uninitialized_error
        self.__dict__["_get_as_site"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISiteDynState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISiteDynState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISiteDynState = agcom.GUID(ISiteDynState._uuid)
        vtable_offset_local = ISiteDynState._vtable_offset - 1
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteDynState, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_object_name"] = IAGFUNCTYPE(pUnk, IID_ISiteDynState, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_valid_object_names"] = IAGFUNCTYPE(pUnk, IID_ISiteDynState, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_as_site"] = IAGFUNCTYPE(pUnk, IID_ISiteDynState, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteDynState.__dict__ and type(ISiteDynState.__dict__[attrname]) == property:
            return ISiteDynState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteDynState.")
    
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_object_name"](arg_newVal.COM_val))

    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_valid_object_names"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppSite:
            agcls.evaluate_hresult(self.__dict__["_get_as_site"](byref(arg_ppSite.COM_val)))
            return arg_ppSite.python_val


agcls.AgClassCatalog.add_catalog_entry("{06485268-3338-46D7-8F0C-7BCA35CE9589}", ISiteDynState)
agcls.AgTypeNameMap["ISiteDynState"] = ISiteDynState



class SiteWaypoint(ISiteWaypoint, ISite):
    """Class defining a waypoint site."""
    def __init__(self, sourceObject=None):
        ISiteWaypoint.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteWaypoint._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteWaypoint._get_property(self, attrname) is not None: found_prop = ISiteWaypoint._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteWaypoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{6d98e9b3-6766-46e5-98e2-b1f859b2ce92}", SiteWaypoint)


class SiteEndOfPrevProcedure(ISiteEndOfPrevProcedure, ISite):
    """Class defining an End of Previous Procedure site."""
    def __init__(self, sourceObject=None):
        ISiteEndOfPrevProcedure.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteEndOfPrevProcedure._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteEndOfPrevProcedure._get_property(self, attrname) is not None: found_prop = ISiteEndOfPrevProcedure._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteEndOfPrevProcedure.")
        
agcls.AgClassCatalog.add_catalog_entry("{24d8e613-5ce5-4e04-9251-fe44414caa14}", SiteEndOfPrevProcedure)


class SiteVTOLPoint(ISiteVTOLPoint, ISite):
    """Class defining a VTOL Point site."""
    def __init__(self, sourceObject=None):
        ISiteVTOLPoint.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteVTOLPoint._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteVTOLPoint._get_property(self, attrname) is not None: found_prop = ISiteVTOLPoint._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteVTOLPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{4f9d9e04-fa7e-4335-b1f4-15788a01c7ea}", SiteVTOLPoint)


class SiteReferenceState(ISiteReferenceState, ISite):
    """Class defining a Reference State site."""
    def __init__(self, sourceObject=None):
        ISiteReferenceState.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteReferenceState._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteReferenceState._get_property(self, attrname) is not None: found_prop = ISiteReferenceState._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteReferenceState.")
        
agcls.AgClassCatalog.add_catalog_entry("{978180ff-3f87-4ead-9405-e12e915c27e1}", SiteReferenceState)


class SiteSTKVehicle(ISiteSTKVehicle, ISite):
    """Class defining a STK Vehicle site."""
    def __init__(self, sourceObject=None):
        ISiteSTKVehicle.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteSTKVehicle._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKVehicle._get_property(self, attrname) is not None: found_prop = ISiteSTKVehicle._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKVehicle.")
        
agcls.AgClassCatalog.add_catalog_entry("{01b272ac-3b19-4daf-825f-88c0ff0e10bb}", SiteSTKVehicle)


class SiteSuperProcedure(ISiteSuperProcedure, ISite):
    """Class defining a Super Procedure site."""
    def __init__(self, sourceObject=None):
        ISiteSuperProcedure.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteSuperProcedure._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSuperProcedure._get_property(self, attrname) is not None: found_prop = ISiteSuperProcedure._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSuperProcedure.")
        
agcls.AgClassCatalog.add_catalog_entry("{0faf9c77-17bc-4a8d-b490-d4dcd2326ca9}", SiteSuperProcedure)


class SiteRelToPrevProcedure(ISiteRelToPrevProcedure, ISite):
    """Class defining a Relative to Previous Procedure site."""
    def __init__(self, sourceObject=None):
        ISiteRelToPrevProcedure.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteRelToPrevProcedure._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRelToPrevProcedure._get_property(self, attrname) is not None: found_prop = ISiteRelToPrevProcedure._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRelToPrevProcedure.")
        
agcls.AgClassCatalog.add_catalog_entry("{aa8dc548-3b50-44d0-b340-f1fca98283ee}", SiteRelToPrevProcedure)


class SiteSTKObjectWaypoint(ISiteSTKObjectWaypoint, ISite):
    """Class defining a STK Object Waypoint site."""
    def __init__(self, sourceObject=None):
        ISiteSTKObjectWaypoint.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteSTKObjectWaypoint._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKObjectWaypoint._get_property(self, attrname) is not None: found_prop = ISiteSTKObjectWaypoint._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKObjectWaypoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{0b1f12ad-e7be-4158-abb4-39efb21a87d3}", SiteSTKObjectWaypoint)


class SiteSTKStaticObject(ISiteSTKStaticObject, ISite):
    """Class defining a STK Static Object site."""
    def __init__(self, sourceObject=None):
        ISiteSTKStaticObject.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteSTKStaticObject._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKStaticObject._get_property(self, attrname) is not None: found_prop = ISiteSTKStaticObject._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKStaticObject.")
        
agcls.AgClassCatalog.add_catalog_entry("{16bc1a6a-6cf6-4e2a-b73f-82e6e0928c61}", SiteSTKStaticObject)


class SiteRelToSTKObject(ISiteRelToSTKObject, ISite):
    """Class defining a Relative to Stationary STK Object site."""
    def __init__(self, sourceObject=None):
        ISiteRelToSTKObject.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteRelToSTKObject._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRelToSTKObject._get_property(self, attrname) is not None: found_prop = ISiteRelToSTKObject._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRelToSTKObject.")
        
agcls.AgClassCatalog.add_catalog_entry("{0c4677b4-f09b-4f8c-a170-3d4f0e1bf7f9}", SiteRelToSTKObject)


class SiteSTKAreaTarget(ISiteSTKAreaTarget, ISite):
    """Class defining a STK Area Target site."""
    def __init__(self, sourceObject=None):
        ISiteSTKAreaTarget.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteSTKAreaTarget._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKAreaTarget._get_property(self, attrname) is not None: found_prop = ISiteSTKAreaTarget._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKAreaTarget.")
        
agcls.AgClassCatalog.add_catalog_entry("{8ae70236-0185-4072-b230-da6e68e122f1}", SiteSTKAreaTarget)


class SiteRunway(ISiteRunway, ISite):
    """Class defining a runway site."""
    def __init__(self, sourceObject=None):
        ISiteRunway.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteRunway._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRunway._get_property(self, attrname) is not None: found_prop = ISiteRunway._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRunway.")
        
agcls.AgClassCatalog.add_catalog_entry("{6bbd87f1-83bc-4750-8128-8ba51a48b4ed}", SiteRunway)


class Site(ISite, ISiteUnknown):
    """Class defining an unknown site type."""
    def __init__(self, sourceObject=None):
        ISite.__init__(self, sourceObject)
        ISiteUnknown.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISite._private_init(self, pUnk)
        ISiteUnknown._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if ISiteUnknown._get_property(self, attrname) is not None: found_prop = ISiteUnknown._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Site.")
        
agcls.AgClassCatalog.add_catalog_entry("{445bad6d-6125-446d-bce6-ac9233f11706}", Site)


class ProcedureLanding(IProcedureLanding, IProcedure):
    """Class defining a landing procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLanding.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureLanding._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLanding._get_property(self, attrname) is not None: found_prop = IProcedureLanding._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLanding.")
        
agcls.AgClassCatalog.add_catalog_entry("{bde94020-cc95-4868-b5f1-da680baf4aeb}", ProcedureLanding)


class ProcedureEnroute(IProcedureEnroute, IProcedure):
    """Class defining an enroute procedure."""
    def __init__(self, sourceObject=None):
        IProcedureEnroute.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureEnroute._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureEnroute._get_property(self, attrname) is not None: found_prop = IProcedureEnroute._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureEnroute.")
        
agcls.AgClassCatalog.add_catalog_entry("{f073011a-bfc1-4c9a-bd43-1a99bed41390}", ProcedureEnroute)


class ProcedureExtEphem(IProcedureExtEphem, IProcedure):
    """Class defining an ExtEphem procedure."""
    def __init__(self, sourceObject=None):
        IProcedureExtEphem.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureExtEphem._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureExtEphem._get_property(self, attrname) is not None: found_prop = IProcedureExtEphem._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureExtEphem.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F39A3ED-4A9E-4893-A061-F73A75ACF910}", ProcedureExtEphem)


class ProcedureFormationFlyer(IProcedureFormationFlyer, IProcedure):
    """Class defining an formationflyer procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFormationFlyer.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureFormationFlyer._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFormationFlyer._get_property(self, attrname) is not None: found_prop = IProcedureFormationFlyer._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFormationFlyer.")
        
agcls.AgClassCatalog.add_catalog_entry("{678807EC-D03C-4E14-A068-3C0D14923D72}", ProcedureFormationFlyer)


class ProcedureBasicPointToPoint(IProcedureBasicPointToPoint, IProcedure):
    """Class defining a basic point to point procedure."""
    def __init__(self, sourceObject=None):
        IProcedureBasicPointToPoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureBasicPointToPoint._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureBasicPointToPoint._get_property(self, attrname) is not None: found_prop = IProcedureBasicPointToPoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureBasicPointToPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{36ce90e9-da71-40a6-aff9-db4aecab63bd}", ProcedureBasicPointToPoint)


class ProcedureArcEnroute(IProcedureArcEnroute, IProcedure):
    """Class defining a arc enroute procedure."""
    def __init__(self, sourceObject=None):
        IProcedureArcEnroute.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureArcEnroute._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureArcEnroute._get_property(self, attrname) is not None: found_prop = IProcedureArcEnroute._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureArcEnroute.")
        
agcls.AgClassCatalog.add_catalog_entry("{7466bbc5-38eb-48ee-aec6-d45c69c562c1}", ProcedureArcEnroute)


class ProcedureArcPointToPoint(IProcedureArcPointToPoint, IProcedure):
    """Class defining a arc point to point procedure."""
    def __init__(self, sourceObject=None):
        IProcedureArcPointToPoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureArcPointToPoint._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureArcPointToPoint._get_property(self, attrname) is not None: found_prop = IProcedureArcPointToPoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureArcPointToPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{c8026c77-0b69-413a-9903-bff5e40f44b8}", ProcedureArcPointToPoint)


class ProcedureFlightLine(IProcedureFlightLine, IProcedure):
    """Class defining a flight line procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFlightLine.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureFlightLine._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFlightLine._get_property(self, attrname) is not None: found_prop = IProcedureFlightLine._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFlightLine.")
        
agcls.AgClassCatalog.add_catalog_entry("{5079d60a-789b-489e-b1ba-749d7a888eba}", ProcedureFlightLine)


class ProcedureDelay(IProcedureDelay, IProcedure):
    """Class defining a delay procedure."""
    def __init__(self, sourceObject=None):
        IProcedureDelay.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureDelay._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureDelay._get_property(self, attrname) is not None: found_prop = IProcedureDelay._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureDelay.")
        
agcls.AgClassCatalog.add_catalog_entry("{bf773446-cf9e-4f29-8c9e-57d62abbdb09}", ProcedureDelay)


class ProcedureTakeoff(IProcedureTakeoff, IProcedure):
    """Class defining a takeoff procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTakeoff.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureTakeoff._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTakeoff._get_property(self, attrname) is not None: found_prop = IProcedureTakeoff._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTakeoff.")
        
agcls.AgClassCatalog.add_catalog_entry("{52f322eb-31ca-4026-910d-ce46cc0830ee}", ProcedureTakeoff)


class ProcedureCollection(IProcedureCollection):
    """Class defining the collection of procedures in the phase of an Aviator mission."""
    def __init__(self, sourceObject=None):
        IProcedureCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureCollection._get_property(self, attrname) is not None: found_prop = IProcedureCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{02be4f36-f12f-4df0-86f4-3740e53fafe9}", ProcedureCollection)


class Phase(IPhase):
    """Class defining a phase in an Aviator mission."""
    def __init__(self, sourceObject=None):
        IPhase.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPhase._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPhase._get_property(self, attrname) is not None: found_prop = IPhase._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Phase.")
        
agcls.AgClassCatalog.add_catalog_entry("{ff7ca84a-39d9-49ee-9629-0e3d46183fbf}", Phase)


class PhaseCollection(IPhaseCollection):
    """Class defining the collection of phases."""
    def __init__(self, sourceObject=None):
        IPhaseCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPhaseCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPhaseCollection._get_property(self, attrname) is not None: found_prop = IPhaseCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PhaseCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{6518b03b-1889-4b4e-86d0-403939b71a21}", PhaseCollection)


class Mission(IMission):
    """Class defining the Aviator mission."""
    def __init__(self, sourceObject=None):
        IMission.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMission._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMission._get_property(self, attrname) is not None: found_prop = IMission._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Mission.")
        
agcls.AgClassCatalog.add_catalog_entry("{26840b17-5789-4690-96be-c8637b15f434}", Mission)


class AviatorPropagator(IAviatorPropagator):
    """Class defining the Aviator propagator."""
    def __init__(self, sourceObject=None):
        IAviatorPropagator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAviatorPropagator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAviatorPropagator._get_property(self, attrname) is not None: found_prop = IAviatorPropagator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AviatorPropagator.")
        
agcls.AgClassCatalog.add_catalog_entry("{e20f6939-fe05-44eb-a175-d63fa503526f}", AviatorPropagator)


class ProcedureBasicManeuver(IProcedureBasicManeuver, IProcedure):
    """Class defining a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IProcedureBasicManeuver.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureBasicManeuver._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureBasicManeuver._get_property(self, attrname) is not None: found_prop = IProcedureBasicManeuver._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureBasicManeuver.")
        
agcls.AgClassCatalog.add_catalog_entry("{7eb66528-bec8-4b78-a9c7-45333edbda52}", ProcedureBasicManeuver)


class BasicManeuverStrategyWeave(IBasicManeuverStrategyWeave, IBasicManeuverStrategy):
    """Class defining Weave strategy for a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyWeave.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyWeave._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyWeave._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyWeave._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyWeave.")
        
agcls.AgClassCatalog.add_catalog_entry("{46876894-f405-41cc-b071-9368b2d615f8}", BasicManeuverStrategyWeave)


class ProcedureTimeOptions(IProcedureTimeOptions):
    """Class defining the time options for the current procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTimeOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureTimeOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTimeOptions._get_property(self, attrname) is not None: found_prop = IProcedureTimeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTimeOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{8f9d3e7e-4531-42b5-b066-44a87d6afc8c}", ProcedureTimeOptions)


class CalculationOptions(ICalculationOptions):
    """Class defining the calculation options for a procedure or phase."""
    def __init__(self, sourceObject=None):
        ICalculationOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationOptions._get_property(self, attrname) is not None: found_prop = ICalculationOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{0538ece7-c599-4fc2-9d5b-3750f6712233}", CalculationOptions)


class AircraftCategory(IAircraftCategory):
    """Class defining the aircraft category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IAircraftCategory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftCategory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftCategory._get_property(self, attrname) is not None: found_prop = IAircraftCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftCategory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7c68c433-7123-45ec-9e3d-3bc4d999c6f3}", AircraftCategory)


class Catalog(ICatalog):
    """Class defining the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        ICatalog.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICatalog._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICatalog._get_property(self, attrname) is not None: found_prop = ICatalog._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Catalog.")
        
agcls.AgClassCatalog.add_catalog_entry("{3ac28f35-5412-4419-ac35-24dfd086a210}", Catalog)


class AircraftModel(IAircraftModel, IAviatorVehicle, ICatalogItem):
    """Class defining an aircraft in Aviator."""
    def __init__(self, sourceObject=None):
        IAircraftModel.__init__(self, sourceObject)
        IAviatorVehicle.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftModel._private_init(self, pUnk)
        IAviatorVehicle._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftModel._get_property(self, attrname) is not None: found_prop = IAircraftModel._get_property(self, attrname)
        if IAviatorVehicle._get_property(self, attrname) is not None: found_prop = IAviatorVehicle._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{063a922a-36a4-492c-8b6b-7b9cd7c29e8d}", AircraftModel)


class MissileModel(IMissileModel, IAviatorVehicle, ICatalogItem):
    """Class defining a missile in Aviator."""
    def __init__(self, sourceObject=None):
        IMissileModel.__init__(self, sourceObject)
        IAviatorVehicle.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileModel._private_init(self, pUnk)
        IAviatorVehicle._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileModel._get_property(self, attrname) is not None: found_prop = IMissileModel._get_property(self, attrname)
        if IAviatorVehicle._get_property(self, attrname) is not None: found_prop = IAviatorVehicle._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{4b46d7a8-3e2b-4cd9-a927-2e49e1b9ab5c}", MissileModel)


class RotorcraftModel(IRotorcraftModel, IAviatorVehicle, ICatalogItem):
    """Class defining a rotorcraft in Aviator."""
    def __init__(self, sourceObject=None):
        IRotorcraftModel.__init__(self, sourceObject)
        IAviatorVehicle.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRotorcraftModel._private_init(self, pUnk)
        IAviatorVehicle._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftModel._get_property(self, attrname) is not None: found_prop = IRotorcraftModel._get_property(self, attrname)
        if IAviatorVehicle._get_property(self, attrname) is not None: found_prop = IAviatorVehicle._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{a10ff662-0083-473b-90c7-5ff75d3144c9}", RotorcraftModel)


class RotorcraftAero(IRotorcraftAero):
    """Class defining the aerodynamic options for a rotorcraft."""
    def __init__(self, sourceObject=None):
        IRotorcraftAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRotorcraftAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftAero._get_property(self, attrname) is not None: found_prop = IRotorcraftAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{df267da7-689f-48eb-bd92-1bdfebc51435}", RotorcraftAero)


class RotorcraftProp(IRotorcraftProp):
    """Class defining the propulsion options for a rotorcraft."""
    def __init__(self, sourceObject=None):
        IRotorcraftProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRotorcraftProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftProp._get_property(self, attrname) is not None: found_prop = IRotorcraftProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{c0734618-529f-4ff2-9a14-3e4bd14cd601}", RotorcraftProp)


class AircraftAcceleration(IAircraftAcceleration, ICatalogItem):
    """Class defining the aircraft acceleration category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAcceleration.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAcceleration._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAcceleration._get_property(self, attrname) is not None: found_prop = IAircraftAcceleration._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAcceleration.")
        
agcls.AgClassCatalog.add_catalog_entry("{574f37f4-4889-4c85-baf5-8359e847acfa}", AircraftAcceleration)


class AircraftBasicAccelerationModel(IAircraftBasicAccelerationModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic acceleration performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicAccelerationModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicAccelerationModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicAccelerationModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicAccelerationModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicAccelerationModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{e33469ad-d69d-48a2-9fc0-3fce97a2b98e}", AircraftBasicAccelerationModel)


class AircraftClimb(IAircraftClimb, ICatalogItem):
    """Class defining the aircraft climb category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftClimb.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftClimb._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftClimb._get_property(self, attrname) is not None: found_prop = IAircraftClimb._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftClimb.")
        
agcls.AgClassCatalog.add_catalog_entry("{2f0086b2-66d4-4df6-9711-ee2524ba1ed0}", AircraftClimb)


class AircraftCruise(IAircraftCruise, ICatalogItem):
    """Class defining the aircraft cruise category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftCruise.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftCruise._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftCruise._get_property(self, attrname) is not None: found_prop = IAircraftCruise._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftCruise.")
        
agcls.AgClassCatalog.add_catalog_entry("{efe9b334-9261-44bb-9834-8e7207ca6e05}", AircraftCruise)


class AircraftDescent(IAircraftDescent, ICatalogItem):
    """Class defining the aircraft descent category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftDescent.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftDescent._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftDescent._get_property(self, attrname) is not None: found_prop = IAircraftDescent._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftDescent.")
        
agcls.AgClassCatalog.add_catalog_entry("{d76fa881-77b3-486a-976c-8184e9cb91fd}", AircraftDescent)


class AircraftLanding(IAircraftLanding, ICatalogItem):
    """Class defining the aircraft landing category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftLanding.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftLanding._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftLanding._get_property(self, attrname) is not None: found_prop = IAircraftLanding._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftLanding.")
        
agcls.AgClassCatalog.add_catalog_entry("{8371480b-53cf-41ca-b749-41623f6d380a}", AircraftLanding)


class AircraftTakeoff(IAircraftTakeoff, ICatalogItem):
    """Class defining the aircraft takeoff category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftTakeoff.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftTakeoff._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftTakeoff._get_property(self, attrname) is not None: found_prop = IAircraftTakeoff._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftTakeoff.")
        
agcls.AgClassCatalog.add_catalog_entry("{aeef7451-7456-4d8c-aabf-147a466149cd}", AircraftTakeoff)


class AircraftBasicClimbModel(IAircraftBasicClimbModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic climb performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicClimbModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicClimbModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicClimbModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicClimbModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicClimbModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{2950de29-1009-4c2a-8db5-378b41c6d48d}", AircraftBasicClimbModel)


class AircraftAdvClimbModel(IAircraftAdvClimbModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced climb performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvClimbModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAdvClimbModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvClimbModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvClimbModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvClimbModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{C1C87503-2B8E-41BC-8BA9-02B7CC1E02C2}", AircraftAdvClimbModel)


class AircraftBasicCruiseModel(IAircraftBasicCruiseModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic cruise performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicCruiseModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicCruiseModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicCruiseModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicCruiseModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicCruiseModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{c6090ace-e557-4bef-adf3-2e56387015a8}", AircraftBasicCruiseModel)


class AircraftAdvCruiseModel(IAircraftAdvCruiseModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced cruise performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvCruiseModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAdvCruiseModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvCruiseModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvCruiseModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvCruiseModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{ead08117-2561-4bb7-a82b-86057f506090}", AircraftAdvCruiseModel)


class AircraftBasicDescentModel(IAircraftBasicDescentModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic descent performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicDescentModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicDescentModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicDescentModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicDescentModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicDescentModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{30cb8d6f-afe5-4275-8479-4ce73b93a758}", AircraftBasicDescentModel)


class AircraftAdvDescentModel(IAircraftAdvDescentModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced descent performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvDescentModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAdvDescentModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvDescentModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvDescentModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvDescentModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{40ee1832-9491-49e5-bd27-40d40fefb326}", AircraftAdvDescentModel)


class AircraftBasicTakeoffModel(IAircraftBasicTakeoffModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic takeoff performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicTakeoffModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicTakeoffModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicTakeoffModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicTakeoffModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicTakeoffModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{3d9380c9-1aa0-4dcf-86bb-ded3b6b656e8}", AircraftBasicTakeoffModel)


class AircraftAdvTakeoffModel(IAircraftAdvTakeoffModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced takeoff performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvTakeoffModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAdvTakeoffModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvTakeoffModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvTakeoffModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvTakeoffModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{fc3190a3-fbeb-46bb-8395-22405fbf5b80}", AircraftAdvTakeoffModel)


class AircraftBasicLandingModel(IAircraftBasicLandingModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic landing performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicLandingModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicLandingModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicLandingModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicLandingModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicLandingModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{bd4e5100-7e2c-40ca-815a-02a618a4321d}", AircraftBasicLandingModel)


class AircraftAdvLandingModel(IAircraftAdvLandingModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced landing performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvLandingModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAdvLandingModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvLandingModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvLandingModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvLandingModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{fb7534d7-1f9b-4133-9712-66728255532b}", AircraftAdvLandingModel)


class AirportCategory(IAirportCategory):
    """Class defining the airport category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IAirportCategory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAirportCategory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAirportCategory._get_property(self, attrname) is not None: found_prop = IAirportCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AirportCategory.")
        
agcls.AgClassCatalog.add_catalog_entry("{d497aeeb-3c6a-44ad-9f1a-6af1504c9a99}", AirportCategory)


class ARINC424Airport(IARINC424Item, ICatalogAirport, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Airport."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogAirport.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IARINC424Item._private_init(self, pUnk)
        ICatalogAirport._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogAirport._get_property(self, attrname) is not None: found_prop = ICatalogAirport._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Airport.")
        
agcls.AgClassCatalog.add_catalog_entry("{1d942d58-5b4d-4784-8ec9-435008352423}", ARINC424Airport)


class ARINC424Runway(IARINC424Runway, IARINC424Item, ICatalogRunway, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Runway."""
    def __init__(self, sourceObject=None):
        IARINC424Runway.__init__(self, sourceObject)
        IARINC424Item.__init__(self, sourceObject)
        ICatalogRunway.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IARINC424Runway._private_init(self, pUnk)
        IARINC424Item._private_init(self, pUnk)
        ICatalogRunway._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Runway._get_property(self, attrname) is not None: found_prop = IARINC424Runway._get_property(self, attrname)
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogRunway._get_property(self, attrname) is not None: found_prop = ICatalogRunway._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Runway.")
        
agcls.AgClassCatalog.add_catalog_entry("{20c6f0ee-a2d5-4447-8d9a-3b67fe759266}", ARINC424Runway)


class DAFIFRunway(IDAFIFItem, ICatalogRunway, ICatalogWaypoint, ICatalogItem):
    """Class defining an DAFIF Runway."""
    def __init__(self, sourceObject=None):
        IDAFIFItem.__init__(self, sourceObject)
        ICatalogRunway.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDAFIFItem._private_init(self, pUnk)
        ICatalogRunway._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFItem._get_property(self, attrname) is not None: found_prop = IDAFIFItem._get_property(self, attrname)
        if ICatalogRunway._get_property(self, attrname) is not None: found_prop = ICatalogRunway._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFRunway.")
        
agcls.AgClassCatalog.add_catalog_entry("{95867fe1-39fa-41cf-aa24-c6068c2cd86a}", DAFIFRunway)


class DAFIFHelipad(IDAFIFItem, ICatalogVTOLPoint, ICatalogWaypoint, ICatalogItem):
    """Class defining an DAFIF Helipad."""
    def __init__(self, sourceObject=None):
        IDAFIFItem.__init__(self, sourceObject)
        ICatalogVTOLPoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDAFIFItem._private_init(self, pUnk)
        ICatalogVTOLPoint._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFItem._get_property(self, attrname) is not None: found_prop = IDAFIFItem._get_property(self, attrname)
        if ICatalogVTOLPoint._get_property(self, attrname) is not None: found_prop = ICatalogVTOLPoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFHelipad.")
        
agcls.AgClassCatalog.add_catalog_entry("{6973673c-7c51-48c2-8931-614aa2ab1da5}", DAFIFHelipad)


class DAFIFWaypoint(IDAFIFItem, ICatalogWaypoint, ICatalogItem):
    """Class defining an DAFIF Waypoint."""
    def __init__(self, sourceObject=None):
        IDAFIFItem.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDAFIFItem._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFItem._get_property(self, attrname) is not None: found_prop = IDAFIFItem._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFWaypoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{62195e59-a4fc-40f9-ab7d-4229c79c0e8f}", DAFIFWaypoint)


class RunwayCategory(IRunwayCategory):
    """Class defining the runway category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IRunwayCategory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRunwayCategory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRunwayCategory._get_property(self, attrname) is not None: found_prop = IRunwayCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RunwayCategory.")
        
agcls.AgClassCatalog.add_catalog_entry("{69b1b664-f8d4-4be5-bfe9-8760573b2c72}", RunwayCategory)


class UserRunwaySource(IUserRunwaySource, ICatalogSource):
    """Class defining the user runways in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserRunwaySource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserRunwaySource._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserRunwaySource._get_property(self, attrname) is not None: found_prop = IUserRunwaySource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserRunwaySource.")
        
agcls.AgClassCatalog.add_catalog_entry("{7b8c1764-ce59-4e35-940a-24d99c2953ef}", UserRunwaySource)


class UserRunway(IUserRunway, ICatalogRunway, ICatalogItem, ICatalogWaypoint):
    """Class defining the user runway in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserRunway.__init__(self, sourceObject)
        ICatalogRunway.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserRunway._private_init(self, pUnk)
        ICatalogRunway._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserRunway._get_property(self, attrname) is not None: found_prop = IUserRunway._get_property(self, attrname)
        if ICatalogRunway._get_property(self, attrname) is not None: found_prop = ICatalogRunway._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserRunway.")
        
agcls.AgClassCatalog.add_catalog_entry("{693bdacd-4c8d-4efd-bb23-3f14c83d3b04}", UserRunway)


class AltitudeMSLOptions(IAltitudeMSLOptions):
    """Class defining the altitude MSL options in a procedure."""
    def __init__(self, sourceObject=None):
        IAltitudeMSLOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAltitudeMSLOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeMSLOptions._get_property(self, attrname) is not None: found_prop = IAltitudeMSLOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeMSLOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{c866a6dd-1070-4162-bff2-4339ab28f6b2}", AltitudeMSLOptions)


class AltitudeOptions(IAltitudeOptions):
    """Class defining the altitude options in a procedure."""
    def __init__(self, sourceObject=None):
        IAltitudeOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAltitudeOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeOptions._get_property(self, attrname) is not None: found_prop = IAltitudeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{4d5d82b7-e342-4dcb-9af1-7cbfa909fc23}", AltitudeOptions)


class ArcAltitudeOptions(IArcAltitudeOptions):
    """Class defining the altitude options for an arc procedure."""
    def __init__(self, sourceObject=None):
        IArcAltitudeOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IArcAltitudeOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcAltitudeOptions._get_property(self, attrname) is not None: found_prop = IArcAltitudeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcAltitudeOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{1c4f7491-db5d-4e52-ba8e-e64ddfc687fe}", ArcAltitudeOptions)


class ArcAltitudeAndDelayOptions(IArcAltitudeAndDelayOptions):
    """Class defining the altitude and delay options for an arc procedure."""
    def __init__(self, sourceObject=None):
        IArcAltitudeAndDelayOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IArcAltitudeAndDelayOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcAltitudeAndDelayOptions._get_property(self, attrname) is not None: found_prop = IArcAltitudeAndDelayOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcAltitudeAndDelayOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{fdf04fa7-1588-4e15-a0ab-37b9586c878f}", ArcAltitudeAndDelayOptions)


class ArcOptions(IArcOptions):
    """Class defining the arc options for a procedure."""
    def __init__(self, sourceObject=None):
        IArcOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IArcOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcOptions._get_property(self, attrname) is not None: found_prop = IArcOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{41af67f7-489f-452e-858a-bd8cc0bf782d}", ArcOptions)


class AltitudeMSLAndLevelOffOptions(IAltitudeMSLAndLevelOffOptions):
    """Class defining the altitude MSL and Level off options in a procedure."""
    def __init__(self, sourceObject=None):
        IAltitudeMSLAndLevelOffOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAltitudeMSLAndLevelOffOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeMSLAndLevelOffOptions._get_property(self, attrname) is not None: found_prop = IAltitudeMSLAndLevelOffOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeMSLAndLevelOffOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{0a38e533-78b2-402b-aed6-0ff04a62fcce}", AltitudeMSLAndLevelOffOptions)


class CruiseAirspeedOptions(ICruiseAirspeedOptions):
    """Class defining the cruise airspeed options in a procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICruiseAirspeedOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedOptions._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CruiseAirspeedOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{05251788-e43e-4d91-84ad-3d2bcfc2087a}", CruiseAirspeedOptions)


class CruiseAirspeedProfile(ICruiseAirspeedProfile):
    """Class defining the cruise profile options in a procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedProfile.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICruiseAirspeedProfile._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedProfile._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedProfile._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CruiseAirspeedProfile.")
        
agcls.AgClassCatalog.add_catalog_entry("{5afc99d6-3a02-45f9-b6f5-87690d8f9702}", CruiseAirspeedProfile)


class CruiseAirspeedAndProfileOptions(ICruiseAirspeedAndProfileOptions):
    """Class defining the cruise airspeed and profile options in a procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedAndProfileOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICruiseAirspeedAndProfileOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedAndProfileOptions._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedAndProfileOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CruiseAirspeedAndProfileOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{ee439155-cd45-45b5-b7f8-eae4f5e51b8e}", CruiseAirspeedAndProfileOptions)


class LandingCruiseAirspeedAndProfileOptions(ICruiseAirspeedAndProfileOptions):
    """Class defining the cruise airspeed and profile options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedAndProfileOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICruiseAirspeedAndProfileOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedAndProfileOptions._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedAndProfileOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingCruiseAirspeedAndProfileOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{cb47399c-3316-494f-959c-4f84b4c4936c}", LandingCruiseAirspeedAndProfileOptions)


class EnrouteOptions(IEnrouteOptions):
    """Class defining the enroute options in a procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEnrouteOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteOptions._get_property(self, attrname) is not None: found_prop = IEnrouteOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EnrouteOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{cb708621-5036-4dbc-a900-a3b3a3fa7124}", EnrouteOptions)


class EnrouteAndDelayOptions(IEnrouteAndDelayOptions):
    """Class defining the enroute and delay options in a procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteAndDelayOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEnrouteAndDelayOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteAndDelayOptions._get_property(self, attrname) is not None: found_prop = IEnrouteAndDelayOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EnrouteAndDelayOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{fc46b909-c927-4e2d-9d82-79c6980807d8}", EnrouteAndDelayOptions)


class LandingEnrouteOptions(IEnrouteAndDelayOptions):
    """Class defining the enroute options in a landing procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteAndDelayOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEnrouteAndDelayOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteAndDelayOptions._get_property(self, attrname) is not None: found_prop = IEnrouteAndDelayOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingEnrouteOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{42ec119b-2661-4c68-b807-a5ed2a3af018}", LandingEnrouteOptions)


class EnrouteTurnDirectionOptions(IEnrouteTurnDirectionOptions):
    """Class defining the enroute turn direction options in a procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteTurnDirectionOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEnrouteTurnDirectionOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteTurnDirectionOptions._get_property(self, attrname) is not None: found_prop = IEnrouteTurnDirectionOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EnrouteTurnDirectionOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{16e895f3-5a65-4caf-960e-691f904ca66c}", EnrouteTurnDirectionOptions)


class NavigationOptions(INavigationOptions):
    """Class defining the navigation options in a procedure."""
    def __init__(self, sourceObject=None):
        INavigationOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        INavigationOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if INavigationOptions._get_property(self, attrname) is not None: found_prop = INavigationOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in NavigationOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{ce90add8-b152-4984-b864-0f6e61e680d4}", NavigationOptions)


class VerticalPlaneOptions(IVerticalPlaneOptions):
    """Class defining the vertical plane options in a procedure."""
    def __init__(self, sourceObject=None):
        IVerticalPlaneOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVerticalPlaneOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVerticalPlaneOptions._get_property(self, attrname) is not None: found_prop = IVerticalPlaneOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VerticalPlaneOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{a902b408-0141-4280-b6cf-e1cb18dae4f6}", VerticalPlaneOptions)


class ArcVerticalPlaneOptions(IArcVerticalPlaneOptions):
    """Class defining the vertical plane options in a procedure."""
    def __init__(self, sourceObject=None):
        IArcVerticalPlaneOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IArcVerticalPlaneOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcVerticalPlaneOptions._get_property(self, attrname) is not None: found_prop = IArcVerticalPlaneOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcVerticalPlaneOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{eae3a835-4897-408f-91dc-59b9a2fbcb5c}", ArcVerticalPlaneOptions)


class VerticalPlaneAndFlightPathOptions(IVerticalPlaneAndFlightPathOptions):
    """Class defining the vertical plane options for an arc procedure."""
    def __init__(self, sourceObject=None):
        IVerticalPlaneAndFlightPathOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVerticalPlaneAndFlightPathOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVerticalPlaneAndFlightPathOptions._get_property(self, attrname) is not None: found_prop = IVerticalPlaneAndFlightPathOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VerticalPlaneAndFlightPathOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{7db61c31-a562-43b9-b3fa-76dc120bdd74}", VerticalPlaneAndFlightPathOptions)


class LandingVerticalPlaneOptions(IVerticalPlaneOptions):
    """Class defining the vertical plane options in a landing procedure."""
    def __init__(self, sourceObject=None):
        IVerticalPlaneOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVerticalPlaneOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVerticalPlaneOptions._get_property(self, attrname) is not None: found_prop = IVerticalPlaneOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingVerticalPlaneOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{846a07a8-230c-4036-a43b-c61ccd1bde69}", LandingVerticalPlaneOptions)


class RunwayHeadingOptions(IRunwayHeadingOptions):
    """Class defining the runway heading options in a takeoff or landing procedure."""
    def __init__(self, sourceObject=None):
        IRunwayHeadingOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRunwayHeadingOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRunwayHeadingOptions._get_property(self, attrname) is not None: found_prop = IRunwayHeadingOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RunwayHeadingOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{167457be-4afe-477d-af6d-4e49413f4863}", RunwayHeadingOptions)


class LandingEnterDownwindPattern(ILandingEnterDownwindPattern):
    """Class defining the enter downwind pattern options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ILandingEnterDownwindPattern.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILandingEnterDownwindPattern._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILandingEnterDownwindPattern._get_property(self, attrname) is not None: found_prop = ILandingEnterDownwindPattern._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingEnterDownwindPattern.")
        
agcls.AgClassCatalog.add_catalog_entry("{7fd1f000-c683-490f-9eea-a30062392898}", LandingEnterDownwindPattern)


class LandingInterceptGlideslope(ILandingInterceptGlideslope):
    """Class defining the intercept glideslope options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ILandingInterceptGlideslope.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILandingInterceptGlideslope._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILandingInterceptGlideslope._get_property(self, attrname) is not None: found_prop = ILandingInterceptGlideslope._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingInterceptGlideslope.")
        
agcls.AgClassCatalog.add_catalog_entry("{f9735637-159f-4a79-9b1c-05d88d8437ac}", LandingInterceptGlideslope)


class LandingStandardInstrumentApproach(ILandingStandardInstrumentApproach):
    """Class defining the standard instrument approach options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ILandingStandardInstrumentApproach.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILandingStandardInstrumentApproach._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILandingStandardInstrumentApproach._get_property(self, attrname) is not None: found_prop = ILandingStandardInstrumentApproach._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingStandardInstrumentApproach.")
        
agcls.AgClassCatalog.add_catalog_entry("{6463a94a-8a78-432d-b155-d9d6d436c748}", LandingStandardInstrumentApproach)


class TakeoffDeparturePoint(ITakeoffDeparturePoint):
    """Class defining the departure point options for a takeoff procedure."""
    def __init__(self, sourceObject=None):
        ITakeoffDeparturePoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITakeoffDeparturePoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITakeoffDeparturePoint._get_property(self, attrname) is not None: found_prop = ITakeoffDeparturePoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TakeoffDeparturePoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{59ebf9c6-d1de-47c0-bd56-b3d455c5c335}", TakeoffDeparturePoint)


class TakeoffLowTransition(ITakeoffLowTransition):
    """Class defining the low transition options for a takeoff procedure."""
    def __init__(self, sourceObject=None):
        ITakeoffLowTransition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITakeoffLowTransition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITakeoffLowTransition._get_property(self, attrname) is not None: found_prop = ITakeoffLowTransition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TakeoffLowTransition.")
        
agcls.AgClassCatalog.add_catalog_entry("{c8f9161b-97e3-4eab-b5e9-6a5aebaddaea}", TakeoffLowTransition)


class TakeoffNormal(ITakeoffNormal):
    """Class defining the normal options for a takeoff procedure."""
    def __init__(self, sourceObject=None):
        ITakeoffNormal.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITakeoffNormal._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITakeoffNormal._get_property(self, attrname) is not None: found_prop = ITakeoffNormal._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TakeoffNormal.")
        
agcls.AgClassCatalog.add_catalog_entry("{4951950f-59cb-4524-a2c6-5d8b6f35922d}", TakeoffNormal)


class LevelTurns(ILevelTurns):
    """Class defining the level turns options for an acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        ILevelTurns.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ILevelTurns._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILevelTurns._get_property(self, attrname) is not None: found_prop = ILevelTurns._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LevelTurns.")
        
agcls.AgClassCatalog.add_catalog_entry("{8c955be7-5999-4332-bb80-4151d864d1d4}", LevelTurns)


class AttitudeTransitions(IAttitudeTransitions):
    """Class defining the attitude transition options for an acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAttitudeTransitions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeTransitions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeTransitions._get_property(self, attrname) is not None: found_prop = IAttitudeTransitions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeTransitions.")
        
agcls.AgClassCatalog.add_catalog_entry("{0fc49614-6fbf-4d80-94ae-f8a338d8e7ab}", AttitudeTransitions)


class ClimbAndDescentTransitions(IClimbAndDescentTransitions):
    """Class defining the climb and descent transition options for an Acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IClimbAndDescentTransitions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IClimbAndDescentTransitions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IClimbAndDescentTransitions._get_property(self, attrname) is not None: found_prop = IClimbAndDescentTransitions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ClimbAndDescentTransitions.")
        
agcls.AgClassCatalog.add_catalog_entry("{c8d87c4a-ee0c-4a96-b7f4-9dbe84a7b2aa}", ClimbAndDescentTransitions)


class AeroPropManeuverModeHelper(IAeroPropManeuverModeHelper):
    """Class defining the The calculation mode for the Aero/Prop maneuver mode helper. Helper for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAeroPropManeuverModeHelper.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAeroPropManeuverModeHelper._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAeroPropManeuverModeHelper._get_property(self, attrname) is not None: found_prop = IAeroPropManeuverModeHelper._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AeroPropManeuverModeHelper.")
        
agcls.AgClassCatalog.add_catalog_entry("{854b3e50-7d20-4d15-a58d-b1f36dac5c77}", AeroPropManeuverModeHelper)


class AircraftAdvAccelerationModel(IAircraftAdvAccelerationModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvAccelerationModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAdvAccelerationModel._private_init(self, pUnk)
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvAccelerationModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvAccelerationModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvAccelerationModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{e55e8521-3091-4a5d-afe0-57f7e7ee698e}", AircraftAdvAccelerationModel)


class AircraftAccelerationMode(IAircraftAccelerationMode):
    """Class defining the acceleration mode options for an advanced acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAccelerationMode.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAccelerationMode._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAccelerationMode._get_property(self, attrname) is not None: found_prop = IAircraftAccelerationMode._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAccelerationMode.")
        
agcls.AgClassCatalog.add_catalog_entry("{551999ee-51a5-4863-a244-0030899884ee}", AircraftAccelerationMode)


class AircraftSimpleAero(IAircraftSimpleAero):
    """Class defining the simple aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftSimpleAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftSimpleAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftSimpleAero._get_property(self, attrname) is not None: found_prop = IAircraftSimpleAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftSimpleAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{54bb15cb-5b0e-44af-9605-0b646efebaeb}", AircraftSimpleAero)


class AircraftExternalAero(IAircraftExternalAero):
    """Class defining the external file aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftExternalAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftExternalAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftExternalAero._get_property(self, attrname) is not None: found_prop = IAircraftExternalAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftExternalAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{f79db172-f8c6-4dc9-84c7-dfff374156bc}", AircraftExternalAero)


class AircraftAero(IAircraftAero):
    """Class defining the aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAero._get_property(self, attrname) is not None: found_prop = IAircraftAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{6005f6fd-9923-4688-a60f-6179d5cec1f3}", AircraftAero)


class AircraftBasicFixedWingAero(IAircraftBasicFixedWingAero):
    """Class defining the basic fixed wing aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicFixedWingAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicFixedWingAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicFixedWingAero._get_property(self, attrname) is not None: found_prop = IAircraftBasicFixedWingAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicFixedWingAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{3e05b32c-25ac-400d-ae1c-e1628b2e6ebb}", AircraftBasicFixedWingAero)


class AircraftProp(IAircraftProp):
    """Class defining the propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftProp._get_property(self, attrname) is not None: found_prop = IAircraftProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{8773e358-a871-4d66-b7b2-25a473f22bdb}", AircraftProp)


class AircraftSimpleProp(IAircraftSimpleProp):
    """Class defining the basic fixed wing propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftSimpleProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftSimpleProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftSimpleProp._get_property(self, attrname) is not None: found_prop = IAircraftSimpleProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftSimpleProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{359cf55e-59da-4f34-93fe-010180c2a415}", AircraftSimpleProp)


class AircraftExternalProp(IAircraftExternalProp):
    """Class defining the external propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftExternalProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftExternalProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftExternalProp._get_property(self, attrname) is not None: found_prop = IAircraftExternalProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftExternalProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{9a59b51f-6133-446f-9f7c-04bfa1e8c69a}", AircraftExternalProp)


class AircraftBasicFixedWingProp(IAircraftBasicFixedWingProp):
    """Class defining the basic fixed wing propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicFixedWingProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftBasicFixedWingProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicFixedWingProp._get_property(self, attrname) is not None: found_prop = IAircraftBasicFixedWingProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicFixedWingProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{b4158163-51d7-4eb6-956a-14740ae523b3}", AircraftBasicFixedWingProp)


class ARINC424Source(IARINC424Source, ICatalogSource):
    """Class defining an ARINC424 source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IARINC424Source.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IARINC424Source._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Source._get_property(self, attrname) is not None: found_prop = IARINC424Source._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Source.")
        
agcls.AgClassCatalog.add_catalog_entry("{e4f5b464-d93a-4541-8a1e-737ece8b120c}", ARINC424Source)


class DAFIFSource(IDAFIFSource, ICatalogSource):
    """Class defining an DAFIF source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IDAFIFSource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDAFIFSource._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFSource._get_property(self, attrname) is not None: found_prop = IDAFIFSource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFSource.")
        
agcls.AgClassCatalog.add_catalog_entry("{4325ae72-1155-40cd-a708-0cf4da0b653c}", DAFIFSource)


class BasicFixedWingFwdFlightLiftHelper(IBasicFixedWingLiftHelper):
    """Class defining the Lift Coefficient Helper for Forward Flight in the Basic Fixed Wing Aerodynamics interface for the Basic Acceleration Model of an aircraft."""
    def __init__(self, sourceObject=None):
        IBasicFixedWingLiftHelper.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicFixedWingLiftHelper._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicFixedWingLiftHelper._get_property(self, attrname) is not None: found_prop = IBasicFixedWingLiftHelper._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicFixedWingFwdFlightLiftHelper.")
        
agcls.AgClassCatalog.add_catalog_entry("{507fa67b-cebe-431c-a109-fb6d77b6b026}", BasicFixedWingFwdFlightLiftHelper)


class BasicManeuverStrategyStraightAhead(IBasicManeuverStrategyStraightAhead, IBasicManeuverStrategy):
    """Class defining the Straight Ahead strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyStraightAhead.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyStraightAhead._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyStraightAhead._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyStraightAhead._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyStraightAhead.")
        
agcls.AgClassCatalog.add_catalog_entry("{beae703c-6b09-4ff9-a7d0-3e6513848c84}", BasicManeuverStrategyStraightAhead)


class BasicManeuverStrategyCruiseProfile(IBasicManeuverStrategyCruiseProfile, IBasicManeuverStrategy):
    """Class defining the Cruise profile strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyCruiseProfile.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyCruiseProfile._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyCruiseProfile._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyCruiseProfile._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyCruiseProfile.")
        
agcls.AgClassCatalog.add_catalog_entry("{00a0e796-7322-478b-9ad6-b8f1d6ef81e1}", BasicManeuverStrategyCruiseProfile)


class BasicManeuverStrategyGlideProfile(IBasicManeuverStrategyGlideProfile, IBasicManeuverStrategy):
    """Class defining the Glide profile strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyGlideProfile.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyGlideProfile._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyGlideProfile._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyGlideProfile._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyGlideProfile.")
        
agcls.AgClassCatalog.add_catalog_entry("{0e60df52-4bb8-40a1-90a8-ecf7a57bca0a}", BasicManeuverStrategyGlideProfile)


class AircraftModels(IAircraftModels, ICatalogSource):
    """Class defining the User Aircraft Models in the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        IAircraftModels.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftModels._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftModels._get_property(self, attrname) is not None: found_prop = IAircraftModels._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftModels.")
        
agcls.AgClassCatalog.add_catalog_entry("{47dd19b1-0ce7-458b-bdb2-2ec0d337231b}", AircraftModels)


class MissileModels(IMissileModels, ICatalogSource):
    """Class defining the User Missile Models in the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        IMissileModels.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileModels._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileModels._get_property(self, attrname) is not None: found_prop = IMissileModels._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileModels.")
        
agcls.AgClassCatalog.add_catalog_entry("{038a565a-efe0-4bc0-8a22-eb1c2d88d87a}", MissileModels)


class RotorcraftModels(IRotorcraftModels, ICatalogSource):
    """Class defining the User Rotorcraft Models in the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        IRotorcraftModels.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRotorcraftModels._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftModels._get_property(self, attrname) is not None: found_prop = IRotorcraftModels._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftModels.")
        
agcls.AgClassCatalog.add_catalog_entry("{f85cc088-0dc1-4436-bc2e-a985bfd4dfb4}", RotorcraftModels)


class Configuration(IConfiguration):
    """Class defining the aircraft configuration for an Aviator mission."""
    def __init__(self, sourceObject=None):
        IConfiguration.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConfiguration._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConfiguration._get_property(self, attrname) is not None: found_prop = IConfiguration._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Configuration.")
        
agcls.AgClassCatalog.add_catalog_entry("{823e96a0-a485-4c5b-9abc-7d6658432f99}", Configuration)


class FuelTankInternal(IFuelTankInternal, IStation):
    """Class defining an internal fuel tank for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IFuelTankInternal.__init__(self, sourceObject)
        IStation.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFuelTankInternal._private_init(self, pUnk)
        IStation._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelTankInternal._get_property(self, attrname) is not None: found_prop = IFuelTankInternal._get_property(self, attrname)
        if IStation._get_property(self, attrname) is not None: found_prop = IStation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelTankInternal.")
        
agcls.AgClassCatalog.add_catalog_entry("{64fd434a-e313-4f15-a236-f25f10461444}", FuelTankInternal)


class FuelTankExternal(IFuelTankExternal):
    """Class defining an external fuel tank for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IFuelTankExternal.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFuelTankExternal._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelTankExternal._get_property(self, attrname) is not None: found_prop = IFuelTankExternal._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelTankExternal.")
        
agcls.AgClassCatalog.add_catalog_entry("{8037f407-784e-469e-b92d-2a0fff148e86}", FuelTankExternal)


class PayloadStation(IPayloadStation, IStation):
    """Class defining a payload station for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IPayloadStation.__init__(self, sourceObject)
        IStation.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPayloadStation._private_init(self, pUnk)
        IStation._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPayloadStation._get_property(self, attrname) is not None: found_prop = IPayloadStation._get_property(self, attrname)
        if IStation._get_property(self, attrname) is not None: found_prop = IStation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PayloadStation.")
        
agcls.AgClassCatalog.add_catalog_entry("{13423a45-1732-438b-a96a-502bc40f0827}", PayloadStation)


class StationCollection(IStationCollection):
    """Class defining a collection of payload stations for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IStationCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStationCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStationCollection._get_property(self, attrname) is not None: found_prop = IStationCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StationCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{e81ed53f-b172-46c4-85b1-e80fe06e211a}", StationCollection)


class WindModel(IWindModel):
    """Class defining the wind model for a mission, scenario, or procedure."""
    def __init__(self, sourceObject=None):
        IWindModel.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWindModel._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWindModel._get_property(self, attrname) is not None: found_prop = IWindModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WindModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{8c0e170c-1818-4bd9-8bbf-e578065ea2a8}", WindModel)


class WindModelConstant(IWindModelConstant):
    """Class defining a constant bearing/speed wind model for a mission."""
    def __init__(self, sourceObject=None):
        IWindModelConstant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWindModelConstant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWindModelConstant._get_property(self, attrname) is not None: found_prop = IWindModelConstant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WindModelConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{079a1206-8ed3-423d-8f1d-855551f0435c}", WindModelConstant)


class WindModelADDS(IWindModelADDS):
    """Class defining a wind model using the NOAA ADDS service for a mission."""
    def __init__(self, sourceObject=None):
        IWindModelADDS.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWindModelADDS._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWindModelADDS._get_property(self, attrname) is not None: found_prop = IWindModelADDS._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WindModelADDS.")
        
agcls.AgClassCatalog.add_catalog_entry("{1e2024ff-d594-49bf-8ea7-a110213078ba}", WindModelADDS)


class ADDSMessage(IADDSMessage):
    """Class defining a message from the NOAA ADDS service."""
    def __init__(self, sourceObject=None):
        IADDSMessage.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IADDSMessage._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IADDSMessage._get_property(self, attrname) is not None: found_prop = IADDSMessage._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ADDSMessage.")
        
agcls.AgClassCatalog.add_catalog_entry("{22e44fa2-cfe7-456a-900c-0916f1d88cec}", ADDSMessage)


class ADDSMessageCollection(IADDSMessageCollection):
    """Class defining a collection of messages from the NOAA ADDS service."""
    def __init__(self, sourceObject=None):
        IADDSMessageCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IADDSMessageCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IADDSMessageCollection._get_property(self, attrname) is not None: found_prop = IADDSMessageCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ADDSMessageCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{f5e634eb-3433-4336-9c0d-73b3d0e9674a}", ADDSMessageCollection)


class Procedure(IProcedure, IConnect):
    """Class defining an unknown procedure type."""
    def __init__(self, sourceObject=None):
        IProcedure.__init__(self, sourceObject)
        IConnect.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedure._private_init(self, pUnk)
        IConnect._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if IConnect._get_property(self, attrname) is not None: found_prop = IConnect._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Procedure.")
        
agcls.AgClassCatalog.add_catalog_entry("{c744fb3a-e51d-4b87-8006-ed9dd4d48495}", Procedure)


class AtmosphereModel(IAtmosphereModel):
    """Class defining the atmosphere model for a mission, scenario, or procedure."""
    def __init__(self, sourceObject=None):
        IAtmosphereModel.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAtmosphereModel._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAtmosphereModel._get_property(self, attrname) is not None: found_prop = IAtmosphereModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AtmosphereModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{43ce46bb-52dc-42d7-818a-5bd4d13dd15d}", AtmosphereModel)


class AtmosphereModelBasic(IAtmosphereModelBasic):
    """Class defining the basic atmosphere model."""
    def __init__(self, sourceObject=None):
        IAtmosphereModelBasic.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAtmosphereModelBasic._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAtmosphereModelBasic._get_property(self, attrname) is not None: found_prop = IAtmosphereModelBasic._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AtmosphereModelBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{9c9a3976-e898-4e98-b2ce-26d045ab4d46}", AtmosphereModelBasic)


class BasicManeuverStrategySimpleTurn(IBasicManeuverStrategySimpleTurn, IBasicManeuverStrategy):
    """Class defining the simple turn strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategySimpleTurn.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategySimpleTurn._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategySimpleTurn._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategySimpleTurn._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategySimpleTurn.")
        
agcls.AgClassCatalog.add_catalog_entry("{5a0fd768-cf78-47cb-8a85-ccb1fbe68cee}", BasicManeuverStrategySimpleTurn)


class BasicManeuverStrategyAileronRoll(IBasicManeuverStrategyAileronRoll, IBasicManeuverStrategy):
    """Class defining the aileron roll strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyAileronRoll.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyAileronRoll._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyAileronRoll._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyAileronRoll._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyAileronRoll.")
        
agcls.AgClassCatalog.add_catalog_entry("{b8979539-00bf-46af-a412-9a16ebb57ac7}", BasicManeuverStrategyAileronRoll)


class BasicManeuverStrategyFlyAOA(IBasicManeuverStrategyFlyAOA, IBasicManeuverStrategy):
    """Class defining the fly AOA strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyFlyAOA.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyFlyAOA._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyFlyAOA._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyFlyAOA._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyFlyAOA.")
        
agcls.AgClassCatalog.add_catalog_entry("{f3c56de2-f58f-4292-a05b-d6e8f2756a55}", BasicManeuverStrategyFlyAOA)


class BasicManeuverStrategyPull(IBasicManeuverStrategyPull, IBasicManeuverStrategy):
    """Class defining the pull strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyPull.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyPull._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyPull._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyPull._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyPull.")
        
agcls.AgClassCatalog.add_catalog_entry("{7f14c043-4c1d-46f2-a3fd-112b17a27e82}", BasicManeuverStrategyPull)


class BasicManeuverStrategyRollingPull(IBasicManeuverStrategyRollingPull, IBasicManeuverStrategy):
    """Class defining the rolling pull strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRollingPull.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyRollingPull._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRollingPull._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRollingPull._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRollingPull.")
        
agcls.AgClassCatalog.add_catalog_entry("{abb3d02b-ae1f-482e-a903-cdc6bcb7bde1}", BasicManeuverStrategyRollingPull)


class BasicManeuverStrategySmoothAccel(IBasicManeuverStrategySmoothAccel, IBasicManeuverStrategy):
    """Class defining the smooth accel strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategySmoothAccel.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategySmoothAccel._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategySmoothAccel._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategySmoothAccel._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategySmoothAccel.")
        
agcls.AgClassCatalog.add_catalog_entry("{e5277844-1d1b-49ae-9a08-553e55823581}", BasicManeuverStrategySmoothAccel)


class BasicManeuverStrategySmoothTurn(IBasicManeuverStrategySmoothTurn, IBasicManeuverStrategy):
    """Class defining the smooth turn strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategySmoothTurn.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategySmoothTurn._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategySmoothTurn._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategySmoothTurn._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategySmoothTurn.")
        
agcls.AgClassCatalog.add_catalog_entry("{d55e7e13-72e2-4046-b7c7-a0702d951b03}", BasicManeuverStrategySmoothTurn)


class BasicManeuverAirspeedOptions(IBasicManeuverAirspeedOptions):
    """Class defining the airspeed options for basic maneuver strategies."""
    def __init__(self, sourceObject=None):
        IBasicManeuverAirspeedOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverAirspeedOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverAirspeedOptions._get_property(self, attrname) is not None: found_prop = IBasicManeuverAirspeedOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverAirspeedOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{0eb776dc-78a8-42db-b8c0-8c62611d7e44}", BasicManeuverAirspeedOptions)


class PropulsionThrust(IPropulsionThrust):
    """Class defining the the thrust propulsion used in basic maneuver procedures."""
    def __init__(self, sourceObject=None):
        IPropulsionThrust.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPropulsionThrust._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPropulsionThrust._get_property(self, attrname) is not None: found_prop = IPropulsionThrust._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PropulsionThrust.")
        
agcls.AgClassCatalog.add_catalog_entry("{50e5309a-e9f9-4dc0-8296-b3bf43a9b1a5}", PropulsionThrust)


class BasicManeuverStrategyAutopilotNav(IBasicManeuverStrategyAutopilotNav, IBasicManeuverStrategy):
    """Class defining the autopilot - horizontal plane strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyAutopilotNav.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyAutopilotNav._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyAutopilotNav._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyAutopilotNav._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyAutopilotNav.")
        
agcls.AgClassCatalog.add_catalog_entry("{129c0672-05c6-41ae-ae30-3aa82d83783a}", BasicManeuverStrategyAutopilotNav)


class BasicManeuverStrategyAutopilotProf(IBasicManeuverStrategyAutopilotProf, IBasicManeuverStrategy):
    """Class defining the autopiloc - vertical plane strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyAutopilotProf.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyAutopilotProf._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyAutopilotProf._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyAutopilotProf._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyAutopilotProf.")
        
agcls.AgClassCatalog.add_catalog_entry("{a86d3f81-6bd4-4f3d-8747-c1b31d7b06e9}", BasicManeuverStrategyAutopilotProf)


class BasicManeuverStrategyBarrelRoll(IBasicManeuverStrategyBarrelRoll, IBasicManeuverStrategy):
    """Class defining the barrel roll strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyBarrelRoll.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyBarrelRoll._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyBarrelRoll._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyBarrelRoll._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyBarrelRoll.")
        
agcls.AgClassCatalog.add_catalog_entry("{3ee92041-1fb9-4a53-ad71-9045d738fe7d}", BasicManeuverStrategyBarrelRoll)


class BasicManeuverStrategyLoop(IBasicManeuverStrategyLoop, IBasicManeuverStrategy):
    """Class defining the loop strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyLoop.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyLoop._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyLoop._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyLoop._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyLoop.")
        
agcls.AgClassCatalog.add_catalog_entry("{77780df4-1f0f-411c-a4eb-edfeb5d44d82}", BasicManeuverStrategyLoop)


class BasicManeuverStrategyLTAHover(IBasicManeuverStrategyLTAHover, IBasicManeuverStrategy):
    """Class defining the lighter than air hover strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyLTAHover.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyLTAHover._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyLTAHover._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyLTAHover._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyLTAHover.")
        
agcls.AgClassCatalog.add_catalog_entry("{5dfffe06-20ce-4e0e-903e-90ca3e60c273}", BasicManeuverStrategyLTAHover)


class BasicManeuverStrategyIntercept(IBasicManeuverStrategyIntercept, IBasicManeuverStrategy):
    """Class defining the Intercept strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyIntercept.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyIntercept._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyIntercept._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyIntercept._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyIntercept.")
        
agcls.AgClassCatalog.add_catalog_entry("{015abd40-d52a-479b-b9ef-92aadb650a42}", BasicManeuverStrategyIntercept)


class BasicManeuverStrategyRelativeBearing(IBasicManeuverStrategyRelativeBearing, IBasicManeuverStrategy):
    """Class defining the Relative Bearing strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelativeBearing.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyRelativeBearing._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelativeBearing._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelativeBearing._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelativeBearing.")
        
agcls.AgClassCatalog.add_catalog_entry("{e2ffd4c9-cab5-4e7d-972f-d7b0f6983a04}", BasicManeuverStrategyRelativeBearing)


class BasicManeuverStrategyRelativeCourse(IBasicManeuverStrategyRelativeCourse, IBasicManeuverStrategy):
    """Class defining the Relative Course strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelativeCourse.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyRelativeCourse._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelativeCourse._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelativeCourse._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelativeCourse.")
        
agcls.AgClassCatalog.add_catalog_entry("{b38ed3c1-d896-476f-8b6d-c5b6d72b4590}", BasicManeuverStrategyRelativeCourse)


class BasicManeuverStrategyRendezvous(IBasicManeuverStrategyRendezvous, IBasicManeuverStrategy):
    """Class defining the Rendezvous/Formation strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRendezvous.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyRendezvous._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRendezvous._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRendezvous._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRendezvous.")
        
agcls.AgClassCatalog.add_catalog_entry("{bb5fdd2b-8e95-40e1-8048-86547b0daff0}", BasicManeuverStrategyRendezvous)


class BasicManeuverStrategyStationkeeping(IBasicManeuverStrategyStationkeeping, IBasicManeuverStrategy):
    """Class defining the Stationkeeping strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyStationkeeping.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyStationkeeping._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyStationkeeping._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyStationkeeping._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyStationkeeping.")
        
agcls.AgClassCatalog.add_catalog_entry("{949ee147-7b1f-4f22-b721-aea0725b9116}", BasicManeuverStrategyStationkeeping)


class BasicManeuverStrategyRelativeFPA(IBasicManeuverStrategyRelativeFPA, IBasicManeuverStrategy):
    """Class defining the Relative Flight Path Angle strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelativeFPA.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyRelativeFPA._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelativeFPA._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelativeFPA._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelativeFPA.")
        
agcls.AgClassCatalog.add_catalog_entry("{dd290505-55b9-48a9-a800-451bcc816dd6}", BasicManeuverStrategyRelativeFPA)


class BasicManeuverStrategyRelSpeedAltitude(IBasicManeuverStrategyRelSpeedAltitude, IBasicManeuverStrategy):
    """Class defining the Relative Speed/Altitude strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelSpeedAltitude.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyRelSpeedAltitude._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelSpeedAltitude._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelSpeedAltitude._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelSpeedAltitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{72d18bdd-ad36-43ed-a8d6-6c25a7d88078}", BasicManeuverStrategyRelSpeedAltitude)


class BasicManeuverStrategyBezier(IBasicManeuverStrategyBezier, IBasicManeuverStrategy):
    """Class defining the Bezier strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyBezier.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyBezier._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyBezier._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyBezier._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyBezier.")
        
agcls.AgClassCatalog.add_catalog_entry("{84f1131f-4e28-4879-902c-bf5c2cbfff5b}", BasicManeuverStrategyBezier)


class BasicManeuverStrategyPushPull(IBasicManeuverStrategyPushPull, IBasicManeuverStrategy):
    """Class defining the Push/Pull strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyPushPull.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyPushPull._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyPushPull._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyPushPull._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyPushPull.")
        
agcls.AgClassCatalog.add_catalog_entry("{6184d781-4842-4e83-8211-fc4baab53395}", BasicManeuverStrategyPushPull)


class ProcedureHoldingCircular(IProcedureHoldingCircular, IProcedure):
    """Class defining a holding circular procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoldingCircular.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureHoldingCircular._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoldingCircular._get_property(self, attrname) is not None: found_prop = IProcedureHoldingCircular._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoldingCircular.")
        
agcls.AgClassCatalog.add_catalog_entry("{dec98be5-d1d2-4a97-bbcd-5a1f7ca5f158}", ProcedureHoldingCircular)


class ProcedureHoldingFigure8(IProcedureHoldingFigure8, IProcedure):
    """Class defining a holding figure 8 procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoldingFigure8.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureHoldingFigure8._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoldingFigure8._get_property(self, attrname) is not None: found_prop = IProcedureHoldingFigure8._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoldingFigure8.")
        
agcls.AgClassCatalog.add_catalog_entry("{cdd17fce-e24c-45f4-8b7c-b313f490e124}", ProcedureHoldingFigure8)


class ProcedureHoldingRacetrack(IProcedureHoldingRacetrack, IProcedure):
    """Class defining a holding racetrack procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoldingRacetrack.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureHoldingRacetrack._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoldingRacetrack._get_property(self, attrname) is not None: found_prop = IProcedureHoldingRacetrack._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoldingRacetrack.")
        
agcls.AgClassCatalog.add_catalog_entry("{d2aa71dd-b167-4eea-be1d-665e4fd586da}", ProcedureHoldingRacetrack)


class ProcedureTransitionToHover(IProcedureTransitionToHover, IProcedure):
    """Class defining a transition to hover procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTransitionToHover.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureTransitionToHover._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTransitionToHover._get_property(self, attrname) is not None: found_prop = IProcedureTransitionToHover._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTransitionToHover.")
        
agcls.AgClassCatalog.add_catalog_entry("{4cc8f381-2118-4c51-a1f4-68db53833efc}", ProcedureTransitionToHover)


class ProcedureTerrainFollow(IProcedureTerrainFollow, IProcedure):
    """Class defining a terrain following procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTerrainFollow.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureTerrainFollow._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTerrainFollow._get_property(self, attrname) is not None: found_prop = IProcedureTerrainFollow._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTerrainFollow.")
        
agcls.AgClassCatalog.add_catalog_entry("{3ab3ca3e-70dd-405c-a470-9bfbdfa23734}", ProcedureTerrainFollow)


class ProcedureHover(IProcedureHover, IProcedure):
    """Class defining a hover procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHover.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureHover._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHover._get_property(self, attrname) is not None: found_prop = IProcedureHover._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHover.")
        
agcls.AgClassCatalog.add_catalog_entry("{2af73325-a00b-405c-987c-af5f4e7f60cf}", ProcedureHover)


class ProcedureHoverTranslate(IProcedureHoverTranslate, IProcedure):
    """Class defining a hover translate procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoverTranslate.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureHoverTranslate._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoverTranslate._get_property(self, attrname) is not None: found_prop = IProcedureHoverTranslate._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoverTranslate.")
        
agcls.AgClassCatalog.add_catalog_entry("{fde61d2d-7896-4b38-a0cb-f3a2776c8cfb}", ProcedureHoverTranslate)


class ProcedureTransitionToForwardFlight(IProcedureTransitionToForwardFlight, IProcedure):
    """Class defining a transition to forward flight procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTransitionToForwardFlight.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureTransitionToForwardFlight._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTransitionToForwardFlight._get_property(self, attrname) is not None: found_prop = IProcedureTransitionToForwardFlight._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTransitionToForwardFlight.")
        
agcls.AgClassCatalog.add_catalog_entry("{f4e5896e-1457-4909-8b6f-0740d9852278}", ProcedureTransitionToForwardFlight)


class HoverAltitudeOptions(IHoverAltitudeOptions):
    """Class defining the altitude options for a VTOL procedure."""
    def __init__(self, sourceObject=None):
        IHoverAltitudeOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IHoverAltitudeOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IHoverAltitudeOptions._get_property(self, attrname) is not None: found_prop = IHoverAltitudeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in HoverAltitudeOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{feb66c2d-f9c7-472d-a389-4764db1d37bf}", HoverAltitudeOptions)


class ProcedureVerticalTakeoff(IProcedureVerticalTakeoff, IProcedure):
    """Class defining a vertical takeoff procedure."""
    def __init__(self, sourceObject=None):
        IProcedureVerticalTakeoff.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureVerticalTakeoff._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureVerticalTakeoff._get_property(self, attrname) is not None: found_prop = IProcedureVerticalTakeoff._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureVerticalTakeoff.")
        
agcls.AgClassCatalog.add_catalog_entry("{518b6d80-31d5-427e-b55f-8b299ba082b9}", ProcedureVerticalTakeoff)


class ProcedureVerticalLanding(IProcedureVerticalLanding, IProcedure):
    """Class defining a vertical landing procedure."""
    def __init__(self, sourceObject=None):
        IProcedureVerticalLanding.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureVerticalLanding._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureVerticalLanding._get_property(self, attrname) is not None: found_prop = IProcedureVerticalLanding._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureVerticalLanding.")
        
agcls.AgClassCatalog.add_catalog_entry("{68401463-90f1-4a74-9346-6e1e99906906}", ProcedureVerticalLanding)


class ProcedureReferenceState(IProcedureReferenceState, IProcedure):
    """Class defining a reference state procedure."""
    def __init__(self, sourceObject=None):
        IProcedureReferenceState.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureReferenceState._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureReferenceState._get_property(self, attrname) is not None: found_prop = IProcedureReferenceState._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureReferenceState.")
        
agcls.AgClassCatalog.add_catalog_entry("{44f22ac8-6eec-42ca-a433-dbf8b9fdaabf}", ProcedureReferenceState)


class ProcedureSuperProcedure(IProcedureSuperProcedure, IProcedure):
    """Class defining a super procedure."""
    def __init__(self, sourceObject=None):
        IProcedureSuperProcedure.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureSuperProcedure._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureSuperProcedure._get_property(self, attrname) is not None: found_prop = IProcedureSuperProcedure._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureSuperProcedure.")
        
agcls.AgClassCatalog.add_catalog_entry("{b49011b5-9b02-48df-9ddd-9936e7903017}", ProcedureSuperProcedure)


class ProcedureLaunch(IProcedureLaunch, IProcedure):
    """Class defining a launch procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLaunch.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureLaunch._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLaunch._get_property(self, attrname) is not None: found_prop = IProcedureLaunch._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLaunch.")
        
agcls.AgClassCatalog.add_catalog_entry("{4121a688-337a-4436-999f-9e1de57aab96}", ProcedureLaunch)


class ProcedureAirway(IProcedureAirway, IProcedure):
    """Class defining an Airway procedure."""
    def __init__(self, sourceObject=None):
        IProcedureAirway.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureAirway._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureAirway._get_property(self, attrname) is not None: found_prop = IProcedureAirway._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureAirway.")
        
agcls.AgClassCatalog.add_catalog_entry("{66c4d604-dac9-4eff-a18d-be1efb81f1f0}", ProcedureAirway)


class ProcedureAirwayRouter(IProcedureAirwayRouter, IProcedure):
    """Class defining an Airway Router procedure."""
    def __init__(self, sourceObject=None):
        IProcedureAirwayRouter.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureAirwayRouter._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureAirwayRouter._get_property(self, attrname) is not None: found_prop = IProcedureAirwayRouter._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureAirwayRouter.")
        
agcls.AgClassCatalog.add_catalog_entry("{c240ee52-dee2-42e0-a8c1-17f52b665f39}", ProcedureAirwayRouter)


class ProcedureAreaTargetSearch(IProcedureAreaTargetSearch, IProcedure):
    """Class defining an Area Target Search procedure."""
    def __init__(self, sourceObject=None):
        IProcedureAreaTargetSearch.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureAreaTargetSearch._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureAreaTargetSearch._get_property(self, attrname) is not None: found_prop = IProcedureAreaTargetSearch._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureAreaTargetSearch.")
        
agcls.AgClassCatalog.add_catalog_entry("{d065a50b-ba9e-4f25-831e-bb691df5cc71}", ProcedureAreaTargetSearch)


class ProcedureFormationRecover(IProcedureFormationRecover, IProcedure):
    """Class defining a Formation/Recover procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFormationRecover.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureFormationRecover._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFormationRecover._get_property(self, attrname) is not None: found_prop = IProcedureFormationRecover._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFormationRecover.")
        
agcls.AgClassCatalog.add_catalog_entry("{c3ca901a-fcb0-407b-a8d7-0f6972ebcd85}", ProcedureFormationRecover)


class ProcedureInFormation(IProcedureInFormation, IProcedure):
    """Class defining an In Formation procedure."""
    def __init__(self, sourceObject=None):
        IProcedureInFormation.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureInFormation._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureInFormation._get_property(self, attrname) is not None: found_prop = IProcedureInFormation._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureInFormation.")
        
agcls.AgClassCatalog.add_catalog_entry("{5f09f987-b896-4cc7-b356-732d0c1500b8}", ProcedureInFormation)


class ProcedureParallelFlightLine(IProcedureParallelFlightLine, IProcedure):
    """Class defining a Parallel Flight Line procedure."""
    def __init__(self, sourceObject=None):
        IProcedureParallelFlightLine.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureParallelFlightLine._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureParallelFlightLine._get_property(self, attrname) is not None: found_prop = IProcedureParallelFlightLine._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureParallelFlightLine.")
        
agcls.AgClassCatalog.add_catalog_entry("{3d83878f-7cda-46e8-b93f-9cbdc117244b}", ProcedureParallelFlightLine)


class ProcedureVGTPoint(IProcedureVGTPoint, IProcedure):
    """Class defining a VGT Point procedure."""
    def __init__(self, sourceObject=None):
        IProcedureVGTPoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureVGTPoint._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureVGTPoint._get_property(self, attrname) is not None: found_prop = IProcedureVGTPoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureVGTPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{c1c57b66-ecf6-47f5-be6a-36075f83917a}", ProcedureVGTPoint)


class PerformanceModelOptions(IPerformanceModelOptions):
    """Class defining the options for the active performance model in a phase."""
    def __init__(self, sourceObject=None):
        IPerformanceModelOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPerformanceModelOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPerformanceModelOptions._get_property(self, attrname) is not None: found_prop = IPerformanceModelOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PerformanceModelOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{d37c0417-9eab-4d38-8a3f-a70e144b5368}", PerformanceModelOptions)


class AdvFixedWingTool(IAdvFixedWingTool):
    """Class defining the options for the Advanced Fixed Wing Tool of an aircraft."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTool.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingTool._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTool._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTool._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTool.")
        
agcls.AgClassCatalog.add_catalog_entry("{e250469c-80a2-44d2-b53d-2712363d7b47}", AdvFixedWingTool)


class AdvFixedWingExternalAero(IAdvFixedWingExternalAero):
    """Class defining the External Aero File aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingExternalAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingExternalAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingExternalAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingExternalAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingExternalAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{0938800e-fa5d-446d-bf7b-3d79283da798}", AdvFixedWingExternalAero)


class AdvFixedWingSubsonicAero(IAdvFixedWingSubsonicAero):
    """Class defining the subsonic aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSubsonicAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingSubsonicAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSubsonicAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSubsonicAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSubsonicAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{ced4d6ca-5a7e-4640-936f-e0db35949454}", AdvFixedWingSubsonicAero)


class AdvFixedWingSubSuperHypersonicAero(IAdvFixedWingSubSuperHypersonicAero):
    """Class defining the Sub/Super/Hypersonic aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSubSuperHypersonicAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingSubSuperHypersonicAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSubSuperHypersonicAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSubSuperHypersonicAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSubSuperHypersonicAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{aa686d0d-7a40-44bb-b340-a5a5470ed81f}", AdvFixedWingSubSuperHypersonicAero)


class AdvFixedWingSupersonicAero(IAdvFixedWingSupersonicAero):
    """Class defining the supersonic aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSupersonicAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingSupersonicAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSupersonicAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSupersonicAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSupersonicAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{00683dc3-fc6d-4ba2-9d0b-306363523e17}", AdvFixedWingSupersonicAero)


class PerformanceModel(IPerformanceModel, ICatalogItem):
    """Class defining an unknown performance model."""
    def __init__(self, sourceObject=None):
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPerformanceModel._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PerformanceModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{07c21222-ddfa-4417-8739-aa7e41a6091a}", PerformanceModel)


class AdvFixedWingGeometryBasic(IAdvFixedWingGeometryBasic, IAdvFixedWingGeometry):
    """Class defining a basic geometry wing in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingGeometryBasic.__init__(self, sourceObject)
        IAdvFixedWingGeometry.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingGeometryBasic._private_init(self, pUnk)
        IAdvFixedWingGeometry._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingGeometryBasic._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometryBasic._get_property(self, attrname)
        if IAdvFixedWingGeometry._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometry._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingGeometryBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{3fccd7b1-9fd7-424e-a251-cadcc2d44a0a}", AdvFixedWingGeometryBasic)


class AdvFixedWingGeometryVariable(IAdvFixedWingGeometryVariable, IAdvFixedWingGeometry):
    """Class defining a variable geometry wing in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingGeometryVariable.__init__(self, sourceObject)
        IAdvFixedWingGeometry.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingGeometryVariable._private_init(self, pUnk)
        IAdvFixedWingGeometry._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingGeometryVariable._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometryVariable._get_property(self, attrname)
        if IAdvFixedWingGeometry._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometry._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingGeometryVariable.")
        
agcls.AgClassCatalog.add_catalog_entry("{a7cb26ac-fa5b-416d-b81b-8a5975937740}", AdvFixedWingGeometryVariable)


class AdvFixedWingElectricPowerplant(IAdvFixedWingElectricPowerplant):
    """Class defining an Electric powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingElectricPowerplant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingElectricPowerplant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingElectricPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingElectricPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingElectricPowerplant.")
        
agcls.AgClassCatalog.add_catalog_entry("{64f956f4-4b87-4b13-b459-efef51191309}", AdvFixedWingElectricPowerplant)


class AdvFixedWingExternalProp(IAdvFixedWingExternalProp):
    """Class defining an External Prop File powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingExternalProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingExternalProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingExternalProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingExternalProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingExternalProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{86d612c4-8537-48d7-912b-931a2c939c8e}", AdvFixedWingExternalProp)


class AdvFixedWingSubSuperHypersonicProp(IAdvFixedWingSubSuperHypersonicProp):
    """Class defining a Sub/Super/Hypersonic powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSubSuperHypersonicProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingSubSuperHypersonicProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSubSuperHypersonicProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSubSuperHypersonicProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSubSuperHypersonicProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{15279d03-0f3b-458d-957c-2cdee97bc0a8}", AdvFixedWingSubSuperHypersonicProp)


class AdvFixedWingPistonPowerplant(IAdvFixedWingPistonPowerplant):
    """Class defining a Piston powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingPistonPowerplant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingPistonPowerplant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingPistonPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingPistonPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingPistonPowerplant.")
        
agcls.AgClassCatalog.add_catalog_entry("{dd383e2b-f1e9-4afe-9241-4d89e95db034}", AdvFixedWingPistonPowerplant)


class AdvFixedWingEmpiricalJetEngine(IAdvFixedWingEmpiricalJetEngine):
    """Class defining the Turbojet and Turbofan empirical models in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingEmpiricalJetEngine.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingEmpiricalJetEngine._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingEmpiricalJetEngine._get_property(self, attrname) is not None: found_prop = IAdvFixedWingEmpiricalJetEngine._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingEmpiricalJetEngine.")
        
agcls.AgClassCatalog.add_catalog_entry("{cf86965f-eacf-47ca-a6b8-5c69a1f9612f}", AdvFixedWingEmpiricalJetEngine)


class AdvFixedWingTurbofanBasicABPowerplant(IAdvFixedWingTurbofanBasicABPowerplant):
    """This class is deprecated. Use AdvFixedWingTurbofanBasicABProp instead."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbofanBasicABPowerplant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingTurbofanBasicABPowerplant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbofanBasicABPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbofanBasicABPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbofanBasicABPowerplant.")
        
agcls.AgClassCatalog.add_catalog_entry("{27a6cd0b-bd9b-4af7-9367-9d2ce3fa39cd}", AdvFixedWingTurbofanBasicABPowerplant)


class AdvFixedWingTurbojetBasicABPowerplant(IAdvFixedWingTurbojetBasicABPowerplant):
    """This class is deprecated. Use AdvFixedWingTurbojetBasicABProp instead."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbojetBasicABPowerplant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingTurbojetBasicABPowerplant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbojetBasicABPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbojetBasicABPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbojetBasicABPowerplant.")
        
agcls.AgClassCatalog.add_catalog_entry("{65230337-ecdc-4b80-92aa-107af1bcfdbe}", AdvFixedWingTurbojetBasicABPowerplant)


class AdvFixedWingTurbofanBasicABProp(IAdvFixedWingTurbofanBasicABProp):
    """Class defining the Turbofan - Basic w/AB (Thermodynamic model) powerplant in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbofanBasicABProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingTurbofanBasicABProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbofanBasicABProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbofanBasicABProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbofanBasicABProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{327e3a7a-ecce-445e-b105-2dbec0239e6d}", AdvFixedWingTurbofanBasicABProp)


class AdvFixedWingTurbojetBasicABProp(IAdvFixedWingTurbojetBasicABProp):
    """Class defining the Turbojet - Basic w/AB (Thermodynamic model) powerplant in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbojetBasicABProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingTurbojetBasicABProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbojetBasicABProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbojetBasicABProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbojetBasicABProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{c60f96fa-5802-4d89-b522-2a1dd5e03ca0}", AdvFixedWingTurbojetBasicABProp)


class AdvFixedWingTurbopropPowerplant(IAdvFixedWingTurbopropPowerplant):
    """Class defining the Turboprop powerplant in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbopropPowerplant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingTurbopropPowerplant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbopropPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbopropPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbopropPowerplant.")
        
agcls.AgClassCatalog.add_catalog_entry("{7ac5402a-9b5d-4fc9-94b5-365e9bc1e25e}", AdvFixedWingTurbopropPowerplant)


class MissileSimpleAero(IMissileSimpleAero):
    """Class defining the simple aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileSimpleAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileSimpleAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileSimpleAero._get_property(self, attrname) is not None: found_prop = IMissileSimpleAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileSimpleAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{99dff5f7-c73c-414d-9c38-2e7b35c93f5e}", MissileSimpleAero)


class MissileExternalAero(IMissileExternalAero):
    """Class defining the external aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileExternalAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileExternalAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileExternalAero._get_property(self, attrname) is not None: found_prop = IMissileExternalAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileExternalAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{92940e34-6d78-4e39-b774-4a865e9d0bc0}", MissileExternalAero)


class MissileAdvancedAero(IMissileAdvancedAero):
    """Class defining the advanced aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileAdvancedAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileAdvancedAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileAdvancedAero._get_property(self, attrname) is not None: found_prop = IMissileAdvancedAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileAdvancedAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{becfe264-7b70-461f-9f64-b0d23aa59f1e}", MissileAdvancedAero)


class MissileAero(IMissileAero):
    """Class defining the aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileAero.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileAero._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileAero._get_property(self, attrname) is not None: found_prop = IMissileAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileAero.")
        
agcls.AgClassCatalog.add_catalog_entry("{bc518434-5a42-49e0-8a54-8212a797c728}", MissileAero)


class MissileProp(IMissileProp):
    """Class defining the propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileProp._get_property(self, attrname) is not None: found_prop = IMissileProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{544b60ce-22da-4e8b-a222-ffd4bc070a01}", MissileProp)


class MissileSimpleProp(IMissileSimpleProp):
    """Class defining the Simple propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileSimpleProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileSimpleProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileSimpleProp._get_property(self, attrname) is not None: found_prop = IMissileSimpleProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileSimpleProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{e92e2a28-9614-4afe-97ee-8e0d90e4ee3b}", MissileSimpleProp)


class MissileExternalProp(IMissileExternalProp):
    """Class defining the External propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileExternalProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileExternalProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileExternalProp._get_property(self, attrname) is not None: found_prop = IMissileExternalProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileExternalProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{4b7a80c7-e7a6-453b-a423-1c53ac68c0bc}", MissileExternalProp)


class MissileRamjetProp(IMissileRamjetProp):
    """Class defining the Ramjet propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileRamjetProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileRamjetProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileRamjetProp._get_property(self, attrname) is not None: found_prop = IMissileRamjetProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileRamjetProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{0bef31b2-9f2c-4dea-b475-e2feeb55052e}", MissileRamjetProp)


class MissileRocketProp(IMissileRocketProp):
    """Class defining the Rocket propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileRocketProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileRocketProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileRocketProp._get_property(self, attrname) is not None: found_prop = IMissileRocketProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileRocketProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{68296bb7-edd5-4305-8b51-3f3d0c7d4428}", MissileRocketProp)


class MissileTurbojetProp(IMissileTurbojetProp):
    """Class defining the Turbojet propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileTurbojetProp.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissileTurbojetProp._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileTurbojetProp._get_property(self, attrname) is not None: found_prop = IMissileTurbojetProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileTurbojetProp.")
        
agcls.AgClassCatalog.add_catalog_entry("{6024d1a7-768e-4015-abb3-e0539d431ff9}", MissileTurbojetProp)


class ReferenceStateForwardFlightOptions(IReferenceStateForwardFlightOptions):
    """Class defining the Forward Flight options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateForwardFlightOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IReferenceStateForwardFlightOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateForwardFlightOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateForwardFlightOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateForwardFlightOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{6f60fd0b-6c79-48a5-908b-b5d697552b94}", ReferenceStateForwardFlightOptions)


class ReferenceStateTakeoffLandingOptions(IReferenceStateTakeoffLandingOptions):
    """Class defining the Takeoff or Landing options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateTakeoffLandingOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IReferenceStateTakeoffLandingOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateTakeoffLandingOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateTakeoffLandingOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateTakeoffLandingOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{5a54840f-128e-411c-af24-2e2c49fbd922}", ReferenceStateTakeoffLandingOptions)


class ReferenceStateHoverOptions(IReferenceStateHoverOptions):
    """Class defining the Hover options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateHoverOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IReferenceStateHoverOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateHoverOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateHoverOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateHoverOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{0767b34e-3bc9-447d-956e-5e0939cc9bfc}", ReferenceStateHoverOptions)


class ReferenceStateWeightOnWheelsOptions(IReferenceStateWeightOnWheelsOptions):
    """Class defining the Weight on Wheels options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateWeightOnWheelsOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IReferenceStateWeightOnWheelsOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateWeightOnWheelsOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateWeightOnWheelsOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateWeightOnWheelsOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{de32d95c-707b-41dd-a7de-072506f171b9}", ReferenceStateWeightOnWheelsOptions)


class SiteRunwayFromCatalog(ISiteRunwayFromCatalog, ISite):
    """Class defining a runway from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteRunwayFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteRunwayFromCatalog._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRunwayFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteRunwayFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRunwayFromCatalog.")
        
agcls.AgClassCatalog.add_catalog_entry("{9220ceaa-69a7-4b64-8dfe-ec4ca0083d3e}", SiteRunwayFromCatalog)


class SiteAirportFromCatalog(ISiteAirportFromCatalog, ISite):
    """Class defining a airport from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteAirportFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteAirportFromCatalog._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteAirportFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteAirportFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteAirportFromCatalog.")
        
agcls.AgClassCatalog.add_catalog_entry("{b5a44f89-2af4-41bd-8ebc-8e503f43f912}", SiteAirportFromCatalog)


class SiteNavaidFromCatalog(ISiteNavaidFromCatalog, ISite):
    """Class defining a navaid from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteNavaidFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteNavaidFromCatalog._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteNavaidFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteNavaidFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteNavaidFromCatalog.")
        
agcls.AgClassCatalog.add_catalog_entry("{59135b93-5164-4c35-8128-de6a6376a66f}", SiteNavaidFromCatalog)


class SiteVTOLPointFromCatalog(ISiteVTOLPointFromCatalog, ISite):
    """Class defining a VTOL point from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteVTOLPointFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteVTOLPointFromCatalog._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteVTOLPointFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteVTOLPointFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteVTOLPointFromCatalog.")
        
agcls.AgClassCatalog.add_catalog_entry("{189c8c0a-c6a4-424f-b2ff-b1e466c38cd4}", SiteVTOLPointFromCatalog)


class SiteWaypointFromCatalog(ISiteWaypointFromCatalog, ISite):
    """Class defining a waypoint from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteWaypointFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteWaypointFromCatalog._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteWaypointFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteWaypointFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteWaypointFromCatalog.")
        
agcls.AgClassCatalog.add_catalog_entry("{d620651a-2526-43c8-8715-122ad6d6eb40}", SiteWaypointFromCatalog)


class NavaidCategory(INavaidCategory):
    """Class defining the navaid category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        INavaidCategory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        INavaidCategory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if INavaidCategory._get_property(self, attrname) is not None: found_prop = INavaidCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in NavaidCategory.")
        
agcls.AgClassCatalog.add_catalog_entry("{9cab926c-f92d-4b63-9588-d5e849f047bf}", NavaidCategory)


class VTOLPointCategory(IVTOLPointCategory):
    """Class defining the VTOL point category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IVTOLPointCategory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVTOLPointCategory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVTOLPointCategory._get_property(self, attrname) is not None: found_prop = IVTOLPointCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VTOLPointCategory.")
        
agcls.AgClassCatalog.add_catalog_entry("{35a0a9ce-18bd-47b5-927a-1cb825edab22}", VTOLPointCategory)


class WaypointCategory(IWaypointCategory):
    """Class defining the waypoint category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IWaypointCategory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IWaypointCategory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWaypointCategory._get_property(self, attrname) is not None: found_prop = IWaypointCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WaypointCategory.")
        
agcls.AgClassCatalog.add_catalog_entry("{502442da-96cc-4a07-9124-9d4e4c287801}", WaypointCategory)


class ARINC424Navaid(IARINC424Item, ICatalogNavaid, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Navaid."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogNavaid.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IARINC424Item._private_init(self, pUnk)
        ICatalogNavaid._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogNavaid._get_property(self, attrname) is not None: found_prop = ICatalogNavaid._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Navaid.")
        
agcls.AgClassCatalog.add_catalog_entry("{18308bdb-0318-4820-87c7-59e4ad432c0f}", ARINC424Navaid)


class ARINC424Helipad(IARINC424Item, ICatalogVTOLPoint, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Helipad."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogVTOLPoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IARINC424Item._private_init(self, pUnk)
        ICatalogVTOLPoint._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogVTOLPoint._get_property(self, attrname) is not None: found_prop = ICatalogVTOLPoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Helipad.")
        
agcls.AgClassCatalog.add_catalog_entry("{6cf2bbc6-dcf3-493e-ad3d-bf58879edd2d}", ARINC424Helipad)


class ARINC424Waypoint(IARINC424Item, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Waypoint."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IARINC424Item._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Waypoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{55d1b405-651f-4687-a34a-f0bb64ec8814}", ARINC424Waypoint)


class UserVTOLPointSource(IUserVTOLPointSource, ICatalogSource):
    """Class defining the user VTOL Point source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserVTOLPointSource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVTOLPointSource._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVTOLPointSource._get_property(self, attrname) is not None: found_prop = IUserVTOLPointSource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVTOLPointSource.")
        
agcls.AgClassCatalog.add_catalog_entry("{dfc0b12b-f8c4-4d99-bb5c-6aecebe0ea7d}", UserVTOLPointSource)


class UserVTOLPoint(IUserVTOLPoint, ICatalogVTOLPoint, ICatalogWaypoint, ICatalogItem):
    """Class defining the user VTOL Point in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserVTOLPoint.__init__(self, sourceObject)
        ICatalogVTOLPoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVTOLPoint._private_init(self, pUnk)
        ICatalogVTOLPoint._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVTOLPoint._get_property(self, attrname) is not None: found_prop = IUserVTOLPoint._get_property(self, attrname)
        if ICatalogVTOLPoint._get_property(self, attrname) is not None: found_prop = ICatalogVTOLPoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVTOLPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{748a44bd-4d22-4800-a311-fc8c95901638}", UserVTOLPoint)


class UserWaypointSource(IUserWaypointSource, ICatalogSource):
    """Class defining the user waypoint source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserWaypointSource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserWaypointSource._private_init(self, pUnk)
        ICatalogSource._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserWaypointSource._get_property(self, attrname) is not None: found_prop = IUserWaypointSource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserWaypointSource.")
        
agcls.AgClassCatalog.add_catalog_entry("{7f85e32f-b5a1-4d12-b7ac-a817dd7162d0}", UserWaypointSource)


class UserWaypoint(IUserWaypoint, ICatalogWaypoint, ICatalogItem):
    """Class defining the user waypoint in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserWaypoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserWaypoint._private_init(self, pUnk)
        ICatalogWaypoint._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserWaypoint._get_property(self, attrname) is not None: found_prop = IUserWaypoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserWaypoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{ca33c45d-2eba-409b-aa44-b57b5a57e3b3}", UserWaypoint)


class PropulsionEfficiencies(IPropulsionEfficiencies):
    """Class defining the Propulsion Efficiencies and Losses of a jet engine powerplant in the advanced fixed wing tool."""
    def __init__(self, sourceObject=None):
        IPropulsionEfficiencies.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPropulsionEfficiencies._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPropulsionEfficiencies._get_property(self, attrname) is not None: found_prop = IPropulsionEfficiencies._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PropulsionEfficiencies.")
        
agcls.AgClassCatalog.add_catalog_entry("{0af7363a-b62a-4eaf-a4b5-4103197bc6b1}", PropulsionEfficiencies)


class FuelModelKeroseneAFPROP(IFuelModelKeroseneAFPROP):
    """Class defining the Kerosense - AFPROP fuel type for a thermodynamic jet engine model."""
    def __init__(self, sourceObject=None):
        IFuelModelKeroseneAFPROP.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFuelModelKeroseneAFPROP._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelModelKeroseneAFPROP._get_property(self, attrname) is not None: found_prop = IFuelModelKeroseneAFPROP._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelModelKeroseneAFPROP.")
        
agcls.AgClassCatalog.add_catalog_entry("{fb23d809-5785-4a45-b914-415015e6d9eb}", FuelModelKeroseneAFPROP)


class FuelModelKeroseneCEA(IFuelModelKeroseneCEA):
    """Class defining the Kerosense - CEA fuel type for a thermodynamic jet engine model."""
    def __init__(self, sourceObject=None):
        IFuelModelKeroseneCEA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFuelModelKeroseneCEA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelModelKeroseneCEA._get_property(self, attrname) is not None: found_prop = IFuelModelKeroseneCEA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelModelKeroseneCEA.")
        
agcls.AgClassCatalog.add_catalog_entry("{6df7fa84-6983-4ed2-9447-a11d0fbd0fac}", FuelModelKeroseneCEA)


class AdvFixedWingRamjetBasic(IAdvFixedWingRamjetBasic):
    """Class defining the basic Ramjet model."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingRamjetBasic.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingRamjetBasic._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingRamjetBasic._get_property(self, attrname) is not None: found_prop = IAdvFixedWingRamjetBasic._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingRamjetBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{9f333e9b-3d22-429d-9880-940122216dde}", AdvFixedWingRamjetBasic)


class AdvFixedWingScramjetBasic(IAdvFixedWingScramjetBasic):
    """Class defining the basic Scramjet model."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingScramjetBasic.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAdvFixedWingScramjetBasic._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingScramjetBasic._get_property(self, attrname) is not None: found_prop = IAdvFixedWingScramjetBasic._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingScramjetBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{6caec1e6-8cf4-4752-89c6-42b55473f144}", AdvFixedWingScramjetBasic)


class AircraftVTOLModel(IAircraftVTOLModel):
    """Class defining the VTOL performance model of an aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftVTOLModel.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftVTOLModel._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftVTOLModel._get_property(self, attrname) is not None: found_prop = IAircraftVTOLModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftVTOLModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{5fb18d9d-20cb-408e-a0d0-60f5cdd9dc2c}", AircraftVTOLModel)


class AircraftVTOL(IAircraftVTOL, ICatalogItem):
    """Class defining the VTOL category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftVTOL.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftVTOL._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftVTOL._get_property(self, attrname) is not None: found_prop = IAircraftVTOL._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftVTOL.")
        
agcls.AgClassCatalog.add_catalog_entry("{c1bd235a-6ffc-435c-900d-0ff6a7ca5422}", AircraftVTOL)


class AircraftTerrainFollowModel(IAircraftTerrainFollowModel):
    """Class defining the TerrainFollow performance model of an aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftTerrainFollowModel.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftTerrainFollowModel._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftTerrainFollowModel._get_property(self, attrname) is not None: found_prop = IAircraftTerrainFollowModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftTerrainFollowModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{27d2c971-cdce-4465-a3df-eaf526de6c01}", AircraftTerrainFollowModel)


class AircraftTerrainFollow(IAircraftTerrainFollow, ICatalogItem):
    """Class defining the TerrainFollow category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftTerrainFollow.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAircraftTerrainFollow._private_init(self, pUnk)
        ICatalogItem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftTerrainFollow._get_property(self, attrname) is not None: found_prop = IAircraftTerrainFollow._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftTerrainFollow.")
        
agcls.AgClassCatalog.add_catalog_entry("{683bec0d-293d-4afa-a1ab-b23b123d62e4}", AircraftTerrainFollow)


class BasicManeuverStrategyBallistic3D(IBasicManeuverStrategyBallistic3D, IBasicManeuverStrategy):
    """Class defining Ballistic 3D strategy for a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyBallistic3D.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyBallistic3D._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyBallistic3D._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyBallistic3D._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyBallistic3D.")
        
agcls.AgClassCatalog.add_catalog_entry("{ec8f88ae-2944-459b-90aa-f8df3e74bf89}", BasicManeuverStrategyBallistic3D)


class ProcedureLaunchDynState(IProcedureLaunchDynState, IProcedure):
    """Class defining a Launch Dyn State procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLaunchDynState.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureLaunchDynState._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLaunchDynState._get_property(self, attrname) is not None: found_prop = IProcedureLaunchDynState._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLaunchDynState.")
        
agcls.AgClassCatalog.add_catalog_entry("{AA90861B-C8E1-46D1-BA87-47F27D731B84}", ProcedureLaunchDynState)


class ProcedureLaunchWaypoint(IProcedureLaunchWaypoint, IProcedure):
    """Class defining a Launch Waypoint procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLaunchWaypoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureLaunchWaypoint._private_init(self, pUnk)
        IProcedure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLaunchWaypoint._get_property(self, attrname) is not None: found_prop = IProcedureLaunchWaypoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLaunchWaypoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{05730C66-FF4D-4A05-A821-C541134119CE}", ProcedureLaunchWaypoint)


class SiteDynState(ISiteDynState, ISite):
    """Class defining a Dyn State site."""
    def __init__(self, sourceObject=None):
        ISiteDynState.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISiteDynState._private_init(self, pUnk)
        ISite._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteDynState._get_property(self, attrname) is not None: found_prop = ISiteDynState._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteDynState.")
        
agcls.AgClassCatalog.add_catalog_entry("{DF907297-E5CC-4346-9E97-95A3AFEE02FD}", SiteDynState)


class BasicManeuverStrategyPitch3D(IBasicManeuverStrategyPitch3D, IBasicManeuverStrategy):
    """Class defining Pitch 3D strategy for a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyPitch3D.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBasicManeuverStrategyPitch3D._private_init(self, pUnk)
        IBasicManeuverStrategy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyPitch3D._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyPitch3D._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyPitch3D.")
        
agcls.AgClassCatalog.add_catalog_entry("{A10EDD83-CED6-4747-AFBA-948653338437}", BasicManeuverStrategyPitch3D)


class RefuelDumpProperties(IRefuelDumpProperties):
    """Class defining the refuel/dump properties for the current procedure."""
    def __init__(self, sourceObject=None):
        IRefuelDumpProperties.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRefuelDumpProperties._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRefuelDumpProperties._get_property(self, attrname) is not None: found_prop = IRefuelDumpProperties._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RefuelDumpProperties.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CB1E862-FDED-463D-B449-C39030B149D6}", RefuelDumpProperties)


class ProcedureFastTimeOptions(IProcedureFastTimeOptions):
    """Class defining fast operations (without error or constraint checks) for time options for the current procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFastTimeOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProcedureFastTimeOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFastTimeOptions._get_property(self, attrname) is not None: found_prop = IProcedureFastTimeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFastTimeOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{D69CF956-3A04-48F1-B553-7A10412253A0}", ProcedureFastTimeOptions)



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
