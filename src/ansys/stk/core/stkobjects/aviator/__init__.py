################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################ 

__all__ = ["ACCELERATION_ADV_ACCEL_MODE", "ACCEL_MANEUVER_AERO_PROP_MODE", "ACCEL_MANEUVER_MODE", "ACCEL_MODE", "ACCEL_PERF_MODEL_OVERRIDE", 
"ADDSMessage", "ADDSMessageCollection", "ADDS_FORECAST_TYPE", "ADDS_MISSING_MSG_TYPE", "ADDS_MSG_EXTRAP_TYPE", "ADDS_MSG_INTERP_TYPE", 
"ADV_FIXED_WING_AERO_STRATEGY", "ADV_FIXED_WING_GEOMETRY", "ADV_FIXED_WING_POWERPLANT_STRATEGY", "AERO_PROP_FLIGHT_MODE", 
"AERO_PROP_SIMPLE_MODE", "AFPROP_FUEL_TYPE", "AGL_MSL", "AILERON_ROLL_FLIGHT_PATH", "AILERON_ROLL_MODE", "AIRCRAFT_AERO_STRATEGY", 
"AIRCRAFT_PROP_STRATEGY", "AIRSPEED_TYPE", "ALTITUDE_CONSTRAINT_MANEUVER_MODE", "ALTITUDE_REFERENCE", "AND_OR", "ANGLE_MODE", 
"APPROACH_MODE", "ARINC424Airport", "ARINC424Helipad", "ARINC424Navaid", "ARINC424Runway", "ARINC424Source", "ARINC424Waypoint", 
"ATMOSPHERE_MODEL", "AUTOPILOT_ALTITUDE_CONTROL_MODE", "AUTOPILOT_ALTITUDE_MODE", "AUTOPILOT_HORIZ_PLANE_MODE", "AdvFixedWingElectricPowerplant", 
"AdvFixedWingEmpiricalJetEngine", "AdvFixedWingExternalAero", "AdvFixedWingExternalProp", "AdvFixedWingGeometryBasic", "AdvFixedWingGeometryVariable", 
"AdvFixedWingPistonPowerplant", "AdvFixedWingRamjetBasic", "AdvFixedWingScramjetBasic", "AdvFixedWingSubSuperHypersonicAero", 
"AdvFixedWingSubSuperHypersonicProp", "AdvFixedWingSubsonicAero", "AdvFixedWingSupersonicAero", "AdvFixedWingTool", "AdvFixedWingTurbofanBasicABPowerplant", 
"AdvFixedWingTurbofanBasicABProp", "AdvFixedWingTurbojetBasicABPowerplant", "AdvFixedWingTurbojetBasicABProp", "AdvFixedWingTurbopropPowerplant", 
"AeroPropManeuverModeHelper", "AircraftAcceleration", "AircraftAccelerationMode", "AircraftAdvAccelerationModel", "AircraftAdvClimbModel", 
"AircraftAdvCruiseModel", "AircraftAdvDescentModel", "AircraftAdvLandingModel", "AircraftAdvTakeoffModel", "AircraftAero", 
"AircraftBasicAccelerationModel", "AircraftBasicClimbModel", "AircraftBasicCruiseModel", "AircraftBasicDescentModel", "AircraftBasicFixedWingAero", 
"AircraftBasicFixedWingProp", "AircraftBasicLandingModel", "AircraftBasicTakeoffModel", "AircraftCategory", "AircraftClimb", 
"AircraftCruise", "AircraftDescent", "AircraftExternalAero", "AircraftExternalProp", "AircraftLanding", "AircraftModel", 
"AircraftModels", "AircraftProp", "AircraftSimpleAero", "AircraftSimpleProp", "AircraftTakeoff", "AircraftTerrainFollow", 
"AircraftTerrainFollowModel", "AircraftVTOL", "AircraftVTOLModel", "AirportCategory", "AltitudeMSLAndLevelOffOptions", "AltitudeMSLOptions", 
"AltitudeOptions", "ArcAltitudeAndDelayOptions", "ArcAltitudeOptions", "ArcOptions", "ArcVerticalPlaneOptions", "AtmosphereModel", 
"AtmosphereModelBasic", "AttitudeTransitions", "AviatorPropagator", "BALLISTIC_3D_CONTROL_MODE", "BASIC_FIXED_WING_PROP_MODE", 
"BASIC_MANEUVER_AIRSPEED_MODE", "BASIC_MANEUVER_ALTITUDE_LIMIT", "BASIC_MANEUVER_FUEL_FLOW_TYPE", "BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE", 
"BASIC_MANEUVER_REFERENCE_FRAME", "BASIC_MANEUVER_STRATEGY", "BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS", "BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", 
"BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE", "BasicFixedWingFwdFlightLiftHelper", "BasicManeuverAirspeedOptions", "BasicManeuverStrategyAileronRoll", 
"BasicManeuverStrategyAutopilotNav", "BasicManeuverStrategyAutopilotProf", "BasicManeuverStrategyBallistic3D", "BasicManeuverStrategyBarrelRoll", 
"BasicManeuverStrategyBezier", "BasicManeuverStrategyCruiseProfile", "BasicManeuverStrategyFlyAOA", "BasicManeuverStrategyGlideProfile", 
"BasicManeuverStrategyIntercept", "BasicManeuverStrategyLTAHover", "BasicManeuverStrategyLoop", "BasicManeuverStrategyPitch3D", 
"BasicManeuverStrategyPull", "BasicManeuverStrategyPushPull", "BasicManeuverStrategyRelSpeedAltitude", "BasicManeuverStrategyRelativeBearing", 
"BasicManeuverStrategyRelativeCourse", "BasicManeuverStrategyRelativeFPA", "BasicManeuverStrategyRendezvous", "BasicManeuverStrategyRollingPull", 
"BasicManeuverStrategySimpleTurn", "BasicManeuverStrategySmoothAccel", "BasicManeuverStrategySmoothTurn", "BasicManeuverStrategyStationkeeping", 
"BasicManeuverStrategyStraightAhead", "BasicManeuverStrategyWeave", "BasicManeuverTargetPositionVel", "BasicManeuverTargetPositionVelNoisyBrnRng", 
"BasicManeuverTargetPositionVelNoisySurfTgt", "CEA_FUEL_TYPE", "CLIMB_SPEED_TYPE", "CLOSURE_MODE", "CLOSURE_VALUE", "CRUISE_MAX_PERF_SPEED_TYPE", 
"CRUISE_SPEED", "CalculationOptions", "Catalog", "ClimbAndDescentTransitions", "Configuration", "CruiseAirspeedAndProfileOptions", 
"CruiseAirspeedOptions", "CruiseAirspeedProfile", "DAFIFHelipad", "DAFIFRunway", "DAFIFSource", "DAFIFWaypoint", "DELAY_ALTITUDE_MODE", 
"DELAY_TURN_DIRECTION", "DEPARTURE_SPEED_MODE", "DESCENT_SPEED_TYPE", "ERROR_CODES", "EXT_EPHEM_FLIGHT_MODE", "EnrouteAndDelayOptions", 
"EnrouteOptions", "EnrouteTurnDirectionOptions", "FLIGHT_LINE_PROC_TYPE", "FLY_AOA_LEFT_RIGHT", "FLY_TO_FLIGHT_PATH_ANGLE_MODE", 
"FORMATION_FLYER_STOP_CONDITION", "FUEL_FLOW_TYPE", "FuelModelKeroseneAFPROP", "FuelModelKeroseneCEA", "FuelTankExternal", 
"FuelTankInternal", "HOLDING_DIRECTION", "HOLDING_ENTRY_MANEUVER", "HOLDING_PROFILE_MODE", "HOLD_REFUEL_DUMP_MODE", "HOVER_ALTITUDE_MODE", 
"HOVER_HEADING_MODE", "HOVER_MODE", "HoverAltitudeOptions", "IADDSMessage", "IADDSMessageCollection", "IARINC424Airport", 
"IARINC424Item", "IARINC424Runway", "IARINC424Source", "IAdvFixedWingElectricPowerplant", "IAdvFixedWingEmpiricalJetEngine", 
"IAdvFixedWingExternalAero", "IAdvFixedWingExternalProp", "IAdvFixedWingGeometry", "IAdvFixedWingGeometryBasic", "IAdvFixedWingGeometryVariable", 
"IAdvFixedWingPistonPowerplant", "IAdvFixedWingPowerplant", "IAdvFixedWingRamjetBasic", "IAdvFixedWingScramjetBasic", "IAdvFixedWingSubSuperHypersonicAero", 
"IAdvFixedWingSubSuperHypersonicProp", "IAdvFixedWingSubsonicAero", "IAdvFixedWingSupersonicAero", "IAdvFixedWingTool", 
"IAdvFixedWingTurbofanBasicABPowerplant", "IAdvFixedWingTurbofanBasicABProp", "IAdvFixedWingTurbojetBasicABPowerplant", 
"IAdvFixedWingTurbojetBasicABProp", "IAdvFixedWingTurbopropPowerplant", "IAeroPropManeuverModeHelper", "IAircraftAcceleration", 
"IAircraftAccelerationMode", "IAircraftAdvAccelerationModel", "IAircraftAdvClimbModel", "IAircraftAdvCruiseModel", "IAircraftAdvDescentModel", 
"IAircraftAdvLandingModel", "IAircraftAdvTakeoffModel", "IAircraftAero", "IAircraftBasicAccelerationModel", "IAircraftBasicClimbModel", 
"IAircraftBasicCruiseModel", "IAircraftBasicDescentModel", "IAircraftBasicFixedWingAero", "IAircraftBasicFixedWingProp", 
"IAircraftBasicLandingModel", "IAircraftBasicTakeoffModel", "IAircraftCategory", "IAircraftClimb", "IAircraftCruise", "IAircraftDescent", 
"IAircraftExternalAero", "IAircraftExternalProp", "IAircraftLanding", "IAircraftModel", "IAircraftModels", "IAircraftProp", 
"IAircraftSimpleAero", "IAircraftSimpleProp", "IAircraftTakeoff", "IAircraftTerrainFollow", "IAircraftTerrainFollowModel", 
"IAircraftVTOL", "IAircraftVTOLModel", "IAirportCategory", "IAltitudeMSLAndLevelOffOptions", "IAltitudeMSLOptions", "IAltitudeOptions", 
"IArcAltitudeAndDelayOptions", "IArcAltitudeOptions", "IArcOptions", "IArcVerticalPlaneOptions", "IAtmosphereModel", "IAtmosphereModelBasic", 
"IAttitudeTransitions", "IAutomationStrategyFactory", "IAviatorPropagator", "IAviatorVehicle", "IBasicFixedWingLiftHelper", 
"IBasicManeuverAirspeedOptions", "IBasicManeuverStrategy", "IBasicManeuverStrategyAileronRoll", "IBasicManeuverStrategyAutopilotNav", 
"IBasicManeuverStrategyAutopilotProf", "IBasicManeuverStrategyBallistic3D", "IBasicManeuverStrategyBarrelRoll", "IBasicManeuverStrategyBezier", 
"IBasicManeuverStrategyCruiseProfile", "IBasicManeuverStrategyFlyAOA", "IBasicManeuverStrategyGlideProfile", "IBasicManeuverStrategyIntercept", 
"IBasicManeuverStrategyLTAHover", "IBasicManeuverStrategyLoop", "IBasicManeuverStrategyPitch3D", "IBasicManeuverStrategyPull", 
"IBasicManeuverStrategyPushPull", "IBasicManeuverStrategyRelSpeedAltitude", "IBasicManeuverStrategyRelativeBearing", "IBasicManeuverStrategyRelativeCourse", 
"IBasicManeuverStrategyRelativeFPA", "IBasicManeuverStrategyRendezvous", "IBasicManeuverStrategyRollingPull", "IBasicManeuverStrategySimpleTurn", 
"IBasicManeuverStrategySmoothAccel", "IBasicManeuverStrategySmoothTurn", "IBasicManeuverStrategyStationkeeping", "IBasicManeuverStrategyStraightAhead", 
"IBasicManeuverStrategyWeave", "IBasicManeuverTargetPositionVel", "IBasicManeuverTargetPositionVelNoisyBrnRng", "IBasicManeuverTargetPositionVelNoisySurfTgt", 
"ICalculationOptions", "ICatalog", "ICatalogAirport", "ICatalogItem", "ICatalogNavaid", "ICatalogRunway", "ICatalogSource", 
"ICatalogVTOLPoint", "ICatalogWaypoint", "IClimbAndDescentTransitions", "IConfiguration", "IConnect", "ICruiseAirspeedAndProfileOptions", 
"ICruiseAirspeedOptions", "ICruiseAirspeedProfile", "IDAFIFItem", "IDAFIFSource", "IEnrouteAndDelayOptions", "IEnrouteOptions", 
"IEnrouteTurnDirectionOptions", "IFuelModelKeroseneAFPROP", "IFuelModelKeroseneCEA", "IFuelTankExternal", "IFuelTankInternal", 
"IHoverAltitudeOptions", "ILandingEnterDownwindPattern", "ILandingInterceptGlideslope", "ILandingStandardInstrumentApproach", 
"ILevelTurns", "IMissileAdvancedAero", "IMissileAero", "IMissileExternalAero", "IMissileExternalProp", "IMissileModel", 
"IMissileModels", "IMissileProp", "IMissileRamjetProp", "IMissileRocketProp", "IMissileSimpleAero", "IMissileSimpleProp", 
"IMissileTurbojetProp", "IMission", "INTERCEPT_MODE", "INavaidCategory", "INavigationOptions", "IPayloadStation", "IPerformanceModel", 
"IPerformanceModelOptions", "IPhase", "IPhaseCollection", "IProcedure", "IProcedureAirway", "IProcedureAirwayRouter", "IProcedureArcEnroute", 
"IProcedureArcPointToPoint", "IProcedureAreaTargetSearch", "IProcedureBasicManeuver", "IProcedureBasicPointToPoint", "IProcedureCollection", 
"IProcedureDelay", "IProcedureEnroute", "IProcedureExtEphem", "IProcedureFastTimeOptions", "IProcedureFlightLine", "IProcedureFormationFlyer", 
"IProcedureFormationRecover", "IProcedureHoldingCircular", "IProcedureHoldingFigure8", "IProcedureHoldingRacetrack", "IProcedureHover", 
"IProcedureHoverTranslate", "IProcedureInFormation", "IProcedureLanding", "IProcedureLaunch", "IProcedureLaunchDynState", 
"IProcedureLaunchWaypoint", "IProcedureParallelFlightLine", "IProcedureReferenceState", "IProcedureSuperProcedure", "IProcedureTakeoff", 
"IProcedureTerrainFollow", "IProcedureTimeOptions", "IProcedureTransitionToForwardFlight", "IProcedureTransitionToHover", 
"IProcedureVGTPoint", "IProcedureVerticalLanding", "IProcedureVerticalTakeoff", "IPropulsionEfficiencies", "IPropulsionThrust", 
"IReferenceStateForwardFlightOptions", "IReferenceStateHoverOptions", "IReferenceStateTakeoffLandingOptions", "IReferenceStateWeightOnWheelsOptions", 
"IRefuelDumpProperties", "IRotorcraftAero", "IRotorcraftModel", "IRotorcraftModels", "IRotorcraftProp", "IRunwayCategory", 
"IRunwayHeadingOptions", "ISite", "ISiteAirportFromCatalog", "ISiteDynState", "ISiteEndOfPrevProcedure", "ISiteNavaidFromCatalog", 
"ISiteReferenceState", "ISiteRelToPrevProcedure", "ISiteRelToSTKObject", "ISiteRunway", "ISiteRunwayFromCatalog", "ISiteSTKAreaTarget", 
"ISiteSTKObjectWaypoint", "ISiteSTKStaticObject", "ISiteSTKVehicle", "ISiteSuperProcedure", "ISiteUnknown", "ISiteVTOLPoint", 
"ISiteVTOLPointFromCatalog", "ISiteWaypoint", "ISiteWaypointFromCatalog", "IStation", "IStationCollection", "ITakeoffDeparturePoint", 
"ITakeoffLowTransition", "ITakeoffNormal", "IUserRunway", "IUserRunwaySource", "IUserVTOLPoint", "IUserVTOLPointSource", 
"IUserWaypoint", "IUserWaypointSource", "IVTOLPointCategory", "IVerticalPlaneAndFlightPathOptions", "IVerticalPlaneOptions", 
"IWaypointCategory", "IWindModel", "IWindModelADDS", "IWindModelConstant", "JET_ENGINE_EXHAUST_NOZZLE_TYPE", "JET_ENGINE_INTAKE_TYPE", 
"JET_ENGINE_TECHNOLOGY_LEVEL", "JET_ENGINE_TURBINE_TYPE", "JET_FUEL_TYPE", "JOIN_EXIT_ARC_METHOD", "LANDING_APPROACH_FIX_RANGE_MODE", 
"LAUNCH_ATTITUDE_MODE", "LAUNCH_DYN_STATE_BEARING_REFERENCE", "LAUNCH_DYN_STATE_COORD_FRAME", "LINE_ORIENTATION", "LandingCruiseAirspeedAndProfileOptions", 
"LandingEnrouteOptions", "LandingEnterDownwindPattern", "LandingInterceptGlideslope", "LandingStandardInstrumentApproach", 
"LandingVerticalPlaneOptions", "LevelTurns", "MINIMIZE_SITE_PROC_TIME_DIFF", "MISSILE_AERO_STRATEGY", "MISSILE_PROP_STRATEGY", 
"MissileAdvancedAero", "MissileAero", "MissileExternalAero", "MissileExternalProp", "MissileModel", "MissileModels", "MissileProp", 
"MissileRamjetProp", "MissileRocketProp", "MissileSimpleAero", "MissileSimpleProp", "MissileTurbojetProp", "Mission", "NAVIGATOR_TURN_DIRECTION", 
"NUMERICAL_INTEGRATOR", "NavaidCategory", "NavigationOptions", "PERF_MODEL_OVERRIDE", "PHASE_OF_FLIGHT", "PITCH_3D_CONTROL_MODE", 
"POINT_TO_POINT_MODE", "PROCEDURE_TYPE", "PROFILE_CONTROL_LIMIT", "PULL_MODE", "PUSH_PULL", "PayloadStation", "PerformanceModel", 
"PerformanceModelOptions", "Phase", "PhaseCollection", "Procedure", "ProcedureAirway", "ProcedureAirwayRouter", "ProcedureArcEnroute", 
"ProcedureArcPointToPoint", "ProcedureAreaTargetSearch", "ProcedureBasicManeuver", "ProcedureBasicPointToPoint", "ProcedureCollection", 
"ProcedureDelay", "ProcedureEnroute", "ProcedureExtEphem", "ProcedureFastTimeOptions", "ProcedureFlightLine", "ProcedureFormationFlyer", 
"ProcedureFormationRecover", "ProcedureHoldingCircular", "ProcedureHoldingFigure8", "ProcedureHoldingRacetrack", "ProcedureHover", 
"ProcedureHoverTranslate", "ProcedureInFormation", "ProcedureLanding", "ProcedureLaunch", "ProcedureLaunchDynState", "ProcedureLaunchWaypoint", 
"ProcedureParallelFlightLine", "ProcedureReferenceState", "ProcedureSuperProcedure", "ProcedureTakeoff", "ProcedureTerrainFollow", 
"ProcedureTimeOptions", "ProcedureTransitionToForwardFlight", "ProcedureTransitionToHover", "ProcedureVGTPoint", "ProcedureVerticalLanding", 
"ProcedureVerticalTakeoff", "PropulsionEfficiencies", "PropulsionThrust", "RAMJET_MODE", "REFERENCE_STATE_ATTITUDE_MODE", 
"REFERENCE_STATE_LATERAL_ACCEL_MODE", "REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE", "REFERENCE_STATE_PERF_MODE", "REFUEL_DUMP_MODE", 
"RELATIVE_ALTITUDE_MODE", "REL_ABS_BEARING", "REL_SPEED_ALTITUDE_STOP_CONDITION", "RENDEZVOUS_STOP_CONDITION", "ROLLING_PULL_MODE", 
"ROLL_LEFT_RIGHT", "ROLL_UPRIGHT_INVERTED", "ROTORCRAFT_POWERPLANT_TYPE", "RUNWAY_HIGH_LOW_END", "ReferenceStateForwardFlightOptions", 
"ReferenceStateHoverOptions", "ReferenceStateTakeoffLandingOptions", "ReferenceStateWeightOnWheelsOptions", "RefuelDumpProperties", 
"RotorcraftAero", "RotorcraftModel", "RotorcraftModels", "RotorcraftProp", "RunwayCategory", "RunwayHeadingOptions", "SCRAMJET_MODE", 
"SEARCH_PATTERN_COURSE_MODE", "SITE_TYPE", "SMOOTH_ACCEL_LEFT_RIGHT", "SMOOTH_ACCEL_STOP_CONDITIONS", "SMOOTH_TURN_FPA_MODE", 
"SMOOTH_TURN_MODE", "STATIONKEEPING_STOP_CONDITION", "STK_OBJECT_WAYPOINT_OFFSET_MODE", "STRAIGHT_AHEAD_REFERENCE_FRAME", 
"Site", "SiteAirportFromCatalog", "SiteDynState", "SiteEndOfPrevProcedure", "SiteNavaidFromCatalog", "SiteReferenceState", 
"SiteRelToPrevProcedure", "SiteRelToSTKObject", "SiteRunway", "SiteRunwayFromCatalog", "SiteSTKAreaTarget", "SiteSTKObjectWaypoint", 
"SiteSTKStaticObject", "SiteSTKVehicle", "SiteSuperProcedure", "SiteVTOLPoint", "SiteVTOLPointFromCatalog", "SiteWaypoint", 
"SiteWaypointFromCatalog", "StationCollection", "TAKEOFF_LANDING_SPEED_MODE", "TAKEOFF_MODE", "TARGET_POSITION_VEL_TYPE", 
"TRAJECTORY_BLEND_MODE", "TRANSITION_TO_HOVER_MODE", "TURBINE_MODE", "TURN_DIRECTION", "TURN_MODE", "TakeoffDeparturePoint", 
"TakeoffLowTransition", "TakeoffNormal", "UserRunway", "UserRunwaySource", "UserVTOLPoint", "UserVTOLPointSource", "UserWaypoint", 
"UserWaypointSource", "VERT_LANDING_MODE", "VTOLPointCategory", "VTOL_FINAL_HEADING_MODE", "VTOL_HEADING_MODE", "VTOL_RATE_MODE", 
"VTOL_TRANSITION_MODE", "VTOL_TRANSLATION_FINAL_COURSE_MODE", "VTOL_TRANSLATION_MODE", "VerticalPlaneAndFlightPathOptions", 
"VerticalPlaneOptions", "WIND_ATMOS_MODEL_SOURCE", "WIND_MODEL_TYPE", "WaypointCategory", "WindModel", "WindModelADDS", 
"WindModelConstant"]

import typing

from ctypes   import POINTER
from enum     import IntEnum

from ...internal  import comutil          as agcom
from ...internal  import coclassutil      as agcls
from ...internal  import marshall         as agmarshall
from ...internal.comutil     import IUnknown, IDispatch
from ...internal.apiutil     import interface_proxy, enumerator_proxy, out_arg
from ...internal.eventutil   import *
from ...utilities.exceptions import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class ERROR_CODES(IntEnum):
    """Error Codes."""
    OBJECT_NOT_FOUND = (((1 << 31) | (4 << 16)) | (0x200 + 1))
    """Object not found."""
    INDEX_OUT_OF_RANGE = (((1 << 31) | (4 << 16)) | (0x200 + 2))
    """Index out of range."""
    INVALID_ATTRIBUTE = (((1 << 31) | (4 << 16)) | (0x200 + 3))
    """The attribute is invalid."""
    COMMAND_FAILED = (((1 << 31) | (4 << 16)) | (0x200 + 4))
    """The command failed."""
    ERROR_INVALID_ARG = (((1 << 31) | (4 << 16)) | (0x200 + 5))
    """Invalid argument."""
    EMPTY_ARG = (((1 << 31) | (4 << 16)) | (0x200 + 6))
    """Empty argument."""
    OBJECT_NOT_REMOVED = (((1 << 31) | (4 << 16)) | (0x200 + 7))
    """Object was not removed."""
    FAILED_TO_RENAME_OBJECT = (((1 << 31) | (4 << 16)) | (0x200 + 8))
    """Error renaming object."""
    UNKNOWN_CLASS_TYPE = (((1 << 31) | (4 << 16)) | (0x200 + 9))
    """Unknown class type."""
    FAILED_TO_CREATE_OBJECT = (((1 << 31) | (4 << 16)) | (0x200 + 10))
    """Failed to create the object."""
    OBJECT_LINK_INVALID_CHOICE = (((1 << 31) | (4 << 16)) | (0x200 + 11))
    """Invalid choice for object link."""
    OBJECT_LINK_NO_CHOICES = (((1 << 31) | (4 << 16)) | (0x200 + 12))
    """No choices available."""
    READ_ONLY_ATTRIBUTE = (((1 << 31) | (4 << 16)) | (0x200 + 13))
    """Read only attribute."""
    INVALID_CSTR_LIST = (((1 << 31) | (4 << 16)) | (0x200 + 14))
    """Invalid constraint list."""
    INVALID_CONSTRAINT = (((1 << 31) | (4 << 16)) | (0x200 + 15))
    """InvalidConstraint."""
    LIST_READ_ONLY = (((1 << 31) | (4 << 16)) | (0x200 + 16))
    """List if read only."""
    LIST_INSERT_FAILED = (((1 << 31) | (4 << 16)) | (0x200 + 17))
    """Failed to insert the item into the list."""
    INVALID_LENGTH = (((1 << 31) | (4 << 16)) | (0x200 + 18))
    """Length is invalid."""
    FAILED_TO_LOAD_FILE = (((1 << 31) | (4 << 16)) | (0x200 + 19))
    """Error loading a file."""
    INVALID_OPERATION = (((1 << 31) | (4 << 16)) | (0x200 + 20))
    """Invalid operation."""
    METHOD_INVOKE_FAILED = (((1 << 31) | (4 << 16)) | (0x200 + 21))
    """Method failed."""
    DEPRECATED = (((1 << 31) | (4 << 16)) | (0x200 + 22))
    """Deprecated property or method."""

ERROR_CODES.OBJECT_NOT_FOUND.__doc__ = "Object not found."
ERROR_CODES.INDEX_OUT_OF_RANGE.__doc__ = "Index out of range."
ERROR_CODES.INVALID_ATTRIBUTE.__doc__ = "The attribute is invalid."
ERROR_CODES.COMMAND_FAILED.__doc__ = "The command failed."
ERROR_CODES.ERROR_INVALID_ARG.__doc__ = "Invalid argument."
ERROR_CODES.EMPTY_ARG.__doc__ = "Empty argument."
ERROR_CODES.OBJECT_NOT_REMOVED.__doc__ = "Object was not removed."
ERROR_CODES.FAILED_TO_RENAME_OBJECT.__doc__ = "Error renaming object."
ERROR_CODES.UNKNOWN_CLASS_TYPE.__doc__ = "Unknown class type."
ERROR_CODES.FAILED_TO_CREATE_OBJECT.__doc__ = "Failed to create the object."
ERROR_CODES.OBJECT_LINK_INVALID_CHOICE.__doc__ = "Invalid choice for object link."
ERROR_CODES.OBJECT_LINK_NO_CHOICES.__doc__ = "No choices available."
ERROR_CODES.READ_ONLY_ATTRIBUTE.__doc__ = "Read only attribute."
ERROR_CODES.INVALID_CSTR_LIST.__doc__ = "Invalid constraint list."
ERROR_CODES.INVALID_CONSTRAINT.__doc__ = "InvalidConstraint."
ERROR_CODES.LIST_READ_ONLY.__doc__ = "List if read only."
ERROR_CODES.LIST_INSERT_FAILED.__doc__ = "Failed to insert the item into the list."
ERROR_CODES.INVALID_LENGTH.__doc__ = "Length is invalid."
ERROR_CODES.FAILED_TO_LOAD_FILE.__doc__ = "Error loading a file."
ERROR_CODES.INVALID_OPERATION.__doc__ = "Invalid operation."
ERROR_CODES.METHOD_INVOKE_FAILED.__doc__ = "Method failed."
ERROR_CODES.DEPRECATED.__doc__ = "Deprecated property or method."

agcls.AgTypeNameMap["ERROR_CODES"] = ERROR_CODES

class CLOSURE_VALUE(IntEnum):
    """The closure value."""
    CLOSURE_MODE = 0
    """The closure mode"""
    MAX_ANGLE = 1
    """The HOBS max angle offset"""
    ANGLE_TOL = 2
    """The HOBS angle tolerance"""

CLOSURE_VALUE.CLOSURE_MODE.__doc__ = "The closure mode"
CLOSURE_VALUE.MAX_ANGLE.__doc__ = "The HOBS max angle offset"
CLOSURE_VALUE.ANGLE_TOL.__doc__ = "The HOBS angle tolerance"

agcls.AgTypeNameMap["CLOSURE_VALUE"] = CLOSURE_VALUE

class PROCEDURE_TYPE(IntEnum):
    """Aviator procedure types."""
    PROC_AIRWAY = 0
    """Airway procedure."""
    PROC_AIRWAY_ROUTER = 1
    """Airway Router procedure."""
    PROC_ARC_ENROUTE = 2
    """ArcEnroute procedure."""
    PROC_ARC_POINT_TO_POINT = 3
    """ArcPointToPoint procedure."""
    PROC_AREA_TARGET_SEARCH = 4
    """Area Target Search procedure."""
    PROC_BASIC_MANEUVER = 5
    """Basic Maneuver procedure."""
    PROC_BASIC_POINT_TO_POINT = 6
    """Basic Point to Point procedure."""
    PROC_DELAY = 7
    """Delay procedure."""
    PROC_ENROUTE = 8
    """Enroute procedure."""
    PROC_FLIGHT_LINE = 9
    """Flight Line procedure."""
    PROC_FORMATION_RECOVER = 10
    """Formation Recover procedure."""
    PROC_HOLDING_CIRCULAR = 11
    """Holding Circular procedure."""
    PROC_HOLDING_FIGURE8 = 12
    """Holding Figure 8 procedure."""
    PROC_HOLDING_RACETRACK = 13
    """Holding Racetrack procedure."""
    PROC_HOVER = 14
    """Hover procedure."""
    PROC_HOVER_TRANSLATE = 15
    """Hover Translate procedure."""
    PROC_IN_FORMATION = 16
    """In Formation procedure."""
    PROC_LANDING = 17
    """Landing procedure."""
    PROC_LAUNCH = 18
    """Launch procedure."""
    PROC_PARALLEL_FLIGHT_LINE = 19
    """Parallel Flight Line procedure."""
    PROC_REFERENCE_STATE = 20
    """Reference State procedure."""
    PROC_SUPER_PROCEDURE = 21
    """Super Procedure procedure."""
    PROC_TAKEOFF = 22
    """Takeoff procedure."""
    PROC_TERRAIN_FOLLOWING = 23
    """Terrain Following procedure."""
    PROC_TRANSITION_TO_FORWARD_FLIGHT = 24
    """Transition to Forward Flight procedure."""
    PROC_TRANSITION_TO_HOVER = 25
    """Transition To Hover procedure."""
    PROC_VERTICAL_LANDING = 26
    """Vertical Landing procedure."""
    PROC_VERTICAL_TAKEOFF = 27
    """Vertical Takeoff procedure."""
    PROC_VGT_POINT = 28
    """VGT Point procedure."""
    PROC_LAUNCH_DYN_STATE = 29
    """LaunchDynState procedure."""
    PROC_LAUNCH_WAYPOINT = 30
    """LaunchWaypoint procedure."""
    PROC_FORMATION_FLYER = 31
    """FormationFlyer procedure."""
    PROC_EXT_EPHEM = 32
    """ExtEphem procedure."""

PROCEDURE_TYPE.PROC_AIRWAY.__doc__ = "Airway procedure."
PROCEDURE_TYPE.PROC_AIRWAY_ROUTER.__doc__ = "Airway Router procedure."
PROCEDURE_TYPE.PROC_ARC_ENROUTE.__doc__ = "ArcEnroute procedure."
PROCEDURE_TYPE.PROC_ARC_POINT_TO_POINT.__doc__ = "ArcPointToPoint procedure."
PROCEDURE_TYPE.PROC_AREA_TARGET_SEARCH.__doc__ = "Area Target Search procedure."
PROCEDURE_TYPE.PROC_BASIC_MANEUVER.__doc__ = "Basic Maneuver procedure."
PROCEDURE_TYPE.PROC_BASIC_POINT_TO_POINT.__doc__ = "Basic Point to Point procedure."
PROCEDURE_TYPE.PROC_DELAY.__doc__ = "Delay procedure."
PROCEDURE_TYPE.PROC_ENROUTE.__doc__ = "Enroute procedure."
PROCEDURE_TYPE.PROC_FLIGHT_LINE.__doc__ = "Flight Line procedure."
PROCEDURE_TYPE.PROC_FORMATION_RECOVER.__doc__ = "Formation Recover procedure."
PROCEDURE_TYPE.PROC_HOLDING_CIRCULAR.__doc__ = "Holding Circular procedure."
PROCEDURE_TYPE.PROC_HOLDING_FIGURE8.__doc__ = "Holding Figure 8 procedure."
PROCEDURE_TYPE.PROC_HOLDING_RACETRACK.__doc__ = "Holding Racetrack procedure."
PROCEDURE_TYPE.PROC_HOVER.__doc__ = "Hover procedure."
PROCEDURE_TYPE.PROC_HOVER_TRANSLATE.__doc__ = "Hover Translate procedure."
PROCEDURE_TYPE.PROC_IN_FORMATION.__doc__ = "In Formation procedure."
PROCEDURE_TYPE.PROC_LANDING.__doc__ = "Landing procedure."
PROCEDURE_TYPE.PROC_LAUNCH.__doc__ = "Launch procedure."
PROCEDURE_TYPE.PROC_PARALLEL_FLIGHT_LINE.__doc__ = "Parallel Flight Line procedure."
PROCEDURE_TYPE.PROC_REFERENCE_STATE.__doc__ = "Reference State procedure."
PROCEDURE_TYPE.PROC_SUPER_PROCEDURE.__doc__ = "Super Procedure procedure."
PROCEDURE_TYPE.PROC_TAKEOFF.__doc__ = "Takeoff procedure."
PROCEDURE_TYPE.PROC_TERRAIN_FOLLOWING.__doc__ = "Terrain Following procedure."
PROCEDURE_TYPE.PROC_TRANSITION_TO_FORWARD_FLIGHT.__doc__ = "Transition to Forward Flight procedure."
PROCEDURE_TYPE.PROC_TRANSITION_TO_HOVER.__doc__ = "Transition To Hover procedure."
PROCEDURE_TYPE.PROC_VERTICAL_LANDING.__doc__ = "Vertical Landing procedure."
PROCEDURE_TYPE.PROC_VERTICAL_TAKEOFF.__doc__ = "Vertical Takeoff procedure."
PROCEDURE_TYPE.PROC_VGT_POINT.__doc__ = "VGT Point procedure."
PROCEDURE_TYPE.PROC_LAUNCH_DYN_STATE.__doc__ = "LaunchDynState procedure."
PROCEDURE_TYPE.PROC_LAUNCH_WAYPOINT.__doc__ = "LaunchWaypoint procedure."
PROCEDURE_TYPE.PROC_FORMATION_FLYER.__doc__ = "FormationFlyer procedure."
PROCEDURE_TYPE.PROC_EXT_EPHEM.__doc__ = "ExtEphem procedure."

agcls.AgTypeNameMap["PROCEDURE_TYPE"] = PROCEDURE_TYPE

class SITE_TYPE(IntEnum):
    """Aviator site types."""
    SITE_AIRPORT_FROM_CATALOG = 0
    """Airport from Catalog site."""
    SITE_END_OF_PREV_PROCEDURE = 1
    """End of Previous Procedure site."""
    SITE_NAVAID_FROM_CATALOG = 2
    """Navaid from Catalog site."""
    SITE_REFERENCE_STATE = 3
    """Reference State site."""
    SITE_RELATIVE_TO_PREV_PROCEDURE = 4
    """Relative to Previous Procedure site."""
    SITE_RELATIVE_TO_STATIONARY_STK_OBJECT = 5
    """Relative to Stationary STK Object site."""
    SITE_RUNWAY = 6
    """Runway site."""
    SITE_RUNWAY_FROM_CATALOG = 7
    """Runway from Catalog site."""
    SITE_STK_AREA_TARGET = 8
    """STK Area Target site."""
    SITE_STK_OBJECT_WAYPOINT = 9
    """STK Object Waypoint site."""
    SITE_STK_STATIC_OBJECT = 10
    """STK STatic Object site."""
    SITE_STK_VEHICLE = 11
    """STK Vehicle site."""
    SITE_SUPER_PROCEDURE = 12
    """Super Procedure site."""
    SITE_VTOL_POINT = 13
    """VTOL Point site."""
    SITE_VTOL_POINT_FROM_CATALOG = 14
    """VTOL Point from Catalog site."""
    SITE_WAYPOINT = 15
    """Waypoint site."""
    SITE_WAYPOINT_FROM_CATALOG = 16
    """Waypoint from Catalog site."""
    SITE_DYN_STATE = 17
    """DynState site."""

SITE_TYPE.SITE_AIRPORT_FROM_CATALOG.__doc__ = "Airport from Catalog site."
SITE_TYPE.SITE_END_OF_PREV_PROCEDURE.__doc__ = "End of Previous Procedure site."
SITE_TYPE.SITE_NAVAID_FROM_CATALOG.__doc__ = "Navaid from Catalog site."
SITE_TYPE.SITE_REFERENCE_STATE.__doc__ = "Reference State site."
SITE_TYPE.SITE_RELATIVE_TO_PREV_PROCEDURE.__doc__ = "Relative to Previous Procedure site."
SITE_TYPE.SITE_RELATIVE_TO_STATIONARY_STK_OBJECT.__doc__ = "Relative to Stationary STK Object site."
SITE_TYPE.SITE_RUNWAY.__doc__ = "Runway site."
SITE_TYPE.SITE_RUNWAY_FROM_CATALOG.__doc__ = "Runway from Catalog site."
SITE_TYPE.SITE_STK_AREA_TARGET.__doc__ = "STK Area Target site."
SITE_TYPE.SITE_STK_OBJECT_WAYPOINT.__doc__ = "STK Object Waypoint site."
SITE_TYPE.SITE_STK_STATIC_OBJECT.__doc__ = "STK STatic Object site."
SITE_TYPE.SITE_STK_VEHICLE.__doc__ = "STK Vehicle site."
SITE_TYPE.SITE_SUPER_PROCEDURE.__doc__ = "Super Procedure site."
SITE_TYPE.SITE_VTOL_POINT.__doc__ = "VTOL Point site."
SITE_TYPE.SITE_VTOL_POINT_FROM_CATALOG.__doc__ = "VTOL Point from Catalog site."
SITE_TYPE.SITE_WAYPOINT.__doc__ = "Waypoint site."
SITE_TYPE.SITE_WAYPOINT_FROM_CATALOG.__doc__ = "Waypoint from Catalog site."
SITE_TYPE.SITE_DYN_STATE.__doc__ = "DynState site."

agcls.AgTypeNameMap["SITE_TYPE"] = SITE_TYPE

class BASIC_MANEUVER_STRATEGY(IntEnum):
    """Basic maneuver strategy types."""
    STRAIGHT_AHEAD = 0
    """Straight Ahead strategy."""
    WEAVE = 1
    """Weave strategy."""

BASIC_MANEUVER_STRATEGY.STRAIGHT_AHEAD.__doc__ = "Straight Ahead strategy."
BASIC_MANEUVER_STRATEGY.WEAVE.__doc__ = "Weave strategy."

agcls.AgTypeNameMap["BASIC_MANEUVER_STRATEGY"] = BASIC_MANEUVER_STRATEGY

class STRAIGHT_AHEAD_REFERENCE_FRAME(IntEnum):
    """Straight Ahead basic maneuver Reference Frame."""
    MAINTAIN_COURSE = 0
    """Maintain Course."""
    MAINTAIN_HEADING = 1
    """Maintain Heading."""
    NO_LATERAL_ACC = 2
    """No Lateral Accelerations."""
    COMPENSATE_CORIOLIS = 3
    """Compensate For Coriolis"""

STRAIGHT_AHEAD_REFERENCE_FRAME.MAINTAIN_COURSE.__doc__ = "Maintain Course."
STRAIGHT_AHEAD_REFERENCE_FRAME.MAINTAIN_HEADING.__doc__ = "Maintain Heading."
STRAIGHT_AHEAD_REFERENCE_FRAME.NO_LATERAL_ACC.__doc__ = "No Lateral Accelerations."
STRAIGHT_AHEAD_REFERENCE_FRAME.COMPENSATE_CORIOLIS.__doc__ = "Compensate For Coriolis"

agcls.AgTypeNameMap["STRAIGHT_AHEAD_REFERENCE_FRAME"] = STRAIGHT_AHEAD_REFERENCE_FRAME

class AIRSPEED_TYPE(IntEnum):
    """Airspeed types."""
    MACH = 0
    """Mach number."""
    EAS = 1
    """Equivalent airspeed."""
    CAS = 2
    """Calibrated airspeed."""
    TAS = 3
    """True airspeed."""

AIRSPEED_TYPE.MACH.__doc__ = "Mach number."
AIRSPEED_TYPE.EAS.__doc__ = "Equivalent airspeed."
AIRSPEED_TYPE.CAS.__doc__ = "Calibrated airspeed."
AIRSPEED_TYPE.TAS.__doc__ = "True airspeed."

agcls.AgTypeNameMap["AIRSPEED_TYPE"] = AIRSPEED_TYPE

class AERO_PROP_SIMPLE_MODE(IntEnum):
    """Aircraft operating mode for basic acceleration models with aerodynamics set to Simple."""
    FIXED_WING = 0
    """Fixed wing operatiog mode."""
    HELICOPTER = 1
    """Helicopter operating mode."""

AERO_PROP_SIMPLE_MODE.FIXED_WING.__doc__ = "Fixed wing operatiog mode."
AERO_PROP_SIMPLE_MODE.HELICOPTER.__doc__ = "Helicopter operating mode."

agcls.AgTypeNameMap["AERO_PROP_SIMPLE_MODE"] = AERO_PROP_SIMPLE_MODE

class AERO_PROP_FLIGHT_MODE(IntEnum):
    """Flight mode for the Aero/Prop maneuver mode helper in aircraft acceleration models."""
    FLIGHT_PERF_FORWARD_FLIGHT = 0
    """Forward Flight mode."""
    FLIGHT_PERF_HOVER = 1
    """Hover mode."""
    FLIGHT_PERF_TAKEOFF = 2
    """Takeoff mode."""
    FLIGHT_PERF_LANDING = 3
    """Landing mode."""
    FLIGHT_PERF_WEIGHT_ON_WHEELS = 4
    """Weight on wheels mode."""

AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_FORWARD_FLIGHT.__doc__ = "Forward Flight mode."
AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_HOVER.__doc__ = "Hover mode."
AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_TAKEOFF.__doc__ = "Takeoff mode."
AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_LANDING.__doc__ = "Landing mode."
AERO_PROP_FLIGHT_MODE.FLIGHT_PERF_WEIGHT_ON_WHEELS.__doc__ = "Weight on wheels mode."

agcls.AgTypeNameMap["AERO_PROP_FLIGHT_MODE"] = AERO_PROP_FLIGHT_MODE

class PHASE_OF_FLIGHT(IntEnum):
    """Flight mode for basic maneuver procedures."""
    FLIGHT_PHASE_TAKEOFF = 1
    """Takeoff flight mode."""
    FLIGHT_PHASE_CLIMB = 2
    """Forward flight climb flight mode."""
    FLIGHT_PHASE_CRUISE = 3
    """Forward flight - cruise flight mode."""
    FLIGHT_PHASE_DESCEND = 4
    """Forward flight descend flight mode."""
    FLIGHT_PHASE_LANDING = 5
    """Landing flight mode."""
    FLIGHT_PHASE_VTOL = 6
    """Rotary wing / hover flight mode"""

PHASE_OF_FLIGHT.FLIGHT_PHASE_TAKEOFF.__doc__ = "Takeoff flight mode."
PHASE_OF_FLIGHT.FLIGHT_PHASE_CLIMB.__doc__ = "Forward flight climb flight mode."
PHASE_OF_FLIGHT.FLIGHT_PHASE_CRUISE.__doc__ = "Forward flight - cruise flight mode."
PHASE_OF_FLIGHT.FLIGHT_PHASE_DESCEND.__doc__ = "Forward flight descend flight mode."
PHASE_OF_FLIGHT.FLIGHT_PHASE_LANDING.__doc__ = "Landing flight mode."
PHASE_OF_FLIGHT.FLIGHT_PHASE_VTOL.__doc__ = "Rotary wing / hover flight mode"

agcls.AgTypeNameMap["PHASE_OF_FLIGHT"] = PHASE_OF_FLIGHT

class CRUISE_SPEED(IntEnum):
    """Cruise airspeed type for the procedure."""
    MIN_AIRSPEED = 0
    """Minimum airspeed."""
    MAX_ENDURANCE_AIRSPEED = 1
    """Maximum endurance airspeed."""
    MAX_RANGE_AIRSPEED = 2
    """Maximum range airspeed."""
    OTHER_AIRSPEED = 3
    """Other airspeed."""
    MAX_AIRSPEED = 4
    """Maximum airspeed."""
    MAX_PERF_AIRSPEED = 6
    """Maximum performance airspeed."""

CRUISE_SPEED.MIN_AIRSPEED.__doc__ = "Minimum airspeed."
CRUISE_SPEED.MAX_ENDURANCE_AIRSPEED.__doc__ = "Maximum endurance airspeed."
CRUISE_SPEED.MAX_RANGE_AIRSPEED.__doc__ = "Maximum range airspeed."
CRUISE_SPEED.OTHER_AIRSPEED.__doc__ = "Other airspeed."
CRUISE_SPEED.MAX_AIRSPEED.__doc__ = "Maximum airspeed."
CRUISE_SPEED.MAX_PERF_AIRSPEED.__doc__ = "Maximum performance airspeed."

agcls.AgTypeNameMap["CRUISE_SPEED"] = CRUISE_SPEED

class TAKEOFF_MODE(IntEnum):
    """Takeoff procedure mode."""
    TAKEOFF_NORMAL = 0
    """Normal takeoff mode."""
    TAKEOFF_FLY_TO_DEPARTURE_POINT = 1
    """Fly to departure point takeoff mode."""
    TAKEOFF_LOW_TRANSITION = 2
    """Low transition takeoff."""

TAKEOFF_MODE.TAKEOFF_NORMAL.__doc__ = "Normal takeoff mode."
TAKEOFF_MODE.TAKEOFF_FLY_TO_DEPARTURE_POINT.__doc__ = "Fly to departure point takeoff mode."
TAKEOFF_MODE.TAKEOFF_LOW_TRANSITION.__doc__ = "Low transition takeoff."

agcls.AgTypeNameMap["TAKEOFF_MODE"] = TAKEOFF_MODE

class APPROACH_MODE(IntEnum):
    """Landing procedure approach mode."""
    STANDARD_INSTRUMENT_APPROACH = 0
    """Standard instrument approach mode."""
    INTERCEPT_GLIDESLOPE = 1
    """Intercept Glideslope approach mode."""
    ENTER_DOWNWIND_PATTERN = 2
    """Enter downwind pattern approach mode."""

APPROACH_MODE.STANDARD_INSTRUMENT_APPROACH.__doc__ = "Standard instrument approach mode."
APPROACH_MODE.INTERCEPT_GLIDESLOPE.__doc__ = "Intercept Glideslope approach mode."
APPROACH_MODE.ENTER_DOWNWIND_PATTERN.__doc__ = "Enter downwind pattern approach mode."

agcls.AgTypeNameMap["APPROACH_MODE"] = APPROACH_MODE

class NAVIGATOR_TURN_DIRECTION(IntEnum):
    """Turn mode for procedures with Enroute Turn Direction options."""
    NAVIGATOR_TURN_AUTO = 0
    """Automatic turn. Aviator will determine the direction of the turn."""
    NAVIGATOR_TURN_LEFT = 1
    """Left turn."""
    NAVIGATOR_TURN_RIGHT = 2
    """Right turn."""

NAVIGATOR_TURN_DIRECTION.NAVIGATOR_TURN_AUTO.__doc__ = "Automatic turn. Aviator will determine the direction of the turn."
NAVIGATOR_TURN_DIRECTION.NAVIGATOR_TURN_LEFT.__doc__ = "Left turn."
NAVIGATOR_TURN_DIRECTION.NAVIGATOR_TURN_RIGHT.__doc__ = "Right turn."

agcls.AgTypeNameMap["NAVIGATOR_TURN_DIRECTION"] = NAVIGATOR_TURN_DIRECTION

class BASIC_MANEUVER_FUEL_FLOW_TYPE(IntEnum):
    """Fuel flow type for basic maneuver procedures."""
    BASIC_MANEUVER_FUEL_FLOW_TAKEOFF = 0
    """Fuel flow defined for the current Takeoff performance model."""
    BASIC_MANEUVER_FUEL_FLOW_CRUISE = 1
    """Fuel flow defined for the current Cruise performance model."""
    BASIC_MANEUVER_FUEL_FLOW_LANDING = 2
    """Fuel flow defined for the current Landing performance model."""
    BASIC_MANEUVER_FUEL_FLOW_VTOL = 3
    """Fuel flow defined for the current VTOL performance model."""
    BASIC_MANEUVER_FUEL_FLOW_AERO_PROP = 4
    """Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model."""
    BASIC_MANEUVER_FUEL_FLOW_OVERRIDE = 5
    """Fuel flow defined manually."""
    BASIC_MANEUVER_FUEL_FLOW_THRUST_MODEL = 6
    """Fuel flow defined using the thrust model for this maneuver."""

BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_TAKEOFF.__doc__ = "Fuel flow defined for the current Takeoff performance model."
BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_CRUISE.__doc__ = "Fuel flow defined for the current Cruise performance model."
BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_LANDING.__doc__ = "Fuel flow defined for the current Landing performance model."
BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_VTOL.__doc__ = "Fuel flow defined for the current VTOL performance model."
BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_AERO_PROP.__doc__ = "Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model."
BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_OVERRIDE.__doc__ = "Fuel flow defined manually."
BASIC_MANEUVER_FUEL_FLOW_TYPE.BASIC_MANEUVER_FUEL_FLOW_THRUST_MODEL.__doc__ = "Fuel flow defined using the thrust model for this maneuver."

agcls.AgTypeNameMap["BASIC_MANEUVER_FUEL_FLOW_TYPE"] = BASIC_MANEUVER_FUEL_FLOW_TYPE

class BASIC_MANEUVER_ALTITUDE_LIMIT(IntEnum):
    """The type of response Aviator will have if the maneuver attempts to exceed the altitude limit."""
    BASIC_MANEUVER_ALTITUDE_LIMIT_ERROR = 0
    """Error when altitude limit exceeded."""
    BASIC_MANEUVER_ALTITUDE_LIMIT_STOP = 1
    """Stop when altitude limit exceeded."""
    BASIC_MANEUVER_ALTITUDE_LIMIT_CONTINUE = 2
    """Continue when altitude limit exceeded."""

BASIC_MANEUVER_ALTITUDE_LIMIT.BASIC_MANEUVER_ALTITUDE_LIMIT_ERROR.__doc__ = "Error when altitude limit exceeded."
BASIC_MANEUVER_ALTITUDE_LIMIT.BASIC_MANEUVER_ALTITUDE_LIMIT_STOP.__doc__ = "Stop when altitude limit exceeded."
BASIC_MANEUVER_ALTITUDE_LIMIT.BASIC_MANEUVER_ALTITUDE_LIMIT_CONTINUE.__doc__ = "Continue when altitude limit exceeded."

agcls.AgTypeNameMap["BASIC_MANEUVER_ALTITUDE_LIMIT"] = BASIC_MANEUVER_ALTITUDE_LIMIT

class RUNWAY_HIGH_LOW_END(IntEnum):
    """Runway heading that the aircraft will use."""
    HIGH_END = 0
    """High end."""
    LOW_END = 1
    """Low end."""
    HEADWIND = 2
    """Headwind."""

RUNWAY_HIGH_LOW_END.HIGH_END.__doc__ = "High end."
RUNWAY_HIGH_LOW_END.LOW_END.__doc__ = "Low end."
RUNWAY_HIGH_LOW_END.HEADWIND.__doc__ = "Headwind."

agcls.AgTypeNameMap["RUNWAY_HIGH_LOW_END"] = RUNWAY_HIGH_LOW_END

class BASIC_MANEUVER_REFERENCE_FRAME(IntEnum):
    """Reference frame for the basic maneuver strategy."""
    EARTH_FRAME = 0
    """Earth frame."""
    WIND_FRAME = 1
    """Wind frame."""

BASIC_MANEUVER_REFERENCE_FRAME.EARTH_FRAME.__doc__ = "Earth frame."
BASIC_MANEUVER_REFERENCE_FRAME.WIND_FRAME.__doc__ = "Wind frame."

agcls.AgTypeNameMap["BASIC_MANEUVER_REFERENCE_FRAME"] = BASIC_MANEUVER_REFERENCE_FRAME

class BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT(IntEnum):
    """Method to define the control limits for the aircraft during the maneuver."""
    NAV_USE_ACCEL_PERF_MODEL = 0
    """Use Accel Perf Model."""
    NAV_MIN_TURN_RADIUS = 1
    """Specify min turn radius."""
    NAV_MAX_TURN_RATE = 2
    """Specify max turn rate."""
    NAV_MAX_HORIZ_ACCEL = 3
    """Specify max horiz accel."""

BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_USE_ACCEL_PERF_MODEL.__doc__ = "Use Accel Perf Model."
BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_MIN_TURN_RADIUS.__doc__ = "Specify min turn radius."
BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_MAX_TURN_RATE.__doc__ = "Specify max turn rate."
BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT.NAV_MAX_HORIZ_ACCEL.__doc__ = "Specify max horiz accel."

agcls.AgTypeNameMap["BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT"] = BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT

class ACCEL_MANEUVER_MODE(IntEnum):
    """The mode that the aircraft will adhere to the specified acceleration parameters."""
    ACCEL_MANEUVER_MODE_NORMAL = 0
    """Constant value (default)."""
    ACCEL_MANEUVER_MODE_DENSITY_SCALE = 1
    """Scale by amtmospheric density. The aircraft will consider dynamic pressure when calculating turn radius."""
    ACCEL_MANEUVER_MODE_AERO_PROP = 2
    """Aero/Prop maneuver mode."""

ACCEL_MANEUVER_MODE.ACCEL_MANEUVER_MODE_NORMAL.__doc__ = "Constant value (default)."
ACCEL_MANEUVER_MODE.ACCEL_MANEUVER_MODE_DENSITY_SCALE.__doc__ = "Scale by amtmospheric density. The aircraft will consider dynamic pressure when calculating turn radius."
ACCEL_MANEUVER_MODE.ACCEL_MANEUVER_MODE_AERO_PROP.__doc__ = "Aero/Prop maneuver mode."

agcls.AgTypeNameMap["ACCEL_MANEUVER_MODE"] = ACCEL_MANEUVER_MODE

class AIRCRAFT_AERO_STRATEGY(IntEnum):
    """The aerodynamic strategy used to compute lift, drag, angle of attack, sideslip and intermediate / derived values."""
    AIRCRAFT_AERO_SIMPLE = 0
    """Simple aerodynamics."""
    AIRCRAFT_AERO_EXTERNAL_FILE = 1
    """External file aerodynamics."""
    AIRCRAFT_AERO_BASIC_FIXED_WING = 2
    """Basic fixed wing aerodynamics."""
    AIRCRAFT_AERO_ADVANCED_MISSILE = 3
    """Advanced missile aerodynamics."""

AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_SIMPLE.__doc__ = "Simple aerodynamics."
AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_EXTERNAL_FILE.__doc__ = "External file aerodynamics."
AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_BASIC_FIXED_WING.__doc__ = "Basic fixed wing aerodynamics."
AIRCRAFT_AERO_STRATEGY.AIRCRAFT_AERO_ADVANCED_MISSILE.__doc__ = "Advanced missile aerodynamics."

agcls.AgTypeNameMap["AIRCRAFT_AERO_STRATEGY"] = AIRCRAFT_AERO_STRATEGY

class AIRCRAFT_PROP_STRATEGY(IntEnum):
    """The propulsion strategy used to compute thrust and throttle setting."""
    AIRCRAFT_PROP_SIMPLE = 0
    """Simple propulsion."""
    AIRCRAFT_PROP_EXTERNAL_FILE = 1
    """External file propulsion."""
    AIRCRAFT_PROP_BASIC_FIXED_WING = 2
    """Basic fixed wing propulsion."""
    AIRCRAFT_PROP_MISSILE_RAMJET = 3
    """Missile - Ramjet propulsion."""
    AIRCRAFT_PROP_MISSILE_ROCKET = 4
    """Missile - Rocket propulsion."""
    AIRCRAFT_PROP_MISSILE_TURBOJET = 5
    """Missile - Turbojet propulsion."""

AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_SIMPLE.__doc__ = "Simple propulsion."
AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_EXTERNAL_FILE.__doc__ = "External file propulsion."
AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_BASIC_FIXED_WING.__doc__ = "Basic fixed wing propulsion."
AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_MISSILE_RAMJET.__doc__ = "Missile - Ramjet propulsion."
AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_MISSILE_ROCKET.__doc__ = "Missile - Rocket propulsion."
AIRCRAFT_PROP_STRATEGY.AIRCRAFT_PROP_MISSILE_TURBOJET.__doc__ = "Missile - Turbojet propulsion."

agcls.AgTypeNameMap["AIRCRAFT_PROP_STRATEGY"] = AIRCRAFT_PROP_STRATEGY

class AGL_MSL(IntEnum):
    """The altitude mode."""
    ALTITUDE_AGL = 0
    """AGl altitude. ALtitude above local terrain"""
    ALTITUDE_MSL = 1
    """MSL altitude. Altitude above sea level."""

AGL_MSL.ALTITUDE_AGL.__doc__ = "AGl altitude. ALtitude above local terrain"
AGL_MSL.ALTITUDE_MSL.__doc__ = "MSL altitude. Altitude above sea level."

agcls.AgTypeNameMap["AGL_MSL"] = AGL_MSL

class LANDING_APPROACH_FIX_RANGE_MODE(IntEnum):
    """The reference point on the runway for the Approach Fix Range."""
    REL_TO_RUNWAY_CENTER = 0
    """Runway center."""
    REL_TO_RUNWAY_END = 1
    """Runway end."""

LANDING_APPROACH_FIX_RANGE_MODE.REL_TO_RUNWAY_CENTER.__doc__ = "Runway center."
LANDING_APPROACH_FIX_RANGE_MODE.REL_TO_RUNWAY_END.__doc__ = "Runway end."

agcls.AgTypeNameMap["LANDING_APPROACH_FIX_RANGE_MODE"] = LANDING_APPROACH_FIX_RANGE_MODE

class ACCELERATION_ADV_ACCEL_MODE(IntEnum):
    """Acceleration mode for aircraft advanced acceleration models."""
    ACCEL_MODE_MAX_ACCEL = 0
    """Max acceleration."""
    ACCEL_MODE_OVERRIDE_ACCEL = 1
    """Manually override the acceleration."""

ACCELERATION_ADV_ACCEL_MODE.ACCEL_MODE_MAX_ACCEL.__doc__ = "Max acceleration."
ACCELERATION_ADV_ACCEL_MODE.ACCEL_MODE_OVERRIDE_ACCEL.__doc__ = "Manually override the acceleration."

agcls.AgTypeNameMap["ACCELERATION_ADV_ACCEL_MODE"] = ACCELERATION_ADV_ACCEL_MODE

class ACCEL_MANEUVER_AERO_PROP_MODE(IntEnum):
    """The mode used for the Aero/Prop maneuver mode helper for aircraft basic acceleration models."""
    USE_THRUST_AND_LIFT_COEFFICIENT = 0
    """Use Thrust and Lift Coefficient"""
    USE_LIFT_COEFFICIENT_ONLY = 1
    """Use Lift Coefficient only."""

ACCEL_MANEUVER_AERO_PROP_MODE.USE_THRUST_AND_LIFT_COEFFICIENT.__doc__ = "Use Thrust and Lift Coefficient"
ACCEL_MANEUVER_AERO_PROP_MODE.USE_LIFT_COEFFICIENT_ONLY.__doc__ = "Use Lift Coefficient only."

agcls.AgTypeNameMap["ACCEL_MANEUVER_AERO_PROP_MODE"] = ACCEL_MANEUVER_AERO_PROP_MODE

class BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS(IntEnum):
    """The type of response Aviator will have if the basic maneuver attempts to exceed the airspeed limit."""
    CONSTRAIN_IF_VIOLATED = 0
    """Constrain the aircraft to not exceed the airspeed limit."""
    STOP_IF_VIOLATED = 1
    """Stop when airspeed limit exceeded.."""
    ERROR_IF_VIOLATED = 2
    """Error when airspeed limit exceeded."""
    IGNORE_IF_VIOLATED = 3
    """Ignore when airspeed limit exceeded."""

BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.CONSTRAIN_IF_VIOLATED.__doc__ = "Constrain the aircraft to not exceed the airspeed limit."
BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.STOP_IF_VIOLATED.__doc__ = "Stop when airspeed limit exceeded.."
BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.ERROR_IF_VIOLATED.__doc__ = "Error when airspeed limit exceeded."
BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS.IGNORE_IF_VIOLATED.__doc__ = "Ignore when airspeed limit exceeded."

agcls.AgTypeNameMap["BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS"] = BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS

class BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE(IntEnum):
    """Powered Cruise Options."""
    GLIDE_SPECIFY_UN_POWERED_CRUISE = 0
    """The mode selected is unpowered options."""
    GLIDE_SPECIFY_THROTTLE = 1
    """The mode selected is specify throttle."""
    GLIDE_SPECIFY_THRUST_MODEL = 2
    """The mode selected is thrust model."""

BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE.GLIDE_SPECIFY_UN_POWERED_CRUISE.__doc__ = "The mode selected is unpowered options."
BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE.GLIDE_SPECIFY_THROTTLE.__doc__ = "The mode selected is specify throttle."
BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE.GLIDE_SPECIFY_THRUST_MODEL.__doc__ = "The mode selected is thrust model."

agcls.AgTypeNameMap["BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE"] = BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE

class TURN_MODE(IntEnum):
    """The mode to specify an aircraft's level turn performance for acceleration performance models."""
    TURN_MODE_TURN_G = 0
    """Turn G. The standard G force of the aircraft in a turn."""
    TURN_MODE_BANK_ANGLE = 1
    """Bank angle."""
    TURN_MODE_ACCEL = 2
    """Turn acceleration."""
    TURN_MODE_RADIUS = 3
    """Turn radius."""
    TURN_MODE_RATE = 4
    """Turn rate."""

TURN_MODE.TURN_MODE_TURN_G.__doc__ = "Turn G. The standard G force of the aircraft in a turn."
TURN_MODE.TURN_MODE_BANK_ANGLE.__doc__ = "Bank angle."
TURN_MODE.TURN_MODE_ACCEL.__doc__ = "Turn acceleration."
TURN_MODE.TURN_MODE_RADIUS.__doc__ = "Turn radius."
TURN_MODE.TURN_MODE_RATE.__doc__ = "Turn rate."

agcls.AgTypeNameMap["TURN_MODE"] = TURN_MODE

class POINT_TO_POINT_MODE(IntEnum):
    """The heading or course of the aircraft at the beginning of the procedure."""
    FLY_DIRECT = 0
    """Fly direct."""
    ARRIVE_ON_COURSE_FOR_NEXT = 1
    """Arrive on course for next procedure."""
    ARRIVE_ON_COURSE = 2
    """Arrive on course."""
    INSCRIBED_TURN = 3
    """Inscribed turn."""
    ARRIVE_ON_HDG_INTO_WIND = 4
    """Arrive on heading into wind."""

POINT_TO_POINT_MODE.FLY_DIRECT.__doc__ = "Fly direct."
POINT_TO_POINT_MODE.ARRIVE_ON_COURSE_FOR_NEXT.__doc__ = "Arrive on course for next procedure."
POINT_TO_POINT_MODE.ARRIVE_ON_COURSE.__doc__ = "Arrive on course."
POINT_TO_POINT_MODE.INSCRIBED_TURN.__doc__ = "Inscribed turn."
POINT_TO_POINT_MODE.ARRIVE_ON_HDG_INTO_WIND.__doc__ = "Arrive on heading into wind."

agcls.AgTypeNameMap["POINT_TO_POINT_MODE"] = POINT_TO_POINT_MODE

class ALTITUDE_CONSTRAINT_MANEUVER_MODE(IntEnum):
    """Turn mode for procedures that may require a level off maneuver."""
    LEVEL_OFF_AUTOMATIC_MANEUVER = 0
    """Automatic turn.Aviator will determine the direction of the turn."""
    LEVEL_OFF_LEFT_TURN_MANEUVER = 1
    """Left turn."""
    LEVEL_OFF_RIGHT_TURN_MANEUVER = 2
    """Right turn."""
    LEVEL_OFF_NO_MANEUVER = 3
    """No turn. A level off maneuver will not be performed."""

ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_AUTOMATIC_MANEUVER.__doc__ = "Automatic turn.Aviator will determine the direction of the turn."
ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_LEFT_TURN_MANEUVER.__doc__ = "Left turn."
ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_RIGHT_TURN_MANEUVER.__doc__ = "Right turn."
ALTITUDE_CONSTRAINT_MANEUVER_MODE.LEVEL_OFF_NO_MANEUVER.__doc__ = "No turn. A level off maneuver will not be performed."

agcls.AgTypeNameMap["ALTITUDE_CONSTRAINT_MANEUVER_MODE"] = ALTITUDE_CONSTRAINT_MANEUVER_MODE

class WIND_MODEL_TYPE(IntEnum):
    """The wind model type."""
    CONSTANT_WIND = 0
    """Constant Wind/Speed."""
    ADDS = 1
    """NOAA ADDS Service."""
    DISABLED = 2
    """Disabled wind model."""

WIND_MODEL_TYPE.CONSTANT_WIND.__doc__ = "Constant Wind/Speed."
WIND_MODEL_TYPE.ADDS.__doc__ = "NOAA ADDS Service."
WIND_MODEL_TYPE.DISABLED.__doc__ = "Disabled wind model."

agcls.AgTypeNameMap["WIND_MODEL_TYPE"] = WIND_MODEL_TYPE

class WIND_ATMOS_MODEL_SOURCE(IntEnum):
    """The source for the wind or atmosphere model."""
    SCENARIO_MODEL = 0
    """Scenario Model."""
    MISSION_MODEL = 1
    """Mission Model."""
    PROCEDURE_MODEL = 2
    """Procedure Model."""

WIND_ATMOS_MODEL_SOURCE.SCENARIO_MODEL.__doc__ = "Scenario Model."
WIND_ATMOS_MODEL_SOURCE.MISSION_MODEL.__doc__ = "Mission Model."
WIND_ATMOS_MODEL_SOURCE.PROCEDURE_MODEL.__doc__ = "Procedure Model."

agcls.AgTypeNameMap["WIND_ATMOS_MODEL_SOURCE"] = WIND_ATMOS_MODEL_SOURCE

class ADDS_MSG_INTERP_TYPE(IntEnum):
    """The interpolation method for the wind conditions."""
    INTERP_ONE_POINT = 0
    """One Point Interpolation."""
    INTERP_TWO_POINT = 1
    """Two Point Interpolation."""

ADDS_MSG_INTERP_TYPE.INTERP_ONE_POINT.__doc__ = "One Point Interpolation."
ADDS_MSG_INTERP_TYPE.INTERP_TWO_POINT.__doc__ = "Two Point Interpolation."

agcls.AgTypeNameMap["ADDS_MSG_INTERP_TYPE"] = ADDS_MSG_INTERP_TYPE

class ADDS_MISSING_MSG_TYPE(IntEnum):
    """The wind effect to apply if there is an interval gap between messages."""
    MISSING_MSG_ZERO_WIND = 0
    """Zero Wind."""
    MISSING_MSG_INTERP_END_POINTS = 1
    """Interpolate End Points."""

ADDS_MISSING_MSG_TYPE.MISSING_MSG_ZERO_WIND.__doc__ = "Zero Wind."
ADDS_MISSING_MSG_TYPE.MISSING_MSG_INTERP_END_POINTS.__doc__ = "Interpolate End Points."

agcls.AgTypeNameMap["ADDS_MISSING_MSG_TYPE"] = ADDS_MISSING_MSG_TYPE

class ADDS_MSG_EXTRAP_TYPE(IntEnum):
    """The wind effect to apply if the procedure(s) extend beyond the intervals of any available messages."""
    EXTRAP_MSG_ZERO_WIND = 0
    """Zero Wind."""
    EXTRAP_MSG_HOLD_END_POINTS = 1
    """Hold End Point Wind."""

ADDS_MSG_EXTRAP_TYPE.EXTRAP_MSG_ZERO_WIND.__doc__ = "Zero Wind."
ADDS_MSG_EXTRAP_TYPE.EXTRAP_MSG_HOLD_END_POINTS.__doc__ = "Hold End Point Wind."

agcls.AgTypeNameMap["ADDS_MSG_EXTRAP_TYPE"] = ADDS_MSG_EXTRAP_TYPE

class ADDS_FORECAST_TYPE(IntEnum):
    """The forecast type for the NOAA ADDS message."""
    HOUR_6 = 0
    """6 hour forecast"""
    HOUR_12 = 1
    """12 hour forecast"""
    HOUR_24 = 2
    """24 hour forecast"""

ADDS_FORECAST_TYPE.HOUR_6.__doc__ = "6 hour forecast"
ADDS_FORECAST_TYPE.HOUR_12.__doc__ = "12 hour forecast"
ADDS_FORECAST_TYPE.HOUR_24.__doc__ = "24 hour forecast"

agcls.AgTypeNameMap["ADDS_FORECAST_TYPE"] = ADDS_FORECAST_TYPE

class ATMOSPHERE_MODEL(IntEnum):
    """The basic atmosphere model type."""
    STANDARD1976 = 0
    """1976 U.S. Standard Atmosphere"""
    MIL_HOT = 1
    """U.S. MIL HDBK 310 - Hot"""
    MIL_COLD = 2
    """U.S. MIL HDBK 310 - Cold"""
    MIL_LOW_DENSITY = 3
    """U.S. MIL HDBK 310 - Low Density"""
    MIL_HIGH_DENSITY = 4
    """U.S. MIL HDBK 310 - High Density"""
    MIL_INTERPOLATE = 5
    """Interpolate MIL HDBK 310 Data"""

ATMOSPHERE_MODEL.STANDARD1976.__doc__ = "1976 U.S. Standard Atmosphere"
ATMOSPHERE_MODEL.MIL_HOT.__doc__ = "U.S. MIL HDBK 310 - Hot"
ATMOSPHERE_MODEL.MIL_COLD.__doc__ = "U.S. MIL HDBK 310 - Cold"
ATMOSPHERE_MODEL.MIL_LOW_DENSITY.__doc__ = "U.S. MIL HDBK 310 - Low Density"
ATMOSPHERE_MODEL.MIL_HIGH_DENSITY.__doc__ = "U.S. MIL HDBK 310 - High Density"
ATMOSPHERE_MODEL.MIL_INTERPOLATE.__doc__ = "Interpolate MIL HDBK 310 Data"

agcls.AgTypeNameMap["ATMOSPHERE_MODEL"] = ATMOSPHERE_MODEL

class SMOOTH_TURN_MODE(IntEnum):
    """The basic maneuver smooth turn mode."""
    SMOOTH_TURN_LOAD_FACTOR = 0
    """Specify the load factor of the smooth turn"""
    SMOOTH_TURN_ROLL_ANGLE = 1
    """Specify the roll angle of the smooth turn"""

SMOOTH_TURN_MODE.SMOOTH_TURN_LOAD_FACTOR.__doc__ = "Specify the load factor of the smooth turn"
SMOOTH_TURN_MODE.SMOOTH_TURN_ROLL_ANGLE.__doc__ = "Specify the roll angle of the smooth turn"

agcls.AgTypeNameMap["SMOOTH_TURN_MODE"] = SMOOTH_TURN_MODE

class PERF_MODEL_OVERRIDE(IntEnum):
    """The performance model override mode."""
    PERF_MODEL_VALUE = 0
    """Use the performance model value"""
    OVERRIDE = 1
    """Override the performance model value"""

PERF_MODEL_OVERRIDE.PERF_MODEL_VALUE.__doc__ = "Use the performance model value"
PERF_MODEL_OVERRIDE.OVERRIDE.__doc__ = "Override the performance model value"

agcls.AgTypeNameMap["PERF_MODEL_OVERRIDE"] = PERF_MODEL_OVERRIDE

class BASIC_MANEUVER_AIRSPEED_MODE(IntEnum):
    """The basic maneuver airspeed mode."""
    MAINTAIN_CURRENT_AIRSPEED = 0
    """Maintain the current airspeed"""
    MAINTAIN_SPECIFIED_AIRSPEED = 1
    """Maintain the specified airspeed"""
    MAINTAIN_MIN_AIRSPEED = 2
    """Maintain the minimum airspeed for the aircraft"""
    MAINTAIN_MAX_ENDURANCE_AIRSPEED = 3
    """Maintain the maximum endurance airspeed for the aircraft"""
    MAINTAIN_MAX_RANGE_AIRSPEED = 4
    """Maintain the maximum range airspeed for the aircraft"""
    MAINTAIN_MAX_AIRSPEED = 5
    """Maintain the maximum airspeed for the aircraft"""
    MAINTAIN_MAX_PERFORMANCE_AIRSPEED = 6
    """Maintain the maximum performance airspeed for the aircraft"""
    ACCEL_AT_G = 7
    """Accelerate at the specified rate"""
    DECEL_AT_G = 8
    """Decelerate at the specified rate"""
    ACCEL_DECEL_UNDER_GRAVITY = 9
    """Accel/Decel at the force of gravity (no drag, no thrust)"""
    ACCEL_DECEL_AERO_PROP = 10
    """Accel/Decel using Aero/Propulsion with throttle setting"""
    THRUST = 11
    """Specify thrust (using drag from Aerodynamics model)"""
    INTERPOLATE_ACCEL_DECEL = 12
    """Interpolate Accelerate/Decelerate over interval"""

BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_CURRENT_AIRSPEED.__doc__ = "Maintain the current airspeed"
BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_SPECIFIED_AIRSPEED.__doc__ = "Maintain the specified airspeed"
BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MIN_AIRSPEED.__doc__ = "Maintain the minimum airspeed for the aircraft"
BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_ENDURANCE_AIRSPEED.__doc__ = "Maintain the maximum endurance airspeed for the aircraft"
BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_RANGE_AIRSPEED.__doc__ = "Maintain the maximum range airspeed for the aircraft"
BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_AIRSPEED.__doc__ = "Maintain the maximum airspeed for the aircraft"
BASIC_MANEUVER_AIRSPEED_MODE.MAINTAIN_MAX_PERFORMANCE_AIRSPEED.__doc__ = "Maintain the maximum performance airspeed for the aircraft"
BASIC_MANEUVER_AIRSPEED_MODE.ACCEL_AT_G.__doc__ = "Accelerate at the specified rate"
BASIC_MANEUVER_AIRSPEED_MODE.DECEL_AT_G.__doc__ = "Decelerate at the specified rate"
BASIC_MANEUVER_AIRSPEED_MODE.ACCEL_DECEL_UNDER_GRAVITY.__doc__ = "Accel/Decel at the force of gravity (no drag, no thrust)"
BASIC_MANEUVER_AIRSPEED_MODE.ACCEL_DECEL_AERO_PROP.__doc__ = "Accel/Decel using Aero/Propulsion with throttle setting"
BASIC_MANEUVER_AIRSPEED_MODE.THRUST.__doc__ = "Specify thrust (using drag from Aerodynamics model)"
BASIC_MANEUVER_AIRSPEED_MODE.INTERPOLATE_ACCEL_DECEL.__doc__ = "Interpolate Accelerate/Decelerate over interval"

agcls.AgTypeNameMap["BASIC_MANEUVER_AIRSPEED_MODE"] = BASIC_MANEUVER_AIRSPEED_MODE

class AILERON_ROLL_FLIGHT_PATH(IntEnum):
    """The flight path option for an aileron roll strategy for a basic maneuver procedure."""
    STRAIGHT_LINE_FLIGHT_PATH = 0
    """Fly a straight line flight path"""
    ZERO_G_FLIGHT_PATH = 1
    """Fly a zero G flight path"""

AILERON_ROLL_FLIGHT_PATH.STRAIGHT_LINE_FLIGHT_PATH.__doc__ = "Fly a straight line flight path"
AILERON_ROLL_FLIGHT_PATH.ZERO_G_FLIGHT_PATH.__doc__ = "Fly a zero G flight path"

agcls.AgTypeNameMap["AILERON_ROLL_FLIGHT_PATH"] = AILERON_ROLL_FLIGHT_PATH

class ROLL_LEFT_RIGHT(IntEnum):
    """The roll direction for an aileron roll strategy for a basic maneuver procedure."""
    ROLL_LEFT = 0
    """Roll left"""
    ROLL_RIGHT = 1
    """Roll right"""

ROLL_LEFT_RIGHT.ROLL_LEFT.__doc__ = "Roll left"
ROLL_LEFT_RIGHT.ROLL_RIGHT.__doc__ = "Roll right"

agcls.AgTypeNameMap["ROLL_LEFT_RIGHT"] = ROLL_LEFT_RIGHT

class ROLL_UPRIGHT_INVERTED(IntEnum):
    """The orientation for an aileron roll strategy for a basic maneuver procedure."""
    ROLL_UPRIGHT = 0
    """Upright roll"""
    ROLL_INVERTED = 1
    """Inverted roll"""

ROLL_UPRIGHT_INVERTED.ROLL_UPRIGHT.__doc__ = "Upright roll"
ROLL_UPRIGHT_INVERTED.ROLL_INVERTED.__doc__ = "Inverted roll"

agcls.AgTypeNameMap["ROLL_UPRIGHT_INVERTED"] = ROLL_UPRIGHT_INVERTED

class AILERON_ROLL_MODE(IntEnum):
    """The roll mode aileron roll strategy for a basic maneuver procedure."""
    ROLL_TO_ANGLE = 0
    """Specify the angle to roll"""
    ROLL_TO_ORIENTATION = 1
    """Specify the orientation to roll to"""

AILERON_ROLL_MODE.ROLL_TO_ANGLE.__doc__ = "Specify the angle to roll"
AILERON_ROLL_MODE.ROLL_TO_ORIENTATION.__doc__ = "Specify the orientation to roll to"

agcls.AgTypeNameMap["AILERON_ROLL_MODE"] = AILERON_ROLL_MODE

class FLY_AOA_LEFT_RIGHT(IntEnum):
    """The roll direction for a Fly AOA strategy for a basic maneuver procedure."""
    FLY_AOA_LEFT = 0
    """Roll left"""
    FLY_AOA_RIGHT = 1
    """Roll right"""
    FLY_AOA_NO_ROLL = 2
    """No roll"""

FLY_AOA_LEFT_RIGHT.FLY_AOA_LEFT.__doc__ = "Roll left"
FLY_AOA_LEFT_RIGHT.FLY_AOA_RIGHT.__doc__ = "Roll right"
FLY_AOA_LEFT_RIGHT.FLY_AOA_NO_ROLL.__doc__ = "No roll"

agcls.AgTypeNameMap["FLY_AOA_LEFT_RIGHT"] = FLY_AOA_LEFT_RIGHT

class SMOOTH_ACCEL_LEFT_RIGHT(IntEnum):
    """The roll direction for a smooth acceleration strategy for a basic maneuver procedure."""
    SMOOTH_ACCEL_LEFT = 0
    """Roll left"""
    SMOOTH_ACCEL_RIGHT = 1
    """Roll right"""
    SMOOTH_ACCEL_NO_ROLL = 2
    """No roll"""

SMOOTH_ACCEL_LEFT_RIGHT.SMOOTH_ACCEL_LEFT.__doc__ = "Roll left"
SMOOTH_ACCEL_LEFT_RIGHT.SMOOTH_ACCEL_RIGHT.__doc__ = "Roll right"
SMOOTH_ACCEL_LEFT_RIGHT.SMOOTH_ACCEL_NO_ROLL.__doc__ = "No roll"

agcls.AgTypeNameMap["SMOOTH_ACCEL_LEFT_RIGHT"] = SMOOTH_ACCEL_LEFT_RIGHT

class PULL_MODE(IntEnum):
    """The pull mode for a pull strategy of a basic maneuver procedure."""
    PULL_TO_ANGLE = 0
    """Pull to the specified angle"""
    PULL_TO_HORIZON = 1
    """Pull to the horizon plus the additional angle"""

PULL_MODE.PULL_TO_ANGLE.__doc__ = "Pull to the specified angle"
PULL_MODE.PULL_TO_HORIZON.__doc__ = "Pull to the horizon plus the additional angle"

agcls.AgTypeNameMap["PULL_MODE"] = PULL_MODE

class ROLLING_PULL_MODE(IntEnum):
    """The rolling pull mode for a rolling pull strategy of a basic maneuver procedure."""
    ROLL_TO_ANGLE_MODE = 0
    """Roll to the specified angle"""
    ROLL_TO_ORIENTATION_MODE = 1
    """Roll to the specified orientaiton plus additional angle"""
    PULL_TO_ANGLE_MODE = 2
    """Pull to the specified angle"""
    PULL_TO_HORIZON_MODE = 3
    """Pull to the horizon plus the additional angle"""

ROLLING_PULL_MODE.ROLL_TO_ANGLE_MODE.__doc__ = "Roll to the specified angle"
ROLLING_PULL_MODE.ROLL_TO_ORIENTATION_MODE.__doc__ = "Roll to the specified orientaiton plus additional angle"
ROLLING_PULL_MODE.PULL_TO_ANGLE_MODE.__doc__ = "Pull to the specified angle"
ROLLING_PULL_MODE.PULL_TO_HORIZON_MODE.__doc__ = "Pull to the horizon plus the additional angle"

agcls.AgTypeNameMap["ROLLING_PULL_MODE"] = ROLLING_PULL_MODE

class SMOOTH_ACCEL_STOP_CONDITIONS(IntEnum):
    """The rolling pull mode for a rolling pull strategy of a basic maneuver procedure."""
    ROLL_RATE_AND_LOAD_FACTOR = 0
    """Roll rate and load factor rate achieved"""
    ROLL_RATE_OR_LOAD_FACTOR = 1
    """Roll rate or load factor rate achieved"""
    SMOOTH_ACCEL_NORMAL_STOP_CONDITIONS = 2
    """Basic stop conditions"""

SMOOTH_ACCEL_STOP_CONDITIONS.ROLL_RATE_AND_LOAD_FACTOR.__doc__ = "Roll rate and load factor rate achieved"
SMOOTH_ACCEL_STOP_CONDITIONS.ROLL_RATE_OR_LOAD_FACTOR.__doc__ = "Roll rate or load factor rate achieved"
SMOOTH_ACCEL_STOP_CONDITIONS.SMOOTH_ACCEL_NORMAL_STOP_CONDITIONS.__doc__ = "Basic stop conditions"

agcls.AgTypeNameMap["SMOOTH_ACCEL_STOP_CONDITIONS"] = SMOOTH_ACCEL_STOP_CONDITIONS

class AUTOPILOT_HORIZ_PLANE_MODE(IntEnum):
    """The autopilot mode for an autopilot - horizontal plane strategy of a basic maneuver procedure."""
    AUTOPILOT_ABSOLUTE_HEADING = 0
    """The absolute heading mode"""
    AUTOPILOT_ABSOLUTE_COURSE = 1
    """The absolute course mode"""
    AUTOPILOT_RELATIVE_HEADING = 2
    """The relative heading change mode"""
    AUTOPILOT_RELATIVE_COURSE = 3
    """The relative course change mode"""
    AUTOPILOT_HEADING_RATE = 4
    """The set heading rate mode"""
    AUTOPILOT_COURSE_RATE = 5
    """The set course rate  mode"""

AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_ABSOLUTE_HEADING.__doc__ = "The absolute heading mode"
AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_ABSOLUTE_COURSE.__doc__ = "The absolute course mode"
AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_RELATIVE_HEADING.__doc__ = "The relative heading change mode"
AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_RELATIVE_COURSE.__doc__ = "The relative course change mode"
AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_HEADING_RATE.__doc__ = "The set heading rate mode"
AUTOPILOT_HORIZ_PLANE_MODE.AUTOPILOT_COURSE_RATE.__doc__ = "The set course rate  mode"

agcls.AgTypeNameMap["AUTOPILOT_HORIZ_PLANE_MODE"] = AUTOPILOT_HORIZ_PLANE_MODE

class ANGLE_MODE(IntEnum):
    """The angle mode for a barrel roll strategy of a basic maneuver procedure."""
    RELATIVE_ANGLE = 0
    """The absolute angle option"""
    ABSOLUTE_ANGLE = 1
    """The relative angle option"""

ANGLE_MODE.RELATIVE_ANGLE.__doc__ = "The absolute angle option"
ANGLE_MODE.ABSOLUTE_ANGLE.__doc__ = "The relative angle option"

agcls.AgTypeNameMap["ANGLE_MODE"] = ANGLE_MODE

class HOVER_ALTITUDE_MODE(IntEnum):
    """The altitude mode for the lighter than air hover strategy of a basic maneuver procedure."""
    HOVER_HOLD_INIT_ALTITUDE = 0
    """The hold initial altitude mode"""
    HOVER_SPECIFY_ALTITUDE = 1
    """The specify altitude mode"""
    HOVER_SPECIFY_ALTITUDE_CHANGE = 2
    """The specify altitude change mode"""
    HOVER_SPECIFY_ALTITUDE_RATE = 3
    """The specify altitude rate mode"""
    HOVER_HOLD_INIT_ALTITUDE_RATE = 4
    """The hold initial altitude rate mode"""
    HOVER_PARACHUTE = 5
    """The parachute mode"""

HOVER_ALTITUDE_MODE.HOVER_HOLD_INIT_ALTITUDE.__doc__ = "The hold initial altitude mode"
HOVER_ALTITUDE_MODE.HOVER_SPECIFY_ALTITUDE.__doc__ = "The specify altitude mode"
HOVER_ALTITUDE_MODE.HOVER_SPECIFY_ALTITUDE_CHANGE.__doc__ = "The specify altitude change mode"
HOVER_ALTITUDE_MODE.HOVER_SPECIFY_ALTITUDE_RATE.__doc__ = "The specify altitude rate mode"
HOVER_ALTITUDE_MODE.HOVER_HOLD_INIT_ALTITUDE_RATE.__doc__ = "The hold initial altitude rate mode"
HOVER_ALTITUDE_MODE.HOVER_PARACHUTE.__doc__ = "The parachute mode"

agcls.AgTypeNameMap["HOVER_ALTITUDE_MODE"] = HOVER_ALTITUDE_MODE

class HOVER_HEADING_MODE(IntEnum):
    """The heading mode for the lighter than air hover strategy of a basic maneuver procedure."""
    HOVER_RELATIVE = 0
    """The relative to start heading mode"""
    HOVER_ABSOLUTE = 1
    """The absolute heading mode"""
    HOVER_INTO_WIND = 2
    """The align into wind heading mode"""
    HOVER_OPPOSITE_WIND = 3
    """The align opposite wind heading mode"""

HOVER_HEADING_MODE.HOVER_RELATIVE.__doc__ = "The relative to start heading mode"
HOVER_HEADING_MODE.HOVER_ABSOLUTE.__doc__ = "The absolute heading mode"
HOVER_HEADING_MODE.HOVER_INTO_WIND.__doc__ = "The align into wind heading mode"
HOVER_HEADING_MODE.HOVER_OPPOSITE_WIND.__doc__ = "The align opposite wind heading mode"

agcls.AgTypeNameMap["HOVER_HEADING_MODE"] = HOVER_HEADING_MODE

class AUTOPILOT_ALTITUDE_MODE(IntEnum):
    """The altitude mode for the autopilot - vertical plane strategy of a basic maneuver procedure."""
    AUTOPILOT_HOLD_INIT_ALTITUDE = 0
    """The hold initial altitude mode"""
    AUTOPILOT_SPECIFY_ALTITUDE = 1
    """The specify altitude mode"""
    AUTOPILOT_SPECIFY_ALTITUDE_CHANGE = 2
    """The specify altitude change mode"""
    AUTOPILOT_SPECIFY_ALTITUDE_RATE = 3
    """The specify altitude rate mode"""
    AUTOPILOT_HOLD_INIT_ALTITUDE_RATE = 4
    """The hold initial altitude rate mode"""
    AUTOPILOT_SPECIFY_FPA = 5
    """The specify wind frame flight path angle mode"""
    AUTOPILOT_HOLD_INIT_FPA = 6
    """The hold initial wind frame flight path angle mode"""
    AUTOPILOT_BALLISTIC = 7
    """The ballistic flight path mode"""

AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_HOLD_INIT_ALTITUDE.__doc__ = "The hold initial altitude mode"
AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_ALTITUDE.__doc__ = "The specify altitude mode"
AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_ALTITUDE_CHANGE.__doc__ = "The specify altitude change mode"
AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_ALTITUDE_RATE.__doc__ = "The specify altitude rate mode"
AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_HOLD_INIT_ALTITUDE_RATE.__doc__ = "The hold initial altitude rate mode"
AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_SPECIFY_FPA.__doc__ = "The specify wind frame flight path angle mode"
AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_HOLD_INIT_FPA.__doc__ = "The hold initial wind frame flight path angle mode"
AUTOPILOT_ALTITUDE_MODE.AUTOPILOT_BALLISTIC.__doc__ = "The ballistic flight path mode"

agcls.AgTypeNameMap["AUTOPILOT_ALTITUDE_MODE"] = AUTOPILOT_ALTITUDE_MODE

class AUTOPILOT_ALTITUDE_CONTROL_MODE(IntEnum):
    """The altitude control mode for the autopilot - vertical plane strategy of a basic maneuver procedure."""
    AUTOPILOT_ALTITUDE_RATE = 0
    """The control altitude rate mode"""
    AUTOPILOT_FPA = 1
    """The control flight path angle mode"""
    AUTOPILOT_PERF_MODELS = 2
    """The climb/descent performance models mode"""

AUTOPILOT_ALTITUDE_CONTROL_MODE.AUTOPILOT_ALTITUDE_RATE.__doc__ = "The control altitude rate mode"
AUTOPILOT_ALTITUDE_CONTROL_MODE.AUTOPILOT_FPA.__doc__ = "The control flight path angle mode"
AUTOPILOT_ALTITUDE_CONTROL_MODE.AUTOPILOT_PERF_MODELS.__doc__ = "The climb/descent performance models mode"

agcls.AgTypeNameMap["AUTOPILOT_ALTITUDE_CONTROL_MODE"] = AUTOPILOT_ALTITUDE_CONTROL_MODE

class CLOSURE_MODE(IntEnum):
    """The closure mode for guidance strategies of the basic maneuver procedure."""
    CLOSURE_NOT_SET = 0
    """The closure is not set. The maneuver will continue whether or not the aircraft is closing with the target"""
    CLOSURE_REQUIRED = 1
    """The closure is required"""
    HOBS = 2
    """The high off boresight mode"""

CLOSURE_MODE.CLOSURE_NOT_SET.__doc__ = "The closure is not set. The maneuver will continue whether or not the aircraft is closing with the target"
CLOSURE_MODE.CLOSURE_REQUIRED.__doc__ = "The closure is required"
CLOSURE_MODE.HOBS.__doc__ = "The high off boresight mode"

agcls.AgTypeNameMap["CLOSURE_MODE"] = CLOSURE_MODE

class INTERCEPT_MODE(IntEnum):
    """The intercept mode for the intercept strategy of the basic maneuver procedure."""
    TARGET_ASPECT = 0
    """The target aspect mode. The aircraft will maintain an approach angle with the target."""
    LATERAL_SEPARATION = 1
    """The lateral separation mode. The aircraft will guide to a specific distance from the target"""

INTERCEPT_MODE.TARGET_ASPECT.__doc__ = "The target aspect mode. The aircraft will maintain an approach angle with the target."
INTERCEPT_MODE.LATERAL_SEPARATION.__doc__ = "The lateral separation mode. The aircraft will guide to a specific distance from the target"

agcls.AgTypeNameMap["INTERCEPT_MODE"] = INTERCEPT_MODE

class RENDEZVOUS_STOP_CONDITION(IntEnum):
    """The stop condition options for a rendezvous formation strategy of the basic maneuver procedure."""
    STOP_NORMAL = 0
    """The basic stopping conditions will be used."""
    STOP_AFTER_TARGET_CURRENT_PROCEDURE = 1
    """Stop after the target completes the current procedure."""
    STOP_AFTER_TARGET_CURRENT_PHASE = 2
    """Stop after the target completes the current phase."""
    STOP_WHEN_TARGET_PERF_MODE_CHANGES = 3
    """Stop when the target enters a new mode of flight."""
    STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES = 4
    """Stop when the target enters a new performance phase."""

RENDEZVOUS_STOP_CONDITION.STOP_NORMAL.__doc__ = "The basic stopping conditions will be used."
RENDEZVOUS_STOP_CONDITION.STOP_AFTER_TARGET_CURRENT_PROCEDURE.__doc__ = "Stop after the target completes the current procedure."
RENDEZVOUS_STOP_CONDITION.STOP_AFTER_TARGET_CURRENT_PHASE.__doc__ = "Stop after the target completes the current phase."
RENDEZVOUS_STOP_CONDITION.STOP_WHEN_TARGET_PERF_MODE_CHANGES.__doc__ = "Stop when the target enters a new mode of flight."
RENDEZVOUS_STOP_CONDITION.STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES.__doc__ = "Stop when the target enters a new performance phase."

agcls.AgTypeNameMap["RENDEZVOUS_STOP_CONDITION"] = RENDEZVOUS_STOP_CONDITION

class FORMATION_FLYER_STOP_CONDITION(IntEnum):
    """The stop condition options for a Formation Flyer procedure."""
    FORMATION_FLYER_STOP_AFTER_FULL_MISSION = 0
    """Stop After FullMission."""
    FORMATION_FLYER_STOP_AFTER_TIME = 1
    """Stop After Time."""
    FORMATION_FLYER_STOP_AFTER_FUEL_STATE = 2
    """Stop After FuelState."""
    FORMATION_FLYER_STOP_AFTER_DOWN_RANGE = 3
    """Stop After DownRange."""
    FORMATION_FLYER_STOP_WHEN_TARGET_PROCEDURE_CHANGES = 4
    """Stop When TargetProcedure Changes."""
    FORMATION_FLYER_STOP_WHEN_TARGET_MISSION_CHANGES = 5
    """Stop When Target Mission Changes."""
    FORMATION_FLYER_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES = 6
    """Stop When Target PhaseOfFlight Changes."""
    FORMATION_FLYER_STOP_WHEN_TARGET_PERF_MODE_CHANGES = 7
    """Stop When Target PerfMode Changes."""

FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_FULL_MISSION.__doc__ = "Stop After FullMission."
FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_TIME.__doc__ = "Stop After Time."
FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_FUEL_STATE.__doc__ = "Stop After FuelState."
FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_AFTER_DOWN_RANGE.__doc__ = "Stop After DownRange."
FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_PROCEDURE_CHANGES.__doc__ = "Stop When TargetProcedure Changes."
FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_MISSION_CHANGES.__doc__ = "Stop When Target Mission Changes."
FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES.__doc__ = "Stop When Target PhaseOfFlight Changes."
FORMATION_FLYER_STOP_CONDITION.FORMATION_FLYER_STOP_WHEN_TARGET_PERF_MODE_CHANGES.__doc__ = "Stop When Target PerfMode Changes."

agcls.AgTypeNameMap["FORMATION_FLYER_STOP_CONDITION"] = FORMATION_FLYER_STOP_CONDITION

class EXT_EPHEM_FLIGHT_MODE(IntEnum):
    """Flight mode enums for ExtEphem."""
    EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CLIMB = 0
    """ForwardFlightClimb."""
    EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CRUISE = 1
    """ForwardFlightCruise."""
    EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_DESCEND = 2
    """ForwardFlightDescend."""
    EXT_EPHEM_FLIGHT_MODE_LANDING = 3
    """Landing."""
    EXT_EPHEM_FLIGHT_MODE_LANDING_WOW = 4
    """LandingWOW."""
    EXT_EPHEM_FLIGHT_MODE_TAKEOFF = 5
    """Takeoff."""
    EXT_EPHEM_FLIGHT_MODE_TAKEOFF_WOW = 6
    """TakeoffWOW."""
    EXT_EPHEM_FLIGHT_MODE_VTOL_HOVER = 7
    """VTOLHover ."""

EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CLIMB.__doc__ = "ForwardFlightClimb."
EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_CRUISE.__doc__ = "ForwardFlightCruise."
EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_FORWARD_FLIGHT_DESCEND.__doc__ = "ForwardFlightDescend."
EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_LANDING.__doc__ = "Landing."
EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_LANDING_WOW.__doc__ = "LandingWOW."
EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_TAKEOFF.__doc__ = "Takeoff."
EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_TAKEOFF_WOW.__doc__ = "TakeoffWOW."
EXT_EPHEM_FLIGHT_MODE.EXT_EPHEM_FLIGHT_MODE_VTOL_HOVER.__doc__ = "VTOLHover ."

agcls.AgTypeNameMap["EXT_EPHEM_FLIGHT_MODE"] = EXT_EPHEM_FLIGHT_MODE

class ACCEL_PERF_MODEL_OVERRIDE(IntEnum):
    """The acceleration performance model override mode."""
    ACCEL_PERF_MODEL_VALUE = 0
    """Use the acceleration performanc model value."""
    ACCEL_OVERRIDE = 1
    """Override the performanc model value."""
    ACCEL_NO_LIMIT = 2
    """Set no limit on the acceleration."""

ACCEL_PERF_MODEL_OVERRIDE.ACCEL_PERF_MODEL_VALUE.__doc__ = "Use the acceleration performanc model value."
ACCEL_PERF_MODEL_OVERRIDE.ACCEL_OVERRIDE.__doc__ = "Override the performanc model value."
ACCEL_PERF_MODEL_OVERRIDE.ACCEL_NO_LIMIT.__doc__ = "Set no limit on the acceleration."

agcls.AgTypeNameMap["ACCEL_PERF_MODEL_OVERRIDE"] = ACCEL_PERF_MODEL_OVERRIDE

class STATIONKEEPING_STOP_CONDITION(IntEnum):
    """The stop condition options for a stationkeeping strategy."""
    STOP_CONDITION_NOT_SET = 0
    """The basic stopping conditions will be used."""
    STOP_AFTER_TURN_COUNT = 1
    """Stop after a specified number of turns."""
    STOP_AFTER_DURATION = 2
    """Stop after a specified duration."""
    STOP_AFTER_TIME = 3
    """Stop at the specified time."""

STATIONKEEPING_STOP_CONDITION.STOP_CONDITION_NOT_SET.__doc__ = "The basic stopping conditions will be used."
STATIONKEEPING_STOP_CONDITION.STOP_AFTER_TURN_COUNT.__doc__ = "Stop after a specified number of turns."
STATIONKEEPING_STOP_CONDITION.STOP_AFTER_DURATION.__doc__ = "Stop after a specified duration."
STATIONKEEPING_STOP_CONDITION.STOP_AFTER_TIME.__doc__ = "Stop at the specified time."

agcls.AgTypeNameMap["STATIONKEEPING_STOP_CONDITION"] = STATIONKEEPING_STOP_CONDITION

class TURN_DIRECTION(IntEnum):
    """The roll direction for an aileron roll strategy for a basic maneuver procedure."""
    TURN_LEFT = 0
    """Turn left"""
    TURN_RIGHT = 2
    """Turn right"""

TURN_DIRECTION.TURN_LEFT.__doc__ = "Turn left"
TURN_DIRECTION.TURN_RIGHT.__doc__ = "Turn right"

agcls.AgTypeNameMap["TURN_DIRECTION"] = TURN_DIRECTION

class PROFILE_CONTROL_LIMIT(IntEnum):
    """Method to define the control limits for a profile strategy of a basic maneuver procedure."""
    PROFILE_ACCEL_PERF_MODEL = 0
    """Use Accel Perf Model"""
    PROFILE_PITCH_RATE = 1
    """Specify the pitch rate"""

PROFILE_CONTROL_LIMIT.PROFILE_ACCEL_PERF_MODEL.__doc__ = "Use Accel Perf Model"
PROFILE_CONTROL_LIMIT.PROFILE_PITCH_RATE.__doc__ = "Specify the pitch rate"

agcls.AgTypeNameMap["PROFILE_CONTROL_LIMIT"] = PROFILE_CONTROL_LIMIT

class REL_SPEED_ALTITUDE_STOP_CONDITION(IntEnum):
    """The stop condition options for a relative speed/altitude strategy."""
    REL_SPEED_ALTITUDE_STOP_NORMAL = 0
    """The basic stopping conditions will be used."""
    REL_SPEED_ALTITUDE_STOP_MIN_RANGE_FOR_EQUAL_SPEED = 1
    """Stop when the aircraft achieves the range for equal speed."""
    REL_SPEED_ALTITUDE_STOP_TRANSITION_SPEED_RANGE = 2
    """Stop when the aircraft achieves the range to transition speed."""
    REL_SPEED_ALTITUDE_STOP_AFTER_TARGET_CURRENT_PROCEDURE = 3
    """Stop after the target completes the current procedure."""
    REL_SPEED_ALTITUDE_STOP_AFTER_TARGET_CURRENT_PHASE = 4
    """Stop after the target completes the current phase."""
    REL_SPEED_ALTITUDE_STOP_WHEN_TARGET_PERF_MODE_CHANGES = 5
    """Stop when the target enters a new mode of flight."""
    REL_SPEED_ALTITUDE_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES = 6
    """Stop when the target enters a new performance phase."""

REL_SPEED_ALTITUDE_STOP_CONDITION.REL_SPEED_ALTITUDE_STOP_NORMAL.__doc__ = "The basic stopping conditions will be used."
REL_SPEED_ALTITUDE_STOP_CONDITION.REL_SPEED_ALTITUDE_STOP_MIN_RANGE_FOR_EQUAL_SPEED.__doc__ = "Stop when the aircraft achieves the range for equal speed."
REL_SPEED_ALTITUDE_STOP_CONDITION.REL_SPEED_ALTITUDE_STOP_TRANSITION_SPEED_RANGE.__doc__ = "Stop when the aircraft achieves the range to transition speed."
REL_SPEED_ALTITUDE_STOP_CONDITION.REL_SPEED_ALTITUDE_STOP_AFTER_TARGET_CURRENT_PROCEDURE.__doc__ = "Stop after the target completes the current procedure."
REL_SPEED_ALTITUDE_STOP_CONDITION.REL_SPEED_ALTITUDE_STOP_AFTER_TARGET_CURRENT_PHASE.__doc__ = "Stop after the target completes the current phase."
REL_SPEED_ALTITUDE_STOP_CONDITION.REL_SPEED_ALTITUDE_STOP_WHEN_TARGET_PERF_MODE_CHANGES.__doc__ = "Stop when the target enters a new mode of flight."
REL_SPEED_ALTITUDE_STOP_CONDITION.REL_SPEED_ALTITUDE_STOP_WHEN_TARGET_PHASE_OF_FLIGHT_CHANGES.__doc__ = "Stop when the target enters a new performance phase."

agcls.AgTypeNameMap["REL_SPEED_ALTITUDE_STOP_CONDITION"] = REL_SPEED_ALTITUDE_STOP_CONDITION

class RELATIVE_ALTITUDE_MODE(IntEnum):
    """The relative altitude mode for a relative speed/altitude strategy."""
    HOLD_OFFSET_ALTITUDE = 0
    """Maintain the specified altitude offset from the target."""
    HOLD_INIT_ALTITUDE_OFFSET = 1
    """Maintain the altitude offset at the beginning of the maneuver."""
    HOLD_ELEVATION_ANGLE = 2
    """Maintain the specified elevation angle from the target."""
    HOLD_INIT_ELEVATION_ANGLE = 3
    """Maintain the elevation angle at the beginning of the maneuver."""

RELATIVE_ALTITUDE_MODE.HOLD_OFFSET_ALTITUDE.__doc__ = "Maintain the specified altitude offset from the target."
RELATIVE_ALTITUDE_MODE.HOLD_INIT_ALTITUDE_OFFSET.__doc__ = "Maintain the altitude offset at the beginning of the maneuver."
RELATIVE_ALTITUDE_MODE.HOLD_ELEVATION_ANGLE.__doc__ = "Maintain the specified elevation angle from the target."
RELATIVE_ALTITUDE_MODE.HOLD_INIT_ELEVATION_ANGLE.__doc__ = "Maintain the elevation angle at the beginning of the maneuver."

agcls.AgTypeNameMap["RELATIVE_ALTITUDE_MODE"] = RELATIVE_ALTITUDE_MODE

class FLY_TO_FLIGHT_PATH_ANGLE_MODE(IntEnum):
    """The flight path angle mode mode for a bezier profile strategy."""
    FLY_TO_ALTITUDE_RATE = 0
    """Fly to a specified altitude rate."""
    FLY_TO_FLIGHT_PATH_ANGLE = 1
    """Fly to a specified flight path angle."""

FLY_TO_FLIGHT_PATH_ANGLE_MODE.FLY_TO_ALTITUDE_RATE.__doc__ = "Fly to a specified altitude rate."
FLY_TO_FLIGHT_PATH_ANGLE_MODE.FLY_TO_FLIGHT_PATH_ANGLE.__doc__ = "Fly to a specified flight path angle."

agcls.AgTypeNameMap["FLY_TO_FLIGHT_PATH_ANGLE_MODE"] = FLY_TO_FLIGHT_PATH_ANGLE_MODE

class PUSH_PULL(IntEnum):
    """The option to pull up or push over for a push/pull profile strategy."""
    PULL_UP = 0
    """Pull up."""
    PUSH_OVER = 1
    """Push over."""

PUSH_PULL.PULL_UP.__doc__ = "Pull up."
PUSH_PULL.PUSH_OVER.__doc__ = "Push over."

agcls.AgTypeNameMap["PUSH_PULL"] = PUSH_PULL

class ACCEL_MODE(IntEnum):
    """The acceleration/decelation option for a push/pull profile strategy."""
    ACCEL = 0
    """Accelerate at specified G."""
    DECEL = 1
    """Decelerate at specified G."""
    MAINTAIN_SPEED = 2
    """Maintain the initial airspeed."""

ACCEL_MODE.ACCEL.__doc__ = "Accelerate at specified G."
ACCEL_MODE.DECEL.__doc__ = "Decelerate at specified G."
ACCEL_MODE.MAINTAIN_SPEED.__doc__ = "Maintain the initial airspeed."

agcls.AgTypeNameMap["ACCEL_MODE"] = ACCEL_MODE

class DELAY_ALTITUDE_MODE(IntEnum):
    """The altitude options for a delay procedure."""
    DELAY_LEVEL_OFF = 0
    """Use a level off maneuver to fly to the default altitude."""
    DELAY_DEFAULT_CRUISE_ALTITUDE = 1
    """The default cruise altitude."""
    DELAY_OVERRIDE = 2
    """Override the default altitude."""

DELAY_ALTITUDE_MODE.DELAY_LEVEL_OFF.__doc__ = "Use a level off maneuver to fly to the default altitude."
DELAY_ALTITUDE_MODE.DELAY_DEFAULT_CRUISE_ALTITUDE.__doc__ = "The default cruise altitude."
DELAY_ALTITUDE_MODE.DELAY_OVERRIDE.__doc__ = "Override the default altitude."

agcls.AgTypeNameMap["DELAY_ALTITUDE_MODE"] = DELAY_ALTITUDE_MODE

class JOIN_EXIT_ARC_METHOD(IntEnum):
    """The options to join or exit an arc."""
    JOIN_EXIT_OUTBOUND = 0
    """The aircraft begins/ends the procedure on a course away from the site."""
    JOIN_EXIT_ON = 1
    """The aircraft begins/ends the procedure at the start bearing."""
    JOIN_EXIT_INBOUND = 2
    """The aircraft begins/ends on a course towards the site."""

JOIN_EXIT_ARC_METHOD.JOIN_EXIT_OUTBOUND.__doc__ = "The aircraft begins/ends the procedure on a course away from the site."
JOIN_EXIT_ARC_METHOD.JOIN_EXIT_ON.__doc__ = "The aircraft begins/ends the procedure at the start bearing."
JOIN_EXIT_ARC_METHOD.JOIN_EXIT_INBOUND.__doc__ = "The aircraft begins/ends on a course towards the site."

agcls.AgTypeNameMap["JOIN_EXIT_ARC_METHOD"] = JOIN_EXIT_ARC_METHOD

class FLIGHT_LINE_PROC_TYPE(IntEnum):
    """The procedure methodology used to calculate the flight line."""
    PROC_TYPE_ENROUTE = 0
    """An enroute procedure type."""
    PROC_TYPE_BASIC_POINT_TO_POINT = 1
    """A basic point to point procedure type."""
    PROC_TYPE_TERRAIN_FOLLOW = 2
    """A terrain follow procedure type."""

FLIGHT_LINE_PROC_TYPE.PROC_TYPE_ENROUTE.__doc__ = "An enroute procedure type."
FLIGHT_LINE_PROC_TYPE.PROC_TYPE_BASIC_POINT_TO_POINT.__doc__ = "A basic point to point procedure type."
FLIGHT_LINE_PROC_TYPE.PROC_TYPE_TERRAIN_FOLLOW.__doc__ = "A terrain follow procedure type."

agcls.AgTypeNameMap["FLIGHT_LINE_PROC_TYPE"] = FLIGHT_LINE_PROC_TYPE

class TRANSITION_TO_HOVER_MODE(IntEnum):
    """The type of hover to transition to."""
    FULL_STOP = 0
    """Transition to a full stop hover."""
    TRANSLATION_ONLY = 1
    """Transition to a hover with a constant translation rate."""
    TRANSLATION_AND_ALTITUDE = 2
    """Transition to a hover with a constant translation and altitude rate."""

TRANSITION_TO_HOVER_MODE.FULL_STOP.__doc__ = "Transition to a full stop hover."
TRANSITION_TO_HOVER_MODE.TRANSLATION_ONLY.__doc__ = "Transition to a hover with a constant translation rate."
TRANSITION_TO_HOVER_MODE.TRANSLATION_AND_ALTITUDE.__doc__ = "Transition to a hover with a constant translation and altitude rate."

agcls.AgTypeNameMap["TRANSITION_TO_HOVER_MODE"] = TRANSITION_TO_HOVER_MODE

class VTOL_RATE_MODE(IntEnum):
    """The rate mode for the VTOL procedure."""
    HALT_AUTOMATIC = 0
    """The rate during the procedure will be maintained."""
    ALWAYS_STOP = 1
    """The rate will be set to zero."""

VTOL_RATE_MODE.HALT_AUTOMATIC.__doc__ = "The rate during the procedure will be maintained."
VTOL_RATE_MODE.ALWAYS_STOP.__doc__ = "The rate will be set to zero."

agcls.AgTypeNameMap["VTOL_RATE_MODE"] = VTOL_RATE_MODE

class HOLDING_PROFILE_MODE(IntEnum):
    """How the aircraft will perform during the holding pattern with respect to airspeed and altitude."""
    STK8_COMPATIBLE = 0
    """The aircraft will fly the pattern at the speed at which it arrived at the entry point."""
    LEVEL_OFF_CRUISE_SPEED = 1
    """The aircraft will level off and fly at the cruise speed"""
    CLIMB_DESCENT_ON_STATION = 2
    """The aircraft will climb or descend to the specified altitude."""

HOLDING_PROFILE_MODE.STK8_COMPATIBLE.__doc__ = "The aircraft will fly the pattern at the speed at which it arrived at the entry point."
HOLDING_PROFILE_MODE.LEVEL_OFF_CRUISE_SPEED.__doc__ = "The aircraft will level off and fly at the cruise speed"
HOLDING_PROFILE_MODE.CLIMB_DESCENT_ON_STATION.__doc__ = "The aircraft will climb or descend to the specified altitude."

agcls.AgTypeNameMap["HOLDING_PROFILE_MODE"] = HOLDING_PROFILE_MODE

class HOLDING_DIRECTION(IntEnum):
    """The turn direction for the aircraft to enter the holding pattern."""
    INBOUND_LEFT_TURN = 0
    """Turn left on the way inbound to the site."""
    INBOUND_RIGHT_TURN = 1
    """Turn right on the way inbound to the site."""
    OUTBOUND_LEFT_TURN = 2
    """Turn left on the way outbound from the site."""
    OUTBOUND_RIGHT_TURN = 3
    """Turn right on the way outbound from the site."""

HOLDING_DIRECTION.INBOUND_LEFT_TURN.__doc__ = "Turn left on the way inbound to the site."
HOLDING_DIRECTION.INBOUND_RIGHT_TURN.__doc__ = "Turn right on the way inbound to the site."
HOLDING_DIRECTION.OUTBOUND_LEFT_TURN.__doc__ = "Turn left on the way outbound from the site."
HOLDING_DIRECTION.OUTBOUND_RIGHT_TURN.__doc__ = "Turn right on the way outbound from the site."

agcls.AgTypeNameMap["HOLDING_DIRECTION"] = HOLDING_DIRECTION

class HOLD_REFUEL_DUMP_MODE(IntEnum):
    """Defines when the aircraft will leave the holding pattern after it has completed refueling or dumping fuel."""
    FULL_NUMER_OF_TURNS = 0
    """Turn left on the way inbound to the site."""
    EXIT_AT_END_OF_TURN = 1
    """Turn right on the way inbound to the site."""
    IMMEDIATE_EXIT = 2
    """Turn left on the way outbound from the site."""

HOLD_REFUEL_DUMP_MODE.FULL_NUMER_OF_TURNS.__doc__ = "Turn left on the way inbound to the site."
HOLD_REFUEL_DUMP_MODE.EXIT_AT_END_OF_TURN.__doc__ = "Turn right on the way inbound to the site."
HOLD_REFUEL_DUMP_MODE.IMMEDIATE_EXIT.__doc__ = "Turn left on the way outbound from the site."

agcls.AgTypeNameMap["HOLD_REFUEL_DUMP_MODE"] = HOLD_REFUEL_DUMP_MODE

class HOLDING_ENTRY_MANEUVER(IntEnum):
    """Defines how the aircraft will enter the holding pattern."""
    HOLD_ENTRY_NO_MANEUVER = 0
    """The aircraft will enter the holding pattern at the normal holding point."""
    USE_STANDARD_ENTRY_TURNS = 1
    """The aircraft will enter the holding pattern using a standard entry maneuvers defined in the FAA Instrument Flying Handbook"""
    USE_ALTERNATE_ENTRY_POINTS = 2
    """The aircraft will enter the holding pattern at an alternate entry point."""

HOLDING_ENTRY_MANEUVER.HOLD_ENTRY_NO_MANEUVER.__doc__ = "The aircraft will enter the holding pattern at the normal holding point."
HOLDING_ENTRY_MANEUVER.USE_STANDARD_ENTRY_TURNS.__doc__ = "The aircraft will enter the holding pattern using a standard entry maneuvers defined in the FAA Instrument Flying Handbook"
HOLDING_ENTRY_MANEUVER.USE_ALTERNATE_ENTRY_POINTS.__doc__ = "The aircraft will enter the holding pattern at an alternate entry point."

agcls.AgTypeNameMap["HOLDING_ENTRY_MANEUVER"] = HOLDING_ENTRY_MANEUVER

class VTOL_TRANSITION_MODE(IntEnum):
    """The mode to specify the course of the transition maneuver."""
    TRANSITION_RELATIVE_HDG = 0
    """Specify a heading relative to the previous procedure."""
    TRANSITION_ABSOLUTE_HDG = 1
    """Specify an absolute heading."""
    TRANSITION_INTO_WIND = 2
    """Transition into the wind direction."""

VTOL_TRANSITION_MODE.TRANSITION_RELATIVE_HDG.__doc__ = "Specify a heading relative to the previous procedure."
VTOL_TRANSITION_MODE.TRANSITION_ABSOLUTE_HDG.__doc__ = "Specify an absolute heading."
VTOL_TRANSITION_MODE.TRANSITION_INTO_WIND.__doc__ = "Transition into the wind direction."

agcls.AgTypeNameMap["VTOL_TRANSITION_MODE"] = VTOL_TRANSITION_MODE

class VTOL_FINAL_HEADING_MODE(IntEnum):
    """The mode to specify the heading at the end of the maneuver."""
    FINAL_HEADING_RELATIVE = 0
    """Specify a heading relative to the previous procedure."""
    FINAL_HEADING_ABSOLUTE = 1
    """Specify an absolute heading."""
    FINAL_HEADING_TRANSLATION_COURSE = 2
    """The aircraft have the same heading as the translation bearing."""

VTOL_FINAL_HEADING_MODE.FINAL_HEADING_RELATIVE.__doc__ = "Specify a heading relative to the previous procedure."
VTOL_FINAL_HEADING_MODE.FINAL_HEADING_ABSOLUTE.__doc__ = "Specify an absolute heading."
VTOL_FINAL_HEADING_MODE.FINAL_HEADING_TRANSLATION_COURSE.__doc__ = "The aircraft have the same heading as the translation bearing."

agcls.AgTypeNameMap["VTOL_FINAL_HEADING_MODE"] = VTOL_FINAL_HEADING_MODE

class VTOL_TRANSLATION_MODE(IntEnum):
    """The mode to specify the translation of the VTOL maneuver."""
    SET_BEARING_AND_RANGE = 0
    """The aircraft will translate on a specific bearing and range."""
    COME_TO_STOP = 1
    """The aircraft will come to a complete stop."""
    MAINTAIN_RATE = 2
    """The aircraft will continue to translate with the same rate and direction as it began the procedure."""

VTOL_TRANSLATION_MODE.SET_BEARING_AND_RANGE.__doc__ = "The aircraft will translate on a specific bearing and range."
VTOL_TRANSLATION_MODE.COME_TO_STOP.__doc__ = "The aircraft will come to a complete stop."
VTOL_TRANSLATION_MODE.MAINTAIN_RATE.__doc__ = "The aircraft will continue to translate with the same rate and direction as it began the procedure."

agcls.AgTypeNameMap["VTOL_TRANSLATION_MODE"] = VTOL_TRANSLATION_MODE

class VTOL_TRANSLATION_FINAL_COURSE_MODE(IntEnum):
    """The mode to specify the final course of the VTOL maneuver."""
    TRANSLATE_DIRECT = 0
    """The aircraft will translate directly along the specified bearing and range."""
    BISECT_INBOUND_OUTBOUND = 1
    """The aircraft will translate along a bisecting line between the inbound and outbound course."""
    ANTICIPATE_NEXT_TRANSLATION = 2
    """The aircraft will evaluate the procedure ahead to determine the translation bearing and rate."""

VTOL_TRANSLATION_FINAL_COURSE_MODE.TRANSLATE_DIRECT.__doc__ = "The aircraft will translate directly along the specified bearing and range."
VTOL_TRANSLATION_FINAL_COURSE_MODE.BISECT_INBOUND_OUTBOUND.__doc__ = "The aircraft will translate along a bisecting line between the inbound and outbound course."
VTOL_TRANSLATION_FINAL_COURSE_MODE.ANTICIPATE_NEXT_TRANSLATION.__doc__ = "The aircraft will evaluate the procedure ahead to determine the translation bearing and rate."

agcls.AgTypeNameMap["VTOL_TRANSLATION_FINAL_COURSE_MODE"] = VTOL_TRANSLATION_FINAL_COURSE_MODE

class HOVER_MODE(IntEnum):
    """The hover mode."""
    HOVER_MODE_FIXED_TIME = 0
    """Hover in place for a fixed time."""
    HOVER_MODE_MANEUVER = 1
    """Perform a hovering maneuver."""

HOVER_MODE.HOVER_MODE_FIXED_TIME.__doc__ = "Hover in place for a fixed time."
HOVER_MODE.HOVER_MODE_MANEUVER.__doc__ = "Perform a hovering maneuver."

agcls.AgTypeNameMap["HOVER_MODE"] = HOVER_MODE

class VTOL_HEADING_MODE(IntEnum):
    """The heading mode for the hover maneuver."""
    HEADING_INDEPENDENT = 0
    """The aircraft's heading is independent of its translation."""
    HEADING_ALIGN_TRANSLATION_COURSE = 1
    """The aircraft will align its heading with the translation course."""
    HEADING_INTO_WIND = 2
    """The aircraft will set its heading into the wind."""

VTOL_HEADING_MODE.HEADING_INDEPENDENT.__doc__ = "The aircraft's heading is independent of its translation."
VTOL_HEADING_MODE.HEADING_ALIGN_TRANSLATION_COURSE.__doc__ = "The aircraft will align its heading with the translation course."
VTOL_HEADING_MODE.HEADING_INTO_WIND.__doc__ = "The aircraft will set its heading into the wind."

agcls.AgTypeNameMap["VTOL_HEADING_MODE"] = VTOL_HEADING_MODE

class VERT_LANDING_MODE(IntEnum):
    """The heading mode for a vertical landing maneuver."""
    VERT_LANDING_INDEPENDENT = 0
    """The aircraft's heading is independent of its translation."""
    VERT_LANDING_ALIGN_TRANSLATION_COURSE = 1
    """The aircraft will align its heading with the translation course."""
    VERT_LANDING_INTO_WIND = 2
    """The aircraft will set its heading into the wind."""
    VERT_LANDING_ALIGN_TRANSLATION_COURSE_OVERRIDE = 3
    """The aircraft will align its heading with the translation course  will achieve the specified heading upon arriving."""

VERT_LANDING_MODE.VERT_LANDING_INDEPENDENT.__doc__ = "The aircraft's heading is independent of its translation."
VERT_LANDING_MODE.VERT_LANDING_ALIGN_TRANSLATION_COURSE.__doc__ = "The aircraft will align its heading with the translation course."
VERT_LANDING_MODE.VERT_LANDING_INTO_WIND.__doc__ = "The aircraft will set its heading into the wind."
VERT_LANDING_MODE.VERT_LANDING_ALIGN_TRANSLATION_COURSE_OVERRIDE.__doc__ = "The aircraft will align its heading with the translation course  will achieve the specified heading upon arriving."

agcls.AgTypeNameMap["VERT_LANDING_MODE"] = VERT_LANDING_MODE

class LAUNCH_ATTITUDE_MODE(IntEnum):
    """The attitude mode for the launch procedure."""
    LAUNCH_ALIGN_DIRECTION_VECTOR = 0
    """The aircraft's attitude is aligned with the specified direction vector."""
    LAUNCH_HOLD_PARENT_ATTITUDE = 1
    """The aircraft will maintain the parent vehicle's attiude at the time of launch."""
    LAUNCH_VTOL = 2
    """The aircraft launches in level flight"""

LAUNCH_ATTITUDE_MODE.LAUNCH_ALIGN_DIRECTION_VECTOR.__doc__ = "The aircraft's attitude is aligned with the specified direction vector."
LAUNCH_ATTITUDE_MODE.LAUNCH_HOLD_PARENT_ATTITUDE.__doc__ = "The aircraft will maintain the parent vehicle's attiude at the time of launch."
LAUNCH_ATTITUDE_MODE.LAUNCH_VTOL.__doc__ = "The aircraft launches in level flight"

agcls.AgTypeNameMap["LAUNCH_ATTITUDE_MODE"] = LAUNCH_ATTITUDE_MODE

class FUEL_FLOW_TYPE(IntEnum):
    """The fuel flow type to use for the procedure."""
    FUEL_FLOW_TAKEOFF = 0
    """Fuel flow defined for the current Takeoff performance model."""
    FUEL_FLOW_CRUISE = 1
    """Fuel flow defined for the current Cruise performance model."""
    FUEL_FLOW_LANDING = 2
    """Fuel flow defined for the current Landing performance model."""
    FUEL_FLOW_VTOL = 3
    """Fuel flow defined for the current VTOL performance model."""
    FUEL_FLOW_AERO_PROP = 4
    """Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model."""
    FUEL_FLOW_OVERRIDE = 5
    """Fuel flow defined manually."""

FUEL_FLOW_TYPE.FUEL_FLOW_TAKEOFF.__doc__ = "Fuel flow defined for the current Takeoff performance model."
FUEL_FLOW_TYPE.FUEL_FLOW_CRUISE.__doc__ = "Fuel flow defined for the current Cruise performance model."
FUEL_FLOW_TYPE.FUEL_FLOW_LANDING.__doc__ = "Fuel flow defined for the current Landing performance model."
FUEL_FLOW_TYPE.FUEL_FLOW_VTOL.__doc__ = "Fuel flow defined for the current VTOL performance model."
FUEL_FLOW_TYPE.FUEL_FLOW_AERO_PROP.__doc__ = "Fuel flow defined for the Aerodynamics and Propulsion Analysis component of the current basic acceleration performance model."
FUEL_FLOW_TYPE.FUEL_FLOW_OVERRIDE.__doc__ = "Fuel flow defined manually."

agcls.AgTypeNameMap["FUEL_FLOW_TYPE"] = FUEL_FLOW_TYPE

class LINE_ORIENTATION(IntEnum):
    """The orientation for a parallel flight line procedure."""
    FLIGHT_LINE_TO_LEFT = 0
    """Left of the previous flight line."""
    FLIGHT_LINE_TO_RIGHT = 1
    """Right of the previous flight line."""

LINE_ORIENTATION.FLIGHT_LINE_TO_LEFT.__doc__ = "Left of the previous flight line."
LINE_ORIENTATION.FLIGHT_LINE_TO_RIGHT.__doc__ = "Right of the previous flight line."

agcls.AgTypeNameMap["LINE_ORIENTATION"] = LINE_ORIENTATION

class REL_ABS_BEARING(IntEnum):
    """The options for a bearing that can be relative or absolute."""
    RELATIVE_BEARING = 0
    """A bearing relative to the previous course."""
    TRUE_BEARING = 1
    """A bearing using true north."""
    MAGNETIC_BEARING = 2
    """A bearing using magnetic north."""

REL_ABS_BEARING.RELATIVE_BEARING.__doc__ = "A bearing relative to the previous course."
REL_ABS_BEARING.TRUE_BEARING.__doc__ = "A bearing using true north."
REL_ABS_BEARING.MAGNETIC_BEARING.__doc__ = "A bearing using magnetic north."

agcls.AgTypeNameMap["REL_ABS_BEARING"] = REL_ABS_BEARING

class BASIC_FIXED_WING_PROP_MODE(IntEnum):
    """The option to specify the thrust (jet engines) or power (propellers)."""
    SPECIFY_THRUST = 0
    """Jet - Specify net thrust."""
    SPECIFY_POWER = 1
    """Propeller - Specify net power."""

BASIC_FIXED_WING_PROP_MODE.SPECIFY_THRUST.__doc__ = "Jet - Specify net thrust."
BASIC_FIXED_WING_PROP_MODE.SPECIFY_POWER.__doc__ = "Propeller - Specify net power."

agcls.AgTypeNameMap["BASIC_FIXED_WING_PROP_MODE"] = BASIC_FIXED_WING_PROP_MODE

class CLIMB_SPEED_TYPE(IntEnum):
    """The mode to calculate the aircraft's airspeed while climbing for an advanced climb performance model."""
    CLIMB_SPEED_BEST_RATE = 0
    """The speed at which the aircraft's rate of climb is maximized."""
    CLIMB_SPEED_BEST_ANGLE = 1
    """The speed at which the aircraft will gain the most altitude over downrange distance."""
    CLIMB_SPEED_MIN_FUEL = 2
    """The speed at which the aircraft's fuel consumption is minimized."""
    CLIMB_SPEED_OVERRIDE = 3
    """Manually specify the speed."""

CLIMB_SPEED_TYPE.CLIMB_SPEED_BEST_RATE.__doc__ = "The speed at which the aircraft's rate of climb is maximized."
CLIMB_SPEED_TYPE.CLIMB_SPEED_BEST_ANGLE.__doc__ = "The speed at which the aircraft will gain the most altitude over downrange distance."
CLIMB_SPEED_TYPE.CLIMB_SPEED_MIN_FUEL.__doc__ = "The speed at which the aircraft's fuel consumption is minimized."
CLIMB_SPEED_TYPE.CLIMB_SPEED_OVERRIDE.__doc__ = "Manually specify the speed."

agcls.AgTypeNameMap["CLIMB_SPEED_TYPE"] = CLIMB_SPEED_TYPE

class CRUISE_MAX_PERF_SPEED_TYPE(IntEnum):
    """The method for defining the maximum performance airspeed of the aircraft for an advanced cruise model."""
    CORNER_SPEED = 0
    """The lowest speed at which the aircraft can generate lift while pulling maximum Gs."""
    MAX_PS_DRY_THRUST = 1
    """The maximum specific excess power without afterburning."""
    MAX_PS_AFTERBURNER = 2
    """The maximum specific excess power while afterburning."""
    MAX_SPEED_DRY_THRUST = 3
    """The maximum speed without afterburning."""
    MAX_RANGE_AFTERBURNER = 4
    """The speed which maximizes the aircraft range while afterburning."""

CRUISE_MAX_PERF_SPEED_TYPE.CORNER_SPEED.__doc__ = "The lowest speed at which the aircraft can generate lift while pulling maximum Gs."
CRUISE_MAX_PERF_SPEED_TYPE.MAX_PS_DRY_THRUST.__doc__ = "The maximum specific excess power without afterburning."
CRUISE_MAX_PERF_SPEED_TYPE.MAX_PS_AFTERBURNER.__doc__ = "The maximum specific excess power while afterburning."
CRUISE_MAX_PERF_SPEED_TYPE.MAX_SPEED_DRY_THRUST.__doc__ = "The maximum speed without afterburning."
CRUISE_MAX_PERF_SPEED_TYPE.MAX_RANGE_AFTERBURNER.__doc__ = "The speed which maximizes the aircraft range while afterburning."

agcls.AgTypeNameMap["CRUISE_MAX_PERF_SPEED_TYPE"] = CRUISE_MAX_PERF_SPEED_TYPE

class DESCENT_SPEED_TYPE(IntEnum):
    """The method for calculating the aircraft's airspeed while descending."""
    DESCENT_MAX_RANGE_CRUISE = 0
    """A variable airspeed that maximizes the distance that the aircraft can fly."""
    DESCENT_MAX_GLIDE_RATIO = 1
    """The speed at which the aircraft's glide ratio is maximized."""
    DESCENT_MIN_SINK_RATE = 2
    """The speed at which the aircraft's rate of descent is minimized."""
    DESCENT_STALL_SPEED_RATIO = 3
    """A speed relative to the aircraft's stall speed.."""
    DESCENT_SPEED_OVERRIDE = 4
    """Manually define the airspeed."""

DESCENT_SPEED_TYPE.DESCENT_MAX_RANGE_CRUISE.__doc__ = "A variable airspeed that maximizes the distance that the aircraft can fly."
DESCENT_SPEED_TYPE.DESCENT_MAX_GLIDE_RATIO.__doc__ = "The speed at which the aircraft's glide ratio is maximized."
DESCENT_SPEED_TYPE.DESCENT_MIN_SINK_RATE.__doc__ = "The speed at which the aircraft's rate of descent is minimized."
DESCENT_SPEED_TYPE.DESCENT_STALL_SPEED_RATIO.__doc__ = "A speed relative to the aircraft's stall speed.."
DESCENT_SPEED_TYPE.DESCENT_SPEED_OVERRIDE.__doc__ = "Manually define the airspeed."

agcls.AgTypeNameMap["DESCENT_SPEED_TYPE"] = DESCENT_SPEED_TYPE

class TAKEOFF_LANDING_SPEED_MODE(IntEnum):
    """The method for calculating the aircraft's speed upon leaving the ground or at wheels down."""
    TAKEOFF_LANDING_STALL_SPEED_RATIO = 0
    """A multiple of the aircraft's stall speed."""
    TAKEOFF_LANDING_ANGLE_OF_ATTACK = 1
    """The speed needed to achieve lift at the specified Angle of Attack."""

TAKEOFF_LANDING_SPEED_MODE.TAKEOFF_LANDING_STALL_SPEED_RATIO.__doc__ = "A multiple of the aircraft's stall speed."
TAKEOFF_LANDING_SPEED_MODE.TAKEOFF_LANDING_ANGLE_OF_ATTACK.__doc__ = "The speed needed to achieve lift at the specified Angle of Attack."

agcls.AgTypeNameMap["TAKEOFF_LANDING_SPEED_MODE"] = TAKEOFF_LANDING_SPEED_MODE

class DEPARTURE_SPEED_MODE(IntEnum):
    """The method for calculating the aircraft's airspeed upon leaving the ground."""
    MAX_CLIMB_ANGLE = 0
    """The aircraft will fly at the max climb angle."""
    MAX_CLIMB_RATE = 1
    """The aircraft will fly at the max climb rate."""
    USE_CLIMB_MODEL = 2
    """The aircraft will fly at the airspeed defined in the Climb performance model."""

DEPARTURE_SPEED_MODE.MAX_CLIMB_ANGLE.__doc__ = "The aircraft will fly at the max climb angle."
DEPARTURE_SPEED_MODE.MAX_CLIMB_RATE.__doc__ = "The aircraft will fly at the max climb rate."
DEPARTURE_SPEED_MODE.USE_CLIMB_MODEL.__doc__ = "The aircraft will fly at the airspeed defined in the Climb performance model."

agcls.AgTypeNameMap["DEPARTURE_SPEED_MODE"] = DEPARTURE_SPEED_MODE

class ADV_FIXED_WING_AERO_STRATEGY(IntEnum):
    """The aerodynamic strategy for the Advanced Fixed Wing Tool."""
    EXTERNAL_AERO_FILE = 0
    """Define the aerodynamics using an external .aero file."""
    SUB_SUPER_HYPER_AERO = 1
    """Define the aerodynamics using a model derived from first principles that is valid for the full speed range of high speed aircraft."""
    SUBSONIC_AERO = 2
    """Define the aerodynamics for an aircraft that generally travels at subsonic speeds."""
    SUPERSONIC_AERO = 3
    """Define the aerodynamics for an aircraft that generally travels at supersonic speeds."""

ADV_FIXED_WING_AERO_STRATEGY.EXTERNAL_AERO_FILE.__doc__ = "Define the aerodynamics using an external .aero file."
ADV_FIXED_WING_AERO_STRATEGY.SUB_SUPER_HYPER_AERO.__doc__ = "Define the aerodynamics using a model derived from first principles that is valid for the full speed range of high speed aircraft."
ADV_FIXED_WING_AERO_STRATEGY.SUBSONIC_AERO.__doc__ = "Define the aerodynamics for an aircraft that generally travels at subsonic speeds."
ADV_FIXED_WING_AERO_STRATEGY.SUPERSONIC_AERO.__doc__ = "Define the aerodynamics for an aircraft that generally travels at supersonic speeds."

agcls.AgTypeNameMap["ADV_FIXED_WING_AERO_STRATEGY"] = ADV_FIXED_WING_AERO_STRATEGY

class ADV_FIXED_WING_GEOMETRY(IntEnum):
    """The method to define the wing geometry of an aircraft in the Advanced Fixed Wing Tool."""
    BASIC_GEOMETRY = 0
    """Define the static properties of an immovable wing."""
    VARIABLE_GEOMETRY = 1
    """Define the minimum and maximum properties of an adjustable wing."""

ADV_FIXED_WING_GEOMETRY.BASIC_GEOMETRY.__doc__ = "Define the static properties of an immovable wing."
ADV_FIXED_WING_GEOMETRY.VARIABLE_GEOMETRY.__doc__ = "Define the minimum and maximum properties of an adjustable wing."

agcls.AgTypeNameMap["ADV_FIXED_WING_GEOMETRY"] = ADV_FIXED_WING_GEOMETRY

class ADV_FIXED_WING_POWERPLANT_STRATEGY(IntEnum):
    """The powerplant strategy for the Advanced Fixed Wing Tool."""
    ELECTRIC_POWERPLANT = 0
    """An electric engine."""
    EXTERNAL_PROP_FILE = 1
    """Define the powerplant using an external .prop file."""
    PISTON_POWERPLANT = 2
    """A piston, or reciprocating, engine."""
    SUB_SUPER_HYPER_POWERPLANT = 3
    """A thermodynamic model that includes turbine, ramjet, and scramjet performance modes."""
    TURBOFAN_BASIC_AB = 4
    """A thermodynamic model of a dual-spool turbofan engine that has an afterburner."""
    TURBOFAN_HIGH_BYPASS = 5
    """An empirical model for a turbofan engine that produces significantly more fan thrust than jet thrust."""
    TURBOFAN_LOW_BYPASS = 6
    """An empirical model for a turbofan engine that produces significantly more jet thrust than fan thrust."""
    TURBOFAN_LOW_BYPASS_AFTERBURNING = 7
    """An empirical model for a turbofan engine that has an afterburner and produces significantly more jet thrust than fan thrust."""
    TURBOJET_AFTERBURNING = 8
    """An empirical model that models a turbojet engine that has an afterburner."""
    TURBOJET_BASIC_AB = 9
    """An empirical model that models a turbojet engine."""
    TURBOJET = 10
    """An empirical model that models a turbojet engine."""
    TURBOPROP = 11
    """An empirical model that models a turboprop engine."""

ADV_FIXED_WING_POWERPLANT_STRATEGY.ELECTRIC_POWERPLANT.__doc__ = "An electric engine."
ADV_FIXED_WING_POWERPLANT_STRATEGY.EXTERNAL_PROP_FILE.__doc__ = "Define the powerplant using an external .prop file."
ADV_FIXED_WING_POWERPLANT_STRATEGY.PISTON_POWERPLANT.__doc__ = "A piston, or reciprocating, engine."
ADV_FIXED_WING_POWERPLANT_STRATEGY.SUB_SUPER_HYPER_POWERPLANT.__doc__ = "A thermodynamic model that includes turbine, ramjet, and scramjet performance modes."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_BASIC_AB.__doc__ = "A thermodynamic model of a dual-spool turbofan engine that has an afterburner."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_HIGH_BYPASS.__doc__ = "An empirical model for a turbofan engine that produces significantly more fan thrust than jet thrust."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_LOW_BYPASS.__doc__ = "An empirical model for a turbofan engine that produces significantly more jet thrust than fan thrust."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOFAN_LOW_BYPASS_AFTERBURNING.__doc__ = "An empirical model for a turbofan engine that has an afterburner and produces significantly more jet thrust than fan thrust."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOJET_AFTERBURNING.__doc__ = "An empirical model that models a turbojet engine that has an afterburner."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOJET_BASIC_AB.__doc__ = "An empirical model that models a turbojet engine."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOJET.__doc__ = "An empirical model that models a turbojet engine."
ADV_FIXED_WING_POWERPLANT_STRATEGY.TURBOPROP.__doc__ = "An empirical model that models a turboprop engine."

agcls.AgTypeNameMap["ADV_FIXED_WING_POWERPLANT_STRATEGY"] = ADV_FIXED_WING_POWERPLANT_STRATEGY

class MISSILE_AERO_STRATEGY(IntEnum):
    """The aerodynamic strategy used to compute lift, drag, angle of attack, sideslip and intermediate / derived values."""
    MISSILE_AERO_SIMPLE = 0
    """Simple aerodynamics."""
    MISSILE_AERO_EXTERNAL_FILE = 1
    """External file aerodynamics."""
    MISSILE_AERO_ADVANCED = 2
    """Advanced missile aerodynamics."""

MISSILE_AERO_STRATEGY.MISSILE_AERO_SIMPLE.__doc__ = "Simple aerodynamics."
MISSILE_AERO_STRATEGY.MISSILE_AERO_EXTERNAL_FILE.__doc__ = "External file aerodynamics."
MISSILE_AERO_STRATEGY.MISSILE_AERO_ADVANCED.__doc__ = "Advanced missile aerodynamics."

agcls.AgTypeNameMap["MISSILE_AERO_STRATEGY"] = MISSILE_AERO_STRATEGY

class MISSILE_PROP_STRATEGY(IntEnum):
    """The propulsion strategy used to compute thrust and throttle setting."""
    MISSILE_PROP_SIMPLE = 0
    """Simple propulsion."""
    MISSILE_PROP_EXTERNAL_FILE = 1
    """External file propulsion."""
    MISSILE_PROP_RAMJET = 2
    """Ramjet propulsion."""
    MISSILE_PROP_ROCKET = 3
    """Rocket propulsion."""
    MISSILE_PROP_TURBOJET = 4
    """Turbojet propulsion."""

MISSILE_PROP_STRATEGY.MISSILE_PROP_SIMPLE.__doc__ = "Simple propulsion."
MISSILE_PROP_STRATEGY.MISSILE_PROP_EXTERNAL_FILE.__doc__ = "External file propulsion."
MISSILE_PROP_STRATEGY.MISSILE_PROP_RAMJET.__doc__ = "Ramjet propulsion."
MISSILE_PROP_STRATEGY.MISSILE_PROP_ROCKET.__doc__ = "Rocket propulsion."
MISSILE_PROP_STRATEGY.MISSILE_PROP_TURBOJET.__doc__ = "Turbojet propulsion."

agcls.AgTypeNameMap["MISSILE_PROP_STRATEGY"] = MISSILE_PROP_STRATEGY

class ROTORCRAFT_POWERPLANT_TYPE(IntEnum):
    """The powerplant type for a rotorcraft."""
    ROTORCRAFT_ELECTRIC = 0
    """Electric propulsion."""
    ROTORCRAFT_TURBOSHAFT = 1
    """Turboshaft propulsion."""
    ROTORCRAFT_PISTON = 2
    """Piston propulsion."""

ROTORCRAFT_POWERPLANT_TYPE.ROTORCRAFT_ELECTRIC.__doc__ = "Electric propulsion."
ROTORCRAFT_POWERPLANT_TYPE.ROTORCRAFT_TURBOSHAFT.__doc__ = "Turboshaft propulsion."
ROTORCRAFT_POWERPLANT_TYPE.ROTORCRAFT_PISTON.__doc__ = "Piston propulsion."

agcls.AgTypeNameMap["ROTORCRAFT_POWERPLANT_TYPE"] = ROTORCRAFT_POWERPLANT_TYPE

class MINIMIZE_SITE_PROC_TIME_DIFF(IntEnum):
    """Options for minimizing the time difference between the procedure and site times."""
    MINIMIZE_TIME_DIFFERENCE_OFF = 0
    """Do not converge the procedure and site times."""
    MINIMIZE_TIME_DIFFERENCE_ALWAYS = 1
    """Always recalculate."""
    MINIMIZE_TIME_DIFFERENCE_NEXT_UPDATE = 2
    """Only recalculate when updated."""

MINIMIZE_SITE_PROC_TIME_DIFF.MINIMIZE_TIME_DIFFERENCE_OFF.__doc__ = "Do not converge the procedure and site times."
MINIMIZE_SITE_PROC_TIME_DIFF.MINIMIZE_TIME_DIFFERENCE_ALWAYS.__doc__ = "Always recalculate."
MINIMIZE_SITE_PROC_TIME_DIFF.MINIMIZE_TIME_DIFFERENCE_NEXT_UPDATE.__doc__ = "Only recalculate when updated."

agcls.AgTypeNameMap["MINIMIZE_SITE_PROC_TIME_DIFF"] = MINIMIZE_SITE_PROC_TIME_DIFF

class STK_OBJECT_WAYPOINT_OFFSET_MODE(IntEnum):
    """The options to offset the site location relative to the STK Object."""
    OFFSET_NONE = 0
    """No offset."""
    OFFSET_BEARING_RANGE = 1
    """Bearing/Range (relative to North)."""
    OFFSET_VGT_POINT = 2
    """VGT Point."""
    OFFSET_RELATIVE_BEARING_RANGE = 3
    """Bearing/Reange relative to Vehicle course."""

STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_NONE.__doc__ = "No offset."
STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_BEARING_RANGE.__doc__ = "Bearing/Range (relative to North)."
STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_VGT_POINT.__doc__ = "VGT Point."
STK_OBJECT_WAYPOINT_OFFSET_MODE.OFFSET_RELATIVE_BEARING_RANGE.__doc__ = "Bearing/Reange relative to Vehicle course."

agcls.AgTypeNameMap["STK_OBJECT_WAYPOINT_OFFSET_MODE"] = STK_OBJECT_WAYPOINT_OFFSET_MODE

class SEARCH_PATTERN_COURSE_MODE(IntEnum):
    """The mode to determine the course of the search pattern."""
    COURSE_MODE_LOW = 0
    """Automatically begin the search pattern within 0 - 180 degrees."""
    COURSE_MODE_HIGH = 1
    """Automatically begin the search pattern within 180 - 360 degrees."""
    COURSE_MODE_OVERRIDE = 2
    """Manually define the course of the search pattern."""

SEARCH_PATTERN_COURSE_MODE.COURSE_MODE_LOW.__doc__ = "Automatically begin the search pattern within 0 - 180 degrees."
SEARCH_PATTERN_COURSE_MODE.COURSE_MODE_HIGH.__doc__ = "Automatically begin the search pattern within 180 - 360 degrees."
SEARCH_PATTERN_COURSE_MODE.COURSE_MODE_OVERRIDE.__doc__ = "Manually define the course of the search pattern."

agcls.AgTypeNameMap["SEARCH_PATTERN_COURSE_MODE"] = SEARCH_PATTERN_COURSE_MODE

class DELAY_TURN_DIRECTION(IntEnum):
    """Turn mode for procedures with Delay options."""
    DELAY_TURN_AUTO = 0
    """Automatic turn. Aviator will determine the direction of the turn."""
    DELAY_TURN_LEFT = 1
    """Left turn."""
    DELAY_TURN_RIGHT = 2
    """Right turn."""

DELAY_TURN_DIRECTION.DELAY_TURN_AUTO.__doc__ = "Automatic turn. Aviator will determine the direction of the turn."
DELAY_TURN_DIRECTION.DELAY_TURN_LEFT.__doc__ = "Left turn."
DELAY_TURN_DIRECTION.DELAY_TURN_RIGHT.__doc__ = "Right turn."

agcls.AgTypeNameMap["DELAY_TURN_DIRECTION"] = DELAY_TURN_DIRECTION

class TRAJECTORY_BLEND_MODE(IntEnum):
    """The interpolation mode to determine the aircraft's position and velocity."""
    BLEND_BODY_QUADRATIC = 0
    """Quadratic interpolation using the body frame."""
    BLEND_BODY_CUBIC = 1
    """Cubic interpolation using the body frame."""
    BLEND_LH_QUADRATIC = 2
    """Quadratic interpolation using the local horizontal frame."""
    BLEND_LH_CUBIC = 3
    """Cubic interpolation using the local horizontal frame."""
    BLEND_ECF_QUADRATIC = 4
    """Quadratic interpolation using the Earth-Centered Fixed frame."""
    BLEND_ECF_CUBIC = 5
    """Cubic interpolation using the Earth-Centered Fixed frame."""

TRAJECTORY_BLEND_MODE.BLEND_BODY_QUADRATIC.__doc__ = "Quadratic interpolation using the body frame."
TRAJECTORY_BLEND_MODE.BLEND_BODY_CUBIC.__doc__ = "Cubic interpolation using the body frame."
TRAJECTORY_BLEND_MODE.BLEND_LH_QUADRATIC.__doc__ = "Quadratic interpolation using the local horizontal frame."
TRAJECTORY_BLEND_MODE.BLEND_LH_CUBIC.__doc__ = "Cubic interpolation using the local horizontal frame."
TRAJECTORY_BLEND_MODE.BLEND_ECF_QUADRATIC.__doc__ = "Quadratic interpolation using the Earth-Centered Fixed frame."
TRAJECTORY_BLEND_MODE.BLEND_ECF_CUBIC.__doc__ = "Cubic interpolation using the Earth-Centered Fixed frame."

agcls.AgTypeNameMap["TRAJECTORY_BLEND_MODE"] = TRAJECTORY_BLEND_MODE

class REFERENCE_STATE_PERF_MODE(IntEnum):
    """The type of motion the aircraft is engaged in at the reference state."""
    REFERENCE_STATE_CLIMB = 0
    """Forward Flight - Climb performance mode."""
    REFERENCE_STATE_CRUISE = 1
    """Forward Flight - Cruise performance mode."""
    REFERENCE_STATE_DESCEND = 2
    """Forward Flight - Descend performance mode."""
    REFERENCE_STATE_HOVER = 3
    """Hover performance mode."""
    REFERENCE_STATE_LANDING = 4
    """Landing performance mode."""
    REFERENCE_STATE_TAKEOFF = 5
    """Takeoff performance mode."""
    REFERENCE_STATE_LANDING_ROLLOUT = 6
    """Weight On Wheels - Landing Rollout performance mode"""
    REFERENCE_STATE_TAKEOFF_RUN = 7
    """Weight On Wheels - Takeoff Run performance mode"""

REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_CLIMB.__doc__ = "Forward Flight - Climb performance mode."
REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_CRUISE.__doc__ = "Forward Flight - Cruise performance mode."
REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_DESCEND.__doc__ = "Forward Flight - Descend performance mode."
REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_HOVER.__doc__ = "Hover performance mode."
REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_LANDING.__doc__ = "Landing performance mode."
REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_TAKEOFF.__doc__ = "Takeoff performance mode."
REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_LANDING_ROLLOUT.__doc__ = "Weight On Wheels - Landing Rollout performance mode"
REFERENCE_STATE_PERF_MODE.REFERENCE_STATE_TAKEOFF_RUN.__doc__ = "Weight On Wheels - Takeoff Run performance mode"

agcls.AgTypeNameMap["REFERENCE_STATE_PERF_MODE"] = REFERENCE_STATE_PERF_MODE

class REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE(IntEnum):
    """The mode to specify the longitudinal acceleration of the aircraft."""
    SPECIFY_TAS_DOT = 0
    """Specify the true airspeed acceleration."""
    SPECIFY_GROUND_SPEED_DOT = 1
    """Specify the groundspeed acceleration."""

REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE.SPECIFY_TAS_DOT.__doc__ = "Specify the true airspeed acceleration."
REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE.SPECIFY_GROUND_SPEED_DOT.__doc__ = "Specify the groundspeed acceleration."

agcls.AgTypeNameMap["REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE"] = REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE

class REFERENCE_STATE_LATERAL_ACCEL_MODE(IntEnum):
    """The mode to specify the lateral acceleration of the aircraft."""
    SPECIFY_HEADING_DOT = 0
    """Specify the heading rate of change."""
    SPECIFY_COURSE_DOT = 1
    """Specify the course rate of change."""

REFERENCE_STATE_LATERAL_ACCEL_MODE.SPECIFY_HEADING_DOT.__doc__ = "Specify the heading rate of change."
REFERENCE_STATE_LATERAL_ACCEL_MODE.SPECIFY_COURSE_DOT.__doc__ = "Specify the course rate of change."

agcls.AgTypeNameMap["REFERENCE_STATE_LATERAL_ACCEL_MODE"] = REFERENCE_STATE_LATERAL_ACCEL_MODE

class REFERENCE_STATE_ATTITUDE_MODE(IntEnum):
    """The mode to specify the attitude rate of change."""
    SPECIFY_PUSH_PULL_G = 0
    """Specify the push/pull G."""
    SPECIFY_PITCH_RATE = 1
    """Specify the pitch rate of change."""

REFERENCE_STATE_ATTITUDE_MODE.SPECIFY_PUSH_PULL_G.__doc__ = "Specify the push/pull G."
REFERENCE_STATE_ATTITUDE_MODE.SPECIFY_PITCH_RATE.__doc__ = "Specify the pitch rate of change."

agcls.AgTypeNameMap["REFERENCE_STATE_ATTITUDE_MODE"] = REFERENCE_STATE_ATTITUDE_MODE

class AND_OR(IntEnum):
    """The option to specify AND or OR."""
    AND = 0
    """And option."""
    OR = 1
    """Or option."""

AND_OR.AND.__doc__ = "And option."
AND_OR.OR.__doc__ = "Or option."

agcls.AgTypeNameMap["AND_OR"] = AND_OR

class JET_ENGINE_TECHNOLOGY_LEVEL(IntEnum):
    """The technology level of the jet engine."""
    IDEAL = 0
    """Ideal (perfect efficiencies)."""
    LEVEL1 = 1
    """Level 1 (1945-1965)."""
    LEVEL2 = 2
    """Level 2 (1965-1985)."""
    LEVEL3 = 3
    """Level 3 (1985-2005)."""
    LEVEL4 = 4
    """Level 4 (2005-2025)."""
    LEVEL5 = 5
    """Level 5 (2025-2045)."""

JET_ENGINE_TECHNOLOGY_LEVEL.IDEAL.__doc__ = "Ideal (perfect efficiencies)."
JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL1.__doc__ = "Level 1 (1945-1965)."
JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL2.__doc__ = "Level 2 (1965-1985)."
JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL3.__doc__ = "Level 3 (1985-2005)."
JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL4.__doc__ = "Level 4 (2005-2025)."
JET_ENGINE_TECHNOLOGY_LEVEL.LEVEL5.__doc__ = "Level 5 (2025-2045)."

agcls.AgTypeNameMap["JET_ENGINE_TECHNOLOGY_LEVEL"] = JET_ENGINE_TECHNOLOGY_LEVEL

class JET_ENGINE_INTAKE_TYPE(IntEnum):
    """The intake type of the jet engine."""
    SUBSONIC_NACELLES = 0
    """Subsonic nacelles."""
    SUBSONIC_EMBEDDED = 1
    """Subsonic embedded."""
    SUPERSONIC_EMBEDDED = 2
    """Supersonic embedded."""

JET_ENGINE_INTAKE_TYPE.SUBSONIC_NACELLES.__doc__ = "Subsonic nacelles."
JET_ENGINE_INTAKE_TYPE.SUBSONIC_EMBEDDED.__doc__ = "Subsonic embedded."
JET_ENGINE_INTAKE_TYPE.SUPERSONIC_EMBEDDED.__doc__ = "Supersonic embedded."

agcls.AgTypeNameMap["JET_ENGINE_INTAKE_TYPE"] = JET_ENGINE_INTAKE_TYPE

class JET_ENGINE_TURBINE_TYPE(IntEnum):
    """The turbine type of the jet engine."""
    UNCOOLED = 0
    """Uncooled turbine."""
    COOLED = 1
    """Cooled turbine."""

JET_ENGINE_TURBINE_TYPE.UNCOOLED.__doc__ = "Uncooled turbine."
JET_ENGINE_TURBINE_TYPE.COOLED.__doc__ = "Cooled turbine."

agcls.AgTypeNameMap["JET_ENGINE_TURBINE_TYPE"] = JET_ENGINE_TURBINE_TYPE

class JET_ENGINE_EXHAUST_NOZZLE_TYPE(IntEnum):
    """The exhaust nozzle type of the jet engine."""
    FIXED_AREA_CONVERGENT = 0
    """Fixed Area Convergent."""
    VARIABLE_AREA_CONVERGENT = 1
    """Variable Area Convergent."""
    VARIABLE_AREA_CONVERGENT_DIVERGENT = 2
    """Variable Area Convergent - Divergent."""

JET_ENGINE_EXHAUST_NOZZLE_TYPE.FIXED_AREA_CONVERGENT.__doc__ = "Fixed Area Convergent."
JET_ENGINE_EXHAUST_NOZZLE_TYPE.VARIABLE_AREA_CONVERGENT.__doc__ = "Variable Area Convergent."
JET_ENGINE_EXHAUST_NOZZLE_TYPE.VARIABLE_AREA_CONVERGENT_DIVERGENT.__doc__ = "Variable Area Convergent - Divergent."

agcls.AgTypeNameMap["JET_ENGINE_EXHAUST_NOZZLE_TYPE"] = JET_ENGINE_EXHAUST_NOZZLE_TYPE

class JET_FUEL_TYPE(IntEnum):
    """The jet fuel type."""
    KEROSENE_AFPROP = 0
    """A kerosene fuel model based on AFPROP."""
    KEROSENE_CEA = 1
    """A kerosene fuel model based on NASA CEA."""
    HYDROGEN = 2
    """A hydrogen fuel model based on NASA CEA."""

JET_FUEL_TYPE.KEROSENE_AFPROP.__doc__ = "A kerosene fuel model based on AFPROP."
JET_FUEL_TYPE.KEROSENE_CEA.__doc__ = "A kerosene fuel model based on NASA CEA."
JET_FUEL_TYPE.HYDROGEN.__doc__ = "A hydrogen fuel model based on NASA CEA."

agcls.AgTypeNameMap["JET_FUEL_TYPE"] = JET_FUEL_TYPE

class AFPROP_FUEL_TYPE(IntEnum):
    """The AFPROP fuel type."""
    AFPROP_OVERRIDE = 0
    """Override the specific energy."""
    AFPROP_JET_A = 1
    """Jet A fuel model based on AFPROP."""
    AFPROP_JET_A1 = 2
    """Jet A-1 fuel model based on AFPROP."""
    AFPROPJP5 = 3
    """JP-5 fuel model based on AFPROP."""
    AFPROPJP7 = 4
    """JP-7 fuel model based on AFPROP."""

AFPROP_FUEL_TYPE.AFPROP_OVERRIDE.__doc__ = "Override the specific energy."
AFPROP_FUEL_TYPE.AFPROP_JET_A.__doc__ = "Jet A fuel model based on AFPROP."
AFPROP_FUEL_TYPE.AFPROP_JET_A1.__doc__ = "Jet A-1 fuel model based on AFPROP."
AFPROP_FUEL_TYPE.AFPROPJP5.__doc__ = "JP-5 fuel model based on AFPROP."
AFPROP_FUEL_TYPE.AFPROPJP7.__doc__ = "JP-7 fuel model based on AFPROP."

agcls.AgTypeNameMap["AFPROP_FUEL_TYPE"] = AFPROP_FUEL_TYPE

class CEA_FUEL_TYPE(IntEnum):
    """The CEA fuel type."""
    CEA_OVERRIDE = 0
    """Override the specific energy."""
    CEA_JET_A = 1
    """Jet A fuel model based on NASA CEA."""
    CEA_JET_A1 = 2
    """Jet A-1 fuel model based on NASA CEA."""
    CEAJP5 = 3
    """JP-5 fuel model based on NASA CEA."""
    CEAJP7 = 4
    """JP-7 fuel model based on NASA CEA."""

CEA_FUEL_TYPE.CEA_OVERRIDE.__doc__ = "Override the specific energy."
CEA_FUEL_TYPE.CEA_JET_A.__doc__ = "Jet A fuel model based on NASA CEA."
CEA_FUEL_TYPE.CEA_JET_A1.__doc__ = "Jet A-1 fuel model based on NASA CEA."
CEA_FUEL_TYPE.CEAJP5.__doc__ = "JP-5 fuel model based on NASA CEA."
CEA_FUEL_TYPE.CEAJP7.__doc__ = "JP-7 fuel model based on NASA CEA."

agcls.AgTypeNameMap["CEA_FUEL_TYPE"] = CEA_FUEL_TYPE

class TURBINE_MODE(IntEnum):
    """The turbine mode for a Sub/Super/Hypersonic powerplant."""
    TURBINE_MODE_DISABLED = 0
    """Disabled turbine mode."""
    TURBINE_MODE_TURBOJET_BASIC_AB = 1
    """Turbojet - Basic w/AB (Thermodynamic model)."""
    TURBINE_MODE_TURBOFAN_BASIC_AB = 2
    """Turbofan - Basic w/AB (Thermodynamic model)."""

TURBINE_MODE.TURBINE_MODE_DISABLED.__doc__ = "Disabled turbine mode."
TURBINE_MODE.TURBINE_MODE_TURBOJET_BASIC_AB.__doc__ = "Turbojet - Basic w/AB (Thermodynamic model)."
TURBINE_MODE.TURBINE_MODE_TURBOFAN_BASIC_AB.__doc__ = "Turbofan - Basic w/AB (Thermodynamic model)."

agcls.AgTypeNameMap["TURBINE_MODE"] = TURBINE_MODE

class RAMJET_MODE(IntEnum):
    """The ramjet mode for a Sub/Super/Hypersonic powerplant."""
    RAMJET_MODE_DISABLED = 0
    """Disabled ramjet mode."""
    RAMJET_MODE_BASIC = 1
    """Ramjet - Basic mode."""

RAMJET_MODE.RAMJET_MODE_DISABLED.__doc__ = "Disabled ramjet mode."
RAMJET_MODE.RAMJET_MODE_BASIC.__doc__ = "Ramjet - Basic mode."

agcls.AgTypeNameMap["RAMJET_MODE"] = RAMJET_MODE

class SCRAMJET_MODE(IntEnum):
    """The scramjet mode for a Sub/Super/Hypersonic powerplant."""
    SCRAMJET_MODE_DISABLED = 0
    """Disabled scramjet mode."""
    SCRAMJET_MODE_BASIC = 1
    """Scramjet - Basic mode."""

SCRAMJET_MODE.SCRAMJET_MODE_DISABLED.__doc__ = "Disabled scramjet mode."
SCRAMJET_MODE.SCRAMJET_MODE_BASIC.__doc__ = "Scramjet - Basic mode."

agcls.AgTypeNameMap["SCRAMJET_MODE"] = SCRAMJET_MODE

class NUMERICAL_INTEGRATOR(IntEnum):
    """The numerical integrator to be used for the procedure."""
    RUNGE_KUTTA4 = 0
    """Runge-Kutta 4th Order Fixed Time Step Integrator"""
    RUNGE_KUTTA45 = 1
    """Runge-Kutta 4th Order Adaptive Time Step Integrator."""

NUMERICAL_INTEGRATOR.RUNGE_KUTTA4.__doc__ = "Runge-Kutta 4th Order Fixed Time Step Integrator"
NUMERICAL_INTEGRATOR.RUNGE_KUTTA45.__doc__ = "Runge-Kutta 4th Order Adaptive Time Step Integrator."

agcls.AgTypeNameMap["NUMERICAL_INTEGRATOR"] = NUMERICAL_INTEGRATOR

class BALLISTIC_3D_CONTROL_MODE(IntEnum):
    """The control mode used to define the ballistic 3D strategy of the basic maneuver procedure."""
    BALLISTIC_3D_COMPENSATE_FOR_WIND = 0
    """The vehicle will compensate for the wind along its ballistic trajectory."""
    BALLISTIC_3D_WIND_PUSHES_VEHICLE = 1
    """Allow the wind to affect the ballistic trajectory."""
    BALLISTIC_3D_PARACHUTE_MODE = 2
    """Model the vehicle as a parachute."""

BALLISTIC_3D_CONTROL_MODE.BALLISTIC_3D_COMPENSATE_FOR_WIND.__doc__ = "The vehicle will compensate for the wind along its ballistic trajectory."
BALLISTIC_3D_CONTROL_MODE.BALLISTIC_3D_WIND_PUSHES_VEHICLE.__doc__ = "Allow the wind to affect the ballistic trajectory."
BALLISTIC_3D_CONTROL_MODE.BALLISTIC_3D_PARACHUTE_MODE.__doc__ = "Model the vehicle as a parachute."

agcls.AgTypeNameMap["BALLISTIC_3D_CONTROL_MODE"] = BALLISTIC_3D_CONTROL_MODE

class LAUNCH_DYN_STATE_COORD_FRAME(IntEnum):
    """The coordinate frame used for a LaunchDynState procedure."""
    LAUNCH_DYN_STATE_COORD_FRAME_BODY = 0
    """The object's body frame."""
    LAUNCH_DYN_STATE_COORD_FRAME_LOCAL_HORIZONTAL = 1
    """The object's local horizontal frame."""

LAUNCH_DYN_STATE_COORD_FRAME.LAUNCH_DYN_STATE_COORD_FRAME_BODY.__doc__ = "The object's body frame."
LAUNCH_DYN_STATE_COORD_FRAME.LAUNCH_DYN_STATE_COORD_FRAME_LOCAL_HORIZONTAL.__doc__ = "The object's local horizontal frame."

agcls.AgTypeNameMap["LAUNCH_DYN_STATE_COORD_FRAME"] = LAUNCH_DYN_STATE_COORD_FRAME

class LAUNCH_DYN_STATE_BEARING_REFERENCE(IntEnum):
    """The vector used as a bearing reference for a LaunchDynState procedure."""
    LAUNCH_DYN_STATE_BEARING_REFERENCE_VELOCITY = 0
    """The object's velocity vector."""
    LAUNCH_DYN_STATE_BEARING_REFERENCE_COORD_FRAME_X = 1
    """The X vector of the object's coordinate frame."""
    LAUNCH_DYN_STATE_BEARING_REFERENCE_NORTH = 2
    """The object's vector to North."""

LAUNCH_DYN_STATE_BEARING_REFERENCE.LAUNCH_DYN_STATE_BEARING_REFERENCE_VELOCITY.__doc__ = "The object's velocity vector."
LAUNCH_DYN_STATE_BEARING_REFERENCE.LAUNCH_DYN_STATE_BEARING_REFERENCE_COORD_FRAME_X.__doc__ = "The X vector of the object's coordinate frame."
LAUNCH_DYN_STATE_BEARING_REFERENCE.LAUNCH_DYN_STATE_BEARING_REFERENCE_NORTH.__doc__ = "The object's vector to North."

agcls.AgTypeNameMap["LAUNCH_DYN_STATE_BEARING_REFERENCE"] = LAUNCH_DYN_STATE_BEARING_REFERENCE

class ALTITUDE_REFERENCE(IntEnum):
    """The altitude reference."""
    ALTITUDE_REFERENCE_WGS84 = 0
    """Altitude above WGS84 ground reference."""
    ALTITUDE_REFERENCE_MSL = 1
    """Altitude above Mean Sea Level (MSL)."""
    ALTITUDE_REFERENCE_TERRAIN = 2
    """ALtitude above terrain."""

ALTITUDE_REFERENCE.ALTITUDE_REFERENCE_WGS84.__doc__ = "Altitude above WGS84 ground reference."
ALTITUDE_REFERENCE.ALTITUDE_REFERENCE_MSL.__doc__ = "Altitude above Mean Sea Level (MSL)."
ALTITUDE_REFERENCE.ALTITUDE_REFERENCE_TERRAIN.__doc__ = "ALtitude above terrain."

agcls.AgTypeNameMap["ALTITUDE_REFERENCE"] = ALTITUDE_REFERENCE

class SMOOTH_TURN_FPA_MODE(IntEnum):
    """The flight path angle mode for the Smooth Turn strategy of the Basic Maneuver procedure."""
    SMOOTH_TURN_FPA_HOLD_INITIAL = 0
    """Hold the initial flight path angle."""
    SMOOTH_TURN_FPA_LEVEL_OFF = 1
    """Levell off the flight path angle."""

SMOOTH_TURN_FPA_MODE.SMOOTH_TURN_FPA_HOLD_INITIAL.__doc__ = "Hold the initial flight path angle."
SMOOTH_TURN_FPA_MODE.SMOOTH_TURN_FPA_LEVEL_OFF.__doc__ = "Levell off the flight path angle."

agcls.AgTypeNameMap["SMOOTH_TURN_FPA_MODE"] = SMOOTH_TURN_FPA_MODE

class PITCH_3D_CONTROL_MODE(IntEnum):
    """The control mode used to define the pitch 3D strategy of the basic maneuver procedure."""
    PITCH_3D_COMPENSATE_FOR_WIND = 0
    """The vehicle will compensate for the wind along its trajectory."""
    PITCH_3D_WIND_PUSHES_VEHICLE = 1
    """Allow the wind to affect the trajectory."""

PITCH_3D_CONTROL_MODE.PITCH_3D_COMPENSATE_FOR_WIND.__doc__ = "The vehicle will compensate for the wind along its trajectory."
PITCH_3D_CONTROL_MODE.PITCH_3D_WIND_PUSHES_VEHICLE.__doc__ = "Allow the wind to affect the trajectory."

agcls.AgTypeNameMap["PITCH_3D_CONTROL_MODE"] = PITCH_3D_CONTROL_MODE

class REFUEL_DUMP_MODE(IntEnum):
    """The modes used to define procedure refuel/dump modes."""
    REFUEL_DUMP_DISABLED = 0
    """RefuelDump Disabled."""
    REFUEL_TOP_OFF = 1
    """Refuel Top Off."""
    REFUEL_TO_FUEL_STATE = 2
    """Refuel to specified fuel state."""
    REFUEL_TO_WEIGHT = 3
    """Refuel to specified weight."""
    REFUEL_QUANTITY = 4
    """Refuel specified quantity."""
    DUMP_TO_FUEL_STATE = 5
    """Dump to specified fuel state."""
    DUMP_TO_WEIGHT = 6
    """Dump to specified weight."""
    DUMP_QUANTITY = 7
    """Dump specified quantity."""

REFUEL_DUMP_MODE.REFUEL_DUMP_DISABLED.__doc__ = "RefuelDump Disabled."
REFUEL_DUMP_MODE.REFUEL_TOP_OFF.__doc__ = "Refuel Top Off."
REFUEL_DUMP_MODE.REFUEL_TO_FUEL_STATE.__doc__ = "Refuel to specified fuel state."
REFUEL_DUMP_MODE.REFUEL_TO_WEIGHT.__doc__ = "Refuel to specified weight."
REFUEL_DUMP_MODE.REFUEL_QUANTITY.__doc__ = "Refuel specified quantity."
REFUEL_DUMP_MODE.DUMP_TO_FUEL_STATE.__doc__ = "Dump to specified fuel state."
REFUEL_DUMP_MODE.DUMP_TO_WEIGHT.__doc__ = "Dump to specified weight."
REFUEL_DUMP_MODE.DUMP_QUANTITY.__doc__ = "Dump specified quantity."

agcls.AgTypeNameMap["REFUEL_DUMP_MODE"] = REFUEL_DUMP_MODE

class BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE(IntEnum):
    """The modes used to define basic maneuver glide speed control modes."""
    GLIDE_SPEED_IMMEDIATE_CHANGE = 0
    """Immediate speed change."""
    GLIDE_SPEED_AT_ALTITUDE = 1
    """Achieve speed at altitude."""

BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE.GLIDE_SPEED_IMMEDIATE_CHANGE.__doc__ = "Immediate speed change."
BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE.GLIDE_SPEED_AT_ALTITUDE.__doc__ = "Achieve speed at altitude."

agcls.AgTypeNameMap["BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE"] = BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE

class TARGET_POSITION_VEL_TYPE(IntEnum):
    """The target pos/vel type."""
    SURFACE = 0
    """Noisy Surface Target PosVel."""
    BEARING = 1
    """Noisy Bearing Range Target PosVel."""
    DISABLED_POSITION_VEL = 2
    """Disabled Target PosVel."""

TARGET_POSITION_VEL_TYPE.SURFACE.__doc__ = "Noisy Surface Target PosVel."
TARGET_POSITION_VEL_TYPE.BEARING.__doc__ = "Noisy Bearing Range Target PosVel."
TARGET_POSITION_VEL_TYPE.DISABLED_POSITION_VEL.__doc__ = "Disabled Target PosVel."

agcls.AgTypeNameMap["TARGET_POSITION_VEL_TYPE"] = TARGET_POSITION_VEL_TYPE


class ISite(object):
    """Interface to access Site options"""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ca4ddeac-d1c9-4bd8-9569-22c259ae7a1b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISite._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISite from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISite.__dict__ and type(ISite.__dict__[attrname]) == property:
            return ISite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISite.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the site."""
        return self._intf.get_property(ISite._metadata, ISite._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the site."""
        return self._intf.set_property(ISite._metadata, ISite._set_name_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{ca4ddeac-d1c9-4bd8-9569-22c259ae7a1b}", ISite)
agcls.AgTypeNameMap["ISite"] = ISite

class IWindModel(object):
    """Interface used to access the wind model for a mission, scenario, or procedure."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7147f488-83c5-49be-949c-84e81fdcfb1a}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_wind_model_type" : 1,
                             "set_wind_model_type" : 2,
                             "get_wind_model_type_string" : 3,
                             "set_wind_model_type_string" : 4,
                             "get_wind_model_source" : 5,
                             "set_wind_model_source" : 6,
                             "get_mode_as_constant" : 7,
                             "get_mode_as_adds" : 8,
                             "copy" : 9,
                             "paste" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IWindModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IWindModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWindModel.__dict__ and type(IWindModel.__dict__[attrname]) == property:
            return IWindModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWindModel.")
    
    _get_wind_model_type_metadata = { "name" : "wind_model_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(WIND_MODEL_TYPE),) }
    @property
    def wind_model_type(self) -> "WIND_MODEL_TYPE":
        """The wind model type."""
        return self._intf.get_property(IWindModel._metadata, IWindModel._get_wind_model_type_metadata)

    _set_wind_model_type_metadata = { "name" : "wind_model_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(WIND_MODEL_TYPE),) }
    @wind_model_type.setter
    def wind_model_type(self, pVal:"WIND_MODEL_TYPE") -> None:
        """The wind model type."""
        return self._intf.set_property(IWindModel._metadata, IWindModel._set_wind_model_type_metadata, pVal)

    _get_wind_model_type_string_metadata = { "name" : "wind_model_type_string",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def wind_model_type_string(self) -> str:
        """The wind model type as a string value. Use this for custom models."""
        return self._intf.get_property(IWindModel._metadata, IWindModel._get_wind_model_type_string_metadata)

    _set_wind_model_type_string_metadata = { "name" : "wind_model_type_string",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @wind_model_type_string.setter
    def wind_model_type_string(self, pVal:str) -> None:
        """The wind model type as a string value. Use this for custom models."""
        return self._intf.set_property(IWindModel._metadata, IWindModel._set_wind_model_type_string_metadata, pVal)

    _get_wind_model_source_metadata = { "name" : "wind_model_source",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(WIND_ATMOS_MODEL_SOURCE),) }
    @property
    def wind_model_source(self) -> "WIND_ATMOS_MODEL_SOURCE":
        """The wind model source."""
        return self._intf.get_property(IWindModel._metadata, IWindModel._get_wind_model_source_metadata)

    _set_wind_model_source_metadata = { "name" : "wind_model_source",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(WIND_ATMOS_MODEL_SOURCE),) }
    @wind_model_source.setter
    def wind_model_source(self, pVal:"WIND_ATMOS_MODEL_SOURCE") -> None:
        """The wind model source."""
        return self._intf.set_property(IWindModel._metadata, IWindModel._set_wind_model_source_metadata, pVal)

    _get_mode_as_constant_metadata = { "name" : "mode_as_constant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_constant(self) -> "WindModelConstant":
        """Get the options for a Constant Bearing/Speed wind model."""
        return self._intf.get_property(IWindModel._metadata, IWindModel._get_mode_as_constant_metadata)

    _get_mode_as_adds_metadata = { "name" : "mode_as_adds",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_adds(self) -> "WindModelADDS":
        """Get the options for a NOAA ADDS Service wind model."""
        return self._intf.get_property(IWindModel._metadata, IWindModel._get_mode_as_adds_metadata)

    _copy_metadata = { "name" : "copy",
            "arg_types" : (),
            "marshallers" : () }
    def copy(self) -> None:
        """Copy the wind model."""
        return self._intf.invoke(IWindModel._metadata, IWindModel._copy_metadata, )

    _paste_metadata = { "name" : "paste",
            "arg_types" : (),
            "marshallers" : () }
    def paste(self) -> None:
        """Paste the wind model."""
        return self._intf.invoke(IWindModel._metadata, IWindModel._paste_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{7147f488-83c5-49be-949c-84e81fdcfb1a}", IWindModel)
agcls.AgTypeNameMap["IWindModel"] = IWindModel

class IADDSMessage(object):
    """Interface used to access a message from the NOAA ADDS forecast."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{cc723181-9845-44c1-b061-f3e516343d88}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_time" : 1,
                             "get_stop_time" : 2,
                             "get_message_time" : 3,
                             "get_type" : 4,
                             "get_source" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IADDSMessage._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IADDSMessage from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IADDSMessage.__dict__ and type(IADDSMessage.__dict__[attrname]) == property:
            return IADDSMessage.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IADDSMessage.")
    
    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_time(self) -> typing.Any:
        """Valid start time for the ADDS message."""
        return self._intf.get_property(IADDSMessage._metadata, IADDSMessage._get_start_time_metadata)

    _get_stop_time_metadata = { "name" : "stop_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_time(self) -> typing.Any:
        """Valid stop time for the ADDS message."""
        return self._intf.get_property(IADDSMessage._metadata, IADDSMessage._get_stop_time_metadata)

    _get_message_time_metadata = { "name" : "message_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def message_time(self) -> typing.Any:
        """The message time for the ADDS message."""
        return self._intf.get_property(IADDSMessage._metadata, IADDSMessage._get_message_time_metadata)

    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADDS_FORECAST_TYPE),) }
    @property
    def type(self) -> "ADDS_FORECAST_TYPE":
        """The ADDS message type."""
        return self._intf.get_property(IADDSMessage._metadata, IADDSMessage._get_type_metadata)

    _get_source_metadata = { "name" : "source",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def source(self) -> str:
        """The ADDS message source."""
        return self._intf.get_property(IADDSMessage._metadata, IADDSMessage._get_source_metadata)


agcls.AgClassCatalog.add_catalog_entry("{cc723181-9845-44c1-b061-f3e516343d88}", IADDSMessage)
agcls.AgTypeNameMap["IADDSMessage"] = IADDSMessage

class IFuelTankInternal(object):
    """Interface used to set an aircraft's internal fuel tank."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4cc46781-fe55-4b7e-9bd8-b4f174b208b2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_capacity" : 3,
                             "set_capacity" : 4,
                             "get_consumption_order" : 5,
                             "set_consumption_order" : 6,
                             "get_initial_fuel_state" : 7,
                             "set_initial_fuel_state" : 8,
                             "get_position_x" : 9,
                             "get_position_y" : 10,
                             "get_position_z" : 11,
                             "set_position" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IFuelTankInternal._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IFuelTankInternal from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelTankInternal.__dict__ and type(IFuelTankInternal.__dict__[attrname]) == property:
            return IFuelTankInternal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelTankInternal.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the fuel tank."""
        return self._intf.get_property(IFuelTankInternal._metadata, IFuelTankInternal._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the fuel tank."""
        return self._intf.set_property(IFuelTankInternal._metadata, IFuelTankInternal._set_name_metadata, newVal)

    _get_capacity_metadata = { "name" : "capacity",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def capacity(self) -> float:
        """The capacity of the fuel tank."""
        return self._intf.get_property(IFuelTankInternal._metadata, IFuelTankInternal._get_capacity_metadata)

    _set_capacity_metadata = { "name" : "capacity",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @capacity.setter
    def capacity(self, newVal:float) -> None:
        """The capacity of the fuel tank."""
        return self._intf.set_property(IFuelTankInternal._metadata, IFuelTankInternal._set_capacity_metadata, newVal)

    _get_consumption_order_metadata = { "name" : "consumption_order",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def consumption_order(self) -> int:
        """The consumption order of the fuel tank."""
        return self._intf.get_property(IFuelTankInternal._metadata, IFuelTankInternal._get_consumption_order_metadata)

    _set_consumption_order_metadata = { "name" : "consumption_order",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @consumption_order.setter
    def consumption_order(self, newVal:int) -> None:
        """The consumption order of the fuel tank."""
        return self._intf.set_property(IFuelTankInternal._metadata, IFuelTankInternal._set_consumption_order_metadata, newVal)

    _get_initial_fuel_state_metadata = { "name" : "initial_fuel_state",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def initial_fuel_state(self) -> float:
        """The initial fuel state of the fuel tank."""
        return self._intf.get_property(IFuelTankInternal._metadata, IFuelTankInternal._get_initial_fuel_state_metadata)

    _set_initial_fuel_state_metadata = { "name" : "initial_fuel_state",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @initial_fuel_state.setter
    def initial_fuel_state(self, newVal:float) -> None:
        """The initial fuel state of the fuel tank."""
        return self._intf.set_property(IFuelTankInternal._metadata, IFuelTankInternal._set_initial_fuel_state_metadata, newVal)

    _get_position_x_metadata = { "name" : "position_x",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def position_x(self) -> float:
        """The X value of the fuel tank's parent relative position."""
        return self._intf.get_property(IFuelTankInternal._metadata, IFuelTankInternal._get_position_x_metadata)

    _get_position_y_metadata = { "name" : "position_y",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def position_y(self) -> float:
        """The Y value of the fuel tank's parent relative position."""
        return self._intf.get_property(IFuelTankInternal._metadata, IFuelTankInternal._get_position_y_metadata)

    _get_position_z_metadata = { "name" : "position_z",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def position_z(self) -> float:
        """The Z value of the fuel tank's parent relative position."""
        return self._intf.get_property(IFuelTankInternal._metadata, IFuelTankInternal._get_position_z_metadata)

    _set_position_metadata = { "name" : "set_position",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_position(self, x:float, y:float, z:float) -> None:
        """Set the fuel tank's parent relative position."""
        return self._intf.invoke(IFuelTankInternal._metadata, IFuelTankInternal._set_position_metadata, x, y, z)


agcls.AgClassCatalog.add_catalog_entry("{4cc46781-fe55-4b7e-9bd8-b4f174b208b2}", IFuelTankInternal)
agcls.AgTypeNameMap["IFuelTankInternal"] = IFuelTankInternal

class IFuelTankExternal(object):
    """Interface used to set an aircraft's external fuel tank."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d4c0aa70-49ba-4343-907b-d7271a23a42f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_empty_weight" : 3,
                             "set_empty_weight" : 4,
                             "get_capacity" : 5,
                             "set_capacity" : 6,
                             "get_initial_fuel_state" : 7,
                             "set_initial_fuel_state" : 8,
                             "get_consumption_order" : 9,
                             "set_consumption_order" : 10,
                             "get_drag_index" : 11,
                             "set_drag_index" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IFuelTankExternal._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IFuelTankExternal from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelTankExternal.__dict__ and type(IFuelTankExternal.__dict__[attrname]) == property:
            return IFuelTankExternal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelTankExternal.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the fuel tank."""
        return self._intf.get_property(IFuelTankExternal._metadata, IFuelTankExternal._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the fuel tank."""
        return self._intf.set_property(IFuelTankExternal._metadata, IFuelTankExternal._set_name_metadata, newVal)

    _get_empty_weight_metadata = { "name" : "empty_weight",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def empty_weight(self) -> float:
        """The empty weight of the fuel tank."""
        return self._intf.get_property(IFuelTankExternal._metadata, IFuelTankExternal._get_empty_weight_metadata)

    _set_empty_weight_metadata = { "name" : "empty_weight",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @empty_weight.setter
    def empty_weight(self, newVal:float) -> None:
        """The empty weight of the fuel tank."""
        return self._intf.set_property(IFuelTankExternal._metadata, IFuelTankExternal._set_empty_weight_metadata, newVal)

    _get_capacity_metadata = { "name" : "capacity",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def capacity(self) -> float:
        """The capacity of the fuel tank."""
        return self._intf.get_property(IFuelTankExternal._metadata, IFuelTankExternal._get_capacity_metadata)

    _set_capacity_metadata = { "name" : "capacity",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @capacity.setter
    def capacity(self, newVal:float) -> None:
        """The capacity of the fuel tank."""
        return self._intf.set_property(IFuelTankExternal._metadata, IFuelTankExternal._set_capacity_metadata, newVal)

    _get_initial_fuel_state_metadata = { "name" : "initial_fuel_state",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def initial_fuel_state(self) -> float:
        """The initial fuel state of the fuel tank."""
        return self._intf.get_property(IFuelTankExternal._metadata, IFuelTankExternal._get_initial_fuel_state_metadata)

    _set_initial_fuel_state_metadata = { "name" : "initial_fuel_state",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @initial_fuel_state.setter
    def initial_fuel_state(self, newVal:float) -> None:
        """The initial fuel state of the fuel tank."""
        return self._intf.set_property(IFuelTankExternal._metadata, IFuelTankExternal._set_initial_fuel_state_metadata, newVal)

    _get_consumption_order_metadata = { "name" : "consumption_order",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def consumption_order(self) -> int:
        """The consumption order of the fuel tank."""
        return self._intf.get_property(IFuelTankExternal._metadata, IFuelTankExternal._get_consumption_order_metadata)

    _set_consumption_order_metadata = { "name" : "consumption_order",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @consumption_order.setter
    def consumption_order(self, newVal:int) -> None:
        """The consumption order of the fuel tank."""
        return self._intf.set_property(IFuelTankExternal._metadata, IFuelTankExternal._set_consumption_order_metadata, newVal)

    _get_drag_index_metadata = { "name" : "drag_index",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def drag_index(self) -> float:
        """The drag index of the fuel tank."""
        return self._intf.get_property(IFuelTankExternal._metadata, IFuelTankExternal._get_drag_index_metadata)

    _set_drag_index_metadata = { "name" : "drag_index",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @drag_index.setter
    def drag_index(self, newVal:float) -> None:
        """The drag index of the fuel tank."""
        return self._intf.set_property(IFuelTankExternal._metadata, IFuelTankExternal._set_drag_index_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{d4c0aa70-49ba-4343-907b-d7271a23a42f}", IFuelTankExternal)
agcls.AgTypeNameMap["IFuelTankExternal"] = IFuelTankExternal

class IPayloadStation(object):
    """Interface used to set an aircraft's payload station."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d13cdb7b-4771-4ca1-954b-772a87f77ad2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_position_x" : 3,
                             "get_position_y" : 4,
                             "get_position_z" : 5,
                             "set_position" : 6,
                             "remove_sub_item" : 7,
                             "add_external_fuel_tank" : 8,
                             "get_external_fuel_tank" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IPayloadStation._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IPayloadStation from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPayloadStation.__dict__ and type(IPayloadStation.__dict__[attrname]) == property:
            return IPayloadStation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPayloadStation.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the payload station."""
        return self._intf.get_property(IPayloadStation._metadata, IPayloadStation._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the payload station."""
        return self._intf.set_property(IPayloadStation._metadata, IPayloadStation._set_name_metadata, newVal)

    _get_position_x_metadata = { "name" : "position_x",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def position_x(self) -> float:
        """The X value of the payload station's parent relative position."""
        return self._intf.get_property(IPayloadStation._metadata, IPayloadStation._get_position_x_metadata)

    _get_position_y_metadata = { "name" : "position_y",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def position_y(self) -> float:
        """The Y value of the payload station's parent relative position."""
        return self._intf.get_property(IPayloadStation._metadata, IPayloadStation._get_position_y_metadata)

    _get_position_z_metadata = { "name" : "position_z",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def position_z(self) -> float:
        """The Z value of the payload station's parent relative position."""
        return self._intf.get_property(IPayloadStation._metadata, IPayloadStation._get_position_z_metadata)

    _set_position_metadata = { "name" : "set_position",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_position(self, x:float, y:float, z:float) -> None:
        """Set the payload station's parent relative position."""
        return self._intf.invoke(IPayloadStation._metadata, IPayloadStation._set_position_metadata, x, y, z)

    _remove_sub_item_metadata = { "name" : "remove_sub_item",
            "arg_types" : (),
            "marshallers" : () }
    def remove_sub_item(self) -> None:
        """Remove any sub item that may be attached to the payload station."""
        return self._intf.invoke(IPayloadStation._metadata, IPayloadStation._remove_sub_item_metadata, )

    _add_external_fuel_tank_metadata = { "name" : "add_external_fuel_tank",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def add_external_fuel_tank(self) -> "FuelTankExternal":
        """Add an external fuel tank to the payload station."""
        return self._intf.invoke(IPayloadStation._metadata, IPayloadStation._add_external_fuel_tank_metadata, out_arg())

    _get_external_fuel_tank_metadata = { "name" : "get_external_fuel_tank",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_external_fuel_tank(self) -> "FuelTankExternal":
        """Get the external fuel tank attached to the payload station."""
        return self._intf.invoke(IPayloadStation._metadata, IPayloadStation._get_external_fuel_tank_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{d13cdb7b-4771-4ca1-954b-772a87f77ad2}", IPayloadStation)
agcls.AgTypeNameMap["IPayloadStation"] = IPayloadStation

class IAircraftModel(object):
    """Interface used to access the aircraft options in the Aviator catalog."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{42c19506-e18d-4500-bc0e-c5db5dad14a1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_perf_model_types" : 1,
                             "get_acceleration" : 2,
                             "get_climb" : 3,
                             "get_cruise" : 4,
                             "get_descent" : 5,
                             "get_landing" : 6,
                             "get_takeoff" : 7,
                             "get_default_configuration" : 8,
                             "get_adv_fixed_wing_tool" : 9,
                             "get_as_catalog_item" : 10,
                             "get_vtol" : 11,
                             "get_terrain_follow" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftModel.__dict__ and type(IAircraftModel.__dict__[attrname]) == property:
            return IAircraftModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftModel.")
    
    _get_perf_model_types_metadata = { "name" : "perf_model_types",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def perf_model_types(self) -> list:
        """Get the types of performance models."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_perf_model_types_metadata)

    _get_acceleration_metadata = { "name" : "acceleration",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def acceleration(self) -> "AircraftAcceleration":
        """Get the acceleration interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_acceleration_metadata)

    _get_climb_metadata = { "name" : "climb",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def climb(self) -> "AircraftClimb":
        """Get the climb interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_climb_metadata)

    _get_cruise_metadata = { "name" : "cruise",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def cruise(self) -> "AircraftCruise":
        """Get the cruise interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_cruise_metadata)

    _get_descent_metadata = { "name" : "descent",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def descent(self) -> "AircraftDescent":
        """Get the descent interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_descent_metadata)

    _get_landing_metadata = { "name" : "landing",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def landing(self) -> "AircraftLanding":
        """Get the landing interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_landing_metadata)

    _get_takeoff_metadata = { "name" : "takeoff",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def takeoff(self) -> "AircraftTakeoff":
        """Get the takeoff interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_takeoff_metadata)

    _get_default_configuration_metadata = { "name" : "default_configuration",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def default_configuration(self) -> "Configuration":
        """The aircraft's default configuration as saved in the catalog."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_default_configuration_metadata)

    _get_adv_fixed_wing_tool_metadata = { "name" : "adv_fixed_wing_tool",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def adv_fixed_wing_tool(self) -> "AdvFixedWingTool":
        """Get the Advanced Fixed Wing Tool for the aircraft."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_adv_fixed_wing_tool_metadata)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftModel._metadata, IAircraftModel._get_as_catalog_item_metadata, out_arg())

    _get_vtol_metadata = { "name" : "vtol",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vtol(self) -> "AircraftVTOL":
        """Get the VTOL interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_vtol_metadata)

    _get_terrain_follow_metadata = { "name" : "terrain_follow",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def terrain_follow(self) -> "AircraftTerrainFollow":
        """Get the TerrainFollow interface."""
        return self._intf.get_property(IAircraftModel._metadata, IAircraftModel._get_terrain_follow_metadata)


agcls.AgClassCatalog.add_catalog_entry("{42c19506-e18d-4500-bc0e-c5db5dad14a1}", IAircraftModel)
agcls.AgTypeNameMap["IAircraftModel"] = IAircraftModel

class IAircraftSimpleAero(object):
    """Interface used to access the Simple Aerodynamics options for the Basic Acceleration Model of an aircraft."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b3a9d57b-8ebb-428c-b36a-b4c701931cc1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_operating_mode" : 1,
                             "set_operating_mode" : 2,
                             "get_s_reference" : 3,
                             "set_s_reference" : 4,
                             "get_cl_max" : 5,
                             "set_cl_max" : 6,
                             "get_cd" : 7,
                             "set_cd" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftSimpleAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftSimpleAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftSimpleAero.__dict__ and type(IAircraftSimpleAero.__dict__[attrname]) == property:
            return IAircraftSimpleAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftSimpleAero.")
    
    _get_operating_mode_metadata = { "name" : "operating_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AERO_PROP_SIMPLE_MODE),) }
    @property
    def operating_mode(self) -> "AERO_PROP_SIMPLE_MODE":
        """The mode option to treat the aircraft as a helicopter or a fixed wing aircraft when calculating the aircraft's attitude."""
        return self._intf.get_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._get_operating_mode_metadata)

    _set_operating_mode_metadata = { "name" : "operating_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AERO_PROP_SIMPLE_MODE),) }
    @operating_mode.setter
    def operating_mode(self, newVal:"AERO_PROP_SIMPLE_MODE") -> None:
        """The mode option to treat the aircraft as a helicopter or a fixed wing aircraft when calculating the aircraft's attitude."""
        return self._intf.set_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._set_operating_mode_metadata, newVal)

    _get_s_reference_metadata = { "name" : "s_reference",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def s_reference(self) -> float:
        """The reference surface area of the aircraft."""
        return self._intf.get_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._get_s_reference_metadata)

    _set_s_reference_metadata = { "name" : "s_reference",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @s_reference.setter
    def s_reference(self, newVal:float) -> None:
        """The reference surface area of the aircraft."""
        return self._intf.set_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._set_s_reference_metadata, newVal)

    _get_cl_max_metadata = { "name" : "cl_max",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cl_max(self) -> float:
        """The max coefficient of lift."""
        return self._intf.get_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._get_cl_max_metadata)

    _set_cl_max_metadata = { "name" : "cl_max",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cl_max.setter
    def cl_max(self, newVal:float) -> None:
        """The max coefficient of lift."""
        return self._intf.set_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._set_cl_max_metadata, newVal)

    _get_cd_metadata = { "name" : "cd",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cd(self) -> float:
        """The coefficient of drag."""
        return self._intf.get_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._get_cd_metadata)

    _set_cd_metadata = { "name" : "cd",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cd.setter
    def cd(self, newVal:float) -> None:
        """The coefficient of drag."""
        return self._intf.set_property(IAircraftSimpleAero._metadata, IAircraftSimpleAero._set_cd_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{b3a9d57b-8ebb-428c-b36a-b4c701931cc1}", IAircraftSimpleAero)
agcls.AgTypeNameMap["IAircraftSimpleAero"] = IAircraftSimpleAero

class ILevelTurns(object):
    """Interface used to access the Level Turns Transitions options found in the Basic Acceleration Model of an aircraft."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5c45254a-230f-4f6d-adb9-d33c0a1bf06c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_turn_mode" : 1,
                             "get_turn_g" : 2,
                             "get_bank_angle" : 3,
                             "get_turn_acceleration" : 4,
                             "get_turn_radius" : 5,
                             "get_turn_rate" : 6,
                             "set_level_turn" : 7,
                             "get_maneuver_mode" : 8,
                             "set_maneuver_mode" : 9,
                             "get_maneuver_mode_helper" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ILevelTurns._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ILevelTurns from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILevelTurns.__dict__ and type(ILevelTurns.__dict__[attrname]) == property:
            return ILevelTurns.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILevelTurns.")
    
    _get_turn_mode_metadata = { "name" : "turn_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TURN_MODE),) }
    @property
    def turn_mode(self) -> "TURN_MODE":
        """Get the turn mode."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_turn_mode_metadata)

    _get_turn_g_metadata = { "name" : "turn_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turn_g(self) -> float:
        """Get the TurnG."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_turn_g_metadata)

    _get_bank_angle_metadata = { "name" : "bank_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bank_angle(self) -> typing.Any:
        """Get the bank angle."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_bank_angle_metadata)

    _get_turn_acceleration_metadata = { "name" : "turn_acceleration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turn_acceleration(self) -> float:
        """Get the turn acceleration."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_turn_acceleration_metadata)

    _get_turn_radius_metadata = { "name" : "turn_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turn_radius(self) -> float:
        """Get the turn radius."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_turn_radius_metadata)

    _get_turn_rate_metadata = { "name" : "turn_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turn_rate(self) -> float:
        """get the turn rate."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_turn_rate_metadata)

    _set_level_turn_metadata = { "name" : "set_level_turn",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(TURN_MODE), agmarshall.VARIANT_arg,) }
    def set_level_turn(self, turnMode:"TURN_MODE", turnValue:typing.Any) -> None:
        """Set the level turn mode and corresponding value."""
        return self._intf.invoke(ILevelTurns._metadata, ILevelTurns._set_level_turn_metadata, turnMode, turnValue)

    _get_maneuver_mode_metadata = { "name" : "maneuver_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_MODE),) }
    @property
    def maneuver_mode(self) -> "ACCEL_MANEUVER_MODE":
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_maneuver_mode_metadata)

    _set_maneuver_mode_metadata = { "name" : "maneuver_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_MODE),) }
    @maneuver_mode.setter
    def maneuver_mode(self, newVal:"ACCEL_MANEUVER_MODE") -> None:
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        return self._intf.set_property(ILevelTurns._metadata, ILevelTurns._set_maneuver_mode_metadata, newVal)

    _get_maneuver_mode_helper_metadata = { "name" : "maneuver_mode_helper",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def maneuver_mode_helper(self) -> "AeroPropManeuverModeHelper":
        """Get the interface for the Aero/Prop Maneuver Mode helper. The maneuver mode must be set to Aero/Prop to access this interface."""
        return self._intf.get_property(ILevelTurns._metadata, ILevelTurns._get_maneuver_mode_helper_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5c45254a-230f-4f6d-adb9-d33c0a1bf06c}", ILevelTurns)
agcls.AgTypeNameMap["ILevelTurns"] = ILevelTurns

class IAttitudeTransitions(object):
    """Interface used to access the Attitude Transitions options found in the Basic Acceleration Model of an aircraft."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3dd0e618-20a7-42be-b04d-63472b068f36}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_roll_rate" : 1,
                             "set_roll_rate" : 2,
                             "get_pitch_rate" : 3,
                             "set_pitch_rate" : 4,
                             "get_yaw_rate" : 5,
                             "set_yaw_rate" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAttitudeTransitions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeTransitions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeTransitions.__dict__ and type(IAttitudeTransitions.__dict__[attrname]) == property:
            return IAttitudeTransitions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAttitudeTransitions.")
    
    _get_roll_rate_metadata = { "name" : "roll_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_rate(self) -> typing.Any:
        """The roll rate when the aircraft in a turn."""
        return self._intf.get_property(IAttitudeTransitions._metadata, IAttitudeTransitions._get_roll_rate_metadata)

    _set_roll_rate_metadata = { "name" : "roll_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_rate.setter
    def roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate when the aircraft in a turn."""
        return self._intf.set_property(IAttitudeTransitions._metadata, IAttitudeTransitions._set_roll_rate_metadata, newVal)

    _get_pitch_rate_metadata = { "name" : "pitch_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def pitch_rate(self) -> typing.Any:
        """The pitch rate when transitioning between attitude modes."""
        return self._intf.get_property(IAttitudeTransitions._metadata, IAttitudeTransitions._get_pitch_rate_metadata)

    _set_pitch_rate_metadata = { "name" : "pitch_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @pitch_rate.setter
    def pitch_rate(self, newVal:typing.Any) -> None:
        """The pitch rate when transitioning between attitude modes."""
        return self._intf.set_property(IAttitudeTransitions._metadata, IAttitudeTransitions._set_pitch_rate_metadata, newVal)

    _get_yaw_rate_metadata = { "name" : "yaw_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def yaw_rate(self) -> typing.Any:
        """The yaw rate when transitioning between attitude modes."""
        return self._intf.get_property(IAttitudeTransitions._metadata, IAttitudeTransitions._get_yaw_rate_metadata)

    _set_yaw_rate_metadata = { "name" : "yaw_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @yaw_rate.setter
    def yaw_rate(self, newVal:typing.Any) -> None:
        """The yaw rate when transitioning between attitude modes."""
        return self._intf.set_property(IAttitudeTransitions._metadata, IAttitudeTransitions._set_yaw_rate_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{3dd0e618-20a7-42be-b04d-63472b068f36}", IAttitudeTransitions)
agcls.AgTypeNameMap["IAttitudeTransitions"] = IAttitudeTransitions

class IClimbAndDescentTransitions(object):
    """Interface used to access the Climb and Descent Transitions options found in the Basic Acceleration Model of an aircraft."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8733914e-9bc9-4270-ab39-0b32af9ca84e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_pull_up_g" : 1,
                             "set_max_pull_up_g" : 2,
                             "get_max_push_over_g" : 3,
                             "set_max_push_over_g" : 4,
                             "get_maneuver_mode" : 5,
                             "set_maneuver_mode" : 6,
                             "get_ignore_fpa" : 7,
                             "set_ignore_fpa" : 8,
                             "get_maneuver_mode_helper" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IClimbAndDescentTransitions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IClimbAndDescentTransitions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IClimbAndDescentTransitions.__dict__ and type(IClimbAndDescentTransitions.__dict__[attrname]) == property:
            return IClimbAndDescentTransitions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IClimbAndDescentTransitions.")
    
    _get_max_pull_up_g_metadata = { "name" : "max_pull_up_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_pull_up_g(self) -> float:
        """The force normal to the velocity vector used to transition into a climb or to a transition out of a dive into the next flight segment."""
        return self._intf.get_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._get_max_pull_up_g_metadata)

    _set_max_pull_up_g_metadata = { "name" : "max_pull_up_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_pull_up_g.setter
    def max_pull_up_g(self, newVal:float) -> None:
        """The force normal to the velocity vector used to transition into a climb or to a transition out of a dive into the next flight segment."""
        return self._intf.set_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._set_max_pull_up_g_metadata, newVal)

    _get_max_push_over_g_metadata = { "name" : "max_push_over_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_push_over_g(self) -> float:
        """The force normal to the velocity vector used to transition into a descent or to a transition from a climb into the next flight segment."""
        return self._intf.get_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._get_max_push_over_g_metadata)

    _set_max_push_over_g_metadata = { "name" : "max_push_over_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_push_over_g.setter
    def max_push_over_g(self, newVal:float) -> None:
        """The force normal to the velocity vector used to transition into a descent or to a transition from a climb into the next flight segment."""
        return self._intf.set_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._set_max_push_over_g_metadata, newVal)

    _get_maneuver_mode_metadata = { "name" : "maneuver_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_MODE),) }
    @property
    def maneuver_mode(self) -> "ACCEL_MANEUVER_MODE":
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        return self._intf.get_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._get_maneuver_mode_metadata)

    _set_maneuver_mode_metadata = { "name" : "maneuver_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_MODE),) }
    @maneuver_mode.setter
    def maneuver_mode(self, newVal:"ACCEL_MANEUVER_MODE") -> None:
        """The mode that the aircraft will adhere to the specified acceleration parameters. Scale by atmospheric density will cause the aircraft to consider dynamic pressure when calculating turn radius."""
        return self._intf.set_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._set_maneuver_mode_metadata, newVal)

    _get_ignore_fpa_metadata = { "name" : "ignore_fpa",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ignore_fpa(self) -> bool:
        """Opt whether to ignore the flight path angle."""
        return self._intf.get_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._get_ignore_fpa_metadata)

    _set_ignore_fpa_metadata = { "name" : "ignore_fpa",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ignore_fpa.setter
    def ignore_fpa(self, newVal:bool) -> None:
        """Opt whether to ignore the flight path angle."""
        return self._intf.set_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._set_ignore_fpa_metadata, newVal)

    _get_maneuver_mode_helper_metadata = { "name" : "maneuver_mode_helper",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def maneuver_mode_helper(self) -> "AeroPropManeuverModeHelper":
        """Get the interface for the Aero/Prop Maneuver Mode helper. The maneuver mode must be set to Aero/Prop to access this interface."""
        return self._intf.get_property(IClimbAndDescentTransitions._metadata, IClimbAndDescentTransitions._get_maneuver_mode_helper_metadata)


agcls.AgClassCatalog.add_catalog_entry("{8733914e-9bc9-4270-ab39-0b32af9ca84e}", IClimbAndDescentTransitions)
agcls.AgTypeNameMap["IClimbAndDescentTransitions"] = IClimbAndDescentTransitions

class ICatalogItem(object):
    """Interface used to access the options for a Catalog Item in the Aviator Catalog. Use this interface to Create, Remove, Duplicate, or Rename items in the catalog."""
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{97dd0fde-8548-4bbf-b2c5-909c6013b32d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_description" : 3,
                             "duplicate" : 4,
                             "remove" : 5,
                             "save" : 6,
                             "get_is_read_only" : 7,
                             "get_child_names" : 8,
                             "get_child_item_by_name" : 9,
                             "get_child_types" : 10,
                             "add_default_child" : 11,
                             "add_child_of_type" : 12,
                             "contains_child_item" : 13, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalogItem._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalogItem from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogItem.__dict__ and type(ICatalogItem.__dict__[attrname]) == property:
            return ICatalogItem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogItem.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """Get the name of the catalog item."""
        return self._intf.get_property(ICatalogItem._metadata, ICatalogItem._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, pVal:str) -> None:
        """Get the name of the catalog item."""
        return self._intf.set_property(ICatalogItem._metadata, ICatalogItem._set_name_metadata, pVal)

    _get_description_metadata = { "name" : "description",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def description(self) -> str:
        """Get the description of the catalog item."""
        return self._intf.get_property(ICatalogItem._metadata, ICatalogItem._get_description_metadata)

    _duplicate_metadata = { "name" : "duplicate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def duplicate(self) -> "ICatalogItem":
        """Duplicates the catalog item."""
        return self._intf.invoke(ICatalogItem._metadata, ICatalogItem._duplicate_metadata, out_arg())

    _remove_metadata = { "name" : "remove",
            "arg_types" : (),
            "marshallers" : () }
    def remove(self) -> None:
        """Removes the catalog item."""
        return self._intf.invoke(ICatalogItem._metadata, ICatalogItem._remove_metadata, )

    _save_metadata = { "name" : "save",
            "arg_types" : (),
            "marshallers" : () }
    def save(self) -> None:
        """Saves the catalog item."""
        return self._intf.invoke(ICatalogItem._metadata, ICatalogItem._save_metadata, )

    _get_is_read_only_metadata = { "name" : "is_read_only",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_read_only(self) -> bool:
        """Get whether the catalog item is read only."""
        return self._intf.get_property(ICatalogItem._metadata, ICatalogItem._get_is_read_only_metadata)

    _get_child_names_metadata = { "name" : "child_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def child_names(self) -> list:
        """Get the child names of the catalog item."""
        return self._intf.get_property(ICatalogItem._metadata, ICatalogItem._get_child_names_metadata)

    _get_child_item_by_name_metadata = { "name" : "get_child_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_child_item_by_name(self, childName:str) -> "ICatalogItem":
        """Get the child of the catalog item with the given name."""
        return self._intf.invoke(ICatalogItem._metadata, ICatalogItem._get_child_item_by_name_metadata, childName, out_arg())

    _get_child_types_metadata = { "name" : "child_types",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def child_types(self) -> list:
        """Get the child types."""
        return self._intf.get_property(ICatalogItem._metadata, ICatalogItem._get_child_types_metadata)

    _add_default_child_metadata = { "name" : "add_default_child",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_default_child(self, childName:str) -> "ICatalogItem":
        """Creates a new child with the given name and default type."""
        return self._intf.invoke(ICatalogItem._metadata, ICatalogItem._add_default_child_metadata, childName, out_arg())

    _add_child_of_type_metadata = { "name" : "add_child_of_type",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_child_of_type(self, childType:str, childName:str) -> "ICatalogItem":
        """Creates a new child with the given name and specified type."""
        return self._intf.invoke(ICatalogItem._metadata, ICatalogItem._add_child_of_type_metadata, childType, childName, out_arg())

    _contains_child_item_metadata = { "name" : "contains_child_item",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains_child_item(self, childItem:str) -> bool:
        """Get whether the catalog item is contains the given child item."""
        return self._intf.invoke(ICatalogItem._metadata, ICatalogItem._contains_child_item_metadata, childItem, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{97dd0fde-8548-4bbf-b2c5-909c6013b32d}", ICatalogItem)
agcls.AgTypeNameMap["ICatalogItem"] = ICatalogItem

class IAircraftBasicClimbModel(object):
    """Interface used to access the basic climb model options for a climb model of an aircraft in the Aviator catalog."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{db58182c-ba76-44ea-be78-5c529aea4de7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ceiling_altitude" : 1,
                             "set_ceiling_altitude" : 2,
                             "get_airspeed" : 3,
                             "get_airspeed_type" : 4,
                             "set_airspeed" : 5,
                             "get_altitude_rate" : 6,
                             "set_altitude_rate" : 7,
                             "get_use_aero_prop_fuel" : 8,
                             "set_use_aero_prop_fuel" : 9,
                             "get_scale_fuel_flow_by_non_std_density" : 10,
                             "set_scale_fuel_flow_by_non_std_density" : 11,
                             "get_fuel_flow" : 12,
                             "set_fuel_flow" : 13,
                             "get_enable_relative_airspeed_tolerance" : 14,
                             "set_enable_relative_airspeed_tolerance" : 15,
                             "get_relative_airspeed_tolerance" : 16,
                             "set_relative_airspeed_tolerance" : 17,
                             "get_as_catalog_item" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicClimbModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicClimbModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicClimbModel.__dict__ and type(IAircraftBasicClimbModel.__dict__[attrname]) == property:
            return IAircraftBasicClimbModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicClimbModel.")
    
    _get_ceiling_altitude_metadata = { "name" : "ceiling_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ceiling_altitude(self) -> float:
        """Get the ceiling altitude."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_ceiling_altitude_metadata)

    _set_ceiling_altitude_metadata = { "name" : "ceiling_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ceiling_altitude.setter
    def ceiling_altitude(self, newVal:float) -> None:
        """Put the ceiling altitude."""
        return self._intf.set_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_ceiling_altitude_metadata, newVal)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """Get the airsepeed."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_airspeed_metadata)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """Get the airspeed type."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_airspeed_type_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed type and value."""
        return self._intf.invoke(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_airspeed_metadata, airspeedType, aispeed)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """Get the altitude rate."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_altitude_rate_metadata)

    _set_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """Put the altitude rate."""
        return self._intf.set_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_altitude_rate_metadata, newVal)

    _get_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_use_aero_prop_fuel_metadata)

    _set_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        return self._intf.set_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_use_aero_prop_fuel_metadata, newVal)

    _get_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_scale_fuel_flow_by_non_std_density_metadata)

    _set_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        return self._intf.set_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_scale_fuel_flow_by_non_std_density_metadata, newVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """Get the Sea Level Fuel Flow."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """Put the Sea Level Fuel Flow."""
        return self._intf.set_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_fuel_flow_metadata, newVal)

    _get_enable_relative_airspeed_tolerance_metadata = { "name" : "enable_relative_airspeed_tolerance",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def enable_relative_airspeed_tolerance(self) -> bool:
        """Get whether to enable relative airspeed tolerance."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_enable_relative_airspeed_tolerance_metadata)

    _set_enable_relative_airspeed_tolerance_metadata = { "name" : "enable_relative_airspeed_tolerance",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @enable_relative_airspeed_tolerance.setter
    def enable_relative_airspeed_tolerance(self, newVal:bool) -> None:
        """Put whether to enable relative airspeed tolerance."""
        return self._intf.set_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_enable_relative_airspeed_tolerance_metadata, newVal)

    _get_relative_airspeed_tolerance_metadata = { "name" : "relative_airspeed_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_airspeed_tolerance(self) -> float:
        """Get the relative airspeed tolerance."""
        return self._intf.get_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_relative_airspeed_tolerance_metadata)

    _set_relative_airspeed_tolerance_metadata = { "name" : "relative_airspeed_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_airspeed_tolerance.setter
    def relative_airspeed_tolerance(self, newVal:float) -> None:
        """Put the relative airspeed tolerance."""
        return self._intf.set_property(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._set_relative_airspeed_tolerance_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftBasicClimbModel._metadata, IAircraftBasicClimbModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{db58182c-ba76-44ea-be78-5c529aea4de7}", IAircraftBasicClimbModel)
agcls.AgTypeNameMap["IAircraftBasicClimbModel"] = IAircraftBasicClimbModel

class IAircraftBasicAccelerationModel(object):
    """Interface used to access the basic acceleration model options for an acceleration model of an aircraft in the Aviator catalog."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a1a75a12-5730-4442-b84c-dc51c7783896}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_level_turns" : 1,
                             "get_attitude_transitions" : 2,
                             "get_climb_and_descent_transitions" : 3,
                             "get_aerodynamics" : 4,
                             "get_propulsion" : 5,
                             "get_as_catalog_item" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicAccelerationModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicAccelerationModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicAccelerationModel.__dict__ and type(IAircraftBasicAccelerationModel.__dict__[attrname]) == property:
            return IAircraftBasicAccelerationModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicAccelerationModel.")
    
    _get_level_turns_metadata = { "name" : "level_turns",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def level_turns(self) -> "LevelTurns":
        """Get the level turns interface."""
        return self._intf.get_property(IAircraftBasicAccelerationModel._metadata, IAircraftBasicAccelerationModel._get_level_turns_metadata)

    _get_attitude_transitions_metadata = { "name" : "attitude_transitions",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def attitude_transitions(self) -> "AttitudeTransitions":
        """Get the attitude transitions interface."""
        return self._intf.get_property(IAircraftBasicAccelerationModel._metadata, IAircraftBasicAccelerationModel._get_attitude_transitions_metadata)

    _get_climb_and_descent_transitions_metadata = { "name" : "climb_and_descent_transitions",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def climb_and_descent_transitions(self) -> "ClimbAndDescentTransitions":
        """Get the climb and descent transitions interface."""
        return self._intf.get_property(IAircraftBasicAccelerationModel._metadata, IAircraftBasicAccelerationModel._get_climb_and_descent_transitions_metadata)

    _get_aerodynamics_metadata = { "name" : "aerodynamics",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aerodynamics(self) -> "AircraftAero":
        """Get the aerodynamics interface."""
        return self._intf.get_property(IAircraftBasicAccelerationModel._metadata, IAircraftBasicAccelerationModel._get_aerodynamics_metadata)

    _get_propulsion_metadata = { "name" : "propulsion",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def propulsion(self) -> "AircraftProp":
        """Get the propulsion interface."""
        return self._intf.get_property(IAircraftBasicAccelerationModel._metadata, IAircraftBasicAccelerationModel._get_propulsion_metadata)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftBasicAccelerationModel._metadata, IAircraftBasicAccelerationModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{a1a75a12-5730-4442-b84c-dc51c7783896}", IAircraftBasicAccelerationModel)
agcls.AgTypeNameMap["IAircraftBasicAccelerationModel"] = IAircraftBasicAccelerationModel

class IAircraftCategory(object):
    """Interface used to access the Aircraft Category in the Aviator Catalog."""
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{222d5a63-81e6-4ada-b309-e5ada49f075d}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_aircraft_models" : 1,
                             "get_missile_models" : 2,
                             "get_rotorcraft_models" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftCategory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftCategory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftCategory.__dict__ and type(IAircraftCategory.__dict__[attrname]) == property:
            return IAircraftCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftCategory.")
    
    _get_aircraft_models_metadata = { "name" : "aircraft_models",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aircraft_models(self) -> "AircraftModels":
        """Get the user aircraft models."""
        return self._intf.get_property(IAircraftCategory._metadata, IAircraftCategory._get_aircraft_models_metadata)

    _get_missile_models_metadata = { "name" : "missile_models",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def missile_models(self) -> "MissileModels":
        """Get the user missile models."""
        return self._intf.get_property(IAircraftCategory._metadata, IAircraftCategory._get_missile_models_metadata)

    _get_rotorcraft_models_metadata = { "name" : "rotorcraft_models",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def rotorcraft_models(self) -> "RotorcraftModels":
        """Get the user rotorcraft models."""
        return self._intf.get_property(IAircraftCategory._metadata, IAircraftCategory._get_rotorcraft_models_metadata)


agcls.AgClassCatalog.add_catalog_entry("{222d5a63-81e6-4ada-b309-e5ada49f075d}", IAircraftCategory)
agcls.AgTypeNameMap["IAircraftCategory"] = IAircraftCategory

class IRunwayCategory(object):
    """Interface used to access runways in the Aviator catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{76f32dcb-0127-47b6-b347-c78c18de45c6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_user_runways" : 1,
                             "get_arinc424_runways" : 2,
                             "get_dafif_runways" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IRunwayCategory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IRunwayCategory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRunwayCategory.__dict__ and type(IRunwayCategory.__dict__[attrname]) == property:
            return IRunwayCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRunwayCategory.")
    
    _get_user_runways_metadata = { "name" : "user_runways",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def user_runways(self) -> "UserRunwaySource":
        """Get the user runways."""
        return self._intf.get_property(IRunwayCategory._metadata, IRunwayCategory._get_user_runways_metadata)

    _get_arinc424_runways_metadata = { "name" : "arinc424_runways",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_runways(self) -> "ARINC424Source":
        """Get the ARINC-424 runways."""
        return self._intf.get_property(IRunwayCategory._metadata, IRunwayCategory._get_arinc424_runways_metadata)

    _get_dafif_runways_metadata = { "name" : "dafif_runways",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def dafif_runways(self) -> "DAFIFSource":
        """Get the DAFIF runways."""
        return self._intf.get_property(IRunwayCategory._metadata, IRunwayCategory._get_dafif_runways_metadata)


agcls.AgClassCatalog.add_catalog_entry("{76f32dcb-0127-47b6-b347-c78c18de45c6}", IRunwayCategory)
agcls.AgTypeNameMap["IRunwayCategory"] = IRunwayCategory

class IBasicManeuverStrategy(object):
    """Interface used to access options for a Basic Maneuver Strategy."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{55e05a46-43d4-41d7-9866-2b1255b5d08f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategy._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategy from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategy.__dict__ and type(IBasicManeuverStrategy.__dict__[attrname]) == property:
            return IBasicManeuverStrategy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategy.")
    

agcls.AgClassCatalog.add_catalog_entry("{55e05a46-43d4-41d7-9866-2b1255b5d08f}", IBasicManeuverStrategy)
agcls.AgTypeNameMap["IBasicManeuverStrategy"] = IBasicManeuverStrategy

class IAircraftVTOL(object):
    """Interface used to access the VTOL options for an aircraft in the Aviator catalog."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{dbf209b7-90de-455a-b287-1b0d6c6fd823}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_vtol_by_name" : 1,
                             "get_as_catalog_item" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftVTOL._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftVTOL from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftVTOL.__dict__ and type(IAircraftVTOL.__dict__[attrname]) == property:
            return IAircraftVTOL.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftVTOL.")
    
    _get_vtol_by_name_metadata = { "name" : "get_vtol_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_vtol_by_name(self, name:str) -> "AircraftVTOLModel":
        """Gets the VTOL model with the given name."""
        return self._intf.invoke(IAircraftVTOL._metadata, IAircraftVTOL._get_vtol_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftVTOL._metadata, IAircraftVTOL._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{dbf209b7-90de-455a-b287-1b0d6c6fd823}", IAircraftVTOL)
agcls.AgTypeNameMap["IAircraftVTOL"] = IAircraftVTOL

class IAircraftExternalAero(object):
    """Interface used to access the External File Aerodynamics options for the Basic Acceleration Model of an aircraft."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8edd99ca-d7c9-4552-aff5-540ae780d319}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_forward_flight_filepath" : 1,
                             "set_forward_flight_filepath" : 2,
                             "reload_forward_flight_file" : 3,
                             "get_forward_flight_reference_area" : 4,
                             "set_forward_flight_reference_area" : 5,
                             "get_can_set_forward_flight_reference_area" : 6,
                             "get_is_forward_flight_valid" : 7,
                             "get_takeoff_landing_filepath" : 8,
                             "set_takeoff_landing_filepath" : 9,
                             "reload_takeoff_landing_file" : 10,
                             "get_takeoff_landing_reference_area" : 11,
                             "set_takeoff_landing_reference_area" : 12,
                             "get_can_set_takeoff_landing_reference_area" : 13,
                             "get_is_takeoff_landing_valid" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftExternalAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftExternalAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftExternalAero.__dict__ and type(IAircraftExternalAero.__dict__[attrname]) == property:
            return IAircraftExternalAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftExternalAero.")
    
    _get_forward_flight_filepath_metadata = { "name" : "forward_flight_filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def forward_flight_filepath(self) -> str:
        """The filepath for the forward flight aero file."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_forward_flight_filepath_metadata)

    _set_forward_flight_filepath_metadata = { "name" : "set_forward_flight_filepath",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_forward_flight_filepath(self, filepath:str) -> str:
        """Set the filepath for the forward flight aero file."""
        return self._intf.invoke(IAircraftExternalAero._metadata, IAircraftExternalAero._set_forward_flight_filepath_metadata, filepath, out_arg())

    _reload_forward_flight_file_metadata = { "name" : "reload_forward_flight_file",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def reload_forward_flight_file(self) -> str:
        """Reload the forward flight aero file."""
        return self._intf.invoke(IAircraftExternalAero._metadata, IAircraftExternalAero._reload_forward_flight_file_metadata, out_arg())

    _get_forward_flight_reference_area_metadata = { "name" : "forward_flight_reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_reference_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_forward_flight_reference_area_metadata)

    _set_forward_flight_reference_area_metadata = { "name" : "forward_flight_reference_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @forward_flight_reference_area.setter
    def forward_flight_reference_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        return self._intf.set_property(IAircraftExternalAero._metadata, IAircraftExternalAero._set_forward_flight_reference_area_metadata, pVal)

    _get_can_set_forward_flight_reference_area_metadata = { "name" : "can_set_forward_flight_reference_area",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def can_set_forward_flight_reference_area(self) -> bool:
        """Check whether you can set the reference area or whether it is specified in the file."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_can_set_forward_flight_reference_area_metadata)

    _get_is_forward_flight_valid_metadata = { "name" : "is_forward_flight_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_forward_flight_valid(self) -> bool:
        """Check whether the forward flight file is valid."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_is_forward_flight_valid_metadata)

    _get_takeoff_landing_filepath_metadata = { "name" : "takeoff_landing_filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def takeoff_landing_filepath(self) -> str:
        """The filepath for the takeoff and landing aero file."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_takeoff_landing_filepath_metadata)

    _set_takeoff_landing_filepath_metadata = { "name" : "set_takeoff_landing_filepath",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_takeoff_landing_filepath(self, filepath:str) -> str:
        """Set the filepath for the takeoff and landing aero file."""
        return self._intf.invoke(IAircraftExternalAero._metadata, IAircraftExternalAero._set_takeoff_landing_filepath_metadata, filepath, out_arg())

    _reload_takeoff_landing_file_metadata = { "name" : "reload_takeoff_landing_file",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def reload_takeoff_landing_file(self) -> str:
        """Reload the takeoff and landing aero file."""
        return self._intf.invoke(IAircraftExternalAero._metadata, IAircraftExternalAero._reload_takeoff_landing_file_metadata, out_arg())

    _get_takeoff_landing_reference_area_metadata = { "name" : "takeoff_landing_reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def takeoff_landing_reference_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_takeoff_landing_reference_area_metadata)

    _set_takeoff_landing_reference_area_metadata = { "name" : "takeoff_landing_reference_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @takeoff_landing_reference_area.setter
    def takeoff_landing_reference_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        return self._intf.set_property(IAircraftExternalAero._metadata, IAircraftExternalAero._set_takeoff_landing_reference_area_metadata, pVal)

    _get_can_set_takeoff_landing_reference_area_metadata = { "name" : "can_set_takeoff_landing_reference_area",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def can_set_takeoff_landing_reference_area(self) -> bool:
        """Check whether you can set the reference area or whether it is specified in the file."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_can_set_takeoff_landing_reference_area_metadata)

    _get_is_takeoff_landing_valid_metadata = { "name" : "is_takeoff_landing_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_takeoff_landing_valid(self) -> bool:
        """Check whether the takeoff and landing file is valid."""
        return self._intf.get_property(IAircraftExternalAero._metadata, IAircraftExternalAero._get_is_takeoff_landing_valid_metadata)


agcls.AgClassCatalog.add_catalog_entry("{8edd99ca-d7c9-4552-aff5-540ae780d319}", IAircraftExternalAero)
agcls.AgTypeNameMap["IAircraftExternalAero"] = IAircraftExternalAero

class IAircraftSimpleProp(object):
    """Interface used to access the Simple Propulsion options for the Basic Acceleration Model of an aircraft."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e765bd7d-75d3-4b0e-afa6-cff14f98226c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_thrust_accel" : 1,
                             "set_max_thrust_accel" : 2,
                             "get_min_thrust_decel" : 3,
                             "set_min_thrust_decel" : 4,
                             "get_use_density_scaling" : 5,
                             "get_density_ratio_exponent" : 6,
                             "set_density_scaling" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftSimpleProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftSimpleProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftSimpleProp.__dict__ and type(IAircraftSimpleProp.__dict__[attrname]) == property:
            return IAircraftSimpleProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftSimpleProp.")
    
    _get_max_thrust_accel_metadata = { "name" : "max_thrust_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_thrust_accel(self) -> float:
        """The rate at which the aircraft speeds up at max throttle."""
        return self._intf.get_property(IAircraftSimpleProp._metadata, IAircraftSimpleProp._get_max_thrust_accel_metadata)

    _set_max_thrust_accel_metadata = { "name" : "max_thrust_accel",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_thrust_accel.setter
    def max_thrust_accel(self, pVal:float) -> None:
        """The rate at which the aircraft speeds up at max throttle."""
        return self._intf.set_property(IAircraftSimpleProp._metadata, IAircraftSimpleProp._set_max_thrust_accel_metadata, pVal)

    _get_min_thrust_decel_metadata = { "name" : "min_thrust_decel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_thrust_decel(self) -> float:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        return self._intf.get_property(IAircraftSimpleProp._metadata, IAircraftSimpleProp._get_min_thrust_decel_metadata)

    _set_min_thrust_decel_metadata = { "name" : "min_thrust_decel",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_thrust_decel.setter
    def min_thrust_decel(self, pVal:float) -> None:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        return self._intf.set_property(IAircraftSimpleProp._metadata, IAircraftSimpleProp._set_min_thrust_decel_metadata, pVal)

    _get_use_density_scaling_metadata = { "name" : "use_density_scaling",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_density_scaling(self) -> bool:
        """Opt whether to scale the accel/decel performance by the density ratio."""
        return self._intf.get_property(IAircraftSimpleProp._metadata, IAircraftSimpleProp._get_use_density_scaling_metadata)

    _get_density_ratio_exponent_metadata = { "name" : "density_ratio_exponent",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def density_ratio_exponent(self) -> float:
        """The relative impace of atmospheric density on the aircraft's performance."""
        return self._intf.get_property(IAircraftSimpleProp._metadata, IAircraftSimpleProp._get_density_ratio_exponent_metadata)

    _set_density_scaling_metadata = { "name" : "set_density_scaling",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_density_scaling(self, useScaling:bool, exponent:float) -> None:
        """Set the option to use density scaling and set the density ratio exponent."""
        return self._intf.invoke(IAircraftSimpleProp._metadata, IAircraftSimpleProp._set_density_scaling_metadata, useScaling, exponent)


agcls.AgClassCatalog.add_catalog_entry("{e765bd7d-75d3-4b0e-afa6-cff14f98226c}", IAircraftSimpleProp)
agcls.AgTypeNameMap["IAircraftSimpleProp"] = IAircraftSimpleProp

class IAircraftExternalProp(object):
    """Interface used to access the External File Propulsion options for the Basic Acceleration Model of an aircraft."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{bc0afa8f-6ccd-4369-8cfd-ee88f8251eec}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_prop_filepath" : 1,
                             "set_prop_filepath" : 2,
                             "reload_prop_file" : 3,
                             "get_is_valid" : 4,
                             "get_can_set_accel_decel" : 5,
                             "get_max_thrust_accel" : 6,
                             "set_max_thrust_accel" : 7,
                             "get_min_thrust_decel" : 8,
                             "set_min_thrust_decel" : 9,
                             "get_use_density_scaling" : 10,
                             "get_density_ratio_exponent" : 11,
                             "set_density_scaling" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftExternalProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftExternalProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftExternalProp.__dict__ and type(IAircraftExternalProp.__dict__[attrname]) == property:
            return IAircraftExternalProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftExternalProp.")
    
    _get_prop_filepath_metadata = { "name" : "prop_filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def prop_filepath(self) -> str:
        """The filepath for the prop file."""
        return self._intf.get_property(IAircraftExternalProp._metadata, IAircraftExternalProp._get_prop_filepath_metadata)

    _set_prop_filepath_metadata = { "name" : "set_prop_filepath",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_prop_filepath(self, filepath:str) -> str:
        """Set the filepath for the prop file."""
        return self._intf.invoke(IAircraftExternalProp._metadata, IAircraftExternalProp._set_prop_filepath_metadata, filepath, out_arg())

    _reload_prop_file_metadata = { "name" : "reload_prop_file",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def reload_prop_file(self) -> str:
        """Reload the prop file."""
        return self._intf.invoke(IAircraftExternalProp._metadata, IAircraftExternalProp._reload_prop_file_metadata, out_arg())

    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Check if the prop file is valid."""
        return self._intf.get_property(IAircraftExternalProp._metadata, IAircraftExternalProp._get_is_valid_metadata)

    _get_can_set_accel_decel_metadata = { "name" : "can_set_accel_decel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def can_set_accel_decel(self) -> bool:
        """Check whether you can set the acceleration and deceleration values or whether they are specified in the file."""
        return self._intf.get_property(IAircraftExternalProp._metadata, IAircraftExternalProp._get_can_set_accel_decel_metadata)

    _get_max_thrust_accel_metadata = { "name" : "max_thrust_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_thrust_accel(self) -> float:
        """The rate at which the aircraft speeds up at max throttle."""
        return self._intf.get_property(IAircraftExternalProp._metadata, IAircraftExternalProp._get_max_thrust_accel_metadata)

    _set_max_thrust_accel_metadata = { "name" : "max_thrust_accel",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_thrust_accel.setter
    def max_thrust_accel(self, pVal:float) -> None:
        """The rate at which the aircraft speeds up at max throttle."""
        return self._intf.set_property(IAircraftExternalProp._metadata, IAircraftExternalProp._set_max_thrust_accel_metadata, pVal)

    _get_min_thrust_decel_metadata = { "name" : "min_thrust_decel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_thrust_decel(self) -> float:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        return self._intf.get_property(IAircraftExternalProp._metadata, IAircraftExternalProp._get_min_thrust_decel_metadata)

    _set_min_thrust_decel_metadata = { "name" : "min_thrust_decel",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_thrust_decel.setter
    def min_thrust_decel(self, pVal:float) -> None:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        return self._intf.set_property(IAircraftExternalProp._metadata, IAircraftExternalProp._set_min_thrust_decel_metadata, pVal)

    _get_use_density_scaling_metadata = { "name" : "use_density_scaling",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_density_scaling(self) -> bool:
        """Opt whether to scale the accel/decel performance by the density ratio."""
        return self._intf.get_property(IAircraftExternalProp._metadata, IAircraftExternalProp._get_use_density_scaling_metadata)

    _get_density_ratio_exponent_metadata = { "name" : "density_ratio_exponent",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def density_ratio_exponent(self) -> float:
        """The relative impace of atmospheric density on the aircraft's performance."""
        return self._intf.get_property(IAircraftExternalProp._metadata, IAircraftExternalProp._get_density_ratio_exponent_metadata)

    _set_density_scaling_metadata = { "name" : "set_density_scaling",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_density_scaling(self, useScaling:bool, exponent:float) -> None:
        """Set the option to use density scaling and set the density ratio exponent."""
        return self._intf.invoke(IAircraftExternalProp._metadata, IAircraftExternalProp._set_density_scaling_metadata, useScaling, exponent)


agcls.AgClassCatalog.add_catalog_entry("{bc0afa8f-6ccd-4369-8cfd-ee88f8251eec}", IAircraftExternalProp)
agcls.AgTypeNameMap["IAircraftExternalProp"] = IAircraftExternalProp

class IAircraftBasicFixedWingProp(object):
    """Interface used to access the Basic Fixed Wing Propulsion options for the Basic Acceleration Model of an aircraft."""
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0c92bc71-bb3f-4953-8171-6efb0d0ab922}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_propulsion_mode" : 1,
                             "set_propulsion_mode" : 2,
                             "get_propeller_count" : 3,
                             "set_propeller_count" : 4,
                             "get_propeller_diameter" : 5,
                             "set_propeller_diameter" : 6,
                             "get_propeller_rpm" : 7,
                             "set_propeller_rpm" : 8,
                             "get_min_power_thrust" : 9,
                             "set_min_power_thrust" : 10,
                             "get_min_fuel_flow" : 11,
                             "set_min_fuel_flow" : 12,
                             "get_max_power_thrust" : 13,
                             "set_max_power_thrust" : 14,
                             "get_max_fuel_flow" : 15,
                             "set_max_fuel_flow" : 16,
                             "get_max_thrust_accel" : 17,
                             "set_max_thrust_accel" : 18,
                             "get_min_thrust_decel" : 19,
                             "set_min_thrust_decel" : 20,
                             "get_use_density_scaling" : 21,
                             "get_density_ratio_exponent" : 22,
                             "set_density_scaling" : 23, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicFixedWingProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicFixedWingProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicFixedWingProp.__dict__ and type(IAircraftBasicFixedWingProp.__dict__[attrname]) == property:
            return IAircraftBasicFixedWingProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicFixedWingProp.")
    
    _get_propulsion_mode_metadata = { "name" : "propulsion_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_FIXED_WING_PROP_MODE),) }
    @property
    def propulsion_mode(self) -> "BASIC_FIXED_WING_PROP_MODE":
        """The option of whether to specify net thrust or net power."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_propulsion_mode_metadata)

    _set_propulsion_mode_metadata = { "name" : "propulsion_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_FIXED_WING_PROP_MODE),) }
    @propulsion_mode.setter
    def propulsion_mode(self, pVal:"BASIC_FIXED_WING_PROP_MODE") -> None:
        """The option of whether to specify net thrust or net power."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_propulsion_mode_metadata, pVal)

    _get_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_propeller_count_metadata)

    _set_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @propeller_count.setter
    def propeller_count(self, pVal:int) -> None:
        """The number of propellers."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_propeller_count_metadata, pVal)

    _get_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_propeller_diameter_metadata)

    _set_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @propeller_diameter.setter
    def propeller_diameter(self, pVal:float) -> None:
        """The propeller diameter."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_propeller_diameter_metadata, pVal)

    _get_propeller_rpm_metadata = { "name" : "propeller_rpm",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def propeller_rpm(self) -> float:
        """The propeller RPM."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_propeller_rpm_metadata)

    _set_propeller_rpm_metadata = { "name" : "propeller_rpm",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @propeller_rpm.setter
    def propeller_rpm(self, pVal:float) -> None:
        """The propeller RPM."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_propeller_rpm_metadata, pVal)

    _get_min_power_thrust_metadata = { "name" : "min_power_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_power_thrust(self) -> float:
        """The minimum power/thrust depending on the propulsion mode."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_min_power_thrust_metadata)

    _set_min_power_thrust_metadata = { "name" : "min_power_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_power_thrust.setter
    def min_power_thrust(self, pVal:float) -> None:
        """The minimum power/thrust depending on the propulsion mode."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_min_power_thrust_metadata, pVal)

    _get_min_fuel_flow_metadata = { "name" : "min_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_fuel_flow(self) -> float:
        """The fuel flow for the minimum thrust/power setting."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_min_fuel_flow_metadata)

    _set_min_fuel_flow_metadata = { "name" : "min_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_fuel_flow.setter
    def min_fuel_flow(self, pVal:float) -> None:
        """The fuel flow for the minimum thrust/power setting."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_min_fuel_flow_metadata, pVal)

    _get_max_power_thrust_metadata = { "name" : "max_power_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_power_thrust(self) -> float:
        """The maximum power/thrust depending on the propulsion mode."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_max_power_thrust_metadata)

    _set_max_power_thrust_metadata = { "name" : "max_power_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_power_thrust.setter
    def max_power_thrust(self, pVal:float) -> None:
        """The maximum power/thrust depending on the propulsion mode."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_max_power_thrust_metadata, pVal)

    _get_max_fuel_flow_metadata = { "name" : "max_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_fuel_flow(self) -> float:
        """The fuel flow for the maximum thrust/power setting."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_max_fuel_flow_metadata)

    _set_max_fuel_flow_metadata = { "name" : "max_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_fuel_flow.setter
    def max_fuel_flow(self, pVal:float) -> None:
        """The fuel flow for the maximum thrust/power setting."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_max_fuel_flow_metadata, pVal)

    _get_max_thrust_accel_metadata = { "name" : "max_thrust_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_thrust_accel(self) -> float:
        """The rate at which the aircraft speeds up at max throttle."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_max_thrust_accel_metadata)

    _set_max_thrust_accel_metadata = { "name" : "max_thrust_accel",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_thrust_accel.setter
    def max_thrust_accel(self, pVal:float) -> None:
        """The rate at which the aircraft speeds up at max throttle."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_max_thrust_accel_metadata, pVal)

    _get_min_thrust_decel_metadata = { "name" : "min_thrust_decel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_thrust_decel(self) -> float:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_min_thrust_decel_metadata)

    _set_min_thrust_decel_metadata = { "name" : "min_thrust_decel",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_thrust_decel.setter
    def min_thrust_decel(self, pVal:float) -> None:
        """The rate at which the aircraft slows down at minimum throttle setting."""
        return self._intf.set_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_min_thrust_decel_metadata, pVal)

    _get_use_density_scaling_metadata = { "name" : "use_density_scaling",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_density_scaling(self) -> bool:
        """Opt whether to scale the accel/decel performance by the density ratio."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_use_density_scaling_metadata)

    _get_density_ratio_exponent_metadata = { "name" : "density_ratio_exponent",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def density_ratio_exponent(self) -> float:
        """The relative impace of atmospheric density on the aircraft's performance."""
        return self._intf.get_property(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._get_density_ratio_exponent_metadata)

    _set_density_scaling_metadata = { "name" : "set_density_scaling",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_density_scaling(self, useScaling:bool, exponent:float) -> None:
        """Set the option to use density scaling and set the density ratio exponent."""
        return self._intf.invoke(IAircraftBasicFixedWingProp._metadata, IAircraftBasicFixedWingProp._set_density_scaling_metadata, useScaling, exponent)


agcls.AgClassCatalog.add_catalog_entry("{0c92bc71-bb3f-4953-8171-6efb0d0ab922}", IAircraftBasicFixedWingProp)
agcls.AgTypeNameMap["IAircraftBasicFixedWingProp"] = IAircraftBasicFixedWingProp

class IAircraftAdvClimbModel(object):
    """Interface used to access the advanced climb model options for a climb model of an aircraft in the Aviator catalog."""
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3e994b97-b141-4cee-aada-d02409dc4756}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_climb_speed_type" : 1,
                             "set_climb_speed_type" : 2,
                             "get_climb_override_airspeed_type" : 3,
                             "get_climb_override_airspeed" : 4,
                             "set_climb_override_airspeed" : 5,
                             "get_use_afterburner" : 6,
                             "set_use_afterburner" : 7,
                             "get_use_airspeed_limit" : 8,
                             "set_use_airspeed_limit" : 9,
                             "get_altitude_limit" : 10,
                             "set_altitude_limit" : 11,
                             "get_airspeed_limit_type" : 12,
                             "get_airspeed_limit" : 13,
                             "set_airspeed_limit" : 14,
                             "get_use_flight_path_angle_limit" : 15,
                             "set_use_flight_path_angle_limit" : 16,
                             "get_flight_path_angle" : 17,
                             "set_flight_path_angle" : 18,
                             "get_compute_delta_altitude" : 19,
                             "set_compute_delta_altitude" : 20,
                             "get_as_catalog_item" : 21, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAdvClimbModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvClimbModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvClimbModel.__dict__ and type(IAircraftAdvClimbModel.__dict__[attrname]) == property:
            return IAircraftAdvClimbModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvClimbModel.")
    
    _get_climb_speed_type_metadata = { "name" : "climb_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CLIMB_SPEED_TYPE),) }
    @property
    def climb_speed_type(self) -> "CLIMB_SPEED_TYPE":
        """The mode to calculate the aircraft's airspeed while climbing."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_climb_speed_type_metadata)

    _set_climb_speed_type_metadata = { "name" : "climb_speed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CLIMB_SPEED_TYPE),) }
    @climb_speed_type.setter
    def climb_speed_type(self, newVal:"CLIMB_SPEED_TYPE") -> None:
        """The mode to calculate the aircraft's airspeed while climbing."""
        return self._intf.set_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_climb_speed_type_metadata, newVal)

    _get_climb_override_airspeed_type_metadata = { "name" : "climb_override_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def climb_override_airspeed_type(self) -> "AIRSPEED_TYPE":
        """Get the override airspeed type."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_climb_override_airspeed_type_metadata)

    _get_climb_override_airspeed_metadata = { "name" : "climb_override_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def climb_override_airspeed(self) -> float:
        """Get the override airsepeed."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_climb_override_airspeed_metadata)

    _set_climb_override_airspeed_metadata = { "name" : "set_climb_override_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_climb_override_airspeed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the override airspeed and airspeed type."""
        return self._intf.invoke(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_climb_override_airspeed_metadata, airspeedType, aispeed)

    _get_use_afterburner_metadata = { "name" : "use_afterburner",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_afterburner(self) -> bool:
        """Opt to use the engine's afterburner when climbing if available."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_use_afterburner_metadata)

    _set_use_afterburner_metadata = { "name" : "use_afterburner",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_afterburner.setter
    def use_afterburner(self, newVal:bool) -> None:
        """Opt to use the engine's afterburner when climbing if available."""
        return self._intf.set_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_use_afterburner_metadata, newVal)

    _get_use_airspeed_limit_metadata = { "name" : "use_airspeed_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_airspeed_limit(self) -> bool:
        """Opt to limit the airspeed below a specified altitude."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_use_airspeed_limit_metadata)

    _set_use_airspeed_limit_metadata = { "name" : "use_airspeed_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_airspeed_limit.setter
    def use_airspeed_limit(self, newVal:bool) -> None:
        """Opt to limit the airspeed below a specified altitude."""
        return self._intf.set_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_use_airspeed_limit_metadata, newVal)

    _get_altitude_limit_metadata = { "name" : "altitude_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_limit(self) -> float:
        """The altitude threshold, below which the airspeed limit will be applied."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_altitude_limit_metadata)

    _set_altitude_limit_metadata = { "name" : "altitude_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_limit.setter
    def altitude_limit(self, newVal:float) -> None:
        """The altitude threshold, below which the airspeed limit will be applied."""
        return self._intf.set_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_altitude_limit_metadata, newVal)

    _get_airspeed_limit_type_metadata = { "name" : "airspeed_limit_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_limit_type(self) -> "AIRSPEED_TYPE":
        """Get the airspeed limit type."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_airspeed_limit_type_metadata)

    _get_airspeed_limit_metadata = { "name" : "airspeed_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed_limit(self) -> float:
        """Get the airsepeed limit below the altitude threshold."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_airspeed_limit_metadata)

    _set_airspeed_limit_metadata = { "name" : "set_airspeed_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed_limit(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed limit and airspeed type below the altitude threshold."""
        return self._intf.invoke(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_airspeed_limit_metadata, airspeedType, aispeed)

    _get_use_flight_path_angle_limit_metadata = { "name" : "use_flight_path_angle_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_flight_path_angle_limit(self) -> bool:
        """Opt to limit the flight path angle."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_use_flight_path_angle_limit_metadata)

    _set_use_flight_path_angle_limit_metadata = { "name" : "use_flight_path_angle_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_flight_path_angle_limit.setter
    def use_flight_path_angle_limit(self, newVal:bool) -> None:
        """Opt to limit the flight path angle."""
        return self._intf.set_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_use_flight_path_angle_limit_metadata, newVal)

    _get_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def flight_path_angle(self) -> typing.Any:
        """Get the flight path angle limit."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_flight_path_angle_metadata)

    _set_flight_path_angle_metadata = { "name" : "set_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_flight_path_angle(self, angle:typing.Any) -> None:
        """Enable the flight path angle limit an set the flight path angle value."""
        return self._intf.invoke(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_flight_path_angle_metadata, angle)

    _get_compute_delta_altitude_metadata = { "name" : "compute_delta_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def compute_delta_altitude(self) -> float:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        return self._intf.get_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_compute_delta_altitude_metadata)

    _set_compute_delta_altitude_metadata = { "name" : "compute_delta_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @compute_delta_altitude.setter
    def compute_delta_altitude(self, newVal:float) -> None:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        return self._intf.set_property(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._set_compute_delta_altitude_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftAdvClimbModel._metadata, IAircraftAdvClimbModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{3e994b97-b141-4cee-aada-d02409dc4756}", IAircraftAdvClimbModel)
agcls.AgTypeNameMap["IAircraftAdvClimbModel"] = IAircraftAdvClimbModel

class IAircraftBasicCruiseModel(object):
    """Interface used to access the basic cruise model options for a cruise model of an aircraft in the Aviator catalog."""
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0416553d-3446-49c1-8b44-e677197bd059}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ceiling_altitude" : 1,
                             "set_ceiling_altitude" : 2,
                             "get_default_cruise_altitude" : 3,
                             "set_default_cruise_altitude" : 4,
                             "get_use_aero_prop_fuel" : 5,
                             "set_use_aero_prop_fuel" : 6,
                             "get_scale_fuel_flow_by_non_std_density" : 7,
                             "set_scale_fuel_flow_by_non_std_density" : 8,
                             "get_airspeed_type" : 9,
                             "set_airspeed_type" : 10,
                             "get_min_airspeed" : 11,
                             "set_min_airspeed" : 12,
                             "get_max_endurance_airspeed" : 13,
                             "set_max_endurance_airspeed" : 14,
                             "get_max_range_airspeed" : 15,
                             "set_max_range_airspeed" : 16,
                             "get_max_airspeed" : 17,
                             "set_max_airspeed" : 18,
                             "get_max_perf_airspeed" : 19,
                             "set_max_perf_airspeed" : 20,
                             "get_min_airspeed_fuel_flow" : 21,
                             "set_min_airspeed_fuel_flow" : 22,
                             "get_max_endurance_fuel_flow" : 23,
                             "set_max_endurance_fuel_flow" : 24,
                             "get_max_range_fuel_flow" : 25,
                             "set_max_range_fuel_flow" : 26,
                             "get_max_airspeed_fuel_flow" : 27,
                             "set_max_airspeed_fuel_flow" : 28,
                             "get_max_perf_airspeed_fuel_flow" : 29,
                             "set_max_perf_airspeed_fuel_flow" : 30,
                             "get_as_catalog_item" : 31, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicCruiseModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicCruiseModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicCruiseModel.__dict__ and type(IAircraftBasicCruiseModel.__dict__[attrname]) == property:
            return IAircraftBasicCruiseModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicCruiseModel.")
    
    _get_ceiling_altitude_metadata = { "name" : "ceiling_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ceiling_altitude(self) -> float:
        """The maximum altitude above mean sea level."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_ceiling_altitude_metadata)

    _set_ceiling_altitude_metadata = { "name" : "ceiling_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ceiling_altitude.setter
    def ceiling_altitude(self, newVal:float) -> None:
        """The maximum altitude above mean sea level."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_ceiling_altitude_metadata, newVal)

    _get_default_cruise_altitude_metadata = { "name" : "default_cruise_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def default_cruise_altitude(self) -> float:
        """The aircraft's default cruise altitude."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_default_cruise_altitude_metadata)

    _set_default_cruise_altitude_metadata = { "name" : "default_cruise_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @default_cruise_altitude.setter
    def default_cruise_altitude(self, newVal:float) -> None:
        """The aircraft's default cruise altitude."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_default_cruise_altitude_metadata, newVal)

    _get_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_aero_prop_fuel(self) -> bool:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_use_aero_prop_fuel_metadata)

    _set_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_use_aero_prop_fuel_metadata, newVal)

    _get_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_scale_fuel_flow_by_non_std_density_metadata)

    _set_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_scale_fuel_flow_by_non_std_density_metadata, newVal)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_airspeed_type_metadata)

    _set_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @airspeed_type.setter
    def airspeed_type(self, newVal:"AIRSPEED_TYPE") -> None:
        """The airspeed type."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_airspeed_type_metadata, newVal)

    _get_min_airspeed_metadata = { "name" : "min_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_airspeed(self) -> float:
        """The minimum cruising airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_min_airspeed_metadata)

    _set_min_airspeed_metadata = { "name" : "min_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_airspeed.setter
    def min_airspeed(self, newVal:float) -> None:
        """The minimum cruising airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_min_airspeed_metadata, newVal)

    _get_max_endurance_airspeed_metadata = { "name" : "max_endurance_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_endurance_airspeed(self) -> float:
        """The cruising airspeed that will provide the maximum flying time for the aircraft."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_endurance_airspeed_metadata)

    _set_max_endurance_airspeed_metadata = { "name" : "max_endurance_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_endurance_airspeed.setter
    def max_endurance_airspeed(self, newVal:float) -> None:
        """The cruising airspeed that will provide the maximum flying time for the aircraft."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_endurance_airspeed_metadata, newVal)

    _get_max_range_airspeed_metadata = { "name" : "max_range_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_range_airspeed(self) -> float:
        """The maximum range cruising airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_range_airspeed_metadata)

    _set_max_range_airspeed_metadata = { "name" : "max_range_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_range_airspeed.setter
    def max_range_airspeed(self, newVal:float) -> None:
        """The maximum range cruising airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_range_airspeed_metadata, newVal)

    _get_max_airspeed_metadata = { "name" : "max_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_airspeed(self) -> float:
        """The maximum cruisng airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_airspeed_metadata)

    _set_max_airspeed_metadata = { "name" : "max_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_airspeed.setter
    def max_airspeed(self, newVal:float) -> None:
        """The maximum cruisng airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_airspeed_metadata, newVal)

    _get_max_perf_airspeed_metadata = { "name" : "max_perf_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_perf_airspeed(self) -> float:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_perf_airspeed_metadata)

    _set_max_perf_airspeed_metadata = { "name" : "max_perf_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_perf_airspeed.setter
    def max_perf_airspeed(self, newVal:float) -> None:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_perf_airspeed_metadata, newVal)

    _get_min_airspeed_fuel_flow_metadata = { "name" : "min_airspeed_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the minimum cruising airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_min_airspeed_fuel_flow_metadata)

    _set_min_airspeed_fuel_flow_metadata = { "name" : "min_airspeed_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_airspeed_fuel_flow.setter
    def min_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the minimum cruising airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_min_airspeed_fuel_flow_metadata, newVal)

    _get_max_endurance_fuel_flow_metadata = { "name" : "max_endurance_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_endurance_fuel_flow(self) -> float:
        """The fuel flow for the maximum endurance cruising airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_endurance_fuel_flow_metadata)

    _set_max_endurance_fuel_flow_metadata = { "name" : "max_endurance_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_endurance_fuel_flow.setter
    def max_endurance_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximumendurance cruising airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_endurance_fuel_flow_metadata, newVal)

    _get_max_range_fuel_flow_metadata = { "name" : "max_range_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_range_fuel_flow(self) -> float:
        """The fuel flow for the maximum range cruising airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_range_fuel_flow_metadata)

    _set_max_range_fuel_flow_metadata = { "name" : "max_range_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_range_fuel_flow.setter
    def max_range_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum range cruising airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_range_fuel_flow_metadata, newVal)

    _get_max_airspeed_fuel_flow_metadata = { "name" : "max_airspeed_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum cruising airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_airspeed_fuel_flow_metadata)

    _set_max_airspeed_fuel_flow_metadata = { "name" : "max_airspeed_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_airspeed_fuel_flow.setter
    def max_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum cruising airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_airspeed_fuel_flow_metadata, newVal)

    _get_max_perf_airspeed_fuel_flow_metadata = { "name" : "max_perf_airspeed_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_perf_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum performance cruising airspeed."""
        return self._intf.get_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_max_perf_airspeed_fuel_flow_metadata)

    _set_max_perf_airspeed_fuel_flow_metadata = { "name" : "max_perf_airspeed_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_perf_airspeed_fuel_flow.setter
    def max_perf_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum performance cruising airspeed."""
        return self._intf.set_property(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._set_max_perf_airspeed_fuel_flow_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftBasicCruiseModel._metadata, IAircraftBasicCruiseModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{0416553d-3446-49c1-8b44-e677197bd059}", IAircraftBasicCruiseModel)
agcls.AgTypeNameMap["IAircraftBasicCruiseModel"] = IAircraftBasicCruiseModel

class IAircraftAdvCruiseModel(object):
    """Interface used to access the advanced cruise model options for a cruise model of an aircraft in the Aviator catalog."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{49d2ea85-8dad-44b8-8ebd-596a3ef22c88}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_default_cruise_altitude" : 1,
                             "set_default_cruise_altitude" : 2,
                             "get_max_perf_airspeed" : 3,
                             "set_max_perf_airspeed" : 4,
                             "get_use_airspeed_limit" : 5,
                             "set_use_airspeed_limit" : 6,
                             "get_altitude_limit" : 7,
                             "set_altitude_limit" : 8,
                             "get_airspeed_limit_type" : 9,
                             "get_airspeed_limit" : 10,
                             "set_airspeed_limit" : 11,
                             "get_compute_delta_downrange" : 12,
                             "set_compute_delta_downrange" : 13,
                             "get_as_catalog_item" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAdvCruiseModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvCruiseModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvCruiseModel.__dict__ and type(IAircraftAdvCruiseModel.__dict__[attrname]) == property:
            return IAircraftAdvCruiseModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvCruiseModel.")
    
    _get_default_cruise_altitude_metadata = { "name" : "default_cruise_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def default_cruise_altitude(self) -> float:
        """The aircraft's default cruising altitude."""
        return self._intf.get_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_default_cruise_altitude_metadata)

    _set_default_cruise_altitude_metadata = { "name" : "default_cruise_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @default_cruise_altitude.setter
    def default_cruise_altitude(self, newVal:float) -> None:
        """The aircraft's default cruising altitude."""
        return self._intf.set_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._set_default_cruise_altitude_metadata, newVal)

    _get_max_perf_airspeed_metadata = { "name" : "max_perf_airspeed",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRUISE_MAX_PERF_SPEED_TYPE),) }
    @property
    def max_perf_airspeed(self) -> "CRUISE_MAX_PERF_SPEED_TYPE":
        """The method for defining the maximum performance airspeed of the aircraft with respect to its altitude."""
        return self._intf.get_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_max_perf_airspeed_metadata)

    _set_max_perf_airspeed_metadata = { "name" : "max_perf_airspeed",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRUISE_MAX_PERF_SPEED_TYPE),) }
    @max_perf_airspeed.setter
    def max_perf_airspeed(self, newVal:"CRUISE_MAX_PERF_SPEED_TYPE") -> None:
        """The method for defining the maximum performance airspeed of the aircraft with respect to its altitude."""
        return self._intf.set_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._set_max_perf_airspeed_metadata, newVal)

    _get_use_airspeed_limit_metadata = { "name" : "use_airspeed_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_airspeed_limit(self) -> bool:
        """Opt to limit the airspeed below a specified altitude."""
        return self._intf.get_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_use_airspeed_limit_metadata)

    _set_use_airspeed_limit_metadata = { "name" : "use_airspeed_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_airspeed_limit.setter
    def use_airspeed_limit(self, newVal:bool) -> None:
        """Opt to limit the airspeed below a specified altitude."""
        return self._intf.set_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._set_use_airspeed_limit_metadata, newVal)

    _get_altitude_limit_metadata = { "name" : "altitude_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_limit(self) -> float:
        """The altitude threshold, below which the airspeed limit will be applied."""
        return self._intf.get_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_altitude_limit_metadata)

    _set_altitude_limit_metadata = { "name" : "altitude_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_limit.setter
    def altitude_limit(self, newVal:float) -> None:
        """The altitude threshold, below which the airspeed limit will be applied."""
        return self._intf.set_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._set_altitude_limit_metadata, newVal)

    _get_airspeed_limit_type_metadata = { "name" : "airspeed_limit_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_limit_type(self) -> "AIRSPEED_TYPE":
        """Get the airspeed limit type."""
        return self._intf.get_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_airspeed_limit_type_metadata)

    _get_airspeed_limit_metadata = { "name" : "airspeed_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed_limit(self) -> float:
        """Get the airsepeed limit below the altitude threshold."""
        return self._intf.get_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_airspeed_limit_metadata)

    _set_airspeed_limit_metadata = { "name" : "set_airspeed_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed_limit(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed limit and airspeed type below the altitude threshold."""
        return self._intf.invoke(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._set_airspeed_limit_metadata, airspeedType, aispeed)

    _get_compute_delta_downrange_metadata = { "name" : "compute_delta_downrange",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def compute_delta_downrange(self) -> float:
        """The maximum change in downrange distance in a computed segment before the data is sampled again."""
        return self._intf.get_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_compute_delta_downrange_metadata)

    _set_compute_delta_downrange_metadata = { "name" : "compute_delta_downrange",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @compute_delta_downrange.setter
    def compute_delta_downrange(self, newVal:float) -> None:
        """The maximum change in downrange distance in a computed segment before the data is sampled again."""
        return self._intf.set_property(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._set_compute_delta_downrange_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftAdvCruiseModel._metadata, IAircraftAdvCruiseModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{49d2ea85-8dad-44b8-8ebd-596a3ef22c88}", IAircraftAdvCruiseModel)
agcls.AgTypeNameMap["IAircraftAdvCruiseModel"] = IAircraftAdvCruiseModel

class IAircraftBasicDescentModel(object):
    """Interface used to access the basic descent model options for a descent model of an aircraft in the Aviator catalog."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b2fec1db-7e30-401b-91cf-b78db9b1401b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ceiling_altitude" : 1,
                             "set_ceiling_altitude" : 2,
                             "get_airspeed" : 3,
                             "get_airspeed_type" : 4,
                             "set_airspeed" : 5,
                             "get_altitude_rate" : 6,
                             "set_altitude_rate" : 7,
                             "get_use_aero_prop_fuel" : 8,
                             "set_use_aero_prop_fuel" : 9,
                             "get_scale_fuel_flow_by_non_std_density" : 10,
                             "set_scale_fuel_flow_by_non_std_density" : 11,
                             "get_fuel_flow" : 12,
                             "set_fuel_flow" : 13,
                             "get_enable_relative_airspeed_tolerance" : 14,
                             "set_enable_relative_airspeed_tolerance" : 15,
                             "get_relative_airspeed_tolerance" : 16,
                             "set_relative_airspeed_tolerance" : 17,
                             "get_as_catalog_item" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicDescentModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicDescentModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicDescentModel.__dict__ and type(IAircraftBasicDescentModel.__dict__[attrname]) == property:
            return IAircraftBasicDescentModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicDescentModel.")
    
    _get_ceiling_altitude_metadata = { "name" : "ceiling_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ceiling_altitude(self) -> float:
        """Get the ceiling altitude."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_ceiling_altitude_metadata)

    _set_ceiling_altitude_metadata = { "name" : "ceiling_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ceiling_altitude.setter
    def ceiling_altitude(self, newVal:float) -> None:
        """Put the ceiling altitude."""
        return self._intf.set_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_ceiling_altitude_metadata, newVal)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """Get the airsepeed."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_airspeed_metadata)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """Get the airspeed type."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_airspeed_type_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed type and value."""
        return self._intf.invoke(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_airspeed_metadata, airspeedType, aispeed)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """Get the altitude rate."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_altitude_rate_metadata)

    _set_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """Put the altitude rate."""
        return self._intf.set_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_altitude_rate_metadata, newVal)

    _get_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_use_aero_prop_fuel_metadata)

    _set_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        return self._intf.set_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_use_aero_prop_fuel_metadata, newVal)

    _get_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_scale_fuel_flow_by_non_std_density_metadata)

    _set_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        return self._intf.set_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_scale_fuel_flow_by_non_std_density_metadata, newVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """Get the Sea Level Fuel Flow."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """Put the Sea Level Fuel Flow."""
        return self._intf.set_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_fuel_flow_metadata, newVal)

    _get_enable_relative_airspeed_tolerance_metadata = { "name" : "enable_relative_airspeed_tolerance",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def enable_relative_airspeed_tolerance(self) -> bool:
        """Get whether to enable relative airspeed tolerance."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_enable_relative_airspeed_tolerance_metadata)

    _set_enable_relative_airspeed_tolerance_metadata = { "name" : "enable_relative_airspeed_tolerance",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @enable_relative_airspeed_tolerance.setter
    def enable_relative_airspeed_tolerance(self, newVal:bool) -> None:
        """Put whether to enable relative airspeed tolerance."""
        return self._intf.set_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_enable_relative_airspeed_tolerance_metadata, newVal)

    _get_relative_airspeed_tolerance_metadata = { "name" : "relative_airspeed_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_airspeed_tolerance(self) -> float:
        """Get the relative airspeed tolerance."""
        return self._intf.get_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_relative_airspeed_tolerance_metadata)

    _set_relative_airspeed_tolerance_metadata = { "name" : "relative_airspeed_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_airspeed_tolerance.setter
    def relative_airspeed_tolerance(self, newVal:float) -> None:
        """Put the relative airspeed tolerance."""
        return self._intf.set_property(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._set_relative_airspeed_tolerance_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftBasicDescentModel._metadata, IAircraftBasicDescentModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{b2fec1db-7e30-401b-91cf-b78db9b1401b}", IAircraftBasicDescentModel)
agcls.AgTypeNameMap["IAircraftBasicDescentModel"] = IAircraftBasicDescentModel

class IAircraftAdvDescentModel(object):
    """Interface used to access the advanced descent model options for a descent model of an aircraft in the Aviator catalog."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e668da71-2641-4751-a2eb-880eff768017}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_descent_speed_type" : 1,
                             "set_descent_speed_type" : 2,
                             "get_descent_stall_speed_ratio" : 3,
                             "set_descent_stall_speed_ratio" : 4,
                             "get_descent_override_airspeed_type" : 5,
                             "get_descent_override_airspeed" : 6,
                             "set_descent_override_airspeed" : 7,
                             "get_speedbrakes" : 8,
                             "set_speedbrakes" : 9,
                             "get_use_airspeed_limit" : 10,
                             "set_use_airspeed_limit" : 11,
                             "get_altitude_limit" : 12,
                             "set_altitude_limit" : 13,
                             "get_airspeed_limit_type" : 14,
                             "get_airspeed_limit" : 15,
                             "set_airspeed_limit" : 16,
                             "get_compute_delta_altitude" : 17,
                             "set_compute_delta_altitude" : 18,
                             "get_as_catalog_item" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAdvDescentModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvDescentModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvDescentModel.__dict__ and type(IAircraftAdvDescentModel.__dict__[attrname]) == property:
            return IAircraftAdvDescentModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvDescentModel.")
    
    _get_descent_speed_type_metadata = { "name" : "descent_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(DESCENT_SPEED_TYPE),) }
    @property
    def descent_speed_type(self) -> "DESCENT_SPEED_TYPE":
        """The mode to calculate the aircraft's airspeed while descending ."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_descent_speed_type_metadata)

    _set_descent_speed_type_metadata = { "name" : "descent_speed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(DESCENT_SPEED_TYPE),) }
    @descent_speed_type.setter
    def descent_speed_type(self, newVal:"DESCENT_SPEED_TYPE") -> None:
        """The mode to calculate the aircraft's airspeed while descending ."""
        return self._intf.set_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_descent_speed_type_metadata, newVal)

    _get_descent_stall_speed_ratio_metadata = { "name" : "descent_stall_speed_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def descent_stall_speed_ratio(self) -> float:
        """The ratio of the airspeed upon leaving the ground to the stall speed."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_descent_stall_speed_ratio_metadata)

    _set_descent_stall_speed_ratio_metadata = { "name" : "descent_stall_speed_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @descent_stall_speed_ratio.setter
    def descent_stall_speed_ratio(self, newVal:float) -> None:
        """The ratio of the airspeed upon leaving the ground to the stall speed."""
        return self._intf.set_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_descent_stall_speed_ratio_metadata, newVal)

    _get_descent_override_airspeed_type_metadata = { "name" : "descent_override_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def descent_override_airspeed_type(self) -> "AIRSPEED_TYPE":
        """Get the override airspeed type."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_descent_override_airspeed_type_metadata)

    _get_descent_override_airspeed_metadata = { "name" : "descent_override_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def descent_override_airspeed(self) -> float:
        """Get the override airsepeed."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_descent_override_airspeed_metadata)

    _set_descent_override_airspeed_metadata = { "name" : "set_descent_override_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_descent_override_airspeed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the override airspeed and airspeed type."""
        return self._intf.invoke(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_descent_override_airspeed_metadata, airspeedType, aispeed)

    _get_speedbrakes_metadata = { "name" : "speedbrakes",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def speedbrakes(self) -> float:
        """The extension of the speedbrakes during the landing."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_speedbrakes_metadata)

    _set_speedbrakes_metadata = { "name" : "speedbrakes",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @speedbrakes.setter
    def speedbrakes(self, newVal:float) -> None:
        """The extension of the speedbrakes during the landing."""
        return self._intf.set_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_speedbrakes_metadata, newVal)

    _get_use_airspeed_limit_metadata = { "name" : "use_airspeed_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_airspeed_limit(self) -> bool:
        """Opt to limit the airspeed below a specified altitude."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_use_airspeed_limit_metadata)

    _set_use_airspeed_limit_metadata = { "name" : "use_airspeed_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_airspeed_limit.setter
    def use_airspeed_limit(self, newVal:bool) -> None:
        """Opt to limit the airspeed below a specified altitude."""
        return self._intf.set_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_use_airspeed_limit_metadata, newVal)

    _get_altitude_limit_metadata = { "name" : "altitude_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_limit(self) -> float:
        """The altitude threshold, below which the airspeed limit will be applied."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_altitude_limit_metadata)

    _set_altitude_limit_metadata = { "name" : "altitude_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_limit.setter
    def altitude_limit(self, newVal:float) -> None:
        """The altitude threshold, below which the airspeed limit will be applied."""
        return self._intf.set_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_altitude_limit_metadata, newVal)

    _get_airspeed_limit_type_metadata = { "name" : "airspeed_limit_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_limit_type(self) -> "AIRSPEED_TYPE":
        """Get the airspeed limit type."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_airspeed_limit_type_metadata)

    _get_airspeed_limit_metadata = { "name" : "airspeed_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed_limit(self) -> float:
        """Get the airsepeed limit below the altitude threshold."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_airspeed_limit_metadata)

    _set_airspeed_limit_metadata = { "name" : "set_airspeed_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed_limit(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the airspeed limit and airspeed type below the altitude threshold."""
        return self._intf.invoke(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_airspeed_limit_metadata, airspeedType, aispeed)

    _get_compute_delta_altitude_metadata = { "name" : "compute_delta_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def compute_delta_altitude(self) -> float:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        return self._intf.get_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_compute_delta_altitude_metadata)

    _set_compute_delta_altitude_metadata = { "name" : "compute_delta_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @compute_delta_altitude.setter
    def compute_delta_altitude(self, newVal:float) -> None:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        return self._intf.set_property(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._set_compute_delta_altitude_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftAdvDescentModel._metadata, IAircraftAdvDescentModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{e668da71-2641-4751-a2eb-880eff768017}", IAircraftAdvDescentModel)
agcls.AgTypeNameMap["IAircraftAdvDescentModel"] = IAircraftAdvDescentModel

class IAircraftBasicLandingModel(object):
    """Interface used to access the basic landing model options for a landing model of an aircraft in the Aviator catalog."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3e5cc8b6-970b-4412-8ee7-4863224e2ae5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_landing_speed" : 1,
                             "get_landing_speed_type" : 2,
                             "set_landing_speed" : 3,
                             "get_sea_level_ground_roll" : 4,
                             "set_sea_level_ground_roll" : 5,
                             "get_use_aero_prop_fuel" : 6,
                             "set_use_aero_prop_fuel" : 7,
                             "get_scale_fuel_flow_by_non_std_density" : 8,
                             "set_scale_fuel_flow_by_non_std_density" : 9,
                             "get_fuel_flow" : 10,
                             "set_fuel_flow" : 11,
                             "get_as_catalog_item" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicLandingModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicLandingModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicLandingModel.__dict__ and type(IAircraftBasicLandingModel.__dict__[attrname]) == property:
            return IAircraftBasicLandingModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicLandingModel.")
    
    _get_landing_speed_metadata = { "name" : "landing_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def landing_speed(self) -> float:
        """The landing speed of the aircraft."""
        return self._intf.get_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._get_landing_speed_metadata)

    _get_landing_speed_type_metadata = { "name" : "landing_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def landing_speed_type(self) -> "AIRSPEED_TYPE":
        """The landing speed type."""
        return self._intf.get_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._get_landing_speed_type_metadata)

    _set_landing_speed_metadata = { "name" : "set_landing_speed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_landing_speed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the landing speed of the aircraft."""
        return self._intf.invoke(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._set_landing_speed_metadata, airspeedType, aispeed)

    _get_sea_level_ground_roll_metadata = { "name" : "sea_level_ground_roll",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def sea_level_ground_roll(self) -> float:
        """The distance the aircraft travels along the ground while decelerating to a stop at sea level."""
        return self._intf.get_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._get_sea_level_ground_roll_metadata)

    _set_sea_level_ground_roll_metadata = { "name" : "sea_level_ground_roll",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @sea_level_ground_roll.setter
    def sea_level_ground_roll(self, newVal:float) -> None:
        """The distance the aircraft travels along the ground while decelerating to a stop at sea level."""
        return self._intf.set_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._set_sea_level_ground_roll_metadata, newVal)

    _get_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        return self._intf.get_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._get_use_aero_prop_fuel_metadata)

    _set_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        return self._intf.set_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._set_use_aero_prop_fuel_metadata, newVal)

    _get_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        return self._intf.get_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._get_scale_fuel_flow_by_non_std_density_metadata)

    _set_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        return self._intf.set_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._set_scale_fuel_flow_by_non_std_density_metadata, newVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """Get the Sea Level Fuel Flow."""
        return self._intf.get_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """Put the Sea Level Fuel Flow."""
        return self._intf.set_property(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._set_fuel_flow_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftBasicLandingModel._metadata, IAircraftBasicLandingModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{3e5cc8b6-970b-4412-8ee7-4863224e2ae5}", IAircraftBasicLandingModel)
agcls.AgTypeNameMap["IAircraftBasicLandingModel"] = IAircraftBasicLandingModel

class IAircraftAdvLandingModel(object):
    """Interface used to access the advanced landing model options for a landing model of an aircraft in the Aviator catalog."""
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{bee9a455-0eeb-493f-aff6-93a11be34090}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_landing_speed_mode" : 1,
                             "set_landing_speed_mode" : 2,
                             "get_stall_speed_ratio" : 3,
                             "set_stall_speed_ratio" : 4,
                             "get_angle_of_attack" : 5,
                             "set_angle_of_attack" : 6,
                             "get_flaps" : 7,
                             "set_flaps" : 8,
                             "get_speedbrakes" : 9,
                             "set_speedbrakes" : 10,
                             "get_braking_decel_g" : 11,
                             "set_braking_decel_g" : 12,
                             "get_as_catalog_item" : 13, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAdvLandingModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvLandingModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvLandingModel.__dict__ and type(IAircraftAdvLandingModel.__dict__[attrname]) == property:
            return IAircraftAdvLandingModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvLandingModel.")
    
    _get_landing_speed_mode_metadata = { "name" : "landing_speed_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TAKEOFF_LANDING_SPEED_MODE),) }
    @property
    def landing_speed_mode(self) -> "TAKEOFF_LANDING_SPEED_MODE":
        """The mode to calculate the aircraft's speed at wheels down."""
        return self._intf.get_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._get_landing_speed_mode_metadata)

    _set_landing_speed_mode_metadata = { "name" : "landing_speed_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TAKEOFF_LANDING_SPEED_MODE),) }
    @landing_speed_mode.setter
    def landing_speed_mode(self, newVal:"TAKEOFF_LANDING_SPEED_MODE") -> None:
        """The mode to calculate the aircraft's speed at wheels down."""
        return self._intf.set_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._set_landing_speed_mode_metadata, newVal)

    _get_stall_speed_ratio_metadata = { "name" : "stall_speed_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stall_speed_ratio(self) -> float:
        """The ratio of the airspeed to the stall speed at wheels down."""
        return self._intf.get_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._get_stall_speed_ratio_metadata)

    _set_stall_speed_ratio_metadata = { "name" : "set_stall_speed_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def set_stall_speed_ratio(self, stallSpeedRatio:float) -> None:
        """Set the landing speed mode to StallSpeedRatio and specify the stall speed ratio."""
        return self._intf.invoke(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._set_stall_speed_ratio_metadata, stallSpeedRatio)

    _get_angle_of_attack_metadata = { "name" : "angle_of_attack",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle_of_attack(self) -> typing.Any:
        """The Angle of Attack at wheels down."""
        return self._intf.get_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._get_angle_of_attack_metadata)

    _set_angle_of_attack_metadata = { "name" : "set_angle_of_attack",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_angle_of_attack(self, angleOfAttack:typing.Any) -> None:
        """Set the landing speed mode to AngleOfAttack and specify the angle of attack"""
        return self._intf.invoke(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._set_angle_of_attack_metadata, angleOfAttack)

    _get_flaps_metadata = { "name" : "flaps",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def flaps(self) -> float:
        """The extension of the flaps during the landing."""
        return self._intf.get_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._get_flaps_metadata)

    _set_flaps_metadata = { "name" : "flaps",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @flaps.setter
    def flaps(self, newVal:float) -> None:
        """The extension of the flaps during the landing."""
        return self._intf.set_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._set_flaps_metadata, newVal)

    _get_speedbrakes_metadata = { "name" : "speedbrakes",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def speedbrakes(self) -> float:
        """The extension of the speedbrakes during the landing."""
        return self._intf.get_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._get_speedbrakes_metadata)

    _set_speedbrakes_metadata = { "name" : "speedbrakes",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @speedbrakes.setter
    def speedbrakes(self, newVal:float) -> None:
        """The extension of the speedbrakes during the landing."""
        return self._intf.set_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._set_speedbrakes_metadata, newVal)

    _get_braking_decel_g_metadata = { "name" : "braking_decel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def braking_decel_g(self) -> float:
        """The deceleration rate, in G, when braking."""
        return self._intf.get_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._get_braking_decel_g_metadata)

    _set_braking_decel_g_metadata = { "name" : "braking_decel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @braking_decel_g.setter
    def braking_decel_g(self, newVal:float) -> None:
        """The deceleration rate, in G, when braking."""
        return self._intf.set_property(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._set_braking_decel_g_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftAdvLandingModel._metadata, IAircraftAdvLandingModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{bee9a455-0eeb-493f-aff6-93a11be34090}", IAircraftAdvLandingModel)
agcls.AgTypeNameMap["IAircraftAdvLandingModel"] = IAircraftAdvLandingModel

class IAircraftBasicTakeoffModel(object):
    """Interface used to access the basic takeoff model options for a takeoff model of an aircraft in the Aviator catalog."""
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{981697a5-e6b3-45d7-a3d4-7caec2237c0a}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_takeoff_speed" : 1,
                             "get_takeoff_speed_type" : 2,
                             "set_takeoff_speed" : 3,
                             "get_sea_level_ground_roll" : 4,
                             "set_sea_level_ground_roll" : 5,
                             "get_departure_speed" : 6,
                             "get_departure_speed_type" : 7,
                             "set_departure_speed" : 8,
                             "get_use_aero_prop_fuel" : 9,
                             "set_use_aero_prop_fuel" : 10,
                             "get_scale_fuel_flow_by_non_std_density" : 11,
                             "set_scale_fuel_flow_by_non_std_density" : 12,
                             "get_accel_fuel_flow" : 13,
                             "set_accel_fuel_flow" : 14,
                             "get_departure_fuel_flow" : 15,
                             "set_departure_fuel_flow" : 16,
                             "get_as_catalog_item" : 17, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicTakeoffModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicTakeoffModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicTakeoffModel.__dict__ and type(IAircraftBasicTakeoffModel.__dict__[attrname]) == property:
            return IAircraftBasicTakeoffModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicTakeoffModel.")
    
    _get_takeoff_speed_metadata = { "name" : "takeoff_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def takeoff_speed(self) -> float:
        """The speed to which the aircraft accelerates on its ground roll for takeoff."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_takeoff_speed_metadata)

    _get_takeoff_speed_type_metadata = { "name" : "takeoff_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def takeoff_speed_type(self) -> "AIRSPEED_TYPE":
        """The takeoff speed type."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_takeoff_speed_type_metadata)

    _set_takeoff_speed_metadata = { "name" : "set_takeoff_speed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_takeoff_speed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the takeoff speed of the aircraft."""
        return self._intf.invoke(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._set_takeoff_speed_metadata, airspeedType, aispeed)

    _get_sea_level_ground_roll_metadata = { "name" : "sea_level_ground_roll",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def sea_level_ground_roll(self) -> float:
        """The distance the aircraft travels along the ground while accelerationg to takeoff at sea level."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_sea_level_ground_roll_metadata)

    _set_sea_level_ground_roll_metadata = { "name" : "sea_level_ground_roll",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @sea_level_ground_roll.setter
    def sea_level_ground_roll(self, newVal:float) -> None:
        """The distance the aircraft travels along the ground while accelerationg to takeoff at sea level."""
        return self._intf.set_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._set_sea_level_ground_roll_metadata, newVal)

    _get_departure_speed_metadata = { "name" : "departure_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def departure_speed(self) -> float:
        """The aircraft's speed upon leaving the ground."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_departure_speed_metadata)

    _get_departure_speed_type_metadata = { "name" : "departure_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def departure_speed_type(self) -> "AIRSPEED_TYPE":
        """The departure speed type."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_departure_speed_type_metadata)

    _set_departure_speed_metadata = { "name" : "set_departure_speed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_departure_speed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the departure speed of the aircraft."""
        return self._intf.invoke(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._set_departure_speed_metadata, airspeedType, aispeed)

    _get_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_use_aero_prop_fuel_metadata)

    _set_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        return self._intf.set_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._set_use_aero_prop_fuel_metadata, newVal)

    _get_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_scale_fuel_flow_by_non_std_density_metadata)

    _set_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        return self._intf.set_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._set_scale_fuel_flow_by_non_std_density_metadata, newVal)

    _get_accel_fuel_flow_metadata = { "name" : "accel_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_fuel_flow(self) -> float:
        """The aircraft's fuel flow rate while accelerating during takeoff."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_accel_fuel_flow_metadata)

    _set_accel_fuel_flow_metadata = { "name" : "accel_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_fuel_flow.setter
    def accel_fuel_flow(self, newVal:float) -> None:
        """The aircraft's fuel flow rate while accelerating during takeoff."""
        return self._intf.set_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._set_accel_fuel_flow_metadata, newVal)

    _get_departure_fuel_flow_metadata = { "name" : "departure_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def departure_fuel_flow(self) -> float:
        """The aircraft's fuel flow rate at departure speed."""
        return self._intf.get_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_departure_fuel_flow_metadata)

    _set_departure_fuel_flow_metadata = { "name" : "departure_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @departure_fuel_flow.setter
    def departure_fuel_flow(self, newVal:float) -> None:
        """The aircraft's fuel flow rate at departure speed."""
        return self._intf.set_property(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._set_departure_fuel_flow_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftBasicTakeoffModel._metadata, IAircraftBasicTakeoffModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{981697a5-e6b3-45d7-a3d4-7caec2237c0a}", IAircraftBasicTakeoffModel)
agcls.AgTypeNameMap["IAircraftBasicTakeoffModel"] = IAircraftBasicTakeoffModel

class IAircraftAdvTakeoffModel(object):
    """Interface used to access the advanced takeoff model options for a takeoff model of an aircraft in the Aviator catalog."""
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3290c530-62d6-49d7-8d89-69f0c3e6148d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_takeoff_speed_mode" : 1,
                             "set_takeoff_speed_mode" : 2,
                             "get_stall_speed_ratio" : 3,
                             "set_stall_speed_ratio" : 4,
                             "get_angle_of_attack" : 5,
                             "set_angle_of_attack" : 6,
                             "get_flaps" : 7,
                             "set_flaps" : 8,
                             "get_departure_speed_mode" : 9,
                             "set_departure_speed_mode" : 10,
                             "get_departure_speed_limit" : 11,
                             "get_departure_speed_limit_type" : 12,
                             "set_departure_speed_limit" : 13,
                             "get_use_afterburner" : 14,
                             "set_use_afterburner" : 15,
                             "get_as_catalog_item" : 16, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAdvTakeoffModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvTakeoffModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvTakeoffModel.__dict__ and type(IAircraftAdvTakeoffModel.__dict__[attrname]) == property:
            return IAircraftAdvTakeoffModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvTakeoffModel.")
    
    _get_takeoff_speed_mode_metadata = { "name" : "takeoff_speed_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TAKEOFF_LANDING_SPEED_MODE),) }
    @property
    def takeoff_speed_mode(self) -> "TAKEOFF_LANDING_SPEED_MODE":
        """The mode to calculate the aircraft's airspeed upon leaving the ground."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_takeoff_speed_mode_metadata)

    _set_takeoff_speed_mode_metadata = { "name" : "takeoff_speed_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TAKEOFF_LANDING_SPEED_MODE),) }
    @takeoff_speed_mode.setter
    def takeoff_speed_mode(self, newVal:"TAKEOFF_LANDING_SPEED_MODE") -> None:
        """The mode to calculate the aircraft's  airspeed upon leaving the ground."""
        return self._intf.set_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._set_takeoff_speed_mode_metadata, newVal)

    _get_stall_speed_ratio_metadata = { "name" : "stall_speed_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stall_speed_ratio(self) -> float:
        """The ratio of the airspeed to the stall speed upon leaving the ground."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_stall_speed_ratio_metadata)

    _set_stall_speed_ratio_metadata = { "name" : "set_stall_speed_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def set_stall_speed_ratio(self, stallSpeedRatio:float) -> None:
        """Set the takeoff speed mode to StallSpeedRatio and specify the stall speed ratio."""
        return self._intf.invoke(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._set_stall_speed_ratio_metadata, stallSpeedRatio)

    _get_angle_of_attack_metadata = { "name" : "angle_of_attack",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle_of_attack(self) -> typing.Any:
        """The Angle of Attack upon leaving the ground."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_angle_of_attack_metadata)

    _set_angle_of_attack_metadata = { "name" : "set_angle_of_attack",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_angle_of_attack(self, angleOfAttack:typing.Any) -> None:
        """Set the takeoff speed mode to AngleOfAttack and specify the angle of attack"""
        return self._intf.invoke(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._set_angle_of_attack_metadata, angleOfAttack)

    _get_flaps_metadata = { "name" : "flaps",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def flaps(self) -> float:
        """The extension of the flaps during takeoff."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_flaps_metadata)

    _set_flaps_metadata = { "name" : "flaps",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @flaps.setter
    def flaps(self, newVal:float) -> None:
        """The extension of the flaps during takeoff."""
        return self._intf.set_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._set_flaps_metadata, newVal)

    _get_departure_speed_mode_metadata = { "name" : "departure_speed_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(DEPARTURE_SPEED_MODE),) }
    @property
    def departure_speed_mode(self) -> "DEPARTURE_SPEED_MODE":
        """The mode to calculate the airspeed upon leaving the ground."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_departure_speed_mode_metadata)

    _set_departure_speed_mode_metadata = { "name" : "departure_speed_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(DEPARTURE_SPEED_MODE),) }
    @departure_speed_mode.setter
    def departure_speed_mode(self, newVal:"DEPARTURE_SPEED_MODE") -> None:
        """The mode to calculate the airspeed upon leaving the ground."""
        return self._intf.set_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._set_departure_speed_mode_metadata, newVal)

    _get_departure_speed_limit_metadata = { "name" : "departure_speed_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def departure_speed_limit(self) -> float:
        """The aircraft's maximum airspeed upon leaving the ground."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_departure_speed_limit_metadata)

    _get_departure_speed_limit_type_metadata = { "name" : "departure_speed_limit_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def departure_speed_limit_type(self) -> "AIRSPEED_TYPE":
        """The departure speed limim type."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_departure_speed_limit_type_metadata)

    _set_departure_speed_limit_metadata = { "name" : "set_departure_speed_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_departure_speed_limit(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the departure speed limit of the aircraft."""
        return self._intf.invoke(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._set_departure_speed_limit_metadata, airspeedType, aispeed)

    _get_use_afterburner_metadata = { "name" : "use_afterburner",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_afterburner(self) -> bool:
        """Opt whether to use the afterburner if it is possible."""
        return self._intf.get_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_use_afterburner_metadata)

    _set_use_afterburner_metadata = { "name" : "use_afterburner",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_afterburner.setter
    def use_afterburner(self, newVal:bool) -> None:
        """Opt whether to use the afterburner if it is possible."""
        return self._intf.set_property(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._set_use_afterburner_metadata, newVal)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftAdvTakeoffModel._metadata, IAircraftAdvTakeoffModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{3290c530-62d6-49d7-8d89-69f0c3e6148d}", IAircraftAdvTakeoffModel)
agcls.AgTypeNameMap["IAircraftAdvTakeoffModel"] = IAircraftAdvTakeoffModel

class IAircraftVTOLModel(object):
    """Interface used to access the options for a VTOL performance model of an aircraft."""
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e9a1ecac-84c0-4fed-bbfc-ae61a6b5d745}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_hover_altitude" : 1,
                             "set_max_hover_altitude" : 2,
                             "get_use_aero_prop_fuel" : 3,
                             "set_use_aero_prop_fuel" : 4,
                             "get_scale_fuel_flow_by_non_std_density" : 5,
                             "set_scale_fuel_flow_by_non_std_density" : 6,
                             "get_hover_fuel" : 7,
                             "set_hover_fuel" : 8,
                             "get_heading_rate" : 9,
                             "set_heading_rate" : 10,
                             "get_heading_transition_time" : 11,
                             "set_heading_transition_time" : 12,
                             "get_vertical_rate" : 13,
                             "set_vertical_rate" : 14,
                             "get_vertical_transition_time" : 15,
                             "set_vertical_transition_time" : 16,
                             "get_translation_rate" : 17,
                             "set_translation_rate" : 18,
                             "get_translation_transition_time" : 19,
                             "set_translation_transition_time" : 20,
                             "get_forward_flight_airspeed" : 21,
                             "get_forward_flight_airspeed_type" : 22,
                             "set_forward_flight_airspeed" : 23,
                             "get_forward_flight_transition_time" : 24,
                             "set_forward_flight_transition_time" : 25, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftVTOLModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftVTOLModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftVTOLModel.__dict__ and type(IAircraftVTOLModel.__dict__[attrname]) == property:
            return IAircraftVTOLModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftVTOLModel.")
    
    _get_max_hover_altitude_metadata = { "name" : "max_hover_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_hover_altitude(self) -> float:
        """The maximum altitude at which the aircraft is capable of hovering."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_max_hover_altitude_metadata)

    _set_max_hover_altitude_metadata = { "name" : "max_hover_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_hover_altitude.setter
    def max_hover_altitude(self, newVal:float) -> None:
        """The maximum altitude at which the aircraft is capable of hovering."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_max_hover_altitude_metadata, newVal)

    _get_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_aero_prop_fuel(self) -> bool:
        """Get whether to use Aero/Propulsion fuel flow."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_use_aero_prop_fuel_metadata)

    _set_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Put whether to use Aero/Propulsion fuel flow."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_use_aero_prop_fuel_metadata, newVal)

    _get_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Get whether to scale fuel flow by non std density."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_scale_fuel_flow_by_non_std_density_metadata)

    _set_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Put whether to scale fuel flow by non std density."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_scale_fuel_flow_by_non_std_density_metadata, newVal)

    _get_hover_fuel_metadata = { "name" : "hover_fuel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def hover_fuel(self) -> float:
        """The aircraft's fuel flow rate while hovering."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_hover_fuel_metadata)

    _set_hover_fuel_metadata = { "name" : "hover_fuel",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @hover_fuel.setter
    def hover_fuel(self, newVal:float) -> None:
        """The aircraft's fuel flow rate while hovering."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_hover_fuel_metadata, newVal)

    _get_heading_rate_metadata = { "name" : "heading_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_rate(self) -> typing.Any:
        """The rate at which the aircraft can change heading while hovering."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_heading_rate_metadata)

    _set_heading_rate_metadata = { "name" : "heading_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading_rate.setter
    def heading_rate(self, newVal:typing.Any) -> None:
        """The rate at which the aircraft can change heading while hovering."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_heading_rate_metadata, newVal)

    _get_heading_transition_time_metadata = { "name" : "heading_transition_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def heading_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to heading change maneuver mode."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_heading_transition_time_metadata)

    _set_heading_transition_time_metadata = { "name" : "heading_transition_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @heading_transition_time.setter
    def heading_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to heading change maneuver mode."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_heading_transition_time_metadata, newVal)

    _get_vertical_rate_metadata = { "name" : "vertical_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def vertical_rate(self) -> float:
        """The aircraft's vertical rate."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_vertical_rate_metadata)

    _set_vertical_rate_metadata = { "name" : "vertical_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @vertical_rate.setter
    def vertical_rate(self, newVal:float) -> None:
        """The aircraft's vertical rate."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_vertical_rate_metadata, newVal)

    _get_vertical_transition_time_metadata = { "name" : "vertical_transition_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def vertical_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to vertical maneuver mode."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_vertical_transition_time_metadata)

    _set_vertical_transition_time_metadata = { "name" : "vertical_transition_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @vertical_transition_time.setter
    def vertical_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to vertical maneuver mode."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_vertical_transition_time_metadata, newVal)

    _get_translation_rate_metadata = { "name" : "translation_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def translation_rate(self) -> float:
        """The rate at which the aircraft can translate while hovering."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_translation_rate_metadata)

    _set_translation_rate_metadata = { "name" : "translation_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @translation_rate.setter
    def translation_rate(self, newVal:float) -> None:
        """The rate at which the aircraft can translate while hovering."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_translation_rate_metadata, newVal)

    _get_translation_transition_time_metadata = { "name" : "translation_transition_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def translation_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to translation maneuver mode."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_translation_transition_time_metadata)

    _set_translation_transition_time_metadata = { "name" : "translation_transition_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @translation_transition_time.setter
    def translation_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to translation maneuver mode."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_translation_transition_time_metadata, newVal)

    _get_forward_flight_airspeed_metadata = { "name" : "forward_flight_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_airspeed(self) -> float:
        """The speed at which the aircraft can begin forward flight."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_forward_flight_airspeed_metadata)

    _get_forward_flight_airspeed_type_metadata = { "name" : "forward_flight_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def forward_flight_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The forward flight airspeed type."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_forward_flight_airspeed_type_metadata)

    _set_forward_flight_airspeed_metadata = { "name" : "set_forward_flight_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_forward_flight_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the speed at which the aircraft can begin forward flight."""
        return self._intf.invoke(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_forward_flight_airspeed_metadata, airspeedType, airspeed)

    _get_forward_flight_transition_time_metadata = { "name" : "forward_flight_transition_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_transition_time(self) -> float:
        """The time required to transition from another maneuvering mode to forward flight at sea level."""
        return self._intf.get_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._get_forward_flight_transition_time_metadata)

    _set_forward_flight_transition_time_metadata = { "name" : "forward_flight_transition_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @forward_flight_transition_time.setter
    def forward_flight_transition_time(self, newVal:float) -> None:
        """The time required to transition from another maneuvering mode to forward flight at sea level."""
        return self._intf.set_property(IAircraftVTOLModel._metadata, IAircraftVTOLModel._set_forward_flight_transition_time_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{e9a1ecac-84c0-4fed-bbfc-ae61a6b5d745}", IAircraftVTOLModel)
agcls.AgTypeNameMap["IAircraftVTOLModel"] = IAircraftVTOLModel

class IAircraftTerrainFollow(object):
    """Interface used to access the TerrainFollow options for an aircraft in the Aviator catalog."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{293c033c-5053-4a55-bfbb-fd8ea210749f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_terrain_follow_by_name" : 1,
                             "get_as_catalog_item" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftTerrainFollow._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftTerrainFollow from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftTerrainFollow.__dict__ and type(IAircraftTerrainFollow.__dict__[attrname]) == property:
            return IAircraftTerrainFollow.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftTerrainFollow.")
    
    _get_terrain_follow_by_name_metadata = { "name" : "get_terrain_follow_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_terrain_follow_by_name(self, name:str) -> "AircraftTerrainFollowModel":
        """Gets the TerrainFollow model with the given name."""
        return self._intf.invoke(IAircraftTerrainFollow._metadata, IAircraftTerrainFollow._get_terrain_follow_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftTerrainFollow._metadata, IAircraftTerrainFollow._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{293c033c-5053-4a55-bfbb-fd8ea210749f}", IAircraftTerrainFollow)
agcls.AgTypeNameMap["IAircraftTerrainFollow"] = IAircraftTerrainFollow

class IPerformanceModelOptions(object):
    """Interface used to change the active performance model in a phase for a given model type."""
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{DE05DB32-36E7-4C14-916E-C626C4E084FD}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "link_to_catalog" : 1,
                             "copy_from_catalog" : 2,
                             "create_new" : 3,
                             "rename" : 4,
                             "delete" : 5,
                             "get_name" : 6,
                             "get_is_linked_to_catalog" : 7,
                             "get_properties" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IPerformanceModelOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IPerformanceModelOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPerformanceModelOptions.__dict__ and type(IPerformanceModelOptions.__dict__[attrname]) == property:
            return IPerformanceModelOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPerformanceModelOptions.")
    
    _link_to_catalog_metadata = { "name" : "link_to_catalog",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def link_to_catalog(self, name:str) -> None:
        """Link to the performance model in the catalog with the given name."""
        return self._intf.invoke(IPerformanceModelOptions._metadata, IPerformanceModelOptions._link_to_catalog_metadata, name)

    _copy_from_catalog_metadata = { "name" : "copy_from_catalog",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def copy_from_catalog(self, name:str) -> None:
        """Create a copy of the performance model in the catalog with the given name."""
        return self._intf.invoke(IPerformanceModelOptions._metadata, IPerformanceModelOptions._copy_from_catalog_metadata, name)

    _create_new_metadata = { "name" : "create_new",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def create_new(self, type:str) -> None:
        """Create a new performance model of the given type."""
        return self._intf.invoke(IPerformanceModelOptions._metadata, IPerformanceModelOptions._create_new_metadata, type)

    _rename_metadata = { "name" : "rename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def rename(self, type:str) -> None:
        """Rename the performance model."""
        return self._intf.invoke(IPerformanceModelOptions._metadata, IPerformanceModelOptions._rename_metadata, type)

    _delete_metadata = { "name" : "delete",
            "arg_types" : (),
            "marshallers" : () }
    def delete(self) -> None:
        """Delete the performance model."""
        return self._intf.invoke(IPerformanceModelOptions._metadata, IPerformanceModelOptions._delete_metadata, )

    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """Get the name of the performance model."""
        return self._intf.get_property(IPerformanceModelOptions._metadata, IPerformanceModelOptions._get_name_metadata)

    _get_is_linked_to_catalog_metadata = { "name" : "is_linked_to_catalog",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_linked_to_catalog(self) -> bool:
        """Get whether the performance model is linked to the catalog."""
        return self._intf.get_property(IPerformanceModelOptions._metadata, IPerformanceModelOptions._get_is_linked_to_catalog_metadata)

    _get_properties_metadata = { "name" : "properties",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def properties(self) -> "IPerformanceModel":
        """Get the properties of the performance model."""
        return self._intf.get_property(IPerformanceModelOptions._metadata, IPerformanceModelOptions._get_properties_metadata)


agcls.AgClassCatalog.add_catalog_entry("{DE05DB32-36E7-4C14-916E-C626C4E084FD}", IPerformanceModelOptions)
agcls.AgTypeNameMap["IPerformanceModelOptions"] = IPerformanceModelOptions

class IAdvFixedWingTool(object):
    """Interface used to access the options for the Advanced Fixed Wing Tool of an aircraft."""
    _num_methods = 41
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{3722BD33-A1BE-48AD-AF6F-4AC40B19FBBA}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_wing_area" : 1,
                             "set_wing_area" : 2,
                             "get_flaps_area" : 3,
                             "set_flaps_area" : 4,
                             "get_speedbrakes_area" : 5,
                             "set_speedbrakes_area" : 6,
                             "get_max_altitude" : 7,
                             "set_max_altitude" : 8,
                             "get_max_mach" : 9,
                             "set_max_mach" : 10,
                             "get_max_eas" : 11,
                             "set_max_eas" : 12,
                             "get_min_load_factor" : 13,
                             "set_min_load_factor" : 14,
                             "get_max_load_factor" : 15,
                             "set_max_load_factor" : 16,
                             "get_use_max_temperature_limit" : 17,
                             "set_use_max_temperature_limit" : 18,
                             "get_max_temperature" : 19,
                             "set_max_temperature" : 20,
                             "get_cache_aero_data" : 21,
                             "set_cache_aero_data" : 22,
                             "get_cache_fuel_flow" : 23,
                             "set_cache_fuel_flow" : 24,
                             "get_aero_strategy" : 25,
                             "set_aero_strategy" : 26,
                             "get_aero_mode_as_external" : 27,
                             "get_aero_mode_as_subsonic" : 28,
                             "get_aero_mode_as_sub_super_hypersonic" : 29,
                             "get_aero_mode_as_supersonic" : 30,
                             "get_powerplant_strategy" : 31,
                             "set_powerplant_strategy" : 32,
                             "get_powerplant_mode_as_electric" : 33,
                             "get_powerplant_mode_as_external" : 34,
                             "get_powerplant_mode_as_piston" : 35,
                             "get_powerplant_mode_as_turboprop" : 36,
                             "get_powerplant_mode_as_empirical_jet_engine" : 37,
                             "create_all_perf_models" : 38,
                             "get_powerplant_mode_as_basic_turbofan" : 39,
                             "get_powerplant_mode_as_basic_turbojet" : 40,
                             "get_powerplant_mode_as_sub_super_hypersonic" : 41, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingTool._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTool from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTool.__dict__ and type(IAdvFixedWingTool.__dict__[attrname]) == property:
            return IAdvFixedWingTool.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTool.")
    
    _get_wing_area_metadata = { "name" : "wing_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wing_area(self) -> float:
        """The total surface area of the wing."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_wing_area_metadata)

    _set_wing_area_metadata = { "name" : "wing_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wing_area.setter
    def wing_area(self, newVal:float) -> None:
        """The total surface area of the wing."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_wing_area_metadata, newVal)

    _get_flaps_area_metadata = { "name" : "flaps_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def flaps_area(self) -> float:
        """The total surface area of the flaps."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_flaps_area_metadata)

    _set_flaps_area_metadata = { "name" : "flaps_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @flaps_area.setter
    def flaps_area(self, newVal:float) -> None:
        """The total surface area of the flaps."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_flaps_area_metadata, newVal)

    _get_speedbrakes_area_metadata = { "name" : "speedbrakes_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def speedbrakes_area(self) -> float:
        """The total surface area of the speedbrakes."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_speedbrakes_area_metadata)

    _set_speedbrakes_area_metadata = { "name" : "speedbrakes_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @speedbrakes_area.setter
    def speedbrakes_area(self, newVal:float) -> None:
        """The total surface area of the speedbrakes."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_speedbrakes_area_metadata, newVal)

    _get_max_altitude_metadata = { "name" : "max_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_altitude(self) -> float:
        """The maximum altitude of the aircraft."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_max_altitude_metadata)

    _set_max_altitude_metadata = { "name" : "max_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_altitude.setter
    def max_altitude(self, newVal:float) -> None:
        """The maximum altitude of the aircraft."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_max_altitude_metadata, newVal)

    _get_max_mach_metadata = { "name" : "max_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_mach(self) -> float:
        """The maximum mach number of the aircraft."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_max_mach_metadata)

    _set_max_mach_metadata = { "name" : "max_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_mach.setter
    def max_mach(self, newVal:float) -> None:
        """The maximum mach number of the aircraft."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_max_mach_metadata, newVal)

    _get_max_eas_metadata = { "name" : "max_eas",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_eas(self) -> float:
        """The maximum equivalent airspeed of the aircraft."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_max_eas_metadata)

    _set_max_eas_metadata = { "name" : "max_eas",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_eas.setter
    def max_eas(self, newVal:float) -> None:
        """The maximum equivalent airspeed of the aircraft."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_max_eas_metadata, newVal)

    _get_min_load_factor_metadata = { "name" : "min_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_load_factor(self) -> float:
        """The minimum load factor the aircraft can bear."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_min_load_factor_metadata)

    _set_min_load_factor_metadata = { "name" : "min_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_load_factor.setter
    def min_load_factor(self, newVal:float) -> None:
        """The minimum load factor the aircraft can bear."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_min_load_factor_metadata, newVal)

    _get_max_load_factor_metadata = { "name" : "max_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_load_factor(self) -> float:
        """The maximum load factor the aircraft can bear."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_max_load_factor_metadata)

    _set_max_load_factor_metadata = { "name" : "max_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_load_factor.setter
    def max_load_factor(self, newVal:float) -> None:
        """The maximum load factor the aircraft can bear."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_max_load_factor_metadata, newVal)

    _get_use_max_temperature_limit_metadata = { "name" : "use_max_temperature_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_temperature_limit(self) -> bool:
        """The option to limit the maximum speed of the aircraft so the specified temperature is not exceeded."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_use_max_temperature_limit_metadata)

    _set_use_max_temperature_limit_metadata = { "name" : "use_max_temperature_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_max_temperature_limit.setter
    def use_max_temperature_limit(self, newVal:bool) -> None:
        """The option to limit the maximum speed of the aircraft so the specified temperature is not exceeded."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_use_max_temperature_limit_metadata, newVal)

    _get_max_temperature_metadata = { "name" : "max_temperature",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_temperature(self) -> float:
        """The maximum total temperature limit of the aircraft."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_max_temperature_metadata)

    _set_max_temperature_metadata = { "name" : "max_temperature",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_temperature.setter
    def max_temperature(self, newVal:float) -> None:
        """The maximum total temperature limit of the aircraft."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_max_temperature_metadata, newVal)

    _get_cache_aero_data_metadata = { "name" : "cache_aero_data",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def cache_aero_data(self) -> bool:
        """The option to store intermediate results for aerodynamics calculations."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_cache_aero_data_metadata)

    _set_cache_aero_data_metadata = { "name" : "cache_aero_data",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @cache_aero_data.setter
    def cache_aero_data(self, newVal:bool) -> None:
        """The option to store intermediate results for aerodynamics calculations."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_cache_aero_data_metadata, newVal)

    _get_cache_fuel_flow_metadata = { "name" : "cache_fuel_flow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def cache_fuel_flow(self) -> bool:
        """The option to store intermediate results for fuel flow calculations."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_cache_fuel_flow_metadata)

    _set_cache_fuel_flow_metadata = { "name" : "cache_fuel_flow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @cache_fuel_flow.setter
    def cache_fuel_flow(self, newVal:bool) -> None:
        """The option to store intermediate results for fuel flow calculations."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_cache_fuel_flow_metadata, newVal)

    _get_aero_strategy_metadata = { "name" : "aero_strategy",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_AERO_STRATEGY),) }
    @property
    def aero_strategy(self) -> "ADV_FIXED_WING_AERO_STRATEGY":
        """The aerodynamic strategy type."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_aero_strategy_metadata)

    _set_aero_strategy_metadata = { "name" : "aero_strategy",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_AERO_STRATEGY),) }
    @aero_strategy.setter
    def aero_strategy(self, newVal:"ADV_FIXED_WING_AERO_STRATEGY") -> None:
        """The aerodynamic strategy type."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_aero_strategy_metadata, newVal)

    _get_aero_mode_as_external_metadata = { "name" : "aero_mode_as_external",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aero_mode_as_external(self) -> "AdvFixedWingExternalAero":
        """Get the interface for an Extern File Aerodynamics strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_aero_mode_as_external_metadata)

    _get_aero_mode_as_subsonic_metadata = { "name" : "aero_mode_as_subsonic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aero_mode_as_subsonic(self) -> "AdvFixedWingSubsonicAero":
        """Get the interface for a Subsonic Aerodynamics strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_aero_mode_as_subsonic_metadata)

    _get_aero_mode_as_sub_super_hypersonic_metadata = { "name" : "aero_mode_as_sub_super_hypersonic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aero_mode_as_sub_super_hypersonic(self) -> "AdvFixedWingSubSuperHypersonicAero":
        """Get the interface for a Sub/Super/Hypersonic Aerodynamics strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_aero_mode_as_sub_super_hypersonic_metadata)

    _get_aero_mode_as_supersonic_metadata = { "name" : "aero_mode_as_supersonic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aero_mode_as_supersonic(self) -> "AdvFixedWingSupersonicAero":
        """Get the interface for a Supersonic Aerodynamics strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_aero_mode_as_supersonic_metadata)

    _get_powerplant_strategy_metadata = { "name" : "powerplant_strategy",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_POWERPLANT_STRATEGY),) }
    @property
    def powerplant_strategy(self) -> "ADV_FIXED_WING_POWERPLANT_STRATEGY":
        """The powerplant strategy type."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_strategy_metadata)

    _set_powerplant_strategy_metadata = { "name" : "powerplant_strategy",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_POWERPLANT_STRATEGY),) }
    @powerplant_strategy.setter
    def powerplant_strategy(self, newVal:"ADV_FIXED_WING_POWERPLANT_STRATEGY") -> None:
        """The powerplant  strategy type."""
        return self._intf.set_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._set_powerplant_strategy_metadata, newVal)

    _get_powerplant_mode_as_electric_metadata = { "name" : "powerplant_mode_as_electric",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_electric(self) -> "AdvFixedWingElectricPowerplant":
        """Get the interface for an Electric Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_electric_metadata)

    _get_powerplant_mode_as_external_metadata = { "name" : "powerplant_mode_as_external",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_external(self) -> "AdvFixedWingExternalProp":
        """Get the interface for an External Prop File Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_external_metadata)

    _get_powerplant_mode_as_piston_metadata = { "name" : "powerplant_mode_as_piston",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_piston(self) -> "AdvFixedWingPistonPowerplant":
        """Get the interface for a Piston Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_piston_metadata)

    _get_powerplant_mode_as_turboprop_metadata = { "name" : "powerplant_mode_as_turboprop",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_turboprop(self) -> "AdvFixedWingTurbopropPowerplant":
        """Get the interface for a Turboprop Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_turboprop_metadata)

    _get_powerplant_mode_as_empirical_jet_engine_metadata = { "name" : "powerplant_mode_as_empirical_jet_engine",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_empirical_jet_engine(self) -> "AdvFixedWingEmpiricalJetEngine":
        """Get the interface for an Empirical Jet Engine Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_empirical_jet_engine_metadata)

    _create_all_perf_models_metadata = { "name" : "create_all_perf_models",
            "arg_types" : (agcom.BSTR, agcom.VARIANT_BOOL, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg, agmarshall.VARIANT_BOOL_arg,) }
    def create_all_perf_models(self, name:str, overwrite:bool, makeDefault:bool) -> None:
        """Create a set of advanced performance models for the aircraft with the given name."""
        return self._intf.invoke(IAdvFixedWingTool._metadata, IAdvFixedWingTool._create_all_perf_models_metadata, name, overwrite, makeDefault)

    _get_powerplant_mode_as_basic_turbofan_metadata = { "name" : "powerplant_mode_as_basic_turbofan",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_basic_turbofan(self) -> "AdvFixedWingTurbofanBasicABProp":
        """Get the interface for a Turbofan - Basic w/ AB Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_basic_turbofan_metadata)

    _get_powerplant_mode_as_basic_turbojet_metadata = { "name" : "powerplant_mode_as_basic_turbojet",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_basic_turbojet(self) -> "AdvFixedWingTurbojetBasicABProp":
        """Get the interface for a Turbojet - Basic w/ AB Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_basic_turbojet_metadata)

    _get_powerplant_mode_as_sub_super_hypersonic_metadata = { "name" : "powerplant_mode_as_sub_super_hypersonic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powerplant_mode_as_sub_super_hypersonic(self) -> "AdvFixedWingSubSuperHypersonicProp":
        """Get the interface for a Sub/Super/Hypersoinc Powerplant strategy."""
        return self._intf.get_property(IAdvFixedWingTool._metadata, IAdvFixedWingTool._get_powerplant_mode_as_sub_super_hypersonic_metadata)


agcls.AgClassCatalog.add_catalog_entry("{3722BD33-A1BE-48AD-AF6F-4AC40B19FBBA}", IAdvFixedWingTool)
agcls.AgTypeNameMap["IAdvFixedWingTool"] = IAdvFixedWingTool

class IAdvFixedWingExternalAero(object):
    """Interface used to access the options for an external file aerodynamic strategy in the advanced fixed wing tool."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7A440104-B346-417B-98CB-7718A5A95848}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filepath" : 1,
                             "set_filepath" : 2,
                             "get_is_valid" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingExternalAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingExternalAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingExternalAero.__dict__ and type(IAdvFixedWingExternalAero.__dict__[attrname]) == property:
            return IAdvFixedWingExternalAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingExternalAero.")
    
    _get_filepath_metadata = { "name" : "filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filepath(self) -> str:
        """The filepath for the external aero file."""
        return self._intf.get_property(IAdvFixedWingExternalAero._metadata, IAdvFixedWingExternalAero._get_filepath_metadata)

    _set_filepath_metadata = { "name" : "set_filepath",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external aero file."""
        return self._intf.invoke(IAdvFixedWingExternalAero._metadata, IAdvFixedWingExternalAero._set_filepath_metadata, filepath, out_arg())

    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        return self._intf.get_property(IAdvFixedWingExternalAero._metadata, IAdvFixedWingExternalAero._get_is_valid_metadata)


agcls.AgClassCatalog.add_catalog_entry("{7A440104-B346-417B-98CB-7718A5A95848}", IAdvFixedWingExternalAero)
agcls.AgTypeNameMap["IAdvFixedWingExternalAero"] = IAdvFixedWingExternalAero

class IAdvFixedWingSubsonicAero(object):
    """Interface used to access the options for the subsonic aerodynamic strategy in the advanced fixed wing tool."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9e4abf77-2ca1-4130-8ff8-e13d216d722b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_geometry_type" : 1,
                             "set_geometry_type" : 2,
                             "get_geometry_mode_as_basic" : 3,
                             "get_geometry_mode_as_variable" : 4,
                             "get_max_aoa" : 5,
                             "set_max_aoa" : 6,
                             "get_cd0" : 7,
                             "set_cd0" : 8,
                             "get_mach_divergence" : 9,
                             "set_mach_divergence" : 10,
                             "get_transonic_mach_drag_factor" : 11,
                             "set_transonic_mach_drag_factor" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingSubsonicAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSubsonicAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSubsonicAero.__dict__ and type(IAdvFixedWingSubsonicAero.__dict__[attrname]) == property:
            return IAdvFixedWingSubsonicAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSubsonicAero.")
    
    _get_geometry_type_metadata = { "name" : "geometry_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_GEOMETRY),) }
    @property
    def geometry_type(self) -> "ADV_FIXED_WING_GEOMETRY":
        """The type of wing geometry for the aircraft."""
        return self._intf.get_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._get_geometry_type_metadata)

    _set_geometry_type_metadata = { "name" : "geometry_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_GEOMETRY),) }
    @geometry_type.setter
    def geometry_type(self, newVal:"ADV_FIXED_WING_GEOMETRY") -> None:
        """The type of wing geometry for the aircraft."""
        return self._intf.set_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._set_geometry_type_metadata, newVal)

    _get_geometry_mode_as_basic_metadata = { "name" : "geometry_mode_as_basic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def geometry_mode_as_basic(self) -> "AdvFixedWingGeometryBasic":
        """The options for a basic geometry wing."""
        return self._intf.get_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._get_geometry_mode_as_basic_metadata)

    _get_geometry_mode_as_variable_metadata = { "name" : "geometry_mode_as_variable",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def geometry_mode_as_variable(self) -> "AdvFixedWingGeometryVariable":
        """The options for a variable geometry wing."""
        return self._intf.get_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._get_geometry_mode_as_variable_metadata)

    _get_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        return self._intf.get_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._get_max_aoa_metadata)

    _set_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        return self._intf.set_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._set_max_aoa_metadata, newVal)

    _get_cd0_metadata = { "name" : "cd0",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cd0(self) -> float:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        return self._intf.get_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._get_cd0_metadata)

    _set_cd0_metadata = { "name" : "cd0",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cd0.setter
    def cd0(self, newVal:float) -> None:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        return self._intf.set_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._set_cd0_metadata, newVal)

    _get_mach_divergence_metadata = { "name" : "mach_divergence",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def mach_divergence(self) -> float:
        """The speed at which the aircraft begins to experience air compression."""
        return self._intf.get_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._get_mach_divergence_metadata)

    _set_mach_divergence_metadata = { "name" : "mach_divergence",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @mach_divergence.setter
    def mach_divergence(self, newVal:float) -> None:
        """The speed at which the aircraft begins to experience air compression."""
        return self._intf.set_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._set_mach_divergence_metadata, newVal)

    _get_transonic_mach_drag_factor_metadata = { "name" : "transonic_mach_drag_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transonic_mach_drag_factor(self) -> float:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying faster than the Mach Divergence."""
        return self._intf.get_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._get_transonic_mach_drag_factor_metadata)

    _set_transonic_mach_drag_factor_metadata = { "name" : "transonic_mach_drag_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transonic_mach_drag_factor.setter
    def transonic_mach_drag_factor(self, newVal:float) -> None:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying faster than the Mach Divergence."""
        return self._intf.set_property(IAdvFixedWingSubsonicAero._metadata, IAdvFixedWingSubsonicAero._set_transonic_mach_drag_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{9e4abf77-2ca1-4130-8ff8-e13d216d722b}", IAdvFixedWingSubsonicAero)
agcls.AgTypeNameMap["IAdvFixedWingSubsonicAero"] = IAdvFixedWingSubsonicAero

class IAdvFixedWingSubSuperHypersonicAero(object):
    """Interface used to access the options for the Sub/Super/Hypersonic aerodynamic strategy in the advanced fixed wing tool."""
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{c229225f-d608-457a-a100-7ef7a8618825}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_aoa" : 1,
                             "set_max_aoa" : 2,
                             "get_transonic_min_mach" : 3,
                             "set_transonic_min_mach" : 4,
                             "get_transonic_max_mach" : 5,
                             "set_transonic_max_mach" : 6,
                             "get_super_hyper_mach_transition" : 7,
                             "set_super_hyper_mach_transition" : 8,
                             "get_leading_edge_frontal_area_ratio" : 9,
                             "set_leading_edge_frontal_area_ratio" : 10,
                             "get_subsonic_aspect_ratio" : 11,
                             "set_subsonic_aspect_ratio" : 12,
                             "get_transonic_mach_drag_factor" : 13,
                             "set_transonic_mach_drag_factor" : 14,
                             "get_wave_drag_factor" : 15,
                             "set_wave_drag_factor" : 16, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingSubSuperHypersonicAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSubSuperHypersonicAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSubSuperHypersonicAero.__dict__ and type(IAdvFixedWingSubSuperHypersonicAero.__dict__[attrname]) == property:
            return IAdvFixedWingSubSuperHypersonicAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSubSuperHypersonicAero.")
    
    _get_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_max_aoa_metadata)

    _set_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_max_aoa_metadata, newVal)

    _get_transonic_min_mach_metadata = { "name" : "transonic_min_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transonic_min_mach(self) -> float:
        """The minimum speed at which the aircraft begins to experience air compression."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_transonic_min_mach_metadata)

    _set_transonic_min_mach_metadata = { "name" : "transonic_min_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transonic_min_mach.setter
    def transonic_min_mach(self, newVal:float) -> None:
        """The minimum speed at which the aircraft begins to experience air compression."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_transonic_min_mach_metadata, newVal)

    _get_transonic_max_mach_metadata = { "name" : "transonic_max_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transonic_max_mach(self) -> float:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_transonic_max_mach_metadata)

    _set_transonic_max_mach_metadata = { "name" : "transonic_max_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transonic_max_mach.setter
    def transonic_max_mach(self, newVal:float) -> None:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_transonic_max_mach_metadata, newVal)

    _get_super_hyper_mach_transition_metadata = { "name" : "super_hyper_mach_transition",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def super_hyper_mach_transition(self) -> float:
        """The minimum speed at which the air flow will be treated as hypersonic."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_super_hyper_mach_transition_metadata)

    _set_super_hyper_mach_transition_metadata = { "name" : "super_hyper_mach_transition",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @super_hyper_mach_transition.setter
    def super_hyper_mach_transition(self, newVal:float) -> None:
        """The minimum speed at which the air flow will be treated as hypersonic."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_super_hyper_mach_transition_metadata, newVal)

    _get_leading_edge_frontal_area_ratio_metadata = { "name" : "leading_edge_frontal_area_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def leading_edge_frontal_area_ratio(self) -> float:
        """The frontal face thickness of the aircraft's wings at their leading edge."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_leading_edge_frontal_area_ratio_metadata)

    _set_leading_edge_frontal_area_ratio_metadata = { "name" : "leading_edge_frontal_area_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @leading_edge_frontal_area_ratio.setter
    def leading_edge_frontal_area_ratio(self, newVal:float) -> None:
        """The frontal face thickness of the aircraft's wings at their leading edge."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_leading_edge_frontal_area_ratio_metadata, newVal)

    _get_subsonic_aspect_ratio_metadata = { "name" : "subsonic_aspect_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def subsonic_aspect_ratio(self) -> float:
        """The aircraft's wingspan squared divided by the wing area."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_subsonic_aspect_ratio_metadata)

    _set_subsonic_aspect_ratio_metadata = { "name" : "subsonic_aspect_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @subsonic_aspect_ratio.setter
    def subsonic_aspect_ratio(self, newVal:float) -> None:
        """The aircraft's wingspan squared divided by the wing area."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_subsonic_aspect_ratio_metadata, newVal)

    _get_transonic_mach_drag_factor_metadata = { "name" : "transonic_mach_drag_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transonic_mach_drag_factor(self) -> float:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_transonic_mach_drag_factor_metadata)

    _set_transonic_mach_drag_factor_metadata = { "name" : "transonic_mach_drag_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transonic_mach_drag_factor.setter
    def transonic_mach_drag_factor(self, newVal:float) -> None:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_transonic_mach_drag_factor_metadata, newVal)

    _get_wave_drag_factor_metadata = { "name" : "wave_drag_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wave_drag_factor(self) -> float:
        """A scalar value that models drag produced by shock waves at or near the aircraft's critical Mach number."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._get_wave_drag_factor_metadata)

    _set_wave_drag_factor_metadata = { "name" : "wave_drag_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wave_drag_factor.setter
    def wave_drag_factor(self, newVal:float) -> None:
        """A scalar value that models drag produced by shock waves at or near the aircraft's critical Mach number."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicAero._metadata, IAdvFixedWingSubSuperHypersonicAero._set_wave_drag_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{c229225f-d608-457a-a100-7ef7a8618825}", IAdvFixedWingSubSuperHypersonicAero)
agcls.AgTypeNameMap["IAdvFixedWingSubSuperHypersonicAero"] = IAdvFixedWingSubSuperHypersonicAero

class IAdvFixedWingSubSuperHypersonicProp(object):
    """Interface used to access the options for the Sub/Super/Hypersonic powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1a204443-6853-4897-b530-6e7231607545}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_turbine_mode" : 1,
                             "set_turbine_mode" : 2,
                             "get_turbine_mode_as_turbojet" : 3,
                             "get_turbine_mode_as_turbofan" : 4,
                             "get_ramjet_mode" : 5,
                             "set_ramjet_mode" : 6,
                             "get_ramjet_mode_as_basic" : 7,
                             "get_scramjet_mode" : 8,
                             "set_scramjet_mode" : 9,
                             "get_scramjet_mode_as_basic" : 10,
                             "get_turbine_reference_area" : 11,
                             "get_ramjet_reference_area" : 12,
                             "get_scramjet_reference_area" : 13,
                             "get_max_turbine_compression_temp" : 14,
                             "set_max_turbine_compression_temp" : 15,
                             "get_max_turbine_burner_temp" : 16,
                             "set_max_turbine_burner_temp" : 17,
                             "get_can_ram_compressor_pressure_ratio" : 18,
                             "set_can_ram_compressor_pressure_ratio" : 19,
                             "get_must_ram_compressor_pressure_ratio" : 20,
                             "set_must_ram_compressor_pressure_ratio" : 21,
                             "get_max_ram_scram_compression_temperature" : 22,
                             "set_max_ram_scram_compression_temperature" : 23,
                             "get_max_ram_scram_burner_total_temperature" : 24,
                             "set_max_ram_scram_burner_total_temperature" : 25, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingSubSuperHypersonicProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSubSuperHypersonicProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSubSuperHypersonicProp.__dict__ and type(IAdvFixedWingSubSuperHypersonicProp.__dict__[attrname]) == property:
            return IAdvFixedWingSubSuperHypersonicProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSubSuperHypersonicProp.")
    
    _get_turbine_mode_metadata = { "name" : "turbine_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TURBINE_MODE),) }
    @property
    def turbine_mode(self) -> "TURBINE_MODE":
        """The turbine operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_turbine_mode_metadata)

    _set_turbine_mode_metadata = { "name" : "turbine_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TURBINE_MODE),) }
    @turbine_mode.setter
    def turbine_mode(self, newVal:"TURBINE_MODE") -> None:
        """The turbine operating mode."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_turbine_mode_metadata, newVal)

    _get_turbine_mode_as_turbojet_metadata = { "name" : "turbine_mode_as_turbojet",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def turbine_mode_as_turbojet(self) -> "AdvFixedWingTurbojetBasicABProp":
        """Get the interface for a Turbojet Basic w/ AB tubrine mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_turbine_mode_as_turbojet_metadata)

    _get_turbine_mode_as_turbofan_metadata = { "name" : "turbine_mode_as_turbofan",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def turbine_mode_as_turbofan(self) -> "AdvFixedWingTurbofanBasicABProp":
        """Get the interface for a Turbojet Basic w/ AB tubrine mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_turbine_mode_as_turbofan_metadata)

    _get_ramjet_mode_metadata = { "name" : "ramjet_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(RAMJET_MODE),) }
    @property
    def ramjet_mode(self) -> "RAMJET_MODE":
        """The ramjet operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_ramjet_mode_metadata)

    _set_ramjet_mode_metadata = { "name" : "ramjet_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(RAMJET_MODE),) }
    @ramjet_mode.setter
    def ramjet_mode(self, newVal:"RAMJET_MODE") -> None:
        """The ramjet operating mode."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_ramjet_mode_metadata, newVal)

    _get_ramjet_mode_as_basic_metadata = { "name" : "ramjet_mode_as_basic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ramjet_mode_as_basic(self) -> "AdvFixedWingRamjetBasic":
        """Get the interface for a Ramjet - Basic."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_ramjet_mode_as_basic_metadata)

    _get_scramjet_mode_metadata = { "name" : "scramjet_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(SCRAMJET_MODE),) }
    @property
    def scramjet_mode(self) -> "SCRAMJET_MODE":
        """The scramjet operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_scramjet_mode_metadata)

    _set_scramjet_mode_metadata = { "name" : "scramjet_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(SCRAMJET_MODE),) }
    @scramjet_mode.setter
    def scramjet_mode(self, newVal:"SCRAMJET_MODE") -> None:
        """The scramjet operating mode."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_scramjet_mode_metadata, newVal)

    _get_scramjet_mode_as_basic_metadata = { "name" : "scramjet_mode_as_basic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def scramjet_mode_as_basic(self) -> "AdvFixedWingScramjetBasic":
        """Get the interface for a Scramjet - Basic."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_scramjet_mode_as_basic_metadata)

    _get_turbine_reference_area_metadata = { "name" : "turbine_reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turbine_reference_area(self) -> float:
        """The reference area used for the turbine operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_turbine_reference_area_metadata)

    _get_ramjet_reference_area_metadata = { "name" : "ramjet_reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ramjet_reference_area(self) -> float:
        """The reference area used for the ramjet operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_ramjet_reference_area_metadata)

    _get_scramjet_reference_area_metadata = { "name" : "scramjet_reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scramjet_reference_area(self) -> float:
        """The reference area used for the scramjet operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_scramjet_reference_area_metadata)

    _get_max_turbine_compression_temp_metadata = { "name" : "max_turbine_compression_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_turbine_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage in the turbine operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_max_turbine_compression_temp_metadata)

    _set_max_turbine_compression_temp_metadata = { "name" : "max_turbine_compression_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_turbine_compression_temp.setter
    def max_turbine_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage in the turbine operating mode."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_max_turbine_compression_temp_metadata, newVal)

    _get_max_turbine_burner_temp_metadata = { "name" : "max_turbine_burner_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_turbine_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage in the turbine operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_max_turbine_burner_temp_metadata)

    _set_max_turbine_burner_temp_metadata = { "name" : "max_turbine_burner_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_turbine_burner_temp.setter
    def max_turbine_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage in the turbine operating mode."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_max_turbine_burner_temp_metadata, newVal)

    _get_can_ram_compressor_pressure_ratio_metadata = { "name" : "can_ram_compressor_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def can_ram_compressor_pressure_ratio(self) -> float:
        """Can Ram compressor pressure ratio."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_can_ram_compressor_pressure_ratio_metadata)

    _set_can_ram_compressor_pressure_ratio_metadata = { "name" : "can_ram_compressor_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @can_ram_compressor_pressure_ratio.setter
    def can_ram_compressor_pressure_ratio(self, newVal:float) -> None:
        """Can Ram compressor pressure ratio."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_can_ram_compressor_pressure_ratio_metadata, newVal)

    _get_must_ram_compressor_pressure_ratio_metadata = { "name" : "must_ram_compressor_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def must_ram_compressor_pressure_ratio(self) -> float:
        """Must Ram compressor pressure ratio."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_must_ram_compressor_pressure_ratio_metadata)

    _set_must_ram_compressor_pressure_ratio_metadata = { "name" : "must_ram_compressor_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @must_ram_compressor_pressure_ratio.setter
    def must_ram_compressor_pressure_ratio(self, newVal:float) -> None:
        """Must Ram compressor pressure ratio."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_must_ram_compressor_pressure_ratio_metadata, newVal)

    _get_max_ram_scram_compression_temperature_metadata = { "name" : "max_ram_scram_compression_temperature",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_ram_scram_compression_temperature(self) -> float:
        """The maximum temperature at the compressor stage in the Ramjet or Scramjet operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_max_ram_scram_compression_temperature_metadata)

    _set_max_ram_scram_compression_temperature_metadata = { "name" : "max_ram_scram_compression_temperature",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_ram_scram_compression_temperature.setter
    def max_ram_scram_compression_temperature(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage in the Ramjet or Scramjet operating mode."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_max_ram_scram_compression_temperature_metadata, newVal)

    _get_max_ram_scram_burner_total_temperature_metadata = { "name" : "max_ram_scram_burner_total_temperature",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_ram_scram_burner_total_temperature(self) -> float:
        """The maximum temperature at the combustion stage in the Ramjet or Scramjet operating mode."""
        return self._intf.get_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._get_max_ram_scram_burner_total_temperature_metadata)

    _set_max_ram_scram_burner_total_temperature_metadata = { "name" : "max_ram_scram_burner_total_temperature",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_ram_scram_burner_total_temperature.setter
    def max_ram_scram_burner_total_temperature(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage in the Ramjet or Scramjet operating mode."""
        return self._intf.set_property(IAdvFixedWingSubSuperHypersonicProp._metadata, IAdvFixedWingSubSuperHypersonicProp._set_max_ram_scram_burner_total_temperature_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{1a204443-6853-4897-b530-6e7231607545}", IAdvFixedWingSubSuperHypersonicProp)
agcls.AgTypeNameMap["IAdvFixedWingSubSuperHypersonicProp"] = IAdvFixedWingSubSuperHypersonicProp

class IAdvFixedWingSupersonicAero(object):
    """Interface used to access the options for the supersonic aerodynamic strategy in the advanced fixed wing tool."""
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8864671c-5df8-40d1-95db-a2f92c6016ea}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_geometry_type" : 1,
                             "set_geometry_type" : 2,
                             "get_geometry_mode_as_basic" : 3,
                             "get_geometry_mode_as_variable" : 4,
                             "get_max_aoa" : 5,
                             "set_max_aoa" : 6,
                             "get_subsonic_cd0" : 7,
                             "set_subsonic_cd0" : 8,
                             "get_transonic_min_mach" : 9,
                             "set_transonic_min_mach" : 10,
                             "get_transonic_max_mach" : 11,
                             "set_transonic_max_mach" : 12,
                             "get_supersonic_max_mach" : 13,
                             "set_supersonic_max_mach" : 14,
                             "get_transonic_mach_drag_factor" : 15,
                             "set_transonic_mach_drag_factor" : 16,
                             "get_supersonic_mach_drag_factor" : 17,
                             "set_supersonic_mach_drag_factor" : 18,
                             "get_leading_edge_suction_efficiency" : 19,
                             "set_leading_edge_suction_efficiency" : 20, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingSupersonicAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingSupersonicAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingSupersonicAero.__dict__ and type(IAdvFixedWingSupersonicAero.__dict__[attrname]) == property:
            return IAdvFixedWingSupersonicAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingSupersonicAero.")
    
    _get_geometry_type_metadata = { "name" : "geometry_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_GEOMETRY),) }
    @property
    def geometry_type(self) -> "ADV_FIXED_WING_GEOMETRY":
        """The type of wing geometry for the aircraft."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_geometry_type_metadata)

    _set_geometry_type_metadata = { "name" : "geometry_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ADV_FIXED_WING_GEOMETRY),) }
    @geometry_type.setter
    def geometry_type(self, newVal:"ADV_FIXED_WING_GEOMETRY") -> None:
        """The type of wing geometry for the aircraft."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_geometry_type_metadata, newVal)

    _get_geometry_mode_as_basic_metadata = { "name" : "geometry_mode_as_basic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def geometry_mode_as_basic(self) -> "AdvFixedWingGeometryBasic":
        """The options for a basic geometry wing."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_geometry_mode_as_basic_metadata)

    _get_geometry_mode_as_variable_metadata = { "name" : "geometry_mode_as_variable",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def geometry_mode_as_variable(self) -> "AdvFixedWingGeometryVariable":
        """The options for a variable geometry wing."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_geometry_mode_as_variable_metadata)

    _get_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_max_aoa_metadata)

    _set_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_max_aoa_metadata, newVal)

    _get_subsonic_cd0_metadata = { "name" : "subsonic_cd0",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def subsonic_cd0(self) -> float:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_subsonic_cd0_metadata)

    _set_subsonic_cd0_metadata = { "name" : "subsonic_cd0",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @subsonic_cd0.setter
    def subsonic_cd0(self, newVal:float) -> None:
        """The parasitic drag coefficient of the aircraft when flying at a speed less than the Mach Divergence."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_subsonic_cd0_metadata, newVal)

    _get_transonic_min_mach_metadata = { "name" : "transonic_min_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transonic_min_mach(self) -> float:
        """The minimum speed at which the aircraft begins to experience air compression."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_transonic_min_mach_metadata)

    _set_transonic_min_mach_metadata = { "name" : "transonic_min_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transonic_min_mach.setter
    def transonic_min_mach(self, newVal:float) -> None:
        """The minimum speed at which the aircraft begins to experience air compression."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_transonic_min_mach_metadata, newVal)

    _get_transonic_max_mach_metadata = { "name" : "transonic_max_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transonic_max_mach(self) -> float:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_transonic_max_mach_metadata)

    _set_transonic_max_mach_metadata = { "name" : "transonic_max_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transonic_max_mach.setter
    def transonic_max_mach(self, newVal:float) -> None:
        """The maximum speed, below supersonic, at which the aircraft begins to experience air compression."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_transonic_max_mach_metadata, newVal)

    _get_supersonic_max_mach_metadata = { "name" : "supersonic_max_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def supersonic_max_mach(self) -> float:
        """The speed at which the Supersonic Mach Drag Factor is applied."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_supersonic_max_mach_metadata)

    _set_supersonic_max_mach_metadata = { "name" : "supersonic_max_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @supersonic_max_mach.setter
    def supersonic_max_mach(self, newVal:float) -> None:
        """The speed at which the Supersonic Mach Drag Factor is applied."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_supersonic_max_mach_metadata, newVal)

    _get_transonic_mach_drag_factor_metadata = { "name" : "transonic_mach_drag_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transonic_mach_drag_factor(self) -> float:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_transonic_mach_drag_factor_metadata)

    _set_transonic_mach_drag_factor_metadata = { "name" : "transonic_mach_drag_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transonic_mach_drag_factor.setter
    def transonic_mach_drag_factor(self, newVal:float) -> None:
        """A factor applied to the aircraft's parasitic drag coefficient when it is flying between the Transonic Min Mach and Transonic Mach Drag Factor speeds."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_transonic_mach_drag_factor_metadata, newVal)

    _get_supersonic_mach_drag_factor_metadata = { "name" : "supersonic_mach_drag_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def supersonic_mach_drag_factor(self) -> float:
        """A scalar value applied to the aircraft's parasitic drag coefficient when it is flying faster than the Supersonic Max Mach."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_supersonic_mach_drag_factor_metadata)

    _set_supersonic_mach_drag_factor_metadata = { "name" : "supersonic_mach_drag_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @supersonic_mach_drag_factor.setter
    def supersonic_mach_drag_factor(self, newVal:float) -> None:
        """A scalar value applied to the aircraft's parasitic drag coefficient when it is flying faster than the Supersonic Max Mach."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_supersonic_mach_drag_factor_metadata, newVal)

    _get_leading_edge_suction_efficiency_metadata = { "name" : "leading_edge_suction_efficiency",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def leading_edge_suction_efficiency(self) -> float:
        """The ability of the wing's leading edge to ingest turbulent airflow and thereby reduce induced drag."""
        return self._intf.get_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._get_leading_edge_suction_efficiency_metadata)

    _set_leading_edge_suction_efficiency_metadata = { "name" : "leading_edge_suction_efficiency",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @leading_edge_suction_efficiency.setter
    def leading_edge_suction_efficiency(self, newVal:float) -> None:
        """The ability of the wing's leading edge to ingest turbulent airflow and thereby reduce induced drag."""
        return self._intf.set_property(IAdvFixedWingSupersonicAero._metadata, IAdvFixedWingSupersonicAero._set_leading_edge_suction_efficiency_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{8864671c-5df8-40d1-95db-a2f92c6016ea}", IAdvFixedWingSupersonicAero)
agcls.AgTypeNameMap["IAdvFixedWingSupersonicAero"] = IAdvFixedWingSupersonicAero

class IAdvFixedWingGeometryBasic(object):
    """Interface used to access the options for a basic geometry wing in the advanced fixed wing tool."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{56a5685f-3271-4635-9989-24663bd35e0d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_aspect_ratio" : 1,
                             "set_aspect_ratio" : 2,
                             "get_wing_sweep" : 3,
                             "set_wing_sweep" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingGeometryBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingGeometryBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingGeometryBasic.__dict__ and type(IAdvFixedWingGeometryBasic.__dict__[attrname]) == property:
            return IAdvFixedWingGeometryBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingGeometryBasic.")
    
    _get_aspect_ratio_metadata = { "name" : "aspect_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def aspect_ratio(self) -> float:
        """The wing sweep of the aircraft."""
        return self._intf.get_property(IAdvFixedWingGeometryBasic._metadata, IAdvFixedWingGeometryBasic._get_aspect_ratio_metadata)

    _set_aspect_ratio_metadata = { "name" : "set_aspect_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def set_aspect_ratio(self, aspectRatio:float) -> None:
        """The wing sweep of the aircraft."""
        return self._intf.invoke(IAdvFixedWingGeometryBasic._metadata, IAdvFixedWingGeometryBasic._set_aspect_ratio_metadata, aspectRatio)

    _get_wing_sweep_metadata = { "name" : "wing_sweep",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def wing_sweep(self) -> typing.Any:
        """The wing sweep of the aircraft."""
        return self._intf.get_property(IAdvFixedWingGeometryBasic._metadata, IAdvFixedWingGeometryBasic._get_wing_sweep_metadata)

    _set_wing_sweep_metadata = { "name" : "wing_sweep",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @wing_sweep.setter
    def wing_sweep(self, newVal:typing.Any) -> None:
        """The wing sweep of the aircraft."""
        return self._intf.set_property(IAdvFixedWingGeometryBasic._metadata, IAdvFixedWingGeometryBasic._set_wing_sweep_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{56a5685f-3271-4635-9989-24663bd35e0d}", IAdvFixedWingGeometryBasic)
agcls.AgTypeNameMap["IAdvFixedWingGeometryBasic"] = IAdvFixedWingGeometryBasic

class IAdvFixedWingGeometryVariable(object):
    """Interface used to access the options for a variable geometry wing in the advanced fixed wing tool."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e6f7e882-f360-4744-858a-7ea1eb2104c6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_aspect_ratio" : 1,
                             "set_aspect_ratio" : 2,
                             "get_start_sweep_mach" : 3,
                             "set_start_sweep_mach" : 4,
                             "get_stop_sweep_mach" : 5,
                             "set_stop_sweep_mach" : 6,
                             "get_min_sweep_angle" : 7,
                             "set_min_sweep_angle" : 8,
                             "get_max_sweep_angle" : 9,
                             "set_max_sweep_angle" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingGeometryVariable._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingGeometryVariable from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingGeometryVariable.__dict__ and type(IAdvFixedWingGeometryVariable.__dict__[attrname]) == property:
            return IAdvFixedWingGeometryVariable.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingGeometryVariable.")
    
    _get_aspect_ratio_metadata = { "name" : "aspect_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def aspect_ratio(self) -> float:
        """The wing sweep of the aircraft."""
        return self._intf.get_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._get_aspect_ratio_metadata)

    _set_aspect_ratio_metadata = { "name" : "set_aspect_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def set_aspect_ratio(self, aspectRatio:float) -> None:
        """The wing sweep of the aircraft."""
        return self._intf.invoke(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._set_aspect_ratio_metadata, aspectRatio)

    _get_start_sweep_mach_metadata = { "name" : "start_sweep_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_sweep_mach(self) -> float:
        """The mach number at which the wings start to sweep from the min sweep angle."""
        return self._intf.get_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._get_start_sweep_mach_metadata)

    _set_start_sweep_mach_metadata = { "name" : "start_sweep_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_sweep_mach.setter
    def start_sweep_mach(self, newVal:float) -> None:
        """The mach number at which the wings start to sweep from the min sweep angle."""
        return self._intf.set_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._set_start_sweep_mach_metadata, newVal)

    _get_stop_sweep_mach_metadata = { "name" : "stop_sweep_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_sweep_mach(self) -> float:
        """The mach number at which the wings are swept to the max sweep angle."""
        return self._intf.get_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._get_stop_sweep_mach_metadata)

    _set_stop_sweep_mach_metadata = { "name" : "stop_sweep_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_sweep_mach.setter
    def stop_sweep_mach(self, newVal:float) -> None:
        """The mach number at which the wings are swept to the max sweep angle."""
        return self._intf.set_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._set_stop_sweep_mach_metadata, newVal)

    _get_min_sweep_angle_metadata = { "name" : "min_sweep_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def min_sweep_angle(self) -> typing.Any:
        """The minimum sweep angle of the wings."""
        return self._intf.get_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._get_min_sweep_angle_metadata)

    _set_min_sweep_angle_metadata = { "name" : "min_sweep_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @min_sweep_angle.setter
    def min_sweep_angle(self, newVal:typing.Any) -> None:
        """The minimum sweep angle of the wings."""
        return self._intf.set_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._set_min_sweep_angle_metadata, newVal)

    _get_max_sweep_angle_metadata = { "name" : "max_sweep_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_sweep_angle(self) -> typing.Any:
        """The maximum sweep angle of the wings."""
        return self._intf.get_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._get_max_sweep_angle_metadata)

    _set_max_sweep_angle_metadata = { "name" : "max_sweep_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_sweep_angle.setter
    def max_sweep_angle(self, newVal:typing.Any) -> None:
        """The maximum sweep angle of the wings."""
        return self._intf.set_property(IAdvFixedWingGeometryVariable._metadata, IAdvFixedWingGeometryVariable._set_max_sweep_angle_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{e6f7e882-f360-4744-858a-7ea1eb2104c6}", IAdvFixedWingGeometryVariable)
agcls.AgTypeNameMap["IAdvFixedWingGeometryVariable"] = IAdvFixedWingGeometryVariable

class IAdvFixedWingElectricPowerplant(object):
    """Interface used to access the options for the Electric powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{285ba7fc-1c89-49e1-983b-bf16ce641584}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_power" : 1,
                             "set_max_power" : 2,
                             "get_propeller_count" : 3,
                             "set_propeller_count" : 4,
                             "get_propeller_diameter" : 5,
                             "set_propeller_diameter" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingElectricPowerplant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingElectricPowerplant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingElectricPowerplant.__dict__ and type(IAdvFixedWingElectricPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingElectricPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingElectricPowerplant.")
    
    _get_max_power_metadata = { "name" : "max_power",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_power(self) -> float:
        """The maximum power of the engine."""
        return self._intf.get_property(IAdvFixedWingElectricPowerplant._metadata, IAdvFixedWingElectricPowerplant._get_max_power_metadata)

    _set_max_power_metadata = { "name" : "max_power",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_power.setter
    def max_power(self, newVal:float) -> None:
        """The maximum power of the engine."""
        return self._intf.set_property(IAdvFixedWingElectricPowerplant._metadata, IAdvFixedWingElectricPowerplant._set_max_power_metadata, newVal)

    _get_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        return self._intf.get_property(IAdvFixedWingElectricPowerplant._metadata, IAdvFixedWingElectricPowerplant._get_propeller_count_metadata)

    _set_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @propeller_count.setter
    def propeller_count(self, newVal:int) -> None:
        """The number of propellers."""
        return self._intf.set_property(IAdvFixedWingElectricPowerplant._metadata, IAdvFixedWingElectricPowerplant._set_propeller_count_metadata, newVal)

    _get_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        return self._intf.get_property(IAdvFixedWingElectricPowerplant._metadata, IAdvFixedWingElectricPowerplant._get_propeller_diameter_metadata)

    _set_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @propeller_diameter.setter
    def propeller_diameter(self, newVal:float) -> None:
        """The propeller diameter."""
        return self._intf.set_property(IAdvFixedWingElectricPowerplant._metadata, IAdvFixedWingElectricPowerplant._set_propeller_diameter_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{285ba7fc-1c89-49e1-983b-bf16ce641584}", IAdvFixedWingElectricPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingElectricPowerplant"] = IAdvFixedWingElectricPowerplant

class IAdvFixedWingExternalProp(object):
    """Interface used to access the options for the External Prop File powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a886a5d9-63f4-455c-9cda-bce9c81d941d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filepath" : 1,
                             "set_filepath" : 2,
                             "get_is_valid" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingExternalProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingExternalProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingExternalProp.__dict__ and type(IAdvFixedWingExternalProp.__dict__[attrname]) == property:
            return IAdvFixedWingExternalProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingExternalProp.")
    
    _get_filepath_metadata = { "name" : "filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filepath(self) -> str:
        """The filepath for the external aero file."""
        return self._intf.get_property(IAdvFixedWingExternalProp._metadata, IAdvFixedWingExternalProp._get_filepath_metadata)

    _set_filepath_metadata = { "name" : "set_filepath",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external aero file."""
        return self._intf.invoke(IAdvFixedWingExternalProp._metadata, IAdvFixedWingExternalProp._set_filepath_metadata, filepath, out_arg())

    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        return self._intf.get_property(IAdvFixedWingExternalProp._metadata, IAdvFixedWingExternalProp._get_is_valid_metadata)


agcls.AgClassCatalog.add_catalog_entry("{a886a5d9-63f4-455c-9cda-bce9c81d941d}", IAdvFixedWingExternalProp)
agcls.AgTypeNameMap["IAdvFixedWingExternalProp"] = IAdvFixedWingExternalProp

class IAdvFixedWingPistonPowerplant(object):
    """Interface used to access the options for the Piston powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{891f9708-b367-447d-9e25-bb8fb24d6c83}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_sea_level_static_power" : 1,
                             "set_max_sea_level_static_power" : 2,
                             "get_critical_altitude" : 3,
                             "set_critical_altitude" : 4,
                             "get_propeller_count" : 5,
                             "set_propeller_count" : 6,
                             "get_propeller_diameter" : 7,
                             "set_propeller_diameter" : 8,
                             "get_fuel_flow" : 9,
                             "set_fuel_flow" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingPistonPowerplant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingPistonPowerplant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingPistonPowerplant.__dict__ and type(IAdvFixedWingPistonPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingPistonPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingPistonPowerplant.")
    
    _get_max_sea_level_static_power_metadata = { "name" : "max_sea_level_static_power",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_sea_level_static_power(self) -> float:
        """The maximum static power of the engine at sea level."""
        return self._intf.get_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._get_max_sea_level_static_power_metadata)

    _set_max_sea_level_static_power_metadata = { "name" : "max_sea_level_static_power",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_sea_level_static_power.setter
    def max_sea_level_static_power(self, newVal:float) -> None:
        """The maximum static power of the engine at sea level."""
        return self._intf.set_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._set_max_sea_level_static_power_metadata, newVal)

    _get_critical_altitude_metadata = { "name" : "critical_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def critical_altitude(self) -> float:
        """The engine's critical altitude."""
        return self._intf.get_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._get_critical_altitude_metadata)

    _set_critical_altitude_metadata = { "name" : "critical_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @critical_altitude.setter
    def critical_altitude(self, newVal:float) -> None:
        """The engine's critical altitude."""
        return self._intf.set_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._set_critical_altitude_metadata, newVal)

    _get_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        return self._intf.get_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._get_propeller_count_metadata)

    _set_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @propeller_count.setter
    def propeller_count(self, newVal:int) -> None:
        """The number of propellers."""
        return self._intf.set_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._set_propeller_count_metadata, newVal)

    _get_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        return self._intf.get_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._get_propeller_diameter_metadata)

    _set_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @propeller_diameter.setter
    def propeller_diameter(self, newVal:float) -> None:
        """The propeller diameter."""
        return self._intf.set_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._set_propeller_diameter_metadata, newVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """The engine's fuel flow at max power."""
        return self._intf.get_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The engine's fuel flow at max power."""
        return self._intf.set_property(IAdvFixedWingPistonPowerplant._metadata, IAdvFixedWingPistonPowerplant._set_fuel_flow_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{891f9708-b367-447d-9e25-bb8fb24d6c83}", IAdvFixedWingPistonPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingPistonPowerplant"] = IAdvFixedWingPistonPowerplant

class IAdvFixedWingTurbopropPowerplant(object):
    """Interface used to access the options for the Turboprop powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{04fd63b4-761a-49b4-8a9c-c1610f676993}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_sea_level_static_power" : 1,
                             "set_max_sea_level_static_power" : 2,
                             "get_propeller_count" : 3,
                             "set_propeller_count" : 4,
                             "get_propeller_diameter" : 5,
                             "set_propeller_diameter" : 6,
                             "get_fuel_flow" : 7,
                             "set_fuel_flow" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingTurbopropPowerplant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbopropPowerplant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbopropPowerplant.__dict__ and type(IAdvFixedWingTurbopropPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingTurbopropPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbopropPowerplant.")
    
    _get_max_sea_level_static_power_metadata = { "name" : "max_sea_level_static_power",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_sea_level_static_power(self) -> float:
        """The maximum static power of the engine at sea level."""
        return self._intf.get_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._get_max_sea_level_static_power_metadata)

    _set_max_sea_level_static_power_metadata = { "name" : "max_sea_level_static_power",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_sea_level_static_power.setter
    def max_sea_level_static_power(self, newVal:float) -> None:
        """The maximum static power of the engine at sea level."""
        return self._intf.set_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._set_max_sea_level_static_power_metadata, newVal)

    _get_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def propeller_count(self) -> int:
        """The number of propellers."""
        return self._intf.get_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._get_propeller_count_metadata)

    _set_propeller_count_metadata = { "name" : "propeller_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @propeller_count.setter
    def propeller_count(self, newVal:int) -> None:
        """The number of propellers."""
        return self._intf.set_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._set_propeller_count_metadata, newVal)

    _get_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def propeller_diameter(self) -> float:
        """The propeller diameter."""
        return self._intf.get_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._get_propeller_diameter_metadata)

    _set_propeller_diameter_metadata = { "name" : "propeller_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @propeller_diameter.setter
    def propeller_diameter(self, newVal:float) -> None:
        """The propeller diameter."""
        return self._intf.set_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._set_propeller_diameter_metadata, newVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """The engine's fuel flow at max power."""
        return self._intf.get_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The engine's fuel flow at max power."""
        return self._intf.set_property(IAdvFixedWingTurbopropPowerplant._metadata, IAdvFixedWingTurbopropPowerplant._set_fuel_flow_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{04fd63b4-761a-49b4-8a9c-c1610f676993}", IAdvFixedWingTurbopropPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingTurbopropPowerplant"] = IAdvFixedWingTurbopropPowerplant

class IAdvFixedWingEmpiricalJetEngine(object):
    """Interface used to access the options for the Sub/Super/Hypersonic powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f8fa49f0-f901-4b85-ac60-0712141db32c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_sea_level_static_thrust" : 1,
                             "set_max_sea_level_static_thrust" : 2,
                             "get_design_point_altitude" : 3,
                             "set_design_point_altitude" : 4,
                             "get_design_point_mach_number" : 5,
                             "set_design_point_mach_number" : 6,
                             "get_fuel_flow" : 7,
                             "set_fuel_flow" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingEmpiricalJetEngine._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingEmpiricalJetEngine from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingEmpiricalJetEngine.__dict__ and type(IAdvFixedWingEmpiricalJetEngine.__dict__[attrname]) == property:
            return IAdvFixedWingEmpiricalJetEngine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingEmpiricalJetEngine.")
    
    _get_max_sea_level_static_thrust_metadata = { "name" : "max_sea_level_static_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_sea_level_static_thrust(self) -> float:
        """The maximum static thrust of the engine at sea level."""
        return self._intf.get_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._get_max_sea_level_static_thrust_metadata)

    _set_max_sea_level_static_thrust_metadata = { "name" : "max_sea_level_static_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_sea_level_static_thrust.setter
    def max_sea_level_static_thrust(self, newVal:float) -> None:
        """The maximum static thrust of the engine at sea level."""
        return self._intf.set_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._set_max_sea_level_static_thrust_metadata, newVal)

    _get_design_point_altitude_metadata = { "name" : "design_point_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_point_altitude(self) -> float:
        """The altitude design point of the engine."""
        return self._intf.get_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._get_design_point_altitude_metadata)

    _set_design_point_altitude_metadata = { "name" : "design_point_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_point_altitude.setter
    def design_point_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        return self._intf.set_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._set_design_point_altitude_metadata, newVal)

    _get_design_point_mach_number_metadata = { "name" : "design_point_mach_number",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_point_mach_number(self) -> float:
        """The mach number design point of the engine."""
        return self._intf.get_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._get_design_point_mach_number_metadata)

    _set_design_point_mach_number_metadata = { "name" : "design_point_mach_number",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_point_mach_number.setter
    def design_point_mach_number(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        return self._intf.set_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._set_design_point_mach_number_metadata, newVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """The engine's fuel flow at max power."""
        return self._intf.get_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The engine's fuel flow at max power."""
        return self._intf.set_property(IAdvFixedWingEmpiricalJetEngine._metadata, IAdvFixedWingEmpiricalJetEngine._set_fuel_flow_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{f8fa49f0-f901-4b85-ac60-0712141db32c}", IAdvFixedWingEmpiricalJetEngine)
agcls.AgTypeNameMap["IAdvFixedWingEmpiricalJetEngine"] = IAdvFixedWingEmpiricalJetEngine

class IAdvFixedWingTurbojetBasicABProp(object):
    """Interface used to access the options for the Turbojet - Basic w/AB (Thermodynamic) powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7ff41deb-7c10-42ac-8805-0b251e250018}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_can_use_afterburner" : 1,
                             "set_can_use_afterburner" : 2,
                             "get_design_altitude" : 3,
                             "set_design_altitude" : 4,
                             "get_design_mach" : 5,
                             "set_design_mach" : 6,
                             "get_design_thrust" : 7,
                             "set_design_thrust" : 8,
                             "get_afterburner_on" : 9,
                             "set_afterburner_on" : 10,
                             "get_max_compression_temp" : 11,
                             "set_max_compression_temp" : 12,
                             "get_max_burner_temp" : 13,
                             "set_max_burner_temp" : 14,
                             "get_max_afterburner_temp" : 15,
                             "set_max_afterburner_temp" : 16,
                             "get_hpc_pressure_ratio" : 17,
                             "set_hpc_pressure_ratio" : 18,
                             "get_lpc_pressure_ratio" : 19,
                             "set_lpc_pressure_ratio" : 20,
                             "get_efficiencies_and_losses" : 21,
                             "get_fuel_type" : 22,
                             "set_fuel_type" : 23,
                             "get_fuel_mode_as_afprop" : 24,
                             "get_fuel_mode_as_cea" : 25, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingTurbojetBasicABProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbojetBasicABProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbojetBasicABProp.__dict__ and type(IAdvFixedWingTurbojetBasicABProp.__dict__[attrname]) == property:
            return IAdvFixedWingTurbojetBasicABProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbojetBasicABProp.")
    
    _get_can_use_afterburner_metadata = { "name" : "can_use_afterburner",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def can_use_afterburner(self) -> bool:
        """Opt whether the engine has an afterburner."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_can_use_afterburner_metadata)

    _set_can_use_afterburner_metadata = { "name" : "can_use_afterburner",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @can_use_afterburner.setter
    def can_use_afterburner(self, newVal:bool) -> None:
        """Opt whether the engine has an afterburner."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_can_use_afterburner_metadata, newVal)

    _get_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_design_altitude_metadata)

    _set_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_design_altitude_metadata, newVal)

    _get_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_design_mach_metadata)

    _set_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_design_mach_metadata, newVal)

    _get_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_design_thrust_metadata)

    _set_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_design_thrust_metadata, newVal)

    _get_afterburner_on_metadata = { "name" : "afterburner_on",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def afterburner_on(self) -> bool:
        """Opt whether to specify the design point with the afterburner on. """
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_afterburner_on_metadata)

    _set_afterburner_on_metadata = { "name" : "afterburner_on",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @afterburner_on.setter
    def afterburner_on(self, newVal:bool) -> None:
        """Opt whether to specify the design point with the afterburner on."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_afterburner_on_metadata, newVal)

    _get_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_max_compression_temp_metadata)

    _set_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_max_compression_temp_metadata, newVal)

    _get_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_max_burner_temp_metadata)

    _set_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_max_burner_temp_metadata, newVal)

    _get_max_afterburner_temp_metadata = { "name" : "max_afterburner_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_afterburner_temp(self) -> float:
        """The maximum temperature at the afterburner."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_max_afterburner_temp_metadata)

    _set_max_afterburner_temp_metadata = { "name" : "max_afterburner_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_afterburner_temp.setter
    def max_afterburner_temp(self, newVal:float) -> None:
        """The maximum temperature at the afterburner."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_max_afterburner_temp_metadata, newVal)

    _get_hpc_pressure_ratio_metadata = { "name" : "hpc_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def hpc_pressure_ratio(self) -> float:
        """The pressure ratio of the high-pressure compressor."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_hpc_pressure_ratio_metadata)

    _set_hpc_pressure_ratio_metadata = { "name" : "hpc_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @hpc_pressure_ratio.setter
    def hpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the high-pressure compressor."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_hpc_pressure_ratio_metadata, newVal)

    _get_lpc_pressure_ratio_metadata = { "name" : "lpc_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def lpc_pressure_ratio(self) -> float:
        """The pressure ratio of the low-pressure compressor."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_lpc_pressure_ratio_metadata)

    _set_lpc_pressure_ratio_metadata = { "name" : "lpc_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @lpc_pressure_ratio.setter
    def lpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the low-pressure compressor."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_lpc_pressure_ratio_metadata, newVal)

    _get_efficiencies_and_losses_metadata = { "name" : "efficiencies_and_losses",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def efficiencies_and_losses(self) -> "PropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_efficiencies_and_losses_metadata)

    _get_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @property
    def fuel_type(self) -> "JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_fuel_type_metadata)

    _set_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @fuel_type.setter
    def fuel_type(self, newVal:"JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        return self._intf.set_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._set_fuel_type_metadata, newVal)

    _get_fuel_mode_as_afprop_metadata = { "name" : "fuel_mode_as_afprop",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_afprop(self) -> "FuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_fuel_mode_as_afprop_metadata)

    _get_fuel_mode_as_cea_metadata = { "name" : "fuel_mode_as_cea",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_cea(self) -> "FuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        return self._intf.get_property(IAdvFixedWingTurbojetBasicABProp._metadata, IAdvFixedWingTurbojetBasicABProp._get_fuel_mode_as_cea_metadata)


agcls.AgClassCatalog.add_catalog_entry("{7ff41deb-7c10-42ac-8805-0b251e250018}", IAdvFixedWingTurbojetBasicABProp)
agcls.AgTypeNameMap["IAdvFixedWingTurbojetBasicABProp"] = IAdvFixedWingTurbojetBasicABProp

class IAdvFixedWingTurbofanBasicABProp(object):
    """Interface used to access the options for the Turbofan - Basic w/AB (Thermodynamic) powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f26a8761-895c-47b1-9836-9278313cf45d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_can_use_afterburner" : 1,
                             "set_can_use_afterburner" : 2,
                             "get_design_altitude" : 3,
                             "set_design_altitude" : 4,
                             "get_design_mach" : 5,
                             "set_design_mach" : 6,
                             "get_design_thrust" : 7,
                             "set_design_thrust" : 8,
                             "get_afterburner_on" : 9,
                             "set_afterburner_on" : 10,
                             "get_max_compression_temp" : 11,
                             "set_max_compression_temp" : 12,
                             "get_max_burner_temp" : 13,
                             "set_max_burner_temp" : 14,
                             "get_max_afterburner_temp" : 15,
                             "set_max_afterburner_temp" : 16,
                             "get_hpc_pressure_ratio" : 17,
                             "set_hpc_pressure_ratio" : 18,
                             "get_lpc_pressure_ratio" : 19,
                             "set_lpc_pressure_ratio" : 20,
                             "get_fan_pressure_ratio" : 21,
                             "set_fan_pressure_ratio" : 22,
                             "get_efficiencies_and_losses" : 23,
                             "get_fuel_type" : 24,
                             "set_fuel_type" : 25,
                             "get_fuel_mode_as_afprop" : 26,
                             "get_fuel_mode_as_cea" : 27, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingTurbofanBasicABProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbofanBasicABProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbofanBasicABProp.__dict__ and type(IAdvFixedWingTurbofanBasicABProp.__dict__[attrname]) == property:
            return IAdvFixedWingTurbofanBasicABProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbofanBasicABProp.")
    
    _get_can_use_afterburner_metadata = { "name" : "can_use_afterburner",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def can_use_afterburner(self) -> bool:
        """Opt whether the engine has an afterburner."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_can_use_afterburner_metadata)

    _set_can_use_afterburner_metadata = { "name" : "can_use_afterburner",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @can_use_afterburner.setter
    def can_use_afterburner(self, newVal:bool) -> None:
        """Opt whether the engine has an afterburner."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_can_use_afterburner_metadata, newVal)

    _get_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_design_altitude_metadata)

    _set_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_design_altitude_metadata, newVal)

    _get_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_design_mach_metadata)

    _set_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_design_mach_metadata, newVal)

    _get_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_design_thrust_metadata)

    _set_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_design_thrust_metadata, newVal)

    _get_afterburner_on_metadata = { "name" : "afterburner_on",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def afterburner_on(self) -> bool:
        """Opt whether to specify the design point with the afterburner on. """
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_afterburner_on_metadata)

    _set_afterburner_on_metadata = { "name" : "afterburner_on",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @afterburner_on.setter
    def afterburner_on(self, newVal:bool) -> None:
        """Opt whether to specify the design point with the afterburner on."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_afterburner_on_metadata, newVal)

    _get_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_max_compression_temp_metadata)

    _set_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_max_compression_temp_metadata, newVal)

    _get_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_max_burner_temp_metadata)

    _set_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_max_burner_temp_metadata, newVal)

    _get_max_afterburner_temp_metadata = { "name" : "max_afterburner_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_afterburner_temp(self) -> float:
        """The maximum temperature at the afterburner."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_max_afterburner_temp_metadata)

    _set_max_afterburner_temp_metadata = { "name" : "max_afterburner_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_afterburner_temp.setter
    def max_afterburner_temp(self, newVal:float) -> None:
        """The maximum temperature at the afterburner."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_max_afterburner_temp_metadata, newVal)

    _get_hpc_pressure_ratio_metadata = { "name" : "hpc_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def hpc_pressure_ratio(self) -> float:
        """The pressure ratio of the high-pressure compressor."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_hpc_pressure_ratio_metadata)

    _set_hpc_pressure_ratio_metadata = { "name" : "hpc_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @hpc_pressure_ratio.setter
    def hpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the high-pressure compressor."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_hpc_pressure_ratio_metadata, newVal)

    _get_lpc_pressure_ratio_metadata = { "name" : "lpc_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def lpc_pressure_ratio(self) -> float:
        """The pressure ratio of the low-pressure compressor."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_lpc_pressure_ratio_metadata)

    _set_lpc_pressure_ratio_metadata = { "name" : "lpc_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @lpc_pressure_ratio.setter
    def lpc_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the low-pressure compressor."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_lpc_pressure_ratio_metadata, newVal)

    _get_fan_pressure_ratio_metadata = { "name" : "fan_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fan_pressure_ratio(self) -> float:
        """The pressure ratio of the fan."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_fan_pressure_ratio_metadata)

    _set_fan_pressure_ratio_metadata = { "name" : "fan_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fan_pressure_ratio.setter
    def fan_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio of the fan."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_fan_pressure_ratio_metadata, newVal)

    _get_efficiencies_and_losses_metadata = { "name" : "efficiencies_and_losses",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def efficiencies_and_losses(self) -> "PropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_efficiencies_and_losses_metadata)

    _get_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @property
    def fuel_type(self) -> "JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_fuel_type_metadata)

    _set_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @fuel_type.setter
    def fuel_type(self, newVal:"JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        return self._intf.set_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._set_fuel_type_metadata, newVal)

    _get_fuel_mode_as_afprop_metadata = { "name" : "fuel_mode_as_afprop",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_afprop(self) -> "FuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_fuel_mode_as_afprop_metadata)

    _get_fuel_mode_as_cea_metadata = { "name" : "fuel_mode_as_cea",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_cea(self) -> "FuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        return self._intf.get_property(IAdvFixedWingTurbofanBasicABProp._metadata, IAdvFixedWingTurbofanBasicABProp._get_fuel_mode_as_cea_metadata)


agcls.AgClassCatalog.add_catalog_entry("{f26a8761-895c-47b1-9836-9278313cf45d}", IAdvFixedWingTurbofanBasicABProp)
agcls.AgTypeNameMap["IAdvFixedWingTurbofanBasicABProp"] = IAdvFixedWingTurbofanBasicABProp

class IAviatorVehicle(object):
    """Interface for a vehicle in Aviator."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9be54cfc-ba13-4a27-a829-2e10e04f2beb}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_catalog_item" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAviatorVehicle._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAviatorVehicle from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAviatorVehicle.__dict__ and type(IAviatorVehicle.__dict__[attrname]) == property:
            return IAviatorVehicle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAviatorVehicle.")
    
    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAviatorVehicle._metadata, IAviatorVehicle._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{9be54cfc-ba13-4a27-a829-2e10e04f2beb}", IAviatorVehicle)
agcls.AgTypeNameMap["IAviatorVehicle"] = IAviatorVehicle

class IMissileModel(object):
    """Interface used to access the missile options in the Aviator catalog."""
    _num_methods = 47
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{80168c56-998d-45e3-9a93-e0511478a44b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_load_factor" : 1,
                             "set_max_load_factor" : 2,
                             "get_maneuver_mode" : 3,
                             "set_maneuver_mode" : 4,
                             "get_maneuver_mode_helper" : 5,
                             "get_attitude_transitions" : 6,
                             "get_ignore_fpa_for_climb_descent_transitions" : 7,
                             "set_ignore_fpa_for_climb_descent_transitions" : 8,
                             "get_climb_airspeed" : 9,
                             "get_climb_airspeed_type" : 10,
                             "set_climb_airspeed" : 11,
                             "get_climb_max_fpa" : 12,
                             "set_climb_max_fpa" : 13,
                             "get_climb_min_fpa" : 14,
                             "set_climb_min_fpa" : 15,
                             "get_climb_fail_on_insufficient_performance" : 16,
                             "set_climb_fail_on_insufficient_performance" : 17,
                             "get_cruise_max_airspeed" : 18,
                             "get_cruise_max_airspeed_type" : 19,
                             "set_cruise_max_airspeed" : 20,
                             "get_cruise_default_altitude" : 21,
                             "set_cruise_default_altitude" : 22,
                             "get_descent_airspeed" : 23,
                             "get_descent_airspeed_type" : 24,
                             "set_descent_airspeed" : 25,
                             "get_descent_max_fpa" : 26,
                             "set_descent_max_fpa" : 27,
                             "get_descent_min_fpa" : 28,
                             "set_descent_min_fpa" : 29,
                             "get_descent_fail_on_insufficient_performance" : 30,
                             "set_descent_fail_on_insufficient_performance" : 31,
                             "get_use_total_temp_limit" : 32,
                             "set_use_total_temp_limit" : 33,
                             "get_total_temp_limit" : 34,
                             "set_total_temp_limit" : 35,
                             "get_use_mach_limit" : 36,
                             "set_use_mach_limit" : 37,
                             "get_mach_limit" : 38,
                             "set_mach_limit" : 39,
                             "get_use_eas_limit" : 40,
                             "set_use_eas_limit" : 41,
                             "get_eas_limit" : 42,
                             "set_eas_limit" : 43,
                             "get_default_configuration" : 44,
                             "get_aerodynamics" : 45,
                             "get_propulsion" : 46,
                             "get_as_catalog_item" : 47, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileModel.__dict__ and type(IMissileModel.__dict__[attrname]) == property:
            return IMissileModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileModel.")
    
    _get_max_load_factor_metadata = { "name" : "max_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_load_factor(self) -> float:
        """The maximum load factor that the missile can withstand while maneuvering."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_max_load_factor_metadata)

    _set_max_load_factor_metadata = { "name" : "max_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_load_factor.setter
    def max_load_factor(self, pVal:float) -> None:
        """The maximum load factor that the missile can withstand while maneuvering."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_max_load_factor_metadata, pVal)

    _get_maneuver_mode_metadata = { "name" : "maneuver_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_MODE),) }
    @property
    def maneuver_mode(self) -> "ACCEL_MANEUVER_MODE":
        """The mode that the missile will adhere to the specified load factor. Scale by atmospheric density will cause the missile to consider dynamic pressure when calculating turn radius."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_maneuver_mode_metadata)

    _set_maneuver_mode_metadata = { "name" : "maneuver_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_MODE),) }
    @maneuver_mode.setter
    def maneuver_mode(self, newVal:"ACCEL_MANEUVER_MODE") -> None:
        """The mode that the missile will adhere to the specified load factor. Scale by atmospheric density will cause the missile to consider dynamic pressure when calculating turn radius."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_maneuver_mode_metadata, newVal)

    _get_maneuver_mode_helper_metadata = { "name" : "maneuver_mode_helper",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def maneuver_mode_helper(self) -> "AeroPropManeuverModeHelper":
        """Get the interface for the Aero/Prop Maneuver Mode helper. The maneuver mode must be set to Aero/Prop to access this interface."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_maneuver_mode_helper_metadata)

    _get_attitude_transitions_metadata = { "name" : "attitude_transitions",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def attitude_transitions(self) -> "AttitudeTransitions":
        """Get the attitude transitions interface."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_attitude_transitions_metadata)

    _get_ignore_fpa_for_climb_descent_transitions_metadata = { "name" : "ignore_fpa_for_climb_descent_transitions",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ignore_fpa_for_climb_descent_transitions(self) -> bool:
        """Opt whether to ignore the flight path angle limits for climb and descent transitions."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_ignore_fpa_for_climb_descent_transitions_metadata)

    _set_ignore_fpa_for_climb_descent_transitions_metadata = { "name" : "ignore_fpa_for_climb_descent_transitions",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ignore_fpa_for_climb_descent_transitions.setter
    def ignore_fpa_for_climb_descent_transitions(self, pVal:bool) -> None:
        """Opt whether to ignore the flight path angle limits for climb and descent transitions."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_ignore_fpa_for_climb_descent_transitions_metadata, pVal)

    _get_climb_airspeed_metadata = { "name" : "climb_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def climb_airspeed(self) -> float:
        """The standard airspeed of the missile while climbing."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_climb_airspeed_metadata)

    _get_climb_airspeed_type_metadata = { "name" : "climb_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def climb_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The climb airspeed type."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_climb_airspeed_type_metadata)

    _set_climb_airspeed_metadata = { "name" : "set_climb_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_climb_airspeed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the missile's climb airspeed and airspeed type."""
        return self._intf.invoke(IMissileModel._metadata, IMissileModel._set_climb_airspeed_metadata, airspeedType, aispeed)

    _get_climb_max_fpa_metadata = { "name" : "climb_max_fpa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def climb_max_fpa(self) -> typing.Any:
        """The maximum flight path angle of the missile's flight path while climbing."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_climb_max_fpa_metadata)

    _set_climb_max_fpa_metadata = { "name" : "climb_max_fpa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @climb_max_fpa.setter
    def climb_max_fpa(self, pVal:typing.Any) -> None:
        """The maximum flight path angle of the missile's flight path while climbing."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_climb_max_fpa_metadata, pVal)

    _get_climb_min_fpa_metadata = { "name" : "climb_min_fpa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def climb_min_fpa(self) -> typing.Any:
        """The minimum flight path angle of the missile's flight path while climbing."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_climb_min_fpa_metadata)

    _set_climb_min_fpa_metadata = { "name" : "climb_min_fpa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @climb_min_fpa.setter
    def climb_min_fpa(self, pVal:typing.Any) -> None:
        """The minimum flight path angle of the missile's flight path while climbing."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_climb_min_fpa_metadata, pVal)

    _get_climb_fail_on_insufficient_performance_metadata = { "name" : "climb_fail_on_insufficient_performance",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def climb_fail_on_insufficient_performance(self) -> bool:
        """Opt whether to fail while climbing if there is insufficient specific excess power."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_climb_fail_on_insufficient_performance_metadata)

    _set_climb_fail_on_insufficient_performance_metadata = { "name" : "climb_fail_on_insufficient_performance",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @climb_fail_on_insufficient_performance.setter
    def climb_fail_on_insufficient_performance(self, pVal:bool) -> None:
        """Opt whether to fail while climbing if there is insufficient specific excess power."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_climb_fail_on_insufficient_performance_metadata, pVal)

    _get_cruise_max_airspeed_metadata = { "name" : "cruise_max_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cruise_max_airspeed(self) -> float:
        """The maximum airspeed of the missile while cruising."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_cruise_max_airspeed_metadata)

    _get_cruise_max_airspeed_type_metadata = { "name" : "cruise_max_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def cruise_max_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The cruise airspeed type."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_cruise_max_airspeed_type_metadata)

    _set_cruise_max_airspeed_metadata = { "name" : "set_cruise_max_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_cruise_max_airspeed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the missile's max cruise airspeed and airspeed type."""
        return self._intf.invoke(IMissileModel._metadata, IMissileModel._set_cruise_max_airspeed_metadata, airspeedType, aispeed)

    _get_cruise_default_altitude_metadata = { "name" : "cruise_default_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cruise_default_altitude(self) -> float:
        """The missile's default cruising altitude."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_cruise_default_altitude_metadata)

    _set_cruise_default_altitude_metadata = { "name" : "cruise_default_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cruise_default_altitude.setter
    def cruise_default_altitude(self, pVal:float) -> None:
        """The missile's default cruising altitude."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_cruise_default_altitude_metadata, pVal)

    _get_descent_airspeed_metadata = { "name" : "descent_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def descent_airspeed(self) -> float:
        """The standard airspeed of the missile while descending."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_descent_airspeed_metadata)

    _get_descent_airspeed_type_metadata = { "name" : "descent_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def descent_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The descent airspeed type."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_descent_airspeed_type_metadata)

    _set_descent_airspeed_metadata = { "name" : "set_descent_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_descent_airspeed(self, airspeedType:"AIRSPEED_TYPE", aispeed:float) -> None:
        """Set the missile's descent airspeed and airspeed type."""
        return self._intf.invoke(IMissileModel._metadata, IMissileModel._set_descent_airspeed_metadata, airspeedType, aispeed)

    _get_descent_max_fpa_metadata = { "name" : "descent_max_fpa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def descent_max_fpa(self) -> typing.Any:
        """The maximum flight path angle of the missile's flight path while descending."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_descent_max_fpa_metadata)

    _set_descent_max_fpa_metadata = { "name" : "descent_max_fpa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @descent_max_fpa.setter
    def descent_max_fpa(self, pVal:typing.Any) -> None:
        """The maximum flight path angle of the missile's flight path while descending."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_descent_max_fpa_metadata, pVal)

    _get_descent_min_fpa_metadata = { "name" : "descent_min_fpa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def descent_min_fpa(self) -> typing.Any:
        """The minimum flight path angle of the missile's flight path while descending."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_descent_min_fpa_metadata)

    _set_descent_min_fpa_metadata = { "name" : "descent_min_fpa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @descent_min_fpa.setter
    def descent_min_fpa(self, pVal:typing.Any) -> None:
        """The minimum flight path angle of the missile's flight path while descending."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_descent_min_fpa_metadata, pVal)

    _get_descent_fail_on_insufficient_performance_metadata = { "name" : "descent_fail_on_insufficient_performance",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def descent_fail_on_insufficient_performance(self) -> bool:
        """Opt whether to fail while descending if there is insufficient specific excess power."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_descent_fail_on_insufficient_performance_metadata)

    _set_descent_fail_on_insufficient_performance_metadata = { "name" : "descent_fail_on_insufficient_performance",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @descent_fail_on_insufficient_performance.setter
    def descent_fail_on_insufficient_performance(self, pVal:bool) -> None:
        """Opt whether to fail while descending if there is insufficient specific excess power."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_descent_fail_on_insufficient_performance_metadata, pVal)

    _get_use_total_temp_limit_metadata = { "name" : "use_total_temp_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_total_temp_limit(self) -> bool:
        """Opt whether to limit the speed of the missile so the specified temperature is not exceeded."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_use_total_temp_limit_metadata)

    _set_use_total_temp_limit_metadata = { "name" : "use_total_temp_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_total_temp_limit.setter
    def use_total_temp_limit(self, pVal:bool) -> None:
        """Opt whether to limit the speed of the missile so the specified temperature is not exceeded."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_use_total_temp_limit_metadata, pVal)

    _get_total_temp_limit_metadata = { "name" : "total_temp_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_temp_limit(self) -> float:
        """The maximum total temperature limit of the missile."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_total_temp_limit_metadata)

    _set_total_temp_limit_metadata = { "name" : "total_temp_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @total_temp_limit.setter
    def total_temp_limit(self, pVal:float) -> None:
        """The maximum total temperature limit of the missile."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_total_temp_limit_metadata, pVal)

    _get_use_mach_limit_metadata = { "name" : "use_mach_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_mach_limit(self) -> bool:
        """Opt whether to limit the speed of the missile so the specified mach number is not exceeded."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_use_mach_limit_metadata)

    _set_use_mach_limit_metadata = { "name" : "use_mach_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_mach_limit.setter
    def use_mach_limit(self, pVal:bool) -> None:
        """Opt whether to limit the speed of the missile so the specified mach number is not exceeded."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_use_mach_limit_metadata, pVal)

    _get_mach_limit_metadata = { "name" : "mach_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def mach_limit(self) -> float:
        """The maximum allowable mach number."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_mach_limit_metadata)

    _set_mach_limit_metadata = { "name" : "mach_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @mach_limit.setter
    def mach_limit(self, pVal:float) -> None:
        """The maximum allowable mach number."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_mach_limit_metadata, pVal)

    _get_use_eas_limit_metadata = { "name" : "use_eas_limit",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_eas_limit(self) -> bool:
        """Opt whether to limit the speed of the missile so the specified Equivalent Airspeed is not exceeded."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_use_eas_limit_metadata)

    _set_use_eas_limit_metadata = { "name" : "use_eas_limit",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_eas_limit.setter
    def use_eas_limit(self, pVal:bool) -> None:
        """Opt whether to limit the speed of the missile so the specified Equivalent Airspeed is not exceeded."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_use_eas_limit_metadata, pVal)

    _get_eas_limit_metadata = { "name" : "eas_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def eas_limit(self) -> float:
        """The maximum allowable Equivalent Airspeed."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_eas_limit_metadata)

    _set_eas_limit_metadata = { "name" : "eas_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @eas_limit.setter
    def eas_limit(self, pVal:float) -> None:
        """The maximum allowable Equivalent Airspeed."""
        return self._intf.set_property(IMissileModel._metadata, IMissileModel._set_eas_limit_metadata, pVal)

    _get_default_configuration_metadata = { "name" : "default_configuration",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def default_configuration(self) -> "Configuration":
        """The aircraft's default configuration as saved in the catalog."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_default_configuration_metadata)

    _get_aerodynamics_metadata = { "name" : "aerodynamics",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aerodynamics(self) -> "MissileAero":
        """Get the aerodynamics interface."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_aerodynamics_metadata)

    _get_propulsion_metadata = { "name" : "propulsion",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def propulsion(self) -> "MissileProp":
        """Get the propulsion interface."""
        return self._intf.get_property(IMissileModel._metadata, IMissileModel._get_propulsion_metadata)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IMissileModel._metadata, IMissileModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{80168c56-998d-45e3-9a93-e0511478a44b}", IMissileModel)
agcls.AgTypeNameMap["IMissileModel"] = IMissileModel

class IMissileAero(object):
    """Interface used to access the aerodynamics options for a missile."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b7e5c31a-5fbd-4a71-b99b-48707d6af556}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_aero_strategy" : 1,
                             "set_aero_strategy" : 2,
                             "get_mode_as_simple" : 3,
                             "get_mode_as_external" : 4,
                             "get_mode_as_advanced" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileAero.__dict__ and type(IMissileAero.__dict__[attrname]) == property:
            return IMissileAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileAero.")
    
    _get_aero_strategy_metadata = { "name" : "aero_strategy",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(MISSILE_AERO_STRATEGY),) }
    @property
    def aero_strategy(self) -> "MISSILE_AERO_STRATEGY":
        """The aerodynamic strategy type."""
        return self._intf.get_property(IMissileAero._metadata, IMissileAero._get_aero_strategy_metadata)

    _set_aero_strategy_metadata = { "name" : "aero_strategy",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(MISSILE_AERO_STRATEGY),) }
    @aero_strategy.setter
    def aero_strategy(self, newVal:"MISSILE_AERO_STRATEGY") -> None:
        """The aerodynamic strategy type."""
        return self._intf.set_property(IMissileAero._metadata, IMissileAero._set_aero_strategy_metadata, newVal)

    _get_mode_as_simple_metadata = { "name" : "mode_as_simple",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_simple(self) -> "MissileSimpleAero":
        """Get the interface for a simple aerodynamics strategy."""
        return self._intf.get_property(IMissileAero._metadata, IMissileAero._get_mode_as_simple_metadata)

    _get_mode_as_external_metadata = { "name" : "mode_as_external",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_external(self) -> "MissileExternalAero":
        """Get the interface for an external file aerodynamics strategy."""
        return self._intf.get_property(IMissileAero._metadata, IMissileAero._get_mode_as_external_metadata)

    _get_mode_as_advanced_metadata = { "name" : "mode_as_advanced",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_advanced(self) -> "MissileAdvancedAero":
        """Get the interface for an advanced aerodynamics strategy."""
        return self._intf.get_property(IMissileAero._metadata, IMissileAero._get_mode_as_advanced_metadata)


agcls.AgClassCatalog.add_catalog_entry("{b7e5c31a-5fbd-4a71-b99b-48707d6af556}", IMissileAero)
agcls.AgTypeNameMap["IMissileAero"] = IMissileAero

class IMissileProp(object):
    """Interface used to access the Propulsion options for a missile."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3a29d5aa-b4f4-4431-9857-1d61bd3250cb}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_prop_strategy" : 1,
                             "set_prop_strategy" : 2,
                             "get_mode_as_simple" : 3,
                             "get_mode_as_external" : 4,
                             "get_mode_as_ramjet" : 5,
                             "get_mode_as_turbojet" : 6,
                             "get_mode_as_rocket" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileProp.__dict__ and type(IMissileProp.__dict__[attrname]) == property:
            return IMissileProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileProp.")
    
    _get_prop_strategy_metadata = { "name" : "prop_strategy",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(MISSILE_PROP_STRATEGY),) }
    @property
    def prop_strategy(self) -> "MISSILE_PROP_STRATEGY":
        """The propulsion strategy type."""
        return self._intf.get_property(IMissileProp._metadata, IMissileProp._get_prop_strategy_metadata)

    _set_prop_strategy_metadata = { "name" : "prop_strategy",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(MISSILE_PROP_STRATEGY),) }
    @prop_strategy.setter
    def prop_strategy(self, newVal:"MISSILE_PROP_STRATEGY") -> None:
        """The propulsion strategy type."""
        return self._intf.set_property(IMissileProp._metadata, IMissileProp._set_prop_strategy_metadata, newVal)

    _get_mode_as_simple_metadata = { "name" : "mode_as_simple",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_simple(self) -> "MissileSimpleProp":
        """Get the interface for a simple propulsion strategy."""
        return self._intf.get_property(IMissileProp._metadata, IMissileProp._get_mode_as_simple_metadata)

    _get_mode_as_external_metadata = { "name" : "mode_as_external",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_external(self) -> "MissileExternalProp":
        """Get the interface for an external file propulsion strategy."""
        return self._intf.get_property(IMissileProp._metadata, IMissileProp._get_mode_as_external_metadata)

    _get_mode_as_ramjet_metadata = { "name" : "mode_as_ramjet",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_ramjet(self) -> "MissileRamjetProp":
        """Get the interface for an Ramjet propulsion strategy."""
        return self._intf.get_property(IMissileProp._metadata, IMissileProp._get_mode_as_ramjet_metadata)

    _get_mode_as_turbojet_metadata = { "name" : "mode_as_turbojet",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_turbojet(self) -> "MissileTurbojetProp":
        """Get the interface for an Turbojet propulsion strategy."""
        return self._intf.get_property(IMissileProp._metadata, IMissileProp._get_mode_as_turbojet_metadata)

    _get_mode_as_rocket_metadata = { "name" : "mode_as_rocket",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_rocket(self) -> "MissileRocketProp":
        """Get the interface for an Rocket propulsion strategy."""
        return self._intf.get_property(IMissileProp._metadata, IMissileProp._get_mode_as_rocket_metadata)


agcls.AgClassCatalog.add_catalog_entry("{3a29d5aa-b4f4-4431-9857-1d61bd3250cb}", IMissileProp)
agcls.AgTypeNameMap["IMissileProp"] = IMissileProp

class IMissileSimpleAero(object):
    """Interface used to access the Simple aerodynamics options for a missile."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e189fccd-ff74-40ee-9181-ed655a619480}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_s_reference" : 1,
                             "set_s_reference" : 2,
                             "get_cl_max" : 3,
                             "set_cl_max" : 4,
                             "get_cd" : 5,
                             "set_cd" : 6,
                             "get_calculate_aoa" : 7,
                             "get_max_aoa" : 8,
                             "set_max_aoa" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileSimpleAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileSimpleAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileSimpleAero.__dict__ and type(IMissileSimpleAero.__dict__[attrname]) == property:
            return IMissileSimpleAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileSimpleAero.")
    
    _get_s_reference_metadata = { "name" : "s_reference",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def s_reference(self) -> float:
        """The area of the lifting surface of the missile."""
        return self._intf.get_property(IMissileSimpleAero._metadata, IMissileSimpleAero._get_s_reference_metadata)

    _set_s_reference_metadata = { "name" : "s_reference",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @s_reference.setter
    def s_reference(self, newVal:float) -> None:
        """The area of the lifting surface of the missile."""
        return self._intf.set_property(IMissileSimpleAero._metadata, IMissileSimpleAero._set_s_reference_metadata, newVal)

    _get_cl_max_metadata = { "name" : "cl_max",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cl_max(self) -> float:
        """The max coefficient of lift."""
        return self._intf.get_property(IMissileSimpleAero._metadata, IMissileSimpleAero._get_cl_max_metadata)

    _set_cl_max_metadata = { "name" : "cl_max",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cl_max.setter
    def cl_max(self, newVal:float) -> None:
        """The max coefficient of lift."""
        return self._intf.set_property(IMissileSimpleAero._metadata, IMissileSimpleAero._set_cl_max_metadata, newVal)

    _get_cd_metadata = { "name" : "cd",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cd(self) -> float:
        """The coefficient of drag."""
        return self._intf.get_property(IMissileSimpleAero._metadata, IMissileSimpleAero._get_cd_metadata)

    _set_cd_metadata = { "name" : "cd",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cd.setter
    def cd(self, newVal:float) -> None:
        """The coefficient of drag."""
        return self._intf.set_property(IMissileSimpleAero._metadata, IMissileSimpleAero._set_cd_metadata, newVal)

    _get_calculate_aoa_metadata = { "name" : "calculate_aoa",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def calculate_aoa(self) -> bool:
        """Opt to allow Aviator to calculate the Angle of Attack. Otherwise, the value will be 0 by default."""
        return self._intf.get_property(IMissileSimpleAero._metadata, IMissileSimpleAero._get_calculate_aoa_metadata)

    _get_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_aoa(self) -> typing.Any:
        """The missile's maximum angle of attack."""
        return self._intf.get_property(IMissileSimpleAero._metadata, IMissileSimpleAero._get_max_aoa_metadata)

    _set_max_aoa_metadata = { "name" : "set_max_aoa",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.VARIANT_arg,) }
    def set_max_aoa(self, calculateAoA:bool, maxAoA:typing.Any) -> None:
        """Set whether to calculate the Angle of Attack and the corresponding value."""
        return self._intf.invoke(IMissileSimpleAero._metadata, IMissileSimpleAero._set_max_aoa_metadata, calculateAoA, maxAoA)


agcls.AgClassCatalog.add_catalog_entry("{e189fccd-ff74-40ee-9181-ed655a619480}", IMissileSimpleAero)
agcls.AgTypeNameMap["IMissileSimpleAero"] = IMissileSimpleAero

class IMissileSimpleProp(object):
    """Interface used to access the Simple propulsion options for a missile."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{410fb08c-ae20-4f74-9b91-9035b813b146}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_thrust" : 1,
                             "set_max_thrust" : 2,
                             "get_fuel_flow" : 3,
                             "set_fuel_flow" : 4,
                             "get_no_thrust_when_no_fuel" : 5,
                             "set_no_thrust_when_no_fuel" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileSimpleProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileSimpleProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileSimpleProp.__dict__ and type(IMissileSimpleProp.__dict__[attrname]) == property:
            return IMissileSimpleProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileSimpleProp.")
    
    _get_max_thrust_metadata = { "name" : "max_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_thrust(self) -> float:
        """The maximum thrust of the missile."""
        return self._intf.get_property(IMissileSimpleProp._metadata, IMissileSimpleProp._get_max_thrust_metadata)

    _set_max_thrust_metadata = { "name" : "max_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_thrust.setter
    def max_thrust(self, pVal:float) -> None:
        """The maximum thrust of the missile."""
        return self._intf.set_property(IMissileSimpleProp._metadata, IMissileSimpleProp._set_max_thrust_metadata, pVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """The fuel flow at max thrust."""
        return self._intf.get_property(IMissileSimpleProp._metadata, IMissileSimpleProp._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, pVal:float) -> None:
        """The fuel flow at max thrust."""
        return self._intf.set_property(IMissileSimpleProp._metadata, IMissileSimpleProp._set_fuel_flow_metadata, pVal)

    _get_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.get_property(IMissileSimpleProp._metadata, IMissileSimpleProp._get_no_thrust_when_no_fuel_metadata)

    _set_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.set_property(IMissileSimpleProp._metadata, IMissileSimpleProp._set_no_thrust_when_no_fuel_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{410fb08c-ae20-4f74-9b91-9035b813b146}", IMissileSimpleProp)
agcls.AgTypeNameMap["IMissileSimpleProp"] = IMissileSimpleProp

class IMissileExternalAero(object):
    """Interface used to access the External aerodynamics options for a missile."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{fed723ce-0c02-41bb-8e61-d602b3543049}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filepath" : 1,
                             "set_filepath" : 2,
                             "reload" : 3,
                             "get_reference_area" : 4,
                             "set_reference_area" : 5,
                             "get_can_set_reference_area" : 6,
                             "get_is_valid" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileExternalAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileExternalAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileExternalAero.__dict__ and type(IMissileExternalAero.__dict__[attrname]) == property:
            return IMissileExternalAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileExternalAero.")
    
    _get_filepath_metadata = { "name" : "filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filepath(self) -> str:
        """The filepath for the external aero file."""
        return self._intf.get_property(IMissileExternalAero._metadata, IMissileExternalAero._get_filepath_metadata)

    _set_filepath_metadata = { "name" : "set_filepath",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external aero file."""
        return self._intf.invoke(IMissileExternalAero._metadata, IMissileExternalAero._set_filepath_metadata, filepath, out_arg())

    _reload_metadata = { "name" : "reload",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def reload(self) -> str:
        """Reload the external aero file."""
        return self._intf.invoke(IMissileExternalAero._metadata, IMissileExternalAero._reload_metadata, out_arg())

    _get_reference_area_metadata = { "name" : "reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def reference_area(self) -> float:
        """The area of the lifting surface of the missile."""
        return self._intf.get_property(IMissileExternalAero._metadata, IMissileExternalAero._get_reference_area_metadata)

    _set_reference_area_metadata = { "name" : "reference_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @reference_area.setter
    def reference_area(self, pVal:float) -> None:
        """The area of the lifting surface of the missile."""
        return self._intf.set_property(IMissileExternalAero._metadata, IMissileExternalAero._set_reference_area_metadata, pVal)

    _get_can_set_reference_area_metadata = { "name" : "can_set_reference_area",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def can_set_reference_area(self) -> bool:
        """Check whether you can set the reference area or whether it is specified in the file."""
        return self._intf.get_property(IMissileExternalAero._metadata, IMissileExternalAero._get_can_set_reference_area_metadata)

    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        return self._intf.get_property(IMissileExternalAero._metadata, IMissileExternalAero._get_is_valid_metadata)


agcls.AgClassCatalog.add_catalog_entry("{fed723ce-0c02-41bb-8e61-d602b3543049}", IMissileExternalAero)
agcls.AgTypeNameMap["IMissileExternalAero"] = IMissileExternalAero

class IMissileExternalProp(object):
    """Interface used to access the External Prop file options for a missile."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{14bcb2f5-2893-4743-9e3c-1b9c52505e0c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filepath" : 1,
                             "set_filepath" : 2,
                             "reload" : 3,
                             "get_no_thrust_when_no_fuel" : 4,
                             "set_no_thrust_when_no_fuel" : 5,
                             "get_is_valid" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileExternalProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileExternalProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileExternalProp.__dict__ and type(IMissileExternalProp.__dict__[attrname]) == property:
            return IMissileExternalProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileExternalProp.")
    
    _get_filepath_metadata = { "name" : "filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filepath(self) -> str:
        """The filepath for the external prop file."""
        return self._intf.get_property(IMissileExternalProp._metadata, IMissileExternalProp._get_filepath_metadata)

    _set_filepath_metadata = { "name" : "set_filepath",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_filepath(self, filepath:str) -> str:
        """Set the filepath for the external prop file."""
        return self._intf.invoke(IMissileExternalProp._metadata, IMissileExternalProp._set_filepath_metadata, filepath, out_arg())

    _reload_metadata = { "name" : "reload",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def reload(self) -> str:
        """Reload the external prop file."""
        return self._intf.invoke(IMissileExternalProp._metadata, IMissileExternalProp._reload_metadata, out_arg())

    _get_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.get_property(IMissileExternalProp._metadata, IMissileExternalProp._get_no_thrust_when_no_fuel_metadata)

    _set_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.set_property(IMissileExternalProp._metadata, IMissileExternalProp._set_no_thrust_when_no_fuel_metadata, pVal)

    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Check whether the filepath is valid."""
        return self._intf.get_property(IMissileExternalProp._metadata, IMissileExternalProp._get_is_valid_metadata)


agcls.AgClassCatalog.add_catalog_entry("{14bcb2f5-2893-4743-9e3c-1b9c52505e0c}", IMissileExternalProp)
agcls.AgTypeNameMap["IMissileExternalProp"] = IMissileExternalProp

class IMissileAdvancedAero(object):
    """Interface used to access the Advanced aerodynamics options for a missile."""
    _num_methods = 48
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a26fe490-218c-44e4-95ab-69c20d3d6629}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_body_width" : 1,
                             "set_body_width" : 2,
                             "get_body_height" : 3,
                             "set_body_height" : 4,
                             "get_body_length" : 5,
                             "set_body_length" : 6,
                             "get_nose_length" : 7,
                             "set_nose_length" : 8,
                             "get_nose_tip_diameter" : 9,
                             "set_nose_tip_diameter" : 10,
                             "get_nozzle_diameter" : 11,
                             "set_nozzle_diameter" : 12,
                             "get_max_aoa" : 13,
                             "set_max_aoa" : 14,
                             "get_min_mach" : 15,
                             "set_min_mach" : 16,
                             "get_wing_count" : 17,
                             "set_wing_count" : 18,
                             "get_wing_span" : 19,
                             "set_wing_span" : 20,
                             "get_wing_surface_area" : 21,
                             "set_wing_surface_area" : 22,
                             "get_wing_leading_edge_sweep_angle" : 23,
                             "set_wing_leading_edge_sweep_angle" : 24,
                             "get_wing_leading_edge_section_angle" : 25,
                             "set_wing_leading_edge_section_angle" : 26,
                             "get_wing_mean_aero_chord_length" : 27,
                             "set_wing_mean_aero_chord_length" : 28,
                             "get_wing_max_thickness_along_mac" : 29,
                             "set_wing_max_thickness_along_mac" : 30,
                             "get_wing_lift_fraction" : 31,
                             "set_wing_lift_fraction" : 32,
                             "get_tail_count" : 33,
                             "set_tail_count" : 34,
                             "get_tail_span" : 35,
                             "set_tail_span" : 36,
                             "get_tail_surface_area" : 37,
                             "set_tail_surface_area" : 38,
                             "get_tail_leading_edge_sweep_angle" : 39,
                             "set_tail_leading_edge_sweep_angle" : 40,
                             "get_tail_leading_edge_section_angle" : 41,
                             "set_tail_leading_edge_section_angle" : 42,
                             "get_tail_mean_aero_chord_length" : 43,
                             "set_tail_mean_aero_chord_length" : 44,
                             "get_tail_max_thickness_along_mac" : 45,
                             "set_tail_max_thickness_along_mac" : 46,
                             "get_tail_lift_fraction" : 47,
                             "set_tail_lift_fraction" : 48, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileAdvancedAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileAdvancedAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileAdvancedAero.__dict__ and type(IMissileAdvancedAero.__dict__[attrname]) == property:
            return IMissileAdvancedAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileAdvancedAero.")
    
    _get_body_width_metadata = { "name" : "body_width",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def body_width(self) -> float:
        """The missile body's width."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_body_width_metadata)

    _set_body_width_metadata = { "name" : "body_width",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @body_width.setter
    def body_width(self, newVal:float) -> None:
        """The missile body's width."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_body_width_metadata, newVal)

    _get_body_height_metadata = { "name" : "body_height",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def body_height(self) -> float:
        """The missile body's height."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_body_height_metadata)

    _set_body_height_metadata = { "name" : "body_height",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @body_height.setter
    def body_height(self, newVal:float) -> None:
        """The missile body's height."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_body_height_metadata, newVal)

    _get_body_length_metadata = { "name" : "body_length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def body_length(self) -> float:
        """The missile body's length."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_body_length_metadata)

    _set_body_length_metadata = { "name" : "body_length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @body_length.setter
    def body_length(self, newVal:float) -> None:
        """The missile body's length."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_body_length_metadata, newVal)

    _get_nose_length_metadata = { "name" : "nose_length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def nose_length(self) -> float:
        """The missile nose's length."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_nose_length_metadata)

    _set_nose_length_metadata = { "name" : "nose_length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @nose_length.setter
    def nose_length(self, newVal:float) -> None:
        """The missile nose's length."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_nose_length_metadata, newVal)

    _get_nose_tip_diameter_metadata = { "name" : "nose_tip_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def nose_tip_diameter(self) -> float:
        """The missile nose's diameter at the tip."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_nose_tip_diameter_metadata)

    _set_nose_tip_diameter_metadata = { "name" : "nose_tip_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @nose_tip_diameter.setter
    def nose_tip_diameter(self, newVal:float) -> None:
        """The missile nose's diameter at the tip."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_nose_tip_diameter_metadata, newVal)

    _get_nozzle_diameter_metadata = { "name" : "nozzle_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def nozzle_diameter(self) -> float:
        """The diameter of the missile's nozzle."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_nozzle_diameter_metadata)

    _set_nozzle_diameter_metadata = { "name" : "nozzle_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @nozzle_diameter.setter
    def nozzle_diameter(self, newVal:float) -> None:
        """The diameter of the missile's nozzle."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_nozzle_diameter_metadata, newVal)

    _get_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_aoa(self) -> typing.Any:
        """The missile's maximum angle of attack."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_max_aoa_metadata)

    _set_max_aoa_metadata = { "name" : "max_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_aoa.setter
    def max_aoa(self, newVal:typing.Any) -> None:
        """The missile's maximum angle of attack."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_max_aoa_metadata, newVal)

    _get_min_mach_metadata = { "name" : "min_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_mach(self) -> float:
        """The minimum mach number of the missile."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_min_mach_metadata)

    _set_min_mach_metadata = { "name" : "min_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_mach.setter
    def min_mach(self, newVal:float) -> None:
        """The minimum mach number of the missile."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_min_mach_metadata, newVal)

    _get_wing_count_metadata = { "name" : "wing_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def wing_count(self) -> int:
        """The number of wings on the missile."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_count_metadata)

    _set_wing_count_metadata = { "name" : "wing_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @wing_count.setter
    def wing_count(self, newVal:int) -> None:
        """The number of wings on the missile."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_count_metadata, newVal)

    _get_wing_span_metadata = { "name" : "wing_span",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wing_span(self) -> float:
        """The span of one of the missile's wings."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_span_metadata)

    _set_wing_span_metadata = { "name" : "wing_span",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wing_span.setter
    def wing_span(self, newVal:float) -> None:
        """The span of one of the missile's wings."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_span_metadata, newVal)

    _get_wing_surface_area_metadata = { "name" : "wing_surface_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wing_surface_area(self) -> float:
        """The area of one of the missile's wings."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_surface_area_metadata)

    _set_wing_surface_area_metadata = { "name" : "wing_surface_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wing_surface_area.setter
    def wing_surface_area(self, newVal:float) -> None:
        """The area of one of the missile's wings."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_surface_area_metadata, newVal)

    _get_wing_leading_edge_sweep_angle_metadata = { "name" : "wing_leading_edge_sweep_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def wing_leading_edge_sweep_angle(self) -> typing.Any:
        """The leading edge weep angle of the wings."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_leading_edge_sweep_angle_metadata)

    _set_wing_leading_edge_sweep_angle_metadata = { "name" : "wing_leading_edge_sweep_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @wing_leading_edge_sweep_angle.setter
    def wing_leading_edge_sweep_angle(self, newVal:typing.Any) -> None:
        """The leading edge weep angle of the wings."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_leading_edge_sweep_angle_metadata, newVal)

    _get_wing_leading_edge_section_angle_metadata = { "name" : "wing_leading_edge_section_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def wing_leading_edge_section_angle(self) -> typing.Any:
        """The leading edge section angle of the wings."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_leading_edge_section_angle_metadata)

    _set_wing_leading_edge_section_angle_metadata = { "name" : "wing_leading_edge_section_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @wing_leading_edge_section_angle.setter
    def wing_leading_edge_section_angle(self, newVal:typing.Any) -> None:
        """The leading edge section angle of the wings."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_leading_edge_section_angle_metadata, newVal)

    _get_wing_mean_aero_chord_length_metadata = { "name" : "wing_mean_aero_chord_length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wing_mean_aero_chord_length(self) -> float:
        """The mean chord length of one of the missile's wings."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_mean_aero_chord_length_metadata)

    _set_wing_mean_aero_chord_length_metadata = { "name" : "wing_mean_aero_chord_length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wing_mean_aero_chord_length.setter
    def wing_mean_aero_chord_length(self, newVal:float) -> None:
        """The mean chord length of one of the missile's wings."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_mean_aero_chord_length_metadata, newVal)

    _get_wing_max_thickness_along_mac_metadata = { "name" : "wing_max_thickness_along_mac",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wing_max_thickness_along_mac(self) -> float:
        """The max thickness of the wing along the mean aerodynamic chord."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_max_thickness_along_mac_metadata)

    _set_wing_max_thickness_along_mac_metadata = { "name" : "wing_max_thickness_along_mac",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wing_max_thickness_along_mac.setter
    def wing_max_thickness_along_mac(self, newVal:float) -> None:
        """The max thickness of the wing along the mean aerodynamic chord."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_max_thickness_along_mac_metadata, newVal)

    _get_wing_lift_fraction_metadata = { "name" : "wing_lift_fraction",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wing_lift_fraction(self) -> float:
        """The lift fraction of the wing."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_wing_lift_fraction_metadata)

    _set_wing_lift_fraction_metadata = { "name" : "wing_lift_fraction",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wing_lift_fraction.setter
    def wing_lift_fraction(self, newVal:float) -> None:
        """The lift fraction of the wing."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_wing_lift_fraction_metadata, newVal)

    _get_tail_count_metadata = { "name" : "tail_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def tail_count(self) -> int:
        """The number of tails on the missile."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_count_metadata)

    _set_tail_count_metadata = { "name" : "tail_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @tail_count.setter
    def tail_count(self, newVal:int) -> None:
        """The number of tails on the missile."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_count_metadata, newVal)

    _get_tail_span_metadata = { "name" : "tail_span",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tail_span(self) -> float:
        """The span of one of the missile's tails."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_span_metadata)

    _set_tail_span_metadata = { "name" : "tail_span",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tail_span.setter
    def tail_span(self, newVal:float) -> None:
        """The span of one of the missile's tails."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_span_metadata, newVal)

    _get_tail_surface_area_metadata = { "name" : "tail_surface_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tail_surface_area(self) -> float:
        """The area of one of the missile's tails."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_surface_area_metadata)

    _set_tail_surface_area_metadata = { "name" : "tail_surface_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tail_surface_area.setter
    def tail_surface_area(self, newVal:float) -> None:
        """The area of one of the missile's tails."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_surface_area_metadata, newVal)

    _get_tail_leading_edge_sweep_angle_metadata = { "name" : "tail_leading_edge_sweep_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def tail_leading_edge_sweep_angle(self) -> typing.Any:
        """The leading edge weep angle of the tails."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_leading_edge_sweep_angle_metadata)

    _set_tail_leading_edge_sweep_angle_metadata = { "name" : "tail_leading_edge_sweep_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @tail_leading_edge_sweep_angle.setter
    def tail_leading_edge_sweep_angle(self, newVal:typing.Any) -> None:
        """The leading edge weep angle of the tails."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_leading_edge_sweep_angle_metadata, newVal)

    _get_tail_leading_edge_section_angle_metadata = { "name" : "tail_leading_edge_section_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def tail_leading_edge_section_angle(self) -> typing.Any:
        """The leading edge section angle of the tails."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_leading_edge_section_angle_metadata)

    _set_tail_leading_edge_section_angle_metadata = { "name" : "tail_leading_edge_section_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @tail_leading_edge_section_angle.setter
    def tail_leading_edge_section_angle(self, newVal:typing.Any) -> None:
        """The leading edge section angle of the tails."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_leading_edge_section_angle_metadata, newVal)

    _get_tail_mean_aero_chord_length_metadata = { "name" : "tail_mean_aero_chord_length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tail_mean_aero_chord_length(self) -> float:
        """The mean chord length of one of the missile's tails."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_mean_aero_chord_length_metadata)

    _set_tail_mean_aero_chord_length_metadata = { "name" : "tail_mean_aero_chord_length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tail_mean_aero_chord_length.setter
    def tail_mean_aero_chord_length(self, newVal:float) -> None:
        """The mean chord length of one of the missile's tails."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_mean_aero_chord_length_metadata, newVal)

    _get_tail_max_thickness_along_mac_metadata = { "name" : "tail_max_thickness_along_mac",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tail_max_thickness_along_mac(self) -> float:
        """The max thickness of the tail along the mean aerodynamic chord."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_max_thickness_along_mac_metadata)

    _set_tail_max_thickness_along_mac_metadata = { "name" : "tail_max_thickness_along_mac",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tail_max_thickness_along_mac.setter
    def tail_max_thickness_along_mac(self, newVal:float) -> None:
        """The max thickness of the tail along the mean aerodynamic chord."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_max_thickness_along_mac_metadata, newVal)

    _get_tail_lift_fraction_metadata = { "name" : "tail_lift_fraction",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tail_lift_fraction(self) -> float:
        """The lift fraction of the tail."""
        return self._intf.get_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._get_tail_lift_fraction_metadata)

    _set_tail_lift_fraction_metadata = { "name" : "tail_lift_fraction",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tail_lift_fraction.setter
    def tail_lift_fraction(self, newVal:float) -> None:
        """The lift fraction of the tail."""
        return self._intf.set_property(IMissileAdvancedAero._metadata, IMissileAdvancedAero._set_tail_lift_fraction_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{a26fe490-218c-44e4-95ab-69c20d3d6629}", IMissileAdvancedAero)
agcls.AgTypeNameMap["IMissileAdvancedAero"] = IMissileAdvancedAero

class IMissileRamjetProp(object):
    """Interface used to access the Ramjet propulsion options for a missile."""
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a0a4fb0a-67cb-44bd-b0e9-2362cfedbb0e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_design_mach" : 1,
                             "set_design_mach" : 2,
                             "get_design_altitude" : 3,
                             "set_design_altitude" : 4,
                             "get_design_thrust" : 5,
                             "set_design_thrust" : 6,
                             "get_engine_temp" : 7,
                             "set_engine_temp" : 8,
                             "get_fuel_heating_value" : 9,
                             "set_fuel_heating_value" : 10,
                             "get_inlet_pressure_ratio" : 11,
                             "set_inlet_pressure_ratio" : 12,
                             "get_burner_pressure_ratio" : 13,
                             "set_burner_pressure_ratio" : 14,
                             "get_nozzle_pressure_ratio" : 15,
                             "set_nozzle_pressure_ratio" : 16,
                             "get_p_0over_p9" : 17,
                             "set_p_0over_p9" : 18,
                             "get_burner_efficiency" : 19,
                             "set_burner_efficiency" : 20,
                             "get_no_thrust_when_no_fuel" : 21,
                             "set_no_thrust_when_no_fuel" : 22, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileRamjetProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileRamjetProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileRamjetProp.__dict__ and type(IMissileRamjetProp.__dict__[attrname]) == property:
            return IMissileRamjetProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileRamjetProp.")
    
    _get_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_design_mach_metadata)

    _set_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_design_mach_metadata, newVal)

    _get_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_design_altitude_metadata)

    _set_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_design_altitude_metadata, newVal)

    _get_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_design_thrust_metadata)

    _set_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_design_thrust_metadata, newVal)

    _get_engine_temp_metadata = { "name" : "engine_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def engine_temp(self) -> float:
        """The maximum temperature that the engine material can support."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_engine_temp_metadata)

    _set_engine_temp_metadata = { "name" : "engine_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @engine_temp.setter
    def engine_temp(self, newVal:float) -> None:
        """The maximum temperature that the engine material can support."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_engine_temp_metadata, newVal)

    _get_fuel_heating_value_metadata = { "name" : "fuel_heating_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_heating_value(self) -> float:
        """The heating value of the fuel."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_fuel_heating_value_metadata)

    _set_fuel_heating_value_metadata = { "name" : "fuel_heating_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_heating_value.setter
    def fuel_heating_value(self, newVal:float) -> None:
        """The heating value of the fuel."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_fuel_heating_value_metadata, newVal)

    _get_inlet_pressure_ratio_metadata = { "name" : "inlet_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def inlet_pressure_ratio(self) -> float:
        """The pressure ratio from the inlet exit to the entrance."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_inlet_pressure_ratio_metadata)

    _set_inlet_pressure_ratio_metadata = { "name" : "inlet_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @inlet_pressure_ratio.setter
    def inlet_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the inlet exit to the entrance."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_inlet_pressure_ratio_metadata, newVal)

    _get_burner_pressure_ratio_metadata = { "name" : "burner_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def burner_pressure_ratio(self) -> float:
        """The pressure ratio from the burner exit to the entrance."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_burner_pressure_ratio_metadata)

    _set_burner_pressure_ratio_metadata = { "name" : "burner_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @burner_pressure_ratio.setter
    def burner_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the burner exit to the entrance."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_burner_pressure_ratio_metadata, newVal)

    _get_nozzle_pressure_ratio_metadata = { "name" : "nozzle_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def nozzle_pressure_ratio(self) -> float:
        """The pressure ratio from the nozzle exit to the entrance."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_nozzle_pressure_ratio_metadata)

    _set_nozzle_pressure_ratio_metadata = { "name" : "nozzle_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @nozzle_pressure_ratio.setter
    def nozzle_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the nozzle exit to the entrance."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_nozzle_pressure_ratio_metadata, newVal)

    _get_p_0over_p9_metadata = { "name" : "p_0over_p9",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def p_0over_p9(self) -> float:
        """The pressure ratio from ambient conditions to the engine exit."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_p_0over_p9_metadata)

    _set_p_0over_p9_metadata = { "name" : "p_0over_p9",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @p_0over_p9.setter
    def p_0over_p9(self, newVal:float) -> None:
        """The pressure ratio from ambient conditions to the engine exit."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_p_0over_p9_metadata, newVal)

    _get_burner_efficiency_metadata = { "name" : "burner_efficiency",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def burner_efficiency(self) -> float:
        """The efficiency of the burner."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_burner_efficiency_metadata)

    _set_burner_efficiency_metadata = { "name" : "burner_efficiency",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @burner_efficiency.setter
    def burner_efficiency(self, newVal:float) -> None:
        """The efficiency of the burner."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_burner_efficiency_metadata, newVal)

    _get_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.get_property(IMissileRamjetProp._metadata, IMissileRamjetProp._get_no_thrust_when_no_fuel_metadata)

    _set_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.set_property(IMissileRamjetProp._metadata, IMissileRamjetProp._set_no_thrust_when_no_fuel_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{a0a4fb0a-67cb-44bd-b0e9-2362cfedbb0e}", IMissileRamjetProp)
agcls.AgTypeNameMap["IMissileRamjetProp"] = IMissileRamjetProp

class IMissileRocketProp(object):
    """Interface used to access the Rocket propulsion options for a missile."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4aa12da8-8ff9-40f4-bbf7-1e09aa7f04f8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_nozzle_expansion_ratio" : 1,
                             "set_nozzle_expansion_ratio" : 2,
                             "get_nozzle_exit_diameter" : 3,
                             "set_nozzle_exit_diameter" : 4,
                             "get_combustion_chamber_pressure" : 5,
                             "set_combustion_chamber_pressure" : 6,
                             "get_propellant_specific_heat_ratio" : 7,
                             "set_propellant_specific_heat_ratio" : 8,
                             "get_propellant_characteristic_velocity" : 9,
                             "set_propellant_characteristic_velocity" : 10,
                             "get_use_boost_sustain_mode" : 11,
                             "set_use_boost_sustain_mode" : 12,
                             "get_boost_fuel_fraction" : 13,
                             "set_boost_fuel_fraction" : 14,
                             "get_boost_chamber_pressure" : 15,
                             "set_boost_chamber_pressure" : 16,
                             "get_no_thrust_when_no_fuel" : 17,
                             "set_no_thrust_when_no_fuel" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileRocketProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileRocketProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileRocketProp.__dict__ and type(IMissileRocketProp.__dict__[attrname]) == property:
            return IMissileRocketProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileRocketProp.")
    
    _get_nozzle_expansion_ratio_metadata = { "name" : "nozzle_expansion_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def nozzle_expansion_ratio(self) -> float:
        """The exit area divided by the throat area."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_nozzle_expansion_ratio_metadata)

    _set_nozzle_expansion_ratio_metadata = { "name" : "nozzle_expansion_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @nozzle_expansion_ratio.setter
    def nozzle_expansion_ratio(self, newVal:float) -> None:
        """The exit area divided by the throat area."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_nozzle_expansion_ratio_metadata, newVal)

    _get_nozzle_exit_diameter_metadata = { "name" : "nozzle_exit_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def nozzle_exit_diameter(self) -> float:
        """The diameter of the nozzle exit."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_nozzle_exit_diameter_metadata)

    _set_nozzle_exit_diameter_metadata = { "name" : "nozzle_exit_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @nozzle_exit_diameter.setter
    def nozzle_exit_diameter(self, newVal:float) -> None:
        """The diameter of the nozzle exit."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_nozzle_exit_diameter_metadata, newVal)

    _get_combustion_chamber_pressure_metadata = { "name" : "combustion_chamber_pressure",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def combustion_chamber_pressure(self) -> float:
        """The pressure in the combustion chamber."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_combustion_chamber_pressure_metadata)

    _set_combustion_chamber_pressure_metadata = { "name" : "combustion_chamber_pressure",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @combustion_chamber_pressure.setter
    def combustion_chamber_pressure(self, newVal:float) -> None:
        """The pressure in the combustion chamber."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_combustion_chamber_pressure_metadata, newVal)

    _get_propellant_specific_heat_ratio_metadata = { "name" : "propellant_specific_heat_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def propellant_specific_heat_ratio(self) -> float:
        """The ratio of the propellant's constant-pressure specific heat to the constant volume specific heat."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_propellant_specific_heat_ratio_metadata)

    _set_propellant_specific_heat_ratio_metadata = { "name" : "propellant_specific_heat_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @propellant_specific_heat_ratio.setter
    def propellant_specific_heat_ratio(self, newVal:float) -> None:
        """The ratio of the propellant's constant-pressure specific heat to the constant volume specific heat."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_propellant_specific_heat_ratio_metadata, newVal)

    _get_propellant_characteristic_velocity_metadata = { "name" : "propellant_characteristic_velocity",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def propellant_characteristic_velocity(self) -> float:
        """The propellant's characteristic velocity (Chamber Pressure * Throat Area / Mass Flow Rate of the engine)."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_propellant_characteristic_velocity_metadata)

    _set_propellant_characteristic_velocity_metadata = { "name" : "propellant_characteristic_velocity",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @propellant_characteristic_velocity.setter
    def propellant_characteristic_velocity(self, newVal:float) -> None:
        """The propellant's characteristic velocity (Chamber Pressure * Throat Area / Mass Flow Rate of the engine)."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_propellant_characteristic_velocity_metadata, newVal)

    _get_use_boost_sustain_mode_metadata = { "name" : "use_boost_sustain_mode",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_boost_sustain_mode(self) -> bool:
        """Opt for the engine to use a boost phase to achieve a target velocity and then transition to a sustenance phase."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_use_boost_sustain_mode_metadata)

    _set_use_boost_sustain_mode_metadata = { "name" : "use_boost_sustain_mode",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_boost_sustain_mode.setter
    def use_boost_sustain_mode(self, newVal:bool) -> None:
        """Opt for the engine to use a boost phase to achieve a target velocity and then transition to a sustenance phase."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_use_boost_sustain_mode_metadata, newVal)

    _get_boost_fuel_fraction_metadata = { "name" : "boost_fuel_fraction",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def boost_fuel_fraction(self) -> float:
        """The amount of fuel that is consumed during the boost phase."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_boost_fuel_fraction_metadata)

    _set_boost_fuel_fraction_metadata = { "name" : "boost_fuel_fraction",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @boost_fuel_fraction.setter
    def boost_fuel_fraction(self, newVal:float) -> None:
        """The amount of fuel that is consumed during the boost phase."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_boost_fuel_fraction_metadata, newVal)

    _get_boost_chamber_pressure_metadata = { "name" : "boost_chamber_pressure",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def boost_chamber_pressure(self) -> float:
        """The combustion chamber pressure during the boost phase."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_boost_chamber_pressure_metadata)

    _set_boost_chamber_pressure_metadata = { "name" : "boost_chamber_pressure",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @boost_chamber_pressure.setter
    def boost_chamber_pressure(self, newVal:float) -> None:
        """The combustion chamber pressure during the boost phase."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_boost_chamber_pressure_metadata, newVal)

    _get_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.get_property(IMissileRocketProp._metadata, IMissileRocketProp._get_no_thrust_when_no_fuel_metadata)

    _set_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.set_property(IMissileRocketProp._metadata, IMissileRocketProp._set_no_thrust_when_no_fuel_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{4aa12da8-8ff9-40f4-bbf7-1e09aa7f04f8}", IMissileRocketProp)
agcls.AgTypeNameMap["IMissileRocketProp"] = IMissileRocketProp

class IMissileTurbojetProp(object):
    """Interface used to access the Turbojet propulsion options for a missile."""
    _num_methods = 30
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7d849783-6cbc-442e-aec8-4137fb673619}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_design_mach" : 1,
                             "set_design_mach" : 2,
                             "get_design_altitude" : 3,
                             "set_design_altitude" : 4,
                             "get_design_thrust" : 5,
                             "set_design_thrust" : 6,
                             "get_turbine_temp" : 7,
                             "set_turbine_temp" : 8,
                             "get_compressor_pressure_ratio" : 9,
                             "set_compressor_pressure_ratio" : 10,
                             "get_fuel_heating_value" : 11,
                             "set_fuel_heating_value" : 12,
                             "get_inlet_subsonic_pressure_ratio" : 13,
                             "set_inlet_subsonic_pressure_ratio" : 14,
                             "get_burner_pressure_ratio" : 15,
                             "set_burner_pressure_ratio" : 16,
                             "get_nozzle_pressure_ratio" : 17,
                             "set_nozzle_pressure_ratio" : 18,
                             "get_p_0over_p9" : 19,
                             "set_p_0over_p9" : 20,
                             "get_compressor_efficiency" : 21,
                             "set_compressor_efficiency" : 22,
                             "get_turbine_efficiency" : 23,
                             "set_turbine_efficiency" : 24,
                             "get_burner_efficiency" : 25,
                             "set_burner_efficiency" : 26,
                             "get_mechanical_efficiency" : 27,
                             "set_mechanical_efficiency" : 28,
                             "get_no_thrust_when_no_fuel" : 29,
                             "set_no_thrust_when_no_fuel" : 30, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileTurbojetProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileTurbojetProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileTurbojetProp.__dict__ and type(IMissileTurbojetProp.__dict__[attrname]) == property:
            return IMissileTurbojetProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileTurbojetProp.")
    
    _get_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_design_mach_metadata)

    _set_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_design_mach_metadata, newVal)

    _get_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_design_altitude_metadata)

    _set_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_design_altitude_metadata, newVal)

    _get_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_design_thrust_metadata)

    _set_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_design_thrust_metadata, newVal)

    _get_turbine_temp_metadata = { "name" : "turbine_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turbine_temp(self) -> float:
        """The maximum temperature that the turbine material can support."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_turbine_temp_metadata)

    _set_turbine_temp_metadata = { "name" : "turbine_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @turbine_temp.setter
    def turbine_temp(self, newVal:float) -> None:
        """The maximum temperature that the turbine material can support."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_turbine_temp_metadata, newVal)

    _get_compressor_pressure_ratio_metadata = { "name" : "compressor_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def compressor_pressure_ratio(self) -> float:
        """The maximum compressor pressure ratio."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_compressor_pressure_ratio_metadata)

    _set_compressor_pressure_ratio_metadata = { "name" : "compressor_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @compressor_pressure_ratio.setter
    def compressor_pressure_ratio(self, newVal:float) -> None:
        """The maximum compressor pressure ratio."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_compressor_pressure_ratio_metadata, newVal)

    _get_fuel_heating_value_metadata = { "name" : "fuel_heating_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_heating_value(self) -> float:
        """The heating value of the fuel."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_fuel_heating_value_metadata)

    _set_fuel_heating_value_metadata = { "name" : "fuel_heating_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_heating_value.setter
    def fuel_heating_value(self, newVal:float) -> None:
        """The heating value of the fuel."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_fuel_heating_value_metadata, newVal)

    _get_inlet_subsonic_pressure_ratio_metadata = { "name" : "inlet_subsonic_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def inlet_subsonic_pressure_ratio(self) -> float:
        """The subsonic pressure ratio from the inlet exit to the entrance."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_inlet_subsonic_pressure_ratio_metadata)

    _set_inlet_subsonic_pressure_ratio_metadata = { "name" : "inlet_subsonic_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @inlet_subsonic_pressure_ratio.setter
    def inlet_subsonic_pressure_ratio(self, newVal:float) -> None:
        """The subsonic pressure ratio from the inlet exit to the entrance."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_inlet_subsonic_pressure_ratio_metadata, newVal)

    _get_burner_pressure_ratio_metadata = { "name" : "burner_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def burner_pressure_ratio(self) -> float:
        """The pressure ratio from the burner exit to the entrance."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_burner_pressure_ratio_metadata)

    _set_burner_pressure_ratio_metadata = { "name" : "burner_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @burner_pressure_ratio.setter
    def burner_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the burner exit to the entrance."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_burner_pressure_ratio_metadata, newVal)

    _get_nozzle_pressure_ratio_metadata = { "name" : "nozzle_pressure_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def nozzle_pressure_ratio(self) -> float:
        """The pressure ratio from the nozzle exit to the entrance."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_nozzle_pressure_ratio_metadata)

    _set_nozzle_pressure_ratio_metadata = { "name" : "nozzle_pressure_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @nozzle_pressure_ratio.setter
    def nozzle_pressure_ratio(self, newVal:float) -> None:
        """The pressure ratio from the nozzle exit to the entrance."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_nozzle_pressure_ratio_metadata, newVal)

    _get_p_0over_p9_metadata = { "name" : "p_0over_p9",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def p_0over_p9(self) -> float:
        """The pressure ratio from ambient conditions to the engine exit."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_p_0over_p9_metadata)

    _set_p_0over_p9_metadata = { "name" : "p_0over_p9",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @p_0over_p9.setter
    def p_0over_p9(self, newVal:float) -> None:
        """The pressure ratio from ambient conditions to the engine exit."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_p_0over_p9_metadata, newVal)

    _get_compressor_efficiency_metadata = { "name" : "compressor_efficiency",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def compressor_efficiency(self) -> float:
        """The efficiency of the compressor."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_compressor_efficiency_metadata)

    _set_compressor_efficiency_metadata = { "name" : "compressor_efficiency",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @compressor_efficiency.setter
    def compressor_efficiency(self, newVal:float) -> None:
        """The efficiency of the compressor."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_compressor_efficiency_metadata, newVal)

    _get_turbine_efficiency_metadata = { "name" : "turbine_efficiency",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turbine_efficiency(self) -> float:
        """The efficiency of the turbine."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_turbine_efficiency_metadata)

    _set_turbine_efficiency_metadata = { "name" : "turbine_efficiency",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @turbine_efficiency.setter
    def turbine_efficiency(self, newVal:float) -> None:
        """The efficiency of the turbine."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_turbine_efficiency_metadata, newVal)

    _get_burner_efficiency_metadata = { "name" : "burner_efficiency",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def burner_efficiency(self) -> float:
        """The efficiency of the burner."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_burner_efficiency_metadata)

    _set_burner_efficiency_metadata = { "name" : "burner_efficiency",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @burner_efficiency.setter
    def burner_efficiency(self, newVal:float) -> None:
        """The efficiency of the burner."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_burner_efficiency_metadata, newVal)

    _get_mechanical_efficiency_metadata = { "name" : "mechanical_efficiency",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def mechanical_efficiency(self) -> float:
        """The mechanical efficiency of the engine."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_mechanical_efficiency_metadata)

    _set_mechanical_efficiency_metadata = { "name" : "mechanical_efficiency",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @mechanical_efficiency.setter
    def mechanical_efficiency(self, newVal:float) -> None:
        """The mechanical efficiency of the engine."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_mechanical_efficiency_metadata, newVal)

    _get_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def no_thrust_when_no_fuel(self) -> bool:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.get_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._get_no_thrust_when_no_fuel_metadata)

    _set_no_thrust_when_no_fuel_metadata = { "name" : "no_thrust_when_no_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @no_thrust_when_no_fuel.setter
    def no_thrust_when_no_fuel(self, pVal:bool) -> None:
        """Opt to have no thrust if the fuel is empty."""
        return self._intf.set_property(IMissileTurbojetProp._metadata, IMissileTurbojetProp._set_no_thrust_when_no_fuel_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{7d849783-6cbc-442e-aec8-4137fb673619}", IMissileTurbojetProp)
agcls.AgTypeNameMap["IMissileTurbojetProp"] = IMissileTurbojetProp

class IRotorcraftModel(object):
    """Interface used to access the rotorcraft options in the Aviator catalog."""
    _num_methods = 44
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{34b21f79-51d4-4687-8d0f-9ae1d8ac063c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_altitude" : 1,
                             "set_max_altitude" : 2,
                             "get_default_cruise_altitude" : 3,
                             "set_default_cruise_altitude" : 4,
                             "get_descent_rate_factor" : 5,
                             "set_descent_rate_factor" : 6,
                             "get_max_climb_angle" : 7,
                             "set_max_climb_angle" : 8,
                             "get_climb_at_cruise_airspeed" : 9,
                             "set_climb_at_cruise_airspeed" : 10,
                             "get_max_descent_angle" : 11,
                             "set_max_descent_angle" : 12,
                             "get_min_descent_rate" : 13,
                             "set_min_descent_rate" : 14,
                             "get_max_load_factor" : 15,
                             "set_max_load_factor" : 16,
                             "get_roll_rate" : 17,
                             "set_roll_rate" : 18,
                             "get_pitch_rate" : 19,
                             "set_pitch_rate" : 20,
                             "get_yaw_rate" : 21,
                             "set_yaw_rate" : 22,
                             "get_yaw_rate_dot" : 23,
                             "set_yaw_rate_dot" : 24,
                             "get_max_transition_pitch_angle" : 25,
                             "set_max_transition_pitch_angle" : 26,
                             "get_tf_max_flight_path_angle" : 27,
                             "set_tf_max_flight_path_angle" : 28,
                             "get_tf_terrain_window" : 29,
                             "set_tf_terrain_window" : 30,
                             "get_compute_delta_altitude" : 31,
                             "set_compute_delta_altitude" : 32,
                             "get_max_safe_airspeed" : 33,
                             "get_max_safe_airspeed_type" : 34,
                             "set_max_safe_airspeed" : 35,
                             "get_max_safe_translation_speed" : 36,
                             "get_max_safe_translation_speed_type" : 37,
                             "set_max_safe_translation_speed" : 38,
                             "get_ignore_fpa_for_climb_descent_transitions" : 39,
                             "set_ignore_fpa_for_climb_descent_transitions" : 40,
                             "get_default_configuration" : 41,
                             "get_aerodynamics" : 42,
                             "get_propulsion" : 43,
                             "get_as_catalog_item" : 44, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IRotorcraftModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftModel.__dict__ and type(IRotorcraftModel.__dict__[attrname]) == property:
            return IRotorcraftModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftModel.")
    
    _get_max_altitude_metadata = { "name" : "max_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_altitude(self) -> float:
        """The maximum altitude at which the rotorcraft is capable of operating."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_altitude_metadata)

    _set_max_altitude_metadata = { "name" : "max_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_altitude.setter
    def max_altitude(self, newVal:float) -> None:
        """The maximum altitude at which the rotorcraft is capable of operating."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_max_altitude_metadata, newVal)

    _get_default_cruise_altitude_metadata = { "name" : "default_cruise_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def default_cruise_altitude(self) -> float:
        """The rotorcraft's default cruising altitude."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_default_cruise_altitude_metadata)

    _set_default_cruise_altitude_metadata = { "name" : "default_cruise_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @default_cruise_altitude.setter
    def default_cruise_altitude(self, newVal:float) -> None:
        """The rotorcraft's default cruising altitude."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_default_cruise_altitude_metadata, newVal)

    _get_descent_rate_factor_metadata = { "name" : "descent_rate_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def descent_rate_factor(self) -> float:
        """The descent rate of the rotorcraft as a factor multiplied by the altitude change rate calculated at zero throttle."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_descent_rate_factor_metadata)

    _set_descent_rate_factor_metadata = { "name" : "descent_rate_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @descent_rate_factor.setter
    def descent_rate_factor(self, newVal:float) -> None:
        """The descent rate of the rotorcraft as a factor multiplied by the altitude change rate calculated at zero throttle."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_descent_rate_factor_metadata, newVal)

    _get_max_climb_angle_metadata = { "name" : "max_climb_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_climb_angle(self) -> typing.Any:
        """The maximum pitch angle of the rotorcraft's flight path while climbing."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_climb_angle_metadata)

    _set_max_climb_angle_metadata = { "name" : "max_climb_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_climb_angle.setter
    def max_climb_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the rotorcraft's flight path while climbing."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_max_climb_angle_metadata, newVal)

    _get_climb_at_cruise_airspeed_metadata = { "name" : "climb_at_cruise_airspeed",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def climb_at_cruise_airspeed(self) -> bool:
        """Select to define the climbing airspeed of the rotorcraft using the cruise airspeed of the current procedure."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_climb_at_cruise_airspeed_metadata)

    _set_climb_at_cruise_airspeed_metadata = { "name" : "climb_at_cruise_airspeed",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @climb_at_cruise_airspeed.setter
    def climb_at_cruise_airspeed(self, newVal:bool) -> None:
        """Select to define the climbing airspeed of the rotorcraft using the cruise airspeed of the current procedure."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_climb_at_cruise_airspeed_metadata, newVal)

    _get_max_descent_angle_metadata = { "name" : "max_descent_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_descent_angle(self) -> typing.Any:
        """The maximum pitch angle of the rotorcraft's flight path while descending."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_descent_angle_metadata)

    _set_max_descent_angle_metadata = { "name" : "max_descent_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_descent_angle.setter
    def max_descent_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the rotorcraft's flight path while descending."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_max_descent_angle_metadata, newVal)

    _get_min_descent_rate_metadata = { "name" : "min_descent_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_descent_rate(self) -> float:
        """The minimum rate at which the aircraft will descend once established in a steady descent."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_min_descent_rate_metadata)

    _set_min_descent_rate_metadata = { "name" : "min_descent_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_descent_rate.setter
    def min_descent_rate(self, newVal:float) -> None:
        """The minimum rate at which the aircraft will descend once established in a steady descent."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_min_descent_rate_metadata, newVal)

    _get_max_load_factor_metadata = { "name" : "max_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_load_factor(self) -> float:
        """The maximum load factor that the aircraft can bear while maneuvering in formation."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_load_factor_metadata)

    _set_max_load_factor_metadata = { "name" : "max_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_load_factor.setter
    def max_load_factor(self, newVal:float) -> None:
        """The maximum load factor that the aircraft can bear while maneuvering in formation."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_max_load_factor_metadata, newVal)

    _get_roll_rate_metadata = { "name" : "roll_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_rate(self) -> typing.Any:
        """The standard roll rate of the rotorcraft in a turn."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_roll_rate_metadata)

    _set_roll_rate_metadata = { "name" : "roll_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_rate.setter
    def roll_rate(self, newVal:typing.Any) -> None:
        """The standard roll rate of the rotorcraft in a turn."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_roll_rate_metadata, newVal)

    _get_pitch_rate_metadata = { "name" : "pitch_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def pitch_rate(self) -> typing.Any:
        """The pitch rate when transitioning between attitude modes or procedures."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_pitch_rate_metadata)

    _set_pitch_rate_metadata = { "name" : "pitch_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @pitch_rate.setter
    def pitch_rate(self, newVal:typing.Any) -> None:
        """The pitch rate when transitioning between attitude modes or procedures."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_pitch_rate_metadata, newVal)

    _get_yaw_rate_metadata = { "name" : "yaw_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def yaw_rate(self) -> typing.Any:
        """The yaw rate when transitioning between attitude modes."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_yaw_rate_metadata)

    _set_yaw_rate_metadata = { "name" : "yaw_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @yaw_rate.setter
    def yaw_rate(self, newVal:typing.Any) -> None:
        """The yaw rate when transitioning between attitude modes."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_yaw_rate_metadata, newVal)

    _get_yaw_rate_dot_metadata = { "name" : "yaw_rate_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def yaw_rate_dot(self) -> typing.Any:
        """The rate of change of the yaw rate."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_yaw_rate_dot_metadata)

    _set_yaw_rate_dot_metadata = { "name" : "yaw_rate_dot",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @yaw_rate_dot.setter
    def yaw_rate_dot(self, newVal:typing.Any) -> None:
        """The rate of change of the yaw rate."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_yaw_rate_dot_metadata, newVal)

    _get_max_transition_pitch_angle_metadata = { "name" : "max_transition_pitch_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_transition_pitch_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path when transitioning between forward flight and hovering."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_transition_pitch_angle_metadata)

    _set_max_transition_pitch_angle_metadata = { "name" : "max_transition_pitch_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_transition_pitch_angle.setter
    def max_transition_pitch_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path when transitioning between forward flight and hovering."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_max_transition_pitch_angle_metadata, newVal)

    _get_tf_max_flight_path_angle_metadata = { "name" : "tf_max_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def tf_max_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path when the rotorcraft is engaged in terrain following flight."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_tf_max_flight_path_angle_metadata)

    _set_tf_max_flight_path_angle_metadata = { "name" : "tf_max_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @tf_max_flight_path_angle.setter
    def tf_max_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path when the rotorcraft is engaged in terrain following flight."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_tf_max_flight_path_angle_metadata, newVal)

    _get_tf_terrain_window_metadata = { "name" : "tf_terrain_window",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tf_terrain_window(self) -> float:
        """The time interval over which terrain points are sampled when the rotorcraft is engaged in terrain following flight."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_tf_terrain_window_metadata)

    _set_tf_terrain_window_metadata = { "name" : "tf_terrain_window",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tf_terrain_window.setter
    def tf_terrain_window(self, newVal:float) -> None:
        """The time interval over which terrain points are sampled when the rotorcraft is engaged in terrain following flight."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_tf_terrain_window_metadata, newVal)

    _get_compute_delta_altitude_metadata = { "name" : "compute_delta_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def compute_delta_altitude(self) -> float:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_compute_delta_altitude_metadata)

    _set_compute_delta_altitude_metadata = { "name" : "compute_delta_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @compute_delta_altitude.setter
    def compute_delta_altitude(self, newVal:float) -> None:
        """The maximum change in altitude in a computed segment before the data is sampled again."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_compute_delta_altitude_metadata, newVal)

    _get_max_safe_airspeed_metadata = { "name" : "max_safe_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_safe_airspeed(self) -> float:
        """The maximum cruising airspeed of the rotorcraft."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_safe_airspeed_metadata)

    _get_max_safe_airspeed_type_metadata = { "name" : "max_safe_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def max_safe_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The maximum safe airspeed type."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_safe_airspeed_type_metadata)

    _set_max_safe_airspeed_metadata = { "name" : "set_max_safe_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_max_safe_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the maximum safe airspeed and airspeed type."""
        return self._intf.invoke(IRotorcraftModel._metadata, IRotorcraftModel._set_max_safe_airspeed_metadata, airspeedType, airspeed)

    _get_max_safe_translation_speed_metadata = { "name" : "max_safe_translation_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_safe_translation_speed(self) -> float:
        """The maximum translation speed of the rotorcraft."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_safe_translation_speed_metadata)

    _get_max_safe_translation_speed_type_metadata = { "name" : "max_safe_translation_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def max_safe_translation_speed_type(self) -> "AIRSPEED_TYPE":
        """The maximum safe translation speed type."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_max_safe_translation_speed_type_metadata)

    _set_max_safe_translation_speed_metadata = { "name" : "set_max_safe_translation_speed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_max_safe_translation_speed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the maximum safe translation airspeed and airspeed type."""
        return self._intf.invoke(IRotorcraftModel._metadata, IRotorcraftModel._set_max_safe_translation_speed_metadata, airspeedType, airspeed)

    _get_ignore_fpa_for_climb_descent_transitions_metadata = { "name" : "ignore_fpa_for_climb_descent_transitions",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ignore_fpa_for_climb_descent_transitions(self) -> bool:
        """Opt to ignore load factor limits when pushing over or pulling up."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_ignore_fpa_for_climb_descent_transitions_metadata)

    _set_ignore_fpa_for_climb_descent_transitions_metadata = { "name" : "ignore_fpa_for_climb_descent_transitions",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ignore_fpa_for_climb_descent_transitions.setter
    def ignore_fpa_for_climb_descent_transitions(self, newVal:bool) -> None:
        """Opt to ignore load factor limits when pushing over or pulling up."""
        return self._intf.set_property(IRotorcraftModel._metadata, IRotorcraftModel._set_ignore_fpa_for_climb_descent_transitions_metadata, newVal)

    _get_default_configuration_metadata = { "name" : "default_configuration",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def default_configuration(self) -> "Configuration":
        """The aircraft's default configuration as saved in the catalog."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_default_configuration_metadata)

    _get_aerodynamics_metadata = { "name" : "aerodynamics",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aerodynamics(self) -> "RotorcraftAero":
        """Get the aerodynamics interface."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_aerodynamics_metadata)

    _get_propulsion_metadata = { "name" : "propulsion",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def propulsion(self) -> "RotorcraftProp":
        """Get the propulsion interface."""
        return self._intf.get_property(IRotorcraftModel._metadata, IRotorcraftModel._get_propulsion_metadata)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IRotorcraftModel._metadata, IRotorcraftModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{34b21f79-51d4-4687-8d0f-9ae1d8ac063c}", IRotorcraftModel)
agcls.AgTypeNameMap["IRotorcraftModel"] = IRotorcraftModel

class IRotorcraftAero(object):
    """Interface used to access the aerodynamics options for a rotorcraft."""
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{76dc620d-2f8f-49ce-b043-7f502815bcb3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_rotor_count" : 1,
                             "set_rotor_count" : 2,
                             "get_rotor_diameter" : 3,
                             "set_rotor_diameter" : 4,
                             "get_blades_per_rotor" : 5,
                             "set_blades_per_rotor" : 6,
                             "get_blade_chord" : 7,
                             "set_blade_chord" : 8,
                             "get_rotor_tip_mach" : 9,
                             "set_rotor_tip_mach" : 10,
                             "get_fuselage_flat_plate_area" : 11,
                             "set_fuselage_flat_plate_area" : 12,
                             "get_tail_rotor_offset" : 13,
                             "set_tail_rotor_offset" : 14,
                             "get_tail_rotor_diameter" : 15,
                             "set_tail_rotor_diameter" : 16,
                             "get_blade_profile_drag_cd0" : 17,
                             "set_blade_profile_drag_cd0" : 18,
                             "get_blade_profile_drag_k" : 19,
                             "set_blade_profile_drag_k" : 20,
                             "get_induced_power_correction_factor" : 21,
                             "set_induced_power_correction_factor" : 22, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IRotorcraftAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftAero.__dict__ and type(IRotorcraftAero.__dict__[attrname]) == property:
            return IRotorcraftAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftAero.")
    
    _get_rotor_count_metadata = { "name" : "rotor_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def rotor_count(self) -> int:
        """The number of rotors."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_rotor_count_metadata)

    _set_rotor_count_metadata = { "name" : "rotor_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @rotor_count.setter
    def rotor_count(self, newVal:int) -> None:
        """The number of rotors."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_rotor_count_metadata, newVal)

    _get_rotor_diameter_metadata = { "name" : "rotor_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def rotor_diameter(self) -> float:
        """The diameter of the rotor."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_rotor_diameter_metadata)

    _set_rotor_diameter_metadata = { "name" : "rotor_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @rotor_diameter.setter
    def rotor_diameter(self, newVal:float) -> None:
        """The diameter of the rotor."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_rotor_diameter_metadata, newVal)

    _get_blades_per_rotor_metadata = { "name" : "blades_per_rotor",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def blades_per_rotor(self) -> int:
        """The number of blades on each rotor."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_blades_per_rotor_metadata)

    _set_blades_per_rotor_metadata = { "name" : "blades_per_rotor",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @blades_per_rotor.setter
    def blades_per_rotor(self, newVal:int) -> None:
        """The number of blades on each rotor."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_blades_per_rotor_metadata, newVal)

    _get_blade_chord_metadata = { "name" : "blade_chord",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def blade_chord(self) -> float:
        """The chord length of the blade."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_blade_chord_metadata)

    _set_blade_chord_metadata = { "name" : "blade_chord",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @blade_chord.setter
    def blade_chord(self, newVal:float) -> None:
        """The chord length of the blade."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_blade_chord_metadata, newVal)

    _get_rotor_tip_mach_metadata = { "name" : "rotor_tip_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def rotor_tip_mach(self) -> float:
        """The Mach number of the advancing blade tip."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_rotor_tip_mach_metadata)

    _set_rotor_tip_mach_metadata = { "name" : "rotor_tip_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @rotor_tip_mach.setter
    def rotor_tip_mach(self, newVal:float) -> None:
        """The Mach number of the advancing blade tip."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_rotor_tip_mach_metadata, newVal)

    _get_fuselage_flat_plate_area_metadata = { "name" : "fuselage_flat_plate_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuselage_flat_plate_area(self) -> float:
        """The flat plate area for the fuselage."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_fuselage_flat_plate_area_metadata)

    _set_fuselage_flat_plate_area_metadata = { "name" : "fuselage_flat_plate_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuselage_flat_plate_area.setter
    def fuselage_flat_plate_area(self, newVal:float) -> None:
        """The flat plate area for the fuselage."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_fuselage_flat_plate_area_metadata, newVal)

    _get_tail_rotor_offset_metadata = { "name" : "tail_rotor_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tail_rotor_offset(self) -> float:
        """The offset of the tail rotor."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_tail_rotor_offset_metadata)

    _set_tail_rotor_offset_metadata = { "name" : "tail_rotor_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tail_rotor_offset.setter
    def tail_rotor_offset(self, newVal:float) -> None:
        """The offset of the tail rotor."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_tail_rotor_offset_metadata, newVal)

    _get_tail_rotor_diameter_metadata = { "name" : "tail_rotor_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tail_rotor_diameter(self) -> float:
        """The diameter of the tail rotor."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_tail_rotor_diameter_metadata)

    _set_tail_rotor_diameter_metadata = { "name" : "tail_rotor_diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tail_rotor_diameter.setter
    def tail_rotor_diameter(self, newVal:float) -> None:
        """The diameter of the tail rotor."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_tail_rotor_diameter_metadata, newVal)

    _get_blade_profile_drag_cd0_metadata = { "name" : "blade_profile_drag_cd0",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def blade_profile_drag_cd0(self) -> float:
        """The drag coefficient when the rotor disc does not generate any lift."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_blade_profile_drag_cd0_metadata)

    _set_blade_profile_drag_cd0_metadata = { "name" : "blade_profile_drag_cd0",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @blade_profile_drag_cd0.setter
    def blade_profile_drag_cd0(self, newVal:float) -> None:
        """The drag coefficient when the rotor disc does not generate any lift."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_blade_profile_drag_cd0_metadata, newVal)

    _get_blade_profile_drag_k_metadata = { "name" : "blade_profile_drag_k",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def blade_profile_drag_k(self) -> float:
        """The induced drag coefficient, which accounts for how lift generation impacts drag."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_blade_profile_drag_k_metadata)

    _set_blade_profile_drag_k_metadata = { "name" : "blade_profile_drag_k",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @blade_profile_drag_k.setter
    def blade_profile_drag_k(self, newVal:float) -> None:
        """The induced drag coefficient, which accounts for how lift generation impacts drag."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_blade_profile_drag_k_metadata, newVal)

    _get_induced_power_correction_factor_metadata = { "name" : "induced_power_correction_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def induced_power_correction_factor(self) -> float:
        """The slop factor that accounts for losses."""
        return self._intf.get_property(IRotorcraftAero._metadata, IRotorcraftAero._get_induced_power_correction_factor_metadata)

    _set_induced_power_correction_factor_metadata = { "name" : "induced_power_correction_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @induced_power_correction_factor.setter
    def induced_power_correction_factor(self, newVal:float) -> None:
        """The slop factor that accounts for losses."""
        return self._intf.set_property(IRotorcraftAero._metadata, IRotorcraftAero._set_induced_power_correction_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{76dc620d-2f8f-49ce-b043-7f502815bcb3}", IRotorcraftAero)
agcls.AgTypeNameMap["IRotorcraftAero"] = IRotorcraftAero

class IRotorcraftProp(object):
    """Interface used to access the Propulsion options for a rotorcraft."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{83f50978-efae-48fd-b5e7-df4f1a487aac}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_powerplant_type" : 1,
                             "set_powerplant_type" : 2,
                             "get_max_sl_power" : 3,
                             "set_max_sl_power" : 4,
                             "get_max_sl_fuel_flow" : 5,
                             "set_max_sl_fuel_flow" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IRotorcraftProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftProp.__dict__ and type(IRotorcraftProp.__dict__[attrname]) == property:
            return IRotorcraftProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftProp.")
    
    _get_powerplant_type_metadata = { "name" : "powerplant_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ROTORCRAFT_POWERPLANT_TYPE),) }
    @property
    def powerplant_type(self) -> "ROTORCRAFT_POWERPLANT_TYPE":
        """The rotorcraft's powerplant type."""
        return self._intf.get_property(IRotorcraftProp._metadata, IRotorcraftProp._get_powerplant_type_metadata)

    _set_powerplant_type_metadata = { "name" : "powerplant_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ROTORCRAFT_POWERPLANT_TYPE),) }
    @powerplant_type.setter
    def powerplant_type(self, newVal:"ROTORCRAFT_POWERPLANT_TYPE") -> None:
        """The rotorcraft's powerplant type."""
        return self._intf.set_property(IRotorcraftProp._metadata, IRotorcraftProp._set_powerplant_type_metadata, newVal)

    _get_max_sl_power_metadata = { "name" : "max_sl_power",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_sl_power(self) -> float:
        """The maximum power at sea level."""
        return self._intf.get_property(IRotorcraftProp._metadata, IRotorcraftProp._get_max_sl_power_metadata)

    _set_max_sl_power_metadata = { "name" : "max_sl_power",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_sl_power.setter
    def max_sl_power(self, newVal:float) -> None:
        """The maximum power at sea level."""
        return self._intf.set_property(IRotorcraftProp._metadata, IRotorcraftProp._set_max_sl_power_metadata, newVal)

    _get_max_sl_fuel_flow_metadata = { "name" : "max_sl_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_sl_fuel_flow(self) -> float:
        """The maximum fuel flow at sea level."""
        return self._intf.get_property(IRotorcraftProp._metadata, IRotorcraftProp._get_max_sl_fuel_flow_metadata)

    _set_max_sl_fuel_flow_metadata = { "name" : "max_sl_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_sl_fuel_flow.setter
    def max_sl_fuel_flow(self, newVal:float) -> None:
        """The maximum fuel flow at sea level."""
        return self._intf.set_property(IRotorcraftProp._metadata, IRotorcraftProp._set_max_sl_fuel_flow_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{83f50978-efae-48fd-b5e7-df4f1a487aac}", IRotorcraftProp)
agcls.AgTypeNameMap["IRotorcraftProp"] = IRotorcraftProp

class IUserRunwaySource(object):
    """Interface used to access the user runways in the Aviator catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{684e58b2-17da-40e6-ab75-00f965dc947c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_user_runway" : 1,
                             "add_user_runway" : 2,
                             "get_as_catalog_source" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IUserRunwaySource._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IUserRunwaySource from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserRunwaySource.__dict__ and type(IUserRunwaySource.__dict__[attrname]) == property:
            return IUserRunwaySource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserRunwaySource.")
    
    _get_user_runway_metadata = { "name" : "get_user_runway",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_user_runway(self, name:str) -> "UserRunway":
        """Gets the user runway with the given name."""
        return self._intf.invoke(IUserRunwaySource._metadata, IUserRunwaySource._get_user_runway_metadata, name, out_arg())

    _add_user_runway_metadata = { "name" : "add_user_runway",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_user_runway(self, name:str) -> "UserRunway":
        """Creates a new user runway with the given name."""
        return self._intf.invoke(IUserRunwaySource._metadata, IUserRunwaySource._add_user_runway_metadata, name, out_arg())

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IUserRunwaySource._metadata, IUserRunwaySource._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{684e58b2-17da-40e6-ab75-00f965dc947c}", IUserRunwaySource)
agcls.AgTypeNameMap["IUserRunwaySource"] = IUserRunwaySource

class IUserRunway(object):
    """Interface used to access a user runway in the Aviator catalog."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{74B0531F-504B-42E6-A8AF-7A6B891A88F8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_catalog_item" : 1,
                             "get_altitude" : 2,
                             "set_altitude" : 3,
                             "get_terrain_altitude" : 4,
                             "get_latitude" : 5,
                             "set_latitude" : 6,
                             "get_longitude" : 7,
                             "set_longitude" : 8,
                             "get_length" : 9,
                             "set_length" : 10,
                             "get_low_end_heading" : 11,
                             "set_low_end_heading" : 12,
                             "get_high_end_heading" : 13,
                             "set_high_end_heading" : 14,
                             "get_is_magnetic" : 15,
                             "set_is_magnetic" : 16,
                             "copy_site" : 17,
                             "paste_site" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IUserRunway._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IUserRunway from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserRunway.__dict__ and type(IUserRunway.__dict__[attrname]) == property:
            return IUserRunway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserRunway.")
    
    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IUserRunway._metadata, IUserRunway._get_as_catalog_item_metadata, out_arg())

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The runway altitude."""
        return self._intf.get_property(IUserRunway._metadata, IUserRunway._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The runway altitude."""
        return self._intf.set_property(IUserRunway._metadata, IUserRunway._set_altitude_metadata, newVal)

    _get_terrain_altitude_metadata = { "name" : "get_terrain_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def get_terrain_altitude(self) -> float:
        """Set the runway altitude to the terrain altitude."""
        return self._intf.invoke(IUserRunway._metadata, IUserRunway._get_terrain_altitude_metadata, out_arg())

    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def latitude(self) -> typing.Any:
        """The runway latitude."""
        return self._intf.get_property(IUserRunway._metadata, IUserRunway._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The runway latitude."""
        return self._intf.set_property(IUserRunway._metadata, IUserRunway._set_latitude_metadata, newVal)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def longitude(self) -> typing.Any:
        """The runway longitude."""
        return self._intf.get_property(IUserRunway._metadata, IUserRunway._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The runway longitude."""
        return self._intf.set_property(IUserRunway._metadata, IUserRunway._set_longitude_metadata, newVal)

    _get_length_metadata = { "name" : "length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def length(self) -> float:
        """The length of the runway"""
        return self._intf.get_property(IUserRunway._metadata, IUserRunway._get_length_metadata)

    _set_length_metadata = { "name" : "length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @length.setter
    def length(self, newVal:float) -> None:
        """The length of the runway"""
        return self._intf.set_property(IUserRunway._metadata, IUserRunway._set_length_metadata, newVal)

    _get_low_end_heading_metadata = { "name" : "low_end_heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def low_end_heading(self) -> typing.Any:
        """The low end heading of the runway."""
        return self._intf.get_property(IUserRunway._metadata, IUserRunway._get_low_end_heading_metadata)

    _set_low_end_heading_metadata = { "name" : "low_end_heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @low_end_heading.setter
    def low_end_heading(self, newVal:typing.Any) -> None:
        """The low end heading of the runway."""
        return self._intf.set_property(IUserRunway._metadata, IUserRunway._set_low_end_heading_metadata, newVal)

    _get_high_end_heading_metadata = { "name" : "high_end_heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def high_end_heading(self) -> typing.Any:
        """The high end heading of the runway."""
        return self._intf.get_property(IUserRunway._metadata, IUserRunway._get_high_end_heading_metadata)

    _set_high_end_heading_metadata = { "name" : "high_end_heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @high_end_heading.setter
    def high_end_heading(self, newVal:typing.Any) -> None:
        """The high end heading of the runway."""
        return self._intf.set_property(IUserRunway._metadata, IUserRunway._set_high_end_heading_metadata, newVal)

    _get_is_magnetic_metadata = { "name" : "is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_magnetic(self) -> bool:
        """Opt whether to use a magnetic heading for the runway heading."""
        return self._intf.get_property(IUserRunway._metadata, IUserRunway._get_is_magnetic_metadata)

    _set_is_magnetic_metadata = { "name" : "is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @is_magnetic.setter
    def is_magnetic(self, newVal:bool) -> None:
        """Opt whether to use a magnetic heading for the runway heading."""
        return self._intf.set_property(IUserRunway._metadata, IUserRunway._set_is_magnetic_metadata, newVal)

    _copy_site_metadata = { "name" : "copy_site",
            "arg_types" : (),
            "marshallers" : () }
    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        return self._intf.invoke(IUserRunway._metadata, IUserRunway._copy_site_metadata, )

    _paste_site_metadata = { "name" : "paste_site",
            "arg_types" : (),
            "marshallers" : () }
    def paste_site(self) -> None:
        """Paste the site to the clipboard."""
        return self._intf.invoke(IUserRunway._metadata, IUserRunway._paste_site_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{74B0531F-504B-42E6-A8AF-7A6B891A88F8}", IUserRunway)
agcls.AgTypeNameMap["IUserRunway"] = IUserRunway

class IARINC424Item(object):
    """Interface used to access the options for an ARINC424 Item found in the Aviator catalog."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ec9a6d30-e195-49d8-a5fd-635114490f7c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_catalog_item" : 1,
                             "get_value" : 2,
                             "get_all_fields" : 3,
                             "get_all_fields_and_values" : 4,
                             "copy_site" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IARINC424Item._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Item from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Item.__dict__ and type(IARINC424Item.__dict__[attrname]) == property:
            return IARINC424Item.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Item.")
    
    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IARINC424Item._metadata, IARINC424Item._get_as_catalog_item_metadata, out_arg())

    _get_value_metadata = { "name" : "get_value",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_arg,) }
    def get_value(self, fieldName:str) -> typing.Any:
        """Get the value of the field with the given name."""
        return self._intf.invoke(IARINC424Item._metadata, IARINC424Item._get_value_metadata, fieldName, out_arg())

    _get_all_fields_metadata = { "name" : "get_all_fields",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_all_fields(self) -> list:
        """Get all the field names."""
        return self._intf.invoke(IARINC424Item._metadata, IARINC424Item._get_all_fields_metadata, out_arg())

    _get_all_fields_and_values_metadata = { "name" : "get_all_fields_and_values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_all_fields_and_values(self) -> list:
        """Get all the field names along with the corresponding value."""
        return self._intf.invoke(IARINC424Item._metadata, IARINC424Item._get_all_fields_and_values_metadata, out_arg())

    _copy_site_metadata = { "name" : "copy_site",
            "arg_types" : (),
            "marshallers" : () }
    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        return self._intf.invoke(IARINC424Item._metadata, IARINC424Item._copy_site_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{ec9a6d30-e195-49d8-a5fd-635114490f7c}", IARINC424Item)
agcls.AgTypeNameMap["IARINC424Item"] = IARINC424Item

class IARINC424Source(object):
    """Interface used to access the options for any ARINC424 source in the Aviator catalog."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{949959c7-31af-48e3-9267-27acdcbedc5e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_arinc424_item" : 1,
                             "get_use_master_data_file" : 2,
                             "set_use_master_data_file" : 3,
                             "get_master_data_filepath" : 4,
                             "set_master_data_filepath" : 5,
                             "get_override_data_filepath" : 6,
                             "set_override_data_filepath" : 7,
                             "get_as_catalog_source" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IARINC424Source._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Source from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Source.__dict__ and type(IARINC424Source.__dict__[attrname]) == property:
            return IARINC424Source.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Source.")
    
    _get_arinc424_item_metadata = { "name" : "get_arinc424_item",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_arinc424_item(self, name:str) -> "IARINC424Item":
        """Gets the ARINC-424 item with the given name."""
        return self._intf.invoke(IARINC424Source._metadata, IARINC424Source._get_arinc424_item_metadata, name, out_arg())

    _get_use_master_data_file_metadata = { "name" : "use_master_data_file",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_master_data_file(self) -> bool:
        """Opt whether to use the master data file."""
        return self._intf.get_property(IARINC424Source._metadata, IARINC424Source._get_use_master_data_file_metadata)

    _set_use_master_data_file_metadata = { "name" : "use_master_data_file",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_master_data_file.setter
    def use_master_data_file(self, newVal:bool) -> None:
        """Opt whether to use the master data file."""
        return self._intf.set_property(IARINC424Source._metadata, IARINC424Source._set_use_master_data_file_metadata, newVal)

    _get_master_data_filepath_metadata = { "name" : "master_data_filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def master_data_filepath(self) -> str:
        """The master data file path."""
        return self._intf.get_property(IARINC424Source._metadata, IARINC424Source._get_master_data_filepath_metadata)

    _set_master_data_filepath_metadata = { "name" : "master_data_filepath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @master_data_filepath.setter
    def master_data_filepath(self, newVal:str) -> None:
        """The master data file path."""
        return self._intf.set_property(IARINC424Source._metadata, IARINC424Source._set_master_data_filepath_metadata, newVal)

    _get_override_data_filepath_metadata = { "name" : "override_data_filepath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def override_data_filepath(self) -> str:
        """The file path to the data overriding the mader data file."""
        return self._intf.get_property(IARINC424Source._metadata, IARINC424Source._get_override_data_filepath_metadata)

    _set_override_data_filepath_metadata = { "name" : "override_data_filepath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @override_data_filepath.setter
    def override_data_filepath(self, newVal:str) -> None:
        """The file path to the data overriding the mader data file."""
        return self._intf.set_property(IARINC424Source._metadata, IARINC424Source._set_override_data_filepath_metadata, newVal)

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IARINC424Source._metadata, IARINC424Source._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{949959c7-31af-48e3-9267-27acdcbedc5e}", IARINC424Source)
agcls.AgTypeNameMap["IARINC424Source"] = IARINC424Source

class IDAFIFSource(object):
    """Interface used to access the options for any DAFIF source in the Aviator catalog."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a5045bd9-f91e-4213-b4f3-0b7a3acce45c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_dafif_item" : 1,
                             "get_data_path" : 2,
                             "set_data_path" : 3,
                             "get_effective_date" : 4,
                             "get_expiration_date" : 5,
                             "get_spec_revision" : 6,
                             "get_as_catalog_source" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IDAFIFSource._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IDAFIFSource from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDAFIFSource.__dict__ and type(IDAFIFSource.__dict__[attrname]) == property:
            return IDAFIFSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDAFIFSource.")
    
    _get_dafif_item_metadata = { "name" : "get_dafif_item",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_dafif_item(self, name:str) -> "IDAFIFItem":
        """Get the DAFIF item with the given name."""
        return self._intf.invoke(IDAFIFSource._metadata, IDAFIFSource._get_dafif_item_metadata, name, out_arg())

    _get_data_path_metadata = { "name" : "data_path",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def data_path(self) -> str:
        """The DAFIF data path."""
        return self._intf.get_property(IDAFIFSource._metadata, IDAFIFSource._get_data_path_metadata)

    _set_data_path_metadata = { "name" : "data_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @data_path.setter
    def data_path(self, newVal:str) -> None:
        """The DAFIF data path."""
        return self._intf.set_property(IDAFIFSource._metadata, IDAFIFSource._set_data_path_metadata, newVal)

    _get_effective_date_metadata = { "name" : "effective_date",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def effective_date(self) -> str:
        """The effective date of the DAFIF catalog."""
        return self._intf.get_property(IDAFIFSource._metadata, IDAFIFSource._get_effective_date_metadata)

    _get_expiration_date_metadata = { "name" : "expiration_date",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def expiration_date(self) -> str:
        """The expiration date of the DAFIF catalog."""
        return self._intf.get_property(IDAFIFSource._metadata, IDAFIFSource._get_expiration_date_metadata)

    _get_spec_revision_metadata = { "name" : "spec_revision",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def spec_revision(self) -> str:
        """The DAFIF edition."""
        return self._intf.get_property(IDAFIFSource._metadata, IDAFIFSource._get_spec_revision_metadata)

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IDAFIFSource._metadata, IDAFIFSource._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{a5045bd9-f91e-4213-b4f3-0b7a3acce45c}", IDAFIFSource)
agcls.AgTypeNameMap["IDAFIFSource"] = IDAFIFSource

class IUserVTOLPoint(object):
    """Interface used to access a user VTOL Point in the Aviator catalog."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{10055426-0046-406c-85db-b418e7b0810e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude" : 1,
                             "set_altitude" : 2,
                             "get_terrain_altitude" : 3,
                             "get_latitude" : 4,
                             "set_latitude" : 5,
                             "get_longitude" : 6,
                             "set_longitude" : 7,
                             "copy_site" : 8,
                             "paste_site" : 9,
                             "get_as_catalog_item" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IUserVTOLPoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IUserVTOLPoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVTOLPoint.__dict__ and type(IUserVTOLPoint.__dict__[attrname]) == property:
            return IUserVTOLPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVTOLPoint.")
    
    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The VTOL Point altitude."""
        return self._intf.get_property(IUserVTOLPoint._metadata, IUserVTOLPoint._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The VTOL Point altitude."""
        return self._intf.set_property(IUserVTOLPoint._metadata, IUserVTOLPoint._set_altitude_metadata, newVal)

    _get_terrain_altitude_metadata = { "name" : "get_terrain_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def get_terrain_altitude(self) -> float:
        """Set the VTOL Point altitude to the terrain altitude."""
        return self._intf.invoke(IUserVTOLPoint._metadata, IUserVTOLPoint._get_terrain_altitude_metadata, out_arg())

    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def latitude(self) -> typing.Any:
        """The VTOL Point latitude."""
        return self._intf.get_property(IUserVTOLPoint._metadata, IUserVTOLPoint._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The VTOL Point latitude."""
        return self._intf.set_property(IUserVTOLPoint._metadata, IUserVTOLPoint._set_latitude_metadata, newVal)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def longitude(self) -> typing.Any:
        """The VTOL Point longitude."""
        return self._intf.get_property(IUserVTOLPoint._metadata, IUserVTOLPoint._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The VTOL Point longitude."""
        return self._intf.set_property(IUserVTOLPoint._metadata, IUserVTOLPoint._set_longitude_metadata, newVal)

    _copy_site_metadata = { "name" : "copy_site",
            "arg_types" : (),
            "marshallers" : () }
    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        return self._intf.invoke(IUserVTOLPoint._metadata, IUserVTOLPoint._copy_site_metadata, )

    _paste_site_metadata = { "name" : "paste_site",
            "arg_types" : (),
            "marshallers" : () }
    def paste_site(self) -> None:
        """Paste the site to the clipboard."""
        return self._intf.invoke(IUserVTOLPoint._metadata, IUserVTOLPoint._paste_site_metadata, )

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IUserVTOLPoint._metadata, IUserVTOLPoint._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{10055426-0046-406c-85db-b418e7b0810e}", IUserVTOLPoint)
agcls.AgTypeNameMap["IUserVTOLPoint"] = IUserVTOLPoint

class IUserVTOLPointSource(object):
    """Interface used to access the user VTOL Points in the Aviator catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f5a61b9c-b511-4cf4-b1ee-058153530c70}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_user_vtol_point" : 1,
                             "add_user_vtol_point" : 2,
                             "get_as_catalog_source" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IUserVTOLPointSource._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IUserVTOLPointSource from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVTOLPointSource.__dict__ and type(IUserVTOLPointSource.__dict__[attrname]) == property:
            return IUserVTOLPointSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVTOLPointSource.")
    
    _get_user_vtol_point_metadata = { "name" : "get_user_vtol_point",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_user_vtol_point(self, name:str) -> "UserVTOLPoint":
        """Gets the user VTOL Point with the given name."""
        return self._intf.invoke(IUserVTOLPointSource._metadata, IUserVTOLPointSource._get_user_vtol_point_metadata, name, out_arg())

    _add_user_vtol_point_metadata = { "name" : "add_user_vtol_point",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_user_vtol_point(self, name:str) -> "UserVTOLPoint":
        """Creates a new user VTOL Point with the given name."""
        return self._intf.invoke(IUserVTOLPointSource._metadata, IUserVTOLPointSource._add_user_vtol_point_metadata, name, out_arg())

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IUserVTOLPointSource._metadata, IUserVTOLPointSource._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{f5a61b9c-b511-4cf4-b1ee-058153530c70}", IUserVTOLPointSource)
agcls.AgTypeNameMap["IUserVTOLPointSource"] = IUserVTOLPointSource

class IUserWaypoint(object):
    """Interface used to access a user waypoint in the Aviator catalog."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2b18b860-070a-41cf-803c-c14d7f87ee8c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_latitude" : 1,
                             "set_latitude" : 2,
                             "get_longitude" : 3,
                             "set_longitude" : 4,
                             "copy_site" : 5,
                             "paste_site" : 6,
                             "get_as_catalog_item" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IUserWaypoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IUserWaypoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserWaypoint.__dict__ and type(IUserWaypoint.__dict__[attrname]) == property:
            return IUserWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserWaypoint.")
    
    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def latitude(self) -> typing.Any:
        """The waypoint latitude."""
        return self._intf.get_property(IUserWaypoint._metadata, IUserWaypoint._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The waypoint latitude."""
        return self._intf.set_property(IUserWaypoint._metadata, IUserWaypoint._set_latitude_metadata, newVal)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def longitude(self) -> typing.Any:
        """The waypoint longitude."""
        return self._intf.get_property(IUserWaypoint._metadata, IUserWaypoint._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The waypoint longitude."""
        return self._intf.set_property(IUserWaypoint._metadata, IUserWaypoint._set_longitude_metadata, newVal)

    _copy_site_metadata = { "name" : "copy_site",
            "arg_types" : (),
            "marshallers" : () }
    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        return self._intf.invoke(IUserWaypoint._metadata, IUserWaypoint._copy_site_metadata, )

    _paste_site_metadata = { "name" : "paste_site",
            "arg_types" : (),
            "marshallers" : () }
    def paste_site(self) -> None:
        """Paste the site to the clipboard."""
        return self._intf.invoke(IUserWaypoint._metadata, IUserWaypoint._paste_site_metadata, )

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IUserWaypoint._metadata, IUserWaypoint._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{2b18b860-070a-41cf-803c-c14d7f87ee8c}", IUserWaypoint)
agcls.AgTypeNameMap["IUserWaypoint"] = IUserWaypoint

class IUserWaypointSource(object):
    """Interface used to access the user waypoints in the Aviator catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{381b23fb-f3b9-4944-996a-efdd9dde16d8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_user_waypoint" : 1,
                             "add_user_waypoint" : 2,
                             "get_as_catalog_source" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IUserWaypointSource._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IUserWaypointSource from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserWaypointSource.__dict__ and type(IUserWaypointSource.__dict__[attrname]) == property:
            return IUserWaypointSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserWaypointSource.")
    
    _get_user_waypoint_metadata = { "name" : "get_user_waypoint",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_user_waypoint(self, name:str) -> "UserWaypoint":
        """Gets the user waypoint with the given name."""
        return self._intf.invoke(IUserWaypointSource._metadata, IUserWaypointSource._get_user_waypoint_metadata, name, out_arg())

    _add_user_waypoint_metadata = { "name" : "add_user_waypoint",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_user_waypoint(self, name:str) -> "UserWaypoint":
        """Creates a new user waypoint with the given name."""
        return self._intf.invoke(IUserWaypointSource._metadata, IUserWaypointSource._add_user_waypoint_metadata, name, out_arg())

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IUserWaypointSource._metadata, IUserWaypointSource._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{381b23fb-f3b9-4944-996a-efdd9dde16d8}", IUserWaypointSource)
agcls.AgTypeNameMap["IUserWaypointSource"] = IUserWaypointSource

class IPropulsionEfficiencies(object):
    """Interface used to access the options for the Efficiencies and Losses of a jet engine powerplant in the advanced fixed wing tool."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ff3eeabb-ada1-40dd-99ce-acacb6c390f2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_technology_level" : 1,
                             "set_technology_level" : 2,
                             "get_intake_type" : 3,
                             "set_intake_type" : 4,
                             "get_turbine_type" : 5,
                             "set_turbine_type" : 6,
                             "get_exhaust_nozzle_type" : 7,
                             "set_exhaust_nozzle_type" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IPropulsionEfficiencies._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IPropulsionEfficiencies from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPropulsionEfficiencies.__dict__ and type(IPropulsionEfficiencies.__dict__[attrname]) == property:
            return IPropulsionEfficiencies.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPropulsionEfficiencies.")
    
    _get_technology_level_metadata = { "name" : "technology_level",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_TECHNOLOGY_LEVEL),) }
    @property
    def technology_level(self) -> "JET_ENGINE_TECHNOLOGY_LEVEL":
        """The technology level of the jet engine."""
        return self._intf.get_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._get_technology_level_metadata)

    _set_technology_level_metadata = { "name" : "technology_level",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_TECHNOLOGY_LEVEL),) }
    @technology_level.setter
    def technology_level(self, newVal:"JET_ENGINE_TECHNOLOGY_LEVEL") -> None:
        """The technology level of the jet engine."""
        return self._intf.set_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._set_technology_level_metadata, newVal)

    _get_intake_type_metadata = { "name" : "intake_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_INTAKE_TYPE),) }
    @property
    def intake_type(self) -> "JET_ENGINE_INTAKE_TYPE":
        """The jet engine intake type."""
        return self._intf.get_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._get_intake_type_metadata)

    _set_intake_type_metadata = { "name" : "intake_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_INTAKE_TYPE),) }
    @intake_type.setter
    def intake_type(self, newVal:"JET_ENGINE_INTAKE_TYPE") -> None:
        """The jet engine intake type."""
        return self._intf.set_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._set_intake_type_metadata, newVal)

    _get_turbine_type_metadata = { "name" : "turbine_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_TURBINE_TYPE),) }
    @property
    def turbine_type(self) -> "JET_ENGINE_TURBINE_TYPE":
        """The jet engine turbine type."""
        return self._intf.get_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._get_turbine_type_metadata)

    _set_turbine_type_metadata = { "name" : "turbine_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_TURBINE_TYPE),) }
    @turbine_type.setter
    def turbine_type(self, newVal:"JET_ENGINE_TURBINE_TYPE") -> None:
        """The jet engine turbine type."""
        return self._intf.set_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._set_turbine_type_metadata, newVal)

    _get_exhaust_nozzle_type_metadata = { "name" : "exhaust_nozzle_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_EXHAUST_NOZZLE_TYPE),) }
    @property
    def exhaust_nozzle_type(self) -> "JET_ENGINE_EXHAUST_NOZZLE_TYPE":
        """The jet engine exhaust nozzle type."""
        return self._intf.get_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._get_exhaust_nozzle_type_metadata)

    _set_exhaust_nozzle_type_metadata = { "name" : "exhaust_nozzle_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_ENGINE_EXHAUST_NOZZLE_TYPE),) }
    @exhaust_nozzle_type.setter
    def exhaust_nozzle_type(self, newVal:"JET_ENGINE_EXHAUST_NOZZLE_TYPE") -> None:
        """The jet engine exhaust nozzle type."""
        return self._intf.set_property(IPropulsionEfficiencies._metadata, IPropulsionEfficiencies._set_exhaust_nozzle_type_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{ff3eeabb-ada1-40dd-99ce-acacb6c390f2}", IPropulsionEfficiencies)
agcls.AgTypeNameMap["IPropulsionEfficiencies"] = IPropulsionEfficiencies

class IFuelModelKeroseneAFPROP(object):
    """Interface used to access the options for Kerosense - CEA fuel for a thermodynamic a jet engine model."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f32e5943-6656-4ef2-983b-e80105acf859}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_subtype" : 1,
                             "set_subtype" : 2,
                             "get_specific_energy" : 3,
                             "set_specific_energy" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IFuelModelKeroseneAFPROP._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IFuelModelKeroseneAFPROP from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelModelKeroseneAFPROP.__dict__ and type(IFuelModelKeroseneAFPROP.__dict__[attrname]) == property:
            return IFuelModelKeroseneAFPROP.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelModelKeroseneAFPROP.")
    
    _get_subtype_metadata = { "name" : "subtype",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AFPROP_FUEL_TYPE),) }
    @property
    def subtype(self) -> "AFPROP_FUEL_TYPE":
        """The fuel subtype."""
        return self._intf.get_property(IFuelModelKeroseneAFPROP._metadata, IFuelModelKeroseneAFPROP._get_subtype_metadata)

    _set_subtype_metadata = { "name" : "subtype",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AFPROP_FUEL_TYPE),) }
    @subtype.setter
    def subtype(self, newVal:"AFPROP_FUEL_TYPE") -> None:
        """The fuel subtype."""
        return self._intf.set_property(IFuelModelKeroseneAFPROP._metadata, IFuelModelKeroseneAFPROP._set_subtype_metadata, newVal)

    _get_specific_energy_metadata = { "name" : "specific_energy",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def specific_energy(self) -> float:
        """The specific energy of the jet fuel."""
        return self._intf.get_property(IFuelModelKeroseneAFPROP._metadata, IFuelModelKeroseneAFPROP._get_specific_energy_metadata)

    _set_specific_energy_metadata = { "name" : "specific_energy",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @specific_energy.setter
    def specific_energy(self, newVal:float) -> None:
        """The specific energy of the jet fuel."""
        return self._intf.set_property(IFuelModelKeroseneAFPROP._metadata, IFuelModelKeroseneAFPROP._set_specific_energy_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{f32e5943-6656-4ef2-983b-e80105acf859}", IFuelModelKeroseneAFPROP)
agcls.AgTypeNameMap["IFuelModelKeroseneAFPROP"] = IFuelModelKeroseneAFPROP

class IFuelModelKeroseneCEA(object):
    """Interface used to access the options for Kerosense - CEA fuel for a thermodynamic a jet engine model."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{52d8882c-bc92-469c-ae5b-2ac105b2f88b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_subtype" : 1,
                             "set_subtype" : 2,
                             "get_specific_energy" : 3,
                             "set_specific_energy" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IFuelModelKeroseneCEA._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IFuelModelKeroseneCEA from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelModelKeroseneCEA.__dict__ and type(IFuelModelKeroseneCEA.__dict__[attrname]) == property:
            return IFuelModelKeroseneCEA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelModelKeroseneCEA.")
    
    _get_subtype_metadata = { "name" : "subtype",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CEA_FUEL_TYPE),) }
    @property
    def subtype(self) -> "CEA_FUEL_TYPE":
        """The fuel subtype."""
        return self._intf.get_property(IFuelModelKeroseneCEA._metadata, IFuelModelKeroseneCEA._get_subtype_metadata)

    _set_subtype_metadata = { "name" : "subtype",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CEA_FUEL_TYPE),) }
    @subtype.setter
    def subtype(self, newVal:"CEA_FUEL_TYPE") -> None:
        """The fuel subtype."""
        return self._intf.set_property(IFuelModelKeroseneCEA._metadata, IFuelModelKeroseneCEA._set_subtype_metadata, newVal)

    _get_specific_energy_metadata = { "name" : "specific_energy",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def specific_energy(self) -> float:
        """The specific energy of the jet fuel."""
        return self._intf.get_property(IFuelModelKeroseneCEA._metadata, IFuelModelKeroseneCEA._get_specific_energy_metadata)

    _set_specific_energy_metadata = { "name" : "specific_energy",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @specific_energy.setter
    def specific_energy(self, newVal:float) -> None:
        """The specific energy of the jet fuel."""
        return self._intf.set_property(IFuelModelKeroseneCEA._metadata, IFuelModelKeroseneCEA._set_specific_energy_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{52d8882c-bc92-469c-ae5b-2ac105b2f88b}", IFuelModelKeroseneCEA)
agcls.AgTypeNameMap["IFuelModelKeroseneCEA"] = IFuelModelKeroseneCEA

class IAdvFixedWingRamjetBasic(object):
    """Interface used to access the options for a basic Ramjet mode."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9533600c-479f-42f8-b14d-a56199f9f64f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_design_altitude" : 1,
                             "set_design_altitude" : 2,
                             "get_design_mach" : 3,
                             "set_design_mach" : 4,
                             "get_design_thrust" : 5,
                             "set_design_thrust" : 6,
                             "get_max_compression_temp" : 7,
                             "set_max_compression_temp" : 8,
                             "get_max_burner_temp" : 9,
                             "set_max_burner_temp" : 10,
                             "get_fuel_type" : 11,
                             "set_fuel_type" : 12,
                             "get_fuel_mode_as_afprop" : 13,
                             "get_fuel_mode_as_cea" : 14,
                             "get_efficiencies_and_losses" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingRamjetBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingRamjetBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingRamjetBasic.__dict__ and type(IAdvFixedWingRamjetBasic.__dict__[attrname]) == property:
            return IAdvFixedWingRamjetBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingRamjetBasic.")
    
    _get_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_design_altitude_metadata)

    _set_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        return self._intf.set_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._set_design_altitude_metadata, newVal)

    _get_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_design_mach_metadata)

    _set_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        return self._intf.set_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._set_design_mach_metadata, newVal)

    _get_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_design_thrust_metadata)

    _set_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        return self._intf.set_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._set_design_thrust_metadata, newVal)

    _get_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_max_compression_temp_metadata)

    _set_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        return self._intf.set_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._set_max_compression_temp_metadata, newVal)

    _get_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_max_burner_temp_metadata)

    _set_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        return self._intf.set_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._set_max_burner_temp_metadata, newVal)

    _get_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @property
    def fuel_type(self) -> "JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_fuel_type_metadata)

    _set_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @fuel_type.setter
    def fuel_type(self, newVal:"JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        return self._intf.set_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._set_fuel_type_metadata, newVal)

    _get_fuel_mode_as_afprop_metadata = { "name" : "fuel_mode_as_afprop",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_afprop(self) -> "FuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_fuel_mode_as_afprop_metadata)

    _get_fuel_mode_as_cea_metadata = { "name" : "fuel_mode_as_cea",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_cea(self) -> "FuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_fuel_mode_as_cea_metadata)

    _get_efficiencies_and_losses_metadata = { "name" : "efficiencies_and_losses",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def efficiencies_and_losses(self) -> "PropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        return self._intf.get_property(IAdvFixedWingRamjetBasic._metadata, IAdvFixedWingRamjetBasic._get_efficiencies_and_losses_metadata)


agcls.AgClassCatalog.add_catalog_entry("{9533600c-479f-42f8-b14d-a56199f9f64f}", IAdvFixedWingRamjetBasic)
agcls.AgTypeNameMap["IAdvFixedWingRamjetBasic"] = IAdvFixedWingRamjetBasic

class IAdvFixedWingScramjetBasic(object):
    """Interface used to access the options for a basic Scramjet mode."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{24585a26-2d65-4fa8-850d-d19e5f7d190d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_design_altitude" : 1,
                             "set_design_altitude" : 2,
                             "get_design_mach" : 3,
                             "set_design_mach" : 4,
                             "get_design_thrust" : 5,
                             "set_design_thrust" : 6,
                             "get_max_compression_temp" : 7,
                             "set_max_compression_temp" : 8,
                             "get_max_burner_temp" : 9,
                             "set_max_burner_temp" : 10,
                             "get_fuel_type" : 11,
                             "set_fuel_type" : 12,
                             "get_fuel_mode_as_afprop" : 13,
                             "get_fuel_mode_as_cea" : 14,
                             "get_efficiencies_and_losses" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingScramjetBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingScramjetBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingScramjetBasic.__dict__ and type(IAdvFixedWingScramjetBasic.__dict__[attrname]) == property:
            return IAdvFixedWingScramjetBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingScramjetBasic.")
    
    _get_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_altitude(self) -> float:
        """The altitude design point of the engine."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_design_altitude_metadata)

    _set_design_altitude_metadata = { "name" : "design_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_altitude.setter
    def design_altitude(self, newVal:float) -> None:
        """The altitude design point of the engine."""
        return self._intf.set_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._set_design_altitude_metadata, newVal)

    _get_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_mach(self) -> float:
        """The mach number design point of the engine."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_design_mach_metadata)

    _set_design_mach_metadata = { "name" : "design_mach",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_mach.setter
    def design_mach(self, newVal:float) -> None:
        """The mach number design point of the engine."""
        return self._intf.set_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._set_design_mach_metadata, newVal)

    _get_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def design_thrust(self) -> float:
        """The thrust design point of the engine."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_design_thrust_metadata)

    _set_design_thrust_metadata = { "name" : "design_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @design_thrust.setter
    def design_thrust(self, newVal:float) -> None:
        """The thrust design point of the engine."""
        return self._intf.set_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._set_design_thrust_metadata, newVal)

    _get_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_compression_temp(self) -> float:
        """The maximum temperature at the compressor stage."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_max_compression_temp_metadata)

    _set_max_compression_temp_metadata = { "name" : "max_compression_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_compression_temp.setter
    def max_compression_temp(self, newVal:float) -> None:
        """The maximum temperature at the compressor stage."""
        return self._intf.set_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._set_max_compression_temp_metadata, newVal)

    _get_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_burner_temp(self) -> float:
        """The maximum temperature at the combustion stage."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_max_burner_temp_metadata)

    _set_max_burner_temp_metadata = { "name" : "max_burner_temp",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_burner_temp.setter
    def max_burner_temp(self, newVal:float) -> None:
        """The maximum temperature at the combustion stage."""
        return self._intf.set_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._set_max_burner_temp_metadata, newVal)

    _get_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @property
    def fuel_type(self) -> "JET_FUEL_TYPE":
        """The jet engine's fuel type."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_fuel_type_metadata)

    _set_fuel_type_metadata = { "name" : "fuel_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JET_FUEL_TYPE),) }
    @fuel_type.setter
    def fuel_type(self, newVal:"JET_FUEL_TYPE") -> None:
        """The jet engine's fuel type."""
        return self._intf.set_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._set_fuel_type_metadata, newVal)

    _get_fuel_mode_as_afprop_metadata = { "name" : "fuel_mode_as_afprop",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_afprop(self) -> "FuelModelKeroseneAFPROP":
        """Get the interface for a Kerosene - AFPROP fuel mode."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_fuel_mode_as_afprop_metadata)

    _get_fuel_mode_as_cea_metadata = { "name" : "fuel_mode_as_cea",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fuel_mode_as_cea(self) -> "FuelModelKeroseneCEA":
        """Get the interface for a Kerosene - CEA fuel mode."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_fuel_mode_as_cea_metadata)

    _get_efficiencies_and_losses_metadata = { "name" : "efficiencies_and_losses",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def efficiencies_and_losses(self) -> "PropulsionEfficiencies":
        """The jet engine's propulsion efficiencies and losses."""
        return self._intf.get_property(IAdvFixedWingScramjetBasic._metadata, IAdvFixedWingScramjetBasic._get_efficiencies_and_losses_metadata)


agcls.AgClassCatalog.add_catalog_entry("{24585a26-2d65-4fa8-850d-d19e5f7d190d}", IAdvFixedWingScramjetBasic)
agcls.AgTypeNameMap["IAdvFixedWingScramjetBasic"] = IAdvFixedWingScramjetBasic

class IRefuelDumpProperties(object):
    """Interface used to access the refuel/dump properties for the current procedure."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8C37F92D-E841-456E-8E12-A09C84D5EFF5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_refuel_dump_mode" : 1,
                             "get_refuel_dump_mode_value" : 2,
                             "set_refuel_dump_mode" : 3,
                             "get_refuel_dump_rate" : 4,
                             "set_refuel_dump_rate" : 5,
                             "get_refuel_dump_time_offset" : 6,
                             "set_refuel_dump_time_offset" : 7,
                             "get_can_use_end_of_enroute_segment_as_epoch" : 8,
                             "get_use_end_of_enroute_segment_as_epoch" : 9,
                             "set_use_end_of_enroute_segment_as_epoch" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IRefuelDumpProperties._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IRefuelDumpProperties from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRefuelDumpProperties.__dict__ and type(IRefuelDumpProperties.__dict__[attrname]) == property:
            return IRefuelDumpProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRefuelDumpProperties.")
    
    _get_refuel_dump_mode_metadata = { "name" : "refuel_dump_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFUEL_DUMP_MODE),) }
    @property
    def refuel_dump_mode(self) -> "REFUEL_DUMP_MODE":
        """Get the RefuelDumpMode"""
        return self._intf.get_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._get_refuel_dump_mode_metadata)

    _get_refuel_dump_mode_value_metadata = { "name" : "refuel_dump_mode_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def refuel_dump_mode_value(self) -> float:
        """Get the RefuelDumpModeValue if applicable"""
        return self._intf.get_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._get_refuel_dump_mode_value_metadata)

    _set_refuel_dump_mode_metadata = { "name" : "set_refuel_dump_mode",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(REFUEL_DUMP_MODE), agmarshall.DOUBLE_arg,) }
    def set_refuel_dump_mode(self, mode:"REFUEL_DUMP_MODE", value:float) -> None:
        """Set RefuelDumpMode and RefuelDumpModeValue if applicable"""
        return self._intf.invoke(IRefuelDumpProperties._metadata, IRefuelDumpProperties._set_refuel_dump_mode_metadata, mode, value)

    _get_refuel_dump_rate_metadata = { "name" : "refuel_dump_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def refuel_dump_rate(self) -> float:
        """Get the RefuelDump rate"""
        return self._intf.get_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._get_refuel_dump_rate_metadata)

    _set_refuel_dump_rate_metadata = { "name" : "refuel_dump_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @refuel_dump_rate.setter
    def refuel_dump_rate(self, newVal:float) -> None:
        """Set the RefuelDump rate"""
        return self._intf.set_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._set_refuel_dump_rate_metadata, newVal)

    _get_refuel_dump_time_offset_metadata = { "name" : "refuel_dump_time_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def refuel_dump_time_offset(self) -> float:
        """Get the RefuelDump time offset"""
        return self._intf.get_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._get_refuel_dump_time_offset_metadata)

    _set_refuel_dump_time_offset_metadata = { "name" : "refuel_dump_time_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @refuel_dump_time_offset.setter
    def refuel_dump_time_offset(self, newVal:float) -> None:
        """Set the RefuelDump time offset"""
        return self._intf.set_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._set_refuel_dump_time_offset_metadata, newVal)

    _get_can_use_end_of_enroute_segment_as_epoch_metadata = { "name" : "can_use_end_of_enroute_segment_as_epoch",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def can_use_end_of_enroute_segment_as_epoch(self) -> bool:
        """Can use end of enroute segment as the epoch"""
        return self._intf.get_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._get_can_use_end_of_enroute_segment_as_epoch_metadata)

    _get_use_end_of_enroute_segment_as_epoch_metadata = { "name" : "use_end_of_enroute_segment_as_epoch",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_end_of_enroute_segment_as_epoch(self) -> bool:
        """Use end of enroute segment as the epoch"""
        return self._intf.get_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._get_use_end_of_enroute_segment_as_epoch_metadata)

    _set_use_end_of_enroute_segment_as_epoch_metadata = { "name" : "use_end_of_enroute_segment_as_epoch",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_end_of_enroute_segment_as_epoch.setter
    def use_end_of_enroute_segment_as_epoch(self, newVal:bool) -> None:
        """Use end of enroute segment as the epoch"""
        return self._intf.set_property(IRefuelDumpProperties._metadata, IRefuelDumpProperties._set_use_end_of_enroute_segment_as_epoch_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{8C37F92D-E841-456E-8E12-A09C84D5EFF5}", IRefuelDumpProperties)
agcls.AgTypeNameMap["IRefuelDumpProperties"] = IRefuelDumpProperties

class IProcedureFastTimeOptions(object):
    """Interface used to access the fast time options (without error or constraint checks) for the current procedure. Use this interface to set an Interrupt Time or Fixed Duration for a procedure."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{776EACCB-1B06-4CB2-A915-01B3B2E15E10}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_time" : 1,
                             "set_start_time" : 2,
                             "set_interrupt_time" : 3,
                             "get_stop_time" : 4,
                             "set_stop_time" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureFastTimeOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFastTimeOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFastTimeOptions.__dict__ and type(IProcedureFastTimeOptions.__dict__[attrname]) == property:
            return IProcedureFastTimeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFastTimeOptions.")
    
    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_time(self) -> typing.Any:
        """Start time for the procedure."""
        return self._intf.get_property(IProcedureFastTimeOptions._metadata, IProcedureFastTimeOptions._get_start_time_metadata)

    _set_start_time_metadata = { "name" : "set_start_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_start_time(self, time:typing.Any) -> None:
        """Set the start time for the procedure."""
        return self._intf.invoke(IProcedureFastTimeOptions._metadata, IProcedureFastTimeOptions._set_start_time_metadata, time)

    _set_interrupt_time_metadata = { "name" : "set_interrupt_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_interrupt_time(self, time:typing.Any) -> None:
        """Set the interrupt time for the procedure."""
        return self._intf.invoke(IProcedureFastTimeOptions._metadata, IProcedureFastTimeOptions._set_interrupt_time_metadata, time)

    _get_stop_time_metadata = { "name" : "stop_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_time(self) -> typing.Any:
        """Stop time for the procedure."""
        return self._intf.get_property(IProcedureFastTimeOptions._metadata, IProcedureFastTimeOptions._get_stop_time_metadata)

    _set_stop_time_metadata = { "name" : "set_stop_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_stop_time(self, time:typing.Any) -> None:
        """Set the stop time for the procedure."""
        return self._intf.invoke(IProcedureFastTimeOptions._metadata, IProcedureFastTimeOptions._set_stop_time_metadata, time)


agcls.AgClassCatalog.add_catalog_entry("{776EACCB-1B06-4CB2-A915-01B3B2E15E10}", IProcedureFastTimeOptions)
agcls.AgTypeNameMap["IProcedureFastTimeOptions"] = IProcedureFastTimeOptions

class IAtmosphereModelBasic(object):
    """Interface used to access the basic atmosphere model."""
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{c39ccd9f-0996-4325-95bf-4b0af8d47b2f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_basic_model_type" : 3,
                             "set_basic_model_type" : 4,
                             "get_use_non_standard_atmosphere" : 5,
                             "set_use_non_standard_atmosphere" : 6,
                             "get_temperature" : 7,
                             "set_temperature" : 8,
                             "get_pressure" : 9,
                             "set_pressure" : 10,
                             "get_density_altitude" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAtmosphereModelBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAtmosphereModelBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAtmosphereModelBasic.__dict__ and type(IAtmosphereModelBasic.__dict__[attrname]) == property:
            return IAtmosphereModelBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAtmosphereModelBasic.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the atmosphere model."""
        return self._intf.get_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the atmospheremodel."""
        return self._intf.set_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._set_name_metadata, newVal)

    _get_basic_model_type_metadata = { "name" : "basic_model_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ATMOSPHERE_MODEL),) }
    @property
    def basic_model_type(self) -> "ATMOSPHERE_MODEL":
        """The type of basic atmosphere."""
        return self._intf.get_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._get_basic_model_type_metadata)

    _set_basic_model_type_metadata = { "name" : "basic_model_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ATMOSPHERE_MODEL),) }
    @basic_model_type.setter
    def basic_model_type(self, newVal:"ATMOSPHERE_MODEL") -> None:
        """The type of basic atmosphere."""
        return self._intf.set_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._set_basic_model_type_metadata, newVal)

    _get_use_non_standard_atmosphere_metadata = { "name" : "use_non_standard_atmosphere",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_non_standard_atmosphere(self) -> bool:
        """Opt whether to use non standard atmosphere conditions."""
        return self._intf.get_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._get_use_non_standard_atmosphere_metadata)

    _set_use_non_standard_atmosphere_metadata = { "name" : "use_non_standard_atmosphere",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_non_standard_atmosphere.setter
    def use_non_standard_atmosphere(self, newVal:bool) -> None:
        """Opt whether to use non standard atmosphere conditions."""
        return self._intf.set_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._set_use_non_standard_atmosphere_metadata, newVal)

    _get_temperature_metadata = { "name" : "temperature",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def temperature(self) -> float:
        """The sea-level temperature."""
        return self._intf.get_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._get_temperature_metadata)

    _set_temperature_metadata = { "name" : "temperature",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @temperature.setter
    def temperature(self, newVal:float) -> None:
        """The sea-level temperature."""
        return self._intf.set_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._set_temperature_metadata, newVal)

    _get_pressure_metadata = { "name" : "pressure",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def pressure(self) -> float:
        """The sea-level pressure."""
        return self._intf.get_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._get_pressure_metadata)

    _set_pressure_metadata = { "name" : "pressure",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @pressure.setter
    def pressure(self, newVal:float) -> None:
        """The sea-level pressure."""
        return self._intf.set_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._set_pressure_metadata, newVal)

    _get_density_altitude_metadata = { "name" : "density_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def density_altitude(self) -> float:
        """The sea-level density altitude."""
        return self._intf.get_property(IAtmosphereModelBasic._metadata, IAtmosphereModelBasic._get_density_altitude_metadata)


agcls.AgClassCatalog.add_catalog_entry("{c39ccd9f-0996-4325-95bf-4b0af8d47b2f}", IAtmosphereModelBasic)
agcls.AgTypeNameMap["IAtmosphereModelBasic"] = IAtmosphereModelBasic

class IAtmosphereModel(object):
    """Interface used to access the atmosphere model for a mission, scenario, or procedure."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1f18b697-794a-4001-a3ee-ccfb21c27e44}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_atmosphere_model_type_string" : 1,
                             "set_atmosphere_model_type_string" : 2,
                             "get_atmosphere_model_source" : 3,
                             "set_atmosphere_model_source" : 4,
                             "get_mode_as_basic" : 5,
                             "copy" : 6,
                             "paste" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAtmosphereModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAtmosphereModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAtmosphereModel.__dict__ and type(IAtmosphereModel.__dict__[attrname]) == property:
            return IAtmosphereModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAtmosphereModel.")
    
    _get_atmosphere_model_type_string_metadata = { "name" : "atmosphere_model_type_string",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def atmosphere_model_type_string(self) -> str:
        """The atmosphere model type as a string value."""
        return self._intf.get_property(IAtmosphereModel._metadata, IAtmosphereModel._get_atmosphere_model_type_string_metadata)

    _set_atmosphere_model_type_string_metadata = { "name" : "atmosphere_model_type_string",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @atmosphere_model_type_string.setter
    def atmosphere_model_type_string(self, pVal:str) -> None:
        """The atmosphere model type as a string value."""
        return self._intf.set_property(IAtmosphereModel._metadata, IAtmosphereModel._set_atmosphere_model_type_string_metadata, pVal)

    _get_atmosphere_model_source_metadata = { "name" : "atmosphere_model_source",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(WIND_ATMOS_MODEL_SOURCE),) }
    @property
    def atmosphere_model_source(self) -> "WIND_ATMOS_MODEL_SOURCE":
        """The atmosphere model source."""
        return self._intf.get_property(IAtmosphereModel._metadata, IAtmosphereModel._get_atmosphere_model_source_metadata)

    _set_atmosphere_model_source_metadata = { "name" : "atmosphere_model_source",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(WIND_ATMOS_MODEL_SOURCE),) }
    @atmosphere_model_source.setter
    def atmosphere_model_source(self, pVal:"WIND_ATMOS_MODEL_SOURCE") -> None:
        """The atmosphere model source."""
        return self._intf.set_property(IAtmosphereModel._metadata, IAtmosphereModel._set_atmosphere_model_source_metadata, pVal)

    _get_mode_as_basic_metadata = { "name" : "mode_as_basic",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_basic(self) -> "AtmosphereModelBasic":
        """Get the options for a Basic Atmosphere model."""
        return self._intf.get_property(IAtmosphereModel._metadata, IAtmosphereModel._get_mode_as_basic_metadata)

    _copy_metadata = { "name" : "copy",
            "arg_types" : (),
            "marshallers" : () }
    def copy(self) -> None:
        """Copy the atmosphere model."""
        return self._intf.invoke(IAtmosphereModel._metadata, IAtmosphereModel._copy_metadata, )

    _paste_metadata = { "name" : "paste",
            "arg_types" : (),
            "marshallers" : () }
    def paste(self) -> None:
        """Paste the atmosphere model."""
        return self._intf.invoke(IAtmosphereModel._metadata, IAtmosphereModel._paste_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{1f18b697-794a-4001-a3ee-ccfb21c27e44}", IAtmosphereModel)
agcls.AgTypeNameMap["IAtmosphereModel"] = IAtmosphereModel

class IADDSMessageCollection(object):
    """Interface used to access the collection of messages from the NOAA ADDS forecast."""
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{fecb8f81-541f-4e86-8f34-ed7570047450}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3,
                             "remove_message" : 4,
                             "clear_messages" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IADDSMessageCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IADDSMessageCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IADDSMessageCollection.__dict__ and type(IADDSMessageCollection.__dict__[attrname]) == property:
            return IADDSMessageCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IADDSMessageCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IADDSMessage":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        return self._intf.get_property(IADDSMessageCollection._metadata, IADDSMessageCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "ADDSMessage":
        """Given an index, returns an element in the collection."""
        return self._intf.invoke(IADDSMessageCollection._metadata, IADDSMessageCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns an enumerator that can iterate through the collection."""
        return self._intf.get_property(IADDSMessageCollection._metadata, IADDSMessageCollection._get__NewEnum_metadata)

    _remove_message_metadata = { "name" : "remove_message",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IADDSMessage"),) }
    def remove_message(self, message:"IADDSMessage") -> None:
        """Remove this message from the forecast."""
        return self._intf.invoke(IADDSMessageCollection._metadata, IADDSMessageCollection._remove_message_metadata, message)

    _clear_messages_metadata = { "name" : "clear_messages",
            "arg_types" : (),
            "marshallers" : () }
    def clear_messages(self) -> None:
        """Clears all of the messages in the collection."""
        return self._intf.invoke(IADDSMessageCollection._metadata, IADDSMessageCollection._clear_messages_metadata, )

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{fecb8f81-541f-4e86-8f34-ed7570047450}", IADDSMessageCollection)
agcls.AgTypeNameMap["IADDSMessageCollection"] = IADDSMessageCollection

class IWindModelADDS(object):
    """Interface used to access the options for a NOAA ADDS wind model."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{56b53131-0902-4469-9acc-75b68ed298d4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_blend_time" : 3,
                             "set_blend_time" : 4,
                             "get_msg_interpolation_type" : 5,
                             "set_msg_interpolation_type" : 6,
                             "get_msg_extrapolation_type" : 7,
                             "set_msg_extrapolation_type" : 8,
                             "get_missing_msg_type" : 9,
                             "set_missing_msg_type" : 10,
                             "get_interp_blend_time" : 11,
                             "set_interp_blend_time" : 12,
                             "add_current_forecast" : 13,
                             "get_messages" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IWindModelADDS._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IWindModelADDS from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWindModelADDS.__dict__ and type(IWindModelADDS.__dict__[attrname]) == property:
            return IWindModelADDS.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWindModelADDS.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the wind model."""
        return self._intf.get_property(IWindModelADDS._metadata, IWindModelADDS._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the wind model."""
        return self._intf.set_property(IWindModelADDS._metadata, IWindModelADDS._set_name_metadata, newVal)

    _get_blend_time_metadata = { "name" : "blend_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def blend_time(self) -> float:
        """The blend time to transition from the previous wind model if one exists."""
        return self._intf.get_property(IWindModelADDS._metadata, IWindModelADDS._get_blend_time_metadata)

    _set_blend_time_metadata = { "name" : "blend_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @blend_time.setter
    def blend_time(self, newVal:float) -> None:
        """The blend time to transition from the previous wind model if one exists."""
        return self._intf.set_property(IWindModelADDS._metadata, IWindModelADDS._set_blend_time_metadata, newVal)

    _get_msg_interpolation_type_metadata = { "name" : "msg_interpolation_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADDS_MSG_INTERP_TYPE),) }
    @property
    def msg_interpolation_type(self) -> "ADDS_MSG_INTERP_TYPE":
        """The message interpolation type."""
        return self._intf.get_property(IWindModelADDS._metadata, IWindModelADDS._get_msg_interpolation_type_metadata)

    _set_msg_interpolation_type_metadata = { "name" : "msg_interpolation_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ADDS_MSG_INTERP_TYPE),) }
    @msg_interpolation_type.setter
    def msg_interpolation_type(self, newVal:"ADDS_MSG_INTERP_TYPE") -> None:
        """The message interpolation type."""
        return self._intf.set_property(IWindModelADDS._metadata, IWindModelADDS._set_msg_interpolation_type_metadata, newVal)

    _get_msg_extrapolation_type_metadata = { "name" : "msg_extrapolation_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADDS_MSG_EXTRAP_TYPE),) }
    @property
    def msg_extrapolation_type(self) -> "ADDS_MSG_EXTRAP_TYPE":
        """The message extrapolation type."""
        return self._intf.get_property(IWindModelADDS._metadata, IWindModelADDS._get_msg_extrapolation_type_metadata)

    _set_msg_extrapolation_type_metadata = { "name" : "msg_extrapolation_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ADDS_MSG_EXTRAP_TYPE),) }
    @msg_extrapolation_type.setter
    def msg_extrapolation_type(self, newVal:"ADDS_MSG_EXTRAP_TYPE") -> None:
        """The message extrapolation type."""
        return self._intf.set_property(IWindModelADDS._metadata, IWindModelADDS._set_msg_extrapolation_type_metadata, newVal)

    _get_missing_msg_type_metadata = { "name" : "missing_msg_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ADDS_MISSING_MSG_TYPE),) }
    @property
    def missing_msg_type(self) -> "ADDS_MISSING_MSG_TYPE":
        """The missing message type."""
        return self._intf.get_property(IWindModelADDS._metadata, IWindModelADDS._get_missing_msg_type_metadata)

    _set_missing_msg_type_metadata = { "name" : "missing_msg_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ADDS_MISSING_MSG_TYPE),) }
    @missing_msg_type.setter
    def missing_msg_type(self, newVal:"ADDS_MISSING_MSG_TYPE") -> None:
        """The missing message type."""
        return self._intf.set_property(IWindModelADDS._metadata, IWindModelADDS._set_missing_msg_type_metadata, newVal)

    _get_interp_blend_time_metadata = { "name" : "interp_blend_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def interp_blend_time(self) -> float:
        """The blend time to transition from the previous wind condition."""
        return self._intf.get_property(IWindModelADDS._metadata, IWindModelADDS._get_interp_blend_time_metadata)

    _set_interp_blend_time_metadata = { "name" : "interp_blend_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @interp_blend_time.setter
    def interp_blend_time(self, newVal:float) -> None:
        """The blend time to transition from the previous wind condition."""
        return self._intf.set_property(IWindModelADDS._metadata, IWindModelADDS._set_interp_blend_time_metadata, newVal)

    _add_current_forecast_metadata = { "name" : "add_current_forecast",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def add_current_forecast(self) -> str:
        """Add the current forecast from the ADDS service."""
        return self._intf.invoke(IWindModelADDS._metadata, IWindModelADDS._add_current_forecast_metadata, out_arg())

    _get_messages_metadata = { "name" : "messages",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def messages(self) -> "ADDSMessageCollection":
        """Get the messages from the current forecast."""
        return self._intf.get_property(IWindModelADDS._metadata, IWindModelADDS._get_messages_metadata)


agcls.AgClassCatalog.add_catalog_entry("{56b53131-0902-4469-9acc-75b68ed298d4}", IWindModelADDS)
agcls.AgTypeNameMap["IWindModelADDS"] = IWindModelADDS

class IWindModelConstant(object):
    """Interface used to access the options for a Constant Bearing/Speed wind model."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d40dcd05-eccc-4264-8b84-39be36b58406}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_blend_time" : 3,
                             "set_blend_time" : 4,
                             "get_wind_speed" : 5,
                             "set_wind_speed" : 6,
                             "get_wind_bearing" : 7,
                             "set_wind_bearing" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IWindModelConstant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IWindModelConstant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWindModelConstant.__dict__ and type(IWindModelConstant.__dict__[attrname]) == property:
            return IWindModelConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWindModelConstant.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the wind model."""
        return self._intf.get_property(IWindModelConstant._metadata, IWindModelConstant._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the wind model."""
        return self._intf.set_property(IWindModelConstant._metadata, IWindModelConstant._set_name_metadata, newVal)

    _get_blend_time_metadata = { "name" : "blend_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def blend_time(self) -> float:
        """The blend time to transition from the previous wind model if one exists."""
        return self._intf.get_property(IWindModelConstant._metadata, IWindModelConstant._get_blend_time_metadata)

    _set_blend_time_metadata = { "name" : "blend_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @blend_time.setter
    def blend_time(self, newVal:float) -> None:
        """The blend time to transition from the previous wind model if one exists."""
        return self._intf.set_property(IWindModelConstant._metadata, IWindModelConstant._set_blend_time_metadata, newVal)

    _get_wind_speed_metadata = { "name" : "wind_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wind_speed(self) -> float:
        """The constant wind speed."""
        return self._intf.get_property(IWindModelConstant._metadata, IWindModelConstant._get_wind_speed_metadata)

    _set_wind_speed_metadata = { "name" : "wind_speed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wind_speed.setter
    def wind_speed(self, newVal:float) -> None:
        """The constant wind speed."""
        return self._intf.set_property(IWindModelConstant._metadata, IWindModelConstant._set_wind_speed_metadata, newVal)

    _get_wind_bearing_metadata = { "name" : "wind_bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def wind_bearing(self) -> typing.Any:
        """The wind's true bearing."""
        return self._intf.get_property(IWindModelConstant._metadata, IWindModelConstant._get_wind_bearing_metadata)

    _set_wind_bearing_metadata = { "name" : "wind_bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @wind_bearing.setter
    def wind_bearing(self, newVal:typing.Any) -> None:
        """The wind's true bearing."""
        return self._intf.set_property(IWindModelConstant._metadata, IWindModelConstant._set_wind_bearing_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{d40dcd05-eccc-4264-8b84-39be36b58406}", IWindModelConstant)
agcls.AgTypeNameMap["IWindModelConstant"] = IWindModelConstant

class IStation(object):
    """Interface used to access a station for an Aviator aircraft."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ac0b6aed-ff8d-4f69-ba75-d31e2285b436}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IStation._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IStation from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStation.__dict__ and type(IStation.__dict__[attrname]) == property:
            return IStation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStation.")
    

agcls.AgClassCatalog.add_catalog_entry("{ac0b6aed-ff8d-4f69-ba75-d31e2285b436}", IStation)
agcls.AgTypeNameMap["IStation"] = IStation

class IStationCollection(object):
    """Interface used to access the list of stations for an Aviator aircraft."""
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{c4e09526-9742-4f58-9943-b176e5192b24}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3,
                             "get_internal_fuel_tank_by_name" : 4,
                             "add_internal_fuel_tank" : 5,
                             "get_payload_station_by_name" : 6,
                             "add_payload_station" : 7,
                             "contains_station" : 8,
                             "remove_station_by_name" : 9,
                             "remove_at_index" : 10,
                             "get_station_names" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IStationCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IStationCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStationCollection.__dict__ and type(IStationCollection.__dict__[attrname]) == property:
            return IStationCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStationCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IStation":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        return self._intf.get_property(IStationCollection._metadata, IStationCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "IStation":
        """Given an index, returns an element in the collection."""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns an enumerator that can iterate through the collection."""
        return self._intf.get_property(IStationCollection._metadata, IStationCollection._get__NewEnum_metadata)

    _get_internal_fuel_tank_by_name_metadata = { "name" : "get_internal_fuel_tank_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_internal_fuel_tank_by_name(self, name:str) -> "FuelTankInternal":
        """Get the internal fuel tank with the given name."""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._get_internal_fuel_tank_by_name_metadata, name, out_arg())

    _add_internal_fuel_tank_metadata = { "name" : "add_internal_fuel_tank",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def add_internal_fuel_tank(self) -> "FuelTankInternal":
        """Add an internal fuel tank"""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._add_internal_fuel_tank_metadata, out_arg())

    _get_payload_station_by_name_metadata = { "name" : "get_payload_station_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_payload_station_by_name(self, name:str) -> "PayloadStation":
        """Get the payload station with the given name."""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._get_payload_station_by_name_metadata, name, out_arg())

    _add_payload_station_metadata = { "name" : "add_payload_station",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def add_payload_station(self) -> "PayloadStation":
        """Add a payload station"""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._add_payload_station_metadata, out_arg())

    _contains_station_metadata = { "name" : "contains_station",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains_station(self, name:str) -> bool:
        """Get whether the station list contains an item with the given name."""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._contains_station_metadata, name, out_arg())

    _remove_station_by_name_metadata = { "name" : "remove_station_by_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove_station_by_name(self, name:str) -> None:
        """Remove an station by name."""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._remove_station_by_name_metadata, name)

    _remove_at_index_metadata = { "name" : "remove_at_index",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    def remove_at_index(self, index:int) -> None:
        """Remove procedure at the given index."""
        return self._intf.invoke(IStationCollection._metadata, IStationCollection._remove_at_index_metadata, index)

    _get_station_names_metadata = { "name" : "station_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def station_names(self) -> list:
        """Returns the station names."""
        return self._intf.get_property(IStationCollection._metadata, IStationCollection._get_station_names_metadata)

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{c4e09526-9742-4f58-9943-b176e5192b24}", IStationCollection)
agcls.AgTypeNameMap["IStationCollection"] = IStationCollection

class IConfiguration(object):
    """Interface used to change an aircraft's configuration for an Aviator mission."""
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{33bb7422-861d-4949-a165-cb4a416c400b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_empty_weight" : 1,
                             "set_empty_weight" : 2,
                             "get_max_landing_weight" : 3,
                             "set_max_landing_weight" : 4,
                             "get_base_drag_index" : 5,
                             "set_base_drag_index" : 6,
                             "get_empty_cgx" : 7,
                             "get_empty_cgy" : 8,
                             "get_empty_cgz" : 9,
                             "set_empty_cg" : 10,
                             "get_total_weight" : 11,
                             "get_total_weight_max_fuel" : 12,
                             "get_total_drag_index" : 13,
                             "get_total_cgx" : 14,
                             "get_total_cgy" : 15,
                             "get_total_cgz" : 16,
                             "paste_configuration" : 17,
                             "get_stations" : 18,
                             "get_total_capacity" : 19,
                             "get_initial_fuel_state" : 20,
                             "save" : 21, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IConfiguration._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IConfiguration from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConfiguration.__dict__ and type(IConfiguration.__dict__[attrname]) == property:
            return IConfiguration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConfiguration.")
    
    _get_empty_weight_metadata = { "name" : "empty_weight",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def empty_weight(self) -> float:
        """The empty weight of the aircraft."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_empty_weight_metadata)

    _set_empty_weight_metadata = { "name" : "empty_weight",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @empty_weight.setter
    def empty_weight(self, newVal:float) -> None:
        """The empty weight of the aircraft."""
        return self._intf.set_property(IConfiguration._metadata, IConfiguration._set_empty_weight_metadata, newVal)

    _get_max_landing_weight_metadata = { "name" : "max_landing_weight",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_landing_weight(self) -> float:
        """The max landing weight of the aircraft."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_max_landing_weight_metadata)

    _set_max_landing_weight_metadata = { "name" : "max_landing_weight",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_landing_weight.setter
    def max_landing_weight(self, newVal:float) -> None:
        """The max landing weight of the aircraft."""
        return self._intf.set_property(IConfiguration._metadata, IConfiguration._set_max_landing_weight_metadata, newVal)

    _get_base_drag_index_metadata = { "name" : "base_drag_index",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def base_drag_index(self) -> float:
        """The base drag index of the aircraft."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_base_drag_index_metadata)

    _set_base_drag_index_metadata = { "name" : "base_drag_index",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @base_drag_index.setter
    def base_drag_index(self, newVal:float) -> None:
        """The base drag index of the aircraft."""
        return self._intf.set_property(IConfiguration._metadata, IConfiguration._set_base_drag_index_metadata, newVal)

    _get_empty_cgx_metadata = { "name" : "empty_cgx",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def empty_cgx(self) -> float:
        """The X value of the aircraft's Empty CG position."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_empty_cgx_metadata)

    _get_empty_cgy_metadata = { "name" : "empty_cgy",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def empty_cgy(self) -> float:
        """The Y value of the aircraft's Empty CG position."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_empty_cgy_metadata)

    _get_empty_cgz_metadata = { "name" : "empty_cgz",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def empty_cgz(self) -> float:
        """The Z value of the aircraft's Empty CG position."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_empty_cgz_metadata)

    _set_empty_cg_metadata = { "name" : "set_empty_cg",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_empty_cg(self, x:float, y:float, z:float) -> None:
        """Set the aircraft's Empty CG position."""
        return self._intf.invoke(IConfiguration._metadata, IConfiguration._set_empty_cg_metadata, x, y, z)

    _get_total_weight_metadata = { "name" : "total_weight",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_weight(self) -> float:
        """The total weight of the aircraft."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_total_weight_metadata)

    _get_total_weight_max_fuel_metadata = { "name" : "total_weight_max_fuel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_weight_max_fuel(self) -> float:
        """The total weight of the aircraft with all fuel tanks full."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_total_weight_max_fuel_metadata)

    _get_total_drag_index_metadata = { "name" : "total_drag_index",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_drag_index(self) -> float:
        """The total drag index of the aircraft."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_total_drag_index_metadata)

    _get_total_cgx_metadata = { "name" : "total_cgx",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_cgx(self) -> float:
        """The X value of the aircraft's Total CG position."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_total_cgx_metadata)

    _get_total_cgy_metadata = { "name" : "total_cgy",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_cgy(self) -> float:
        """The Y value of the aircraft's Total CG position."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_total_cgy_metadata)

    _get_total_cgz_metadata = { "name" : "total_cgz",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_cgz(self) -> float:
        """The Z value of the aircraft's Total CG position."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_total_cgz_metadata)

    _paste_configuration_metadata = { "name" : "paste_configuration",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IConfiguration"),) }
    def paste_configuration(self, otherConfiguration:"IConfiguration") -> None:
        """Paste the aircraft's configuration."""
        return self._intf.invoke(IConfiguration._metadata, IConfiguration._paste_configuration_metadata, otherConfiguration)

    _get_stations_metadata = { "name" : "get_stations",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_stations(self) -> "StationCollection":
        """Get a collection of the aircraft's payload stations."""
        return self._intf.invoke(IConfiguration._metadata, IConfiguration._get_stations_metadata, out_arg())

    _get_total_capacity_metadata = { "name" : "total_capacity",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def total_capacity(self) -> float:
        """The total fuel capacity of the aircraft."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_total_capacity_metadata)

    _get_initial_fuel_state_metadata = { "name" : "initial_fuel_state",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def initial_fuel_state(self) -> float:
        """The initial fuel state of the aircraft."""
        return self._intf.get_property(IConfiguration._metadata, IConfiguration._get_initial_fuel_state_metadata)

    _save_metadata = { "name" : "save",
            "arg_types" : (),
            "marshallers" : () }
    def save(self) -> None:
        """Save."""
        return self._intf.invoke(IConfiguration._metadata, IConfiguration._save_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{33bb7422-861d-4949-a165-cb4a416c400b}", IConfiguration)
agcls.AgTypeNameMap["IConfiguration"] = IConfiguration

class ICatalogSource(object):
    """Interface used to access options for a source in the Aviator Catalog. Examples of sources include User Aircraft Models, ARINC424runways, User Runways, etc."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ea6e896f-5c4d-4614-9835-4a9f598e52b3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_child_names" : 1,
                             "contains" : 2,
                             "remove_child" : 3,
                             "save" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalogSource._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalogSource from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogSource.__dict__ and type(ICatalogSource.__dict__[attrname]) == property:
            return ICatalogSource.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogSource.")
    
    _get_child_names_metadata = { "name" : "child_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def child_names(self) -> list:
        """Returns the child names."""
        return self._intf.get_property(ICatalogSource._metadata, ICatalogSource._get_child_names_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, aircraftName:str) -> bool:
        """Checks whether the catalog source contains the catalog item with the given name."""
        return self._intf.invoke(ICatalogSource._metadata, ICatalogSource._contains_metadata, aircraftName, out_arg())

    _remove_child_metadata = { "name" : "remove_child",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove_child(self, childName:str) -> None:
        """Removes the child with the given name."""
        return self._intf.invoke(ICatalogSource._metadata, ICatalogSource._remove_child_metadata, childName)

    _save_metadata = { "name" : "save",
            "arg_types" : (),
            "marshallers" : () }
    def save(self) -> None:
        """Saves the catalog item."""
        return self._intf.invoke(ICatalogSource._metadata, ICatalogSource._save_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{ea6e896f-5c4d-4614-9835-4a9f598e52b3}", ICatalogSource)
agcls.AgTypeNameMap["ICatalogSource"] = ICatalogSource

class IAircraftModels(object):
    """Interface for the User Aircraft Models in the Aviator Catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7fffbf9b-1624-4cc9-ba50-ad078c509123}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_aircraft" : 1,
                             "add_aircraft" : 2,
                             "get_as_catalog_source" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftModels._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftModels from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftModels.__dict__ and type(IAircraftModels.__dict__[attrname]) == property:
            return IAircraftModels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftModels.")
    
    _get_aircraft_metadata = { "name" : "get_aircraft",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_aircraft(self, aircraftName:str) -> "AircraftModel":
        """Gets the aircraft with the given name."""
        return self._intf.invoke(IAircraftModels._metadata, IAircraftModels._get_aircraft_metadata, aircraftName, out_arg())

    _add_aircraft_metadata = { "name" : "add_aircraft",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_aircraft(self, aircraftName:str) -> "AircraftModel":
        """Creates a new aircraft with the given name."""
        return self._intf.invoke(IAircraftModels._metadata, IAircraftModels._add_aircraft_metadata, aircraftName, out_arg())

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IAircraftModels._metadata, IAircraftModels._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7fffbf9b-1624-4cc9-ba50-ad078c509123}", IAircraftModels)
agcls.AgTypeNameMap["IAircraftModels"] = IAircraftModels

class IMissileModels(object):
    """Interface for the User Missile Models in the Aviator Catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7d284b91-7746-4fb4-bb96-a115192c18b6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_missile" : 1,
                             "add_missile" : 2,
                             "get_as_catalog_source" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMissileModels._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMissileModels from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissileModels.__dict__ and type(IMissileModels.__dict__[attrname]) == property:
            return IMissileModels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissileModels.")
    
    _get_missile_metadata = { "name" : "get_missile",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_missile(self, name:str) -> "MissileModel":
        """Gets the missile with the given name."""
        return self._intf.invoke(IMissileModels._metadata, IMissileModels._get_missile_metadata, name, out_arg())

    _add_missile_metadata = { "name" : "add_missile",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_missile(self, name:str) -> "MissileModel":
        """Creates a new missile with the given name."""
        return self._intf.invoke(IMissileModels._metadata, IMissileModels._add_missile_metadata, name, out_arg())

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IMissileModels._metadata, IMissileModels._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7d284b91-7746-4fb4-bb96-a115192c18b6}", IMissileModels)
agcls.AgTypeNameMap["IMissileModels"] = IMissileModels

class IRotorcraftModels(object):
    """Interface for the User Rotorcraft Models in the Aviator Catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{60605557-ec23-4435-a778-d524335f9244}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_rotorcraft" : 1,
                             "add_rotorcraft" : 2,
                             "get_as_catalog_source" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IRotorcraftModels._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IRotorcraftModels from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRotorcraftModels.__dict__ and type(IRotorcraftModels.__dict__[attrname]) == property:
            return IRotorcraftModels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRotorcraftModels.")
    
    _get_rotorcraft_metadata = { "name" : "get_rotorcraft",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_rotorcraft(self, name:str) -> "RotorcraftModel":
        """Gets the rotorcraft with the given name."""
        return self._intf.invoke(IRotorcraftModels._metadata, IRotorcraftModels._get_rotorcraft_metadata, name, out_arg())

    _add_rotorcraft_metadata = { "name" : "add_rotorcraft",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def add_rotorcraft(self, name:str) -> "RotorcraftModel":
        """Creates a new rotorcraft with the given name."""
        return self._intf.invoke(IRotorcraftModels._metadata, IRotorcraftModels._add_rotorcraft_metadata, name, out_arg())

    _get_as_catalog_source_metadata = { "name" : "get_as_catalog_source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_source(self) -> "ICatalogSource":
        """Get the catalog source interface for this object."""
        return self._intf.invoke(IRotorcraftModels._metadata, IRotorcraftModels._get_as_catalog_source_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{60605557-ec23-4435-a778-d524335f9244}", IRotorcraftModels)
agcls.AgTypeNameMap["IRotorcraftModels"] = IRotorcraftModels

class IBasicFixedWingLiftHelper(object):
    """Interface used to access Lift Coefficient Helper in the Basic Fixed Wing Aerodynamics interface for the Basic Acceleration Model of an aircraft."""
    _num_methods = 0
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{6c9d7ac9-cf16-4110-87e4-080c83a44322}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicFixedWingLiftHelper._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicFixedWingLiftHelper from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicFixedWingLiftHelper.__dict__ and type(IBasicFixedWingLiftHelper.__dict__[attrname]) == property:
            return IBasicFixedWingLiftHelper.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicFixedWingLiftHelper.")
    

agcls.AgClassCatalog.add_catalog_entry("{6c9d7ac9-cf16-4110-87e4-080c83a44322}", IBasicFixedWingLiftHelper)
agcls.AgTypeNameMap["IBasicFixedWingLiftHelper"] = IBasicFixedWingLiftHelper

class IAircraftBasicFixedWingAero(object):
    """Interface used to access Basic Fixed Wing Aerodynamics interface for the Basic Acceleration Model of an aircraft."""
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{cdf3e057-6192-4817-a72b-8f3cba8b38e5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_forward_flight_reference_area" : 1,
                             "set_forward_flight_reference_area" : 2,
                             "get_forward_flight_use_compressible_flow" : 3,
                             "set_forward_flight_use_compressible_flow" : 4,
                             "get_forward_flight_cl0" : 5,
                             "set_forward_flight_cl0" : 6,
                             "get_forward_flight_cl_alpha" : 7,
                             "set_forward_flight_cl_alpha" : 8,
                             "get_forward_flight_min_aoa" : 9,
                             "set_forward_flight_min_aoa" : 10,
                             "get_forward_flight_max_aoa" : 11,
                             "set_forward_flight_max_aoa" : 12,
                             "get_forward_flight_cd0" : 13,
                             "set_forward_flight_cd0" : 14,
                             "get_forward_flight_k" : 15,
                             "set_forward_flight_k" : 16,
                             "get_takeoff_landing_reference_area" : 17,
                             "set_takeoff_landing_reference_area" : 18,
                             "get_takeoff_landing_use_compressible_flow" : 19,
                             "set_takeoff_landing_use_compressible_flow" : 20,
                             "get_takeoff_landing_cl0" : 21,
                             "set_takeoff_landing_cl0" : 22,
                             "get_takeoff_landing_cl_alpha" : 23,
                             "set_takeoff_landing_cl_alpha" : 24,
                             "get_takeoff_landing_min_aoa" : 25,
                             "set_takeoff_landing_min_aoa" : 26,
                             "get_takeoff_landing_max_aoa" : 27,
                             "set_takeoff_landing_max_aoa" : 28,
                             "get_takeoff_landing_cd0" : 29,
                             "set_takeoff_landing_cd0" : 30,
                             "get_takeoff_landing_k" : 31,
                             "set_takeoff_landing_k" : 32, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftBasicFixedWingAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftBasicFixedWingAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftBasicFixedWingAero.__dict__ and type(IAircraftBasicFixedWingAero.__dict__[attrname]) == property:
            return IAircraftBasicFixedWingAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftBasicFixedWingAero.")
    
    _get_forward_flight_reference_area_metadata = { "name" : "forward_flight_reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_reference_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_reference_area_metadata)

    _set_forward_flight_reference_area_metadata = { "name" : "forward_flight_reference_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @forward_flight_reference_area.setter
    def forward_flight_reference_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_reference_area_metadata, pVal)

    _get_forward_flight_use_compressible_flow_metadata = { "name" : "forward_flight_use_compressible_flow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def forward_flight_use_compressible_flow(self) -> bool:
        """Opt to define the aerodynamic parameters for forward flight with respect to supersonic flight conditions."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_use_compressible_flow_metadata)

    _set_forward_flight_use_compressible_flow_metadata = { "name" : "forward_flight_use_compressible_flow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @forward_flight_use_compressible_flow.setter
    def forward_flight_use_compressible_flow(self, newVal:bool) -> None:
        """Opt to define the aerodynamic parameters for forward flight with respect to supersonic flight conditions."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_use_compressible_flow_metadata, newVal)

    _get_forward_flight_cl0_metadata = { "name" : "forward_flight_cl0",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_cl0(self) -> float:
        """The coefficient of lift at zero angle of attack."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_cl0_metadata)

    _set_forward_flight_cl0_metadata = { "name" : "forward_flight_cl0",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @forward_flight_cl0.setter
    def forward_flight_cl0(self, newVal:float) -> None:
        """The coefficient of lift at zero angle of attack."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_cl0_metadata, newVal)

    _get_forward_flight_cl_alpha_metadata = { "name" : "forward_flight_cl_alpha",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_cl_alpha(self) -> float:
        """The slope of the coefficient of lift curve."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_cl_alpha_metadata)

    _set_forward_flight_cl_alpha_metadata = { "name" : "forward_flight_cl_alpha",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @forward_flight_cl_alpha.setter
    def forward_flight_cl_alpha(self, newVal:float) -> None:
        """The slope of the coefficient of lift curve."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_cl_alpha_metadata, newVal)

    _get_forward_flight_min_aoa_metadata = { "name" : "forward_flight_min_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def forward_flight_min_aoa(self) -> typing.Any:
        """The minimum angle of attack possible."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_min_aoa_metadata)

    _set_forward_flight_min_aoa_metadata = { "name" : "forward_flight_min_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @forward_flight_min_aoa.setter
    def forward_flight_min_aoa(self, newVal:typing.Any) -> None:
        """The minimum angle of attack possible."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_min_aoa_metadata, newVal)

    _get_forward_flight_max_aoa_metadata = { "name" : "forward_flight_max_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def forward_flight_max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_max_aoa_metadata)

    _set_forward_flight_max_aoa_metadata = { "name" : "forward_flight_max_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @forward_flight_max_aoa.setter
    def forward_flight_max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_max_aoa_metadata, newVal)

    _get_forward_flight_cd0_metadata = { "name" : "forward_flight_cd0",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_cd0(self) -> float:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_cd0_metadata)

    _set_forward_flight_cd0_metadata = { "name" : "forward_flight_cd0",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @forward_flight_cd0.setter
    def forward_flight_cd0(self, newVal:float) -> None:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_cd0_metadata, newVal)

    _get_forward_flight_k_metadata = { "name" : "forward_flight_k",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def forward_flight_k(self) -> float:
        """The coefficient of induced drag."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_forward_flight_k_metadata)

    _set_forward_flight_k_metadata = { "name" : "forward_flight_k",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @forward_flight_k.setter
    def forward_flight_k(self, newVal:float) -> None:
        """The coefficient of induced drag."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_forward_flight_k_metadata, newVal)

    _get_takeoff_landing_reference_area_metadata = { "name" : "takeoff_landing_reference_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def takeoff_landing_reference_area(self) -> float:
        """The area of the lifting surface of the aircraft."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_reference_area_metadata)

    _set_takeoff_landing_reference_area_metadata = { "name" : "takeoff_landing_reference_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @takeoff_landing_reference_area.setter
    def takeoff_landing_reference_area(self, pVal:float) -> None:
        """The area of the lifting surface of the aircraft."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_reference_area_metadata, pVal)

    _get_takeoff_landing_use_compressible_flow_metadata = { "name" : "takeoff_landing_use_compressible_flow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def takeoff_landing_use_compressible_flow(self) -> bool:
        """Opt to define the aerodynamic parameters for takeoff and landing with respect to supersonic flight conditions."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_use_compressible_flow_metadata)

    _set_takeoff_landing_use_compressible_flow_metadata = { "name" : "takeoff_landing_use_compressible_flow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @takeoff_landing_use_compressible_flow.setter
    def takeoff_landing_use_compressible_flow(self, newVal:bool) -> None:
        """Opt to define the aerodynamic parameters for takeoff and landing with respect to supersonic flight conditions."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_use_compressible_flow_metadata, newVal)

    _get_takeoff_landing_cl0_metadata = { "name" : "takeoff_landing_cl0",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def takeoff_landing_cl0(self) -> float:
        """The coefficient of lift at zero angle of attack."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_cl0_metadata)

    _set_takeoff_landing_cl0_metadata = { "name" : "takeoff_landing_cl0",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @takeoff_landing_cl0.setter
    def takeoff_landing_cl0(self, newVal:float) -> None:
        """The coefficient of lift at zero angle of attack."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_cl0_metadata, newVal)

    _get_takeoff_landing_cl_alpha_metadata = { "name" : "takeoff_landing_cl_alpha",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def takeoff_landing_cl_alpha(self) -> float:
        """The slope of the coefficient of lift curve."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_cl_alpha_metadata)

    _set_takeoff_landing_cl_alpha_metadata = { "name" : "takeoff_landing_cl_alpha",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @takeoff_landing_cl_alpha.setter
    def takeoff_landing_cl_alpha(self, newVal:float) -> None:
        """The slope of the coefficient of lift curve."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_cl_alpha_metadata, newVal)

    _get_takeoff_landing_min_aoa_metadata = { "name" : "takeoff_landing_min_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def takeoff_landing_min_aoa(self) -> typing.Any:
        """The minimum angle of attack possible."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_min_aoa_metadata)

    _set_takeoff_landing_min_aoa_metadata = { "name" : "takeoff_landing_min_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @takeoff_landing_min_aoa.setter
    def takeoff_landing_min_aoa(self, newVal:typing.Any) -> None:
        """The minimum angle of attack possible."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_min_aoa_metadata, newVal)

    _get_takeoff_landing_max_aoa_metadata = { "name" : "takeoff_landing_max_aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def takeoff_landing_max_aoa(self) -> typing.Any:
        """The maximum angle of attack possible."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_max_aoa_metadata)

    _set_takeoff_landing_max_aoa_metadata = { "name" : "takeoff_landing_max_aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @takeoff_landing_max_aoa.setter
    def takeoff_landing_max_aoa(self, newVal:typing.Any) -> None:
        """The maximum angle of attack possible."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_max_aoa_metadata, newVal)

    _get_takeoff_landing_cd0_metadata = { "name" : "takeoff_landing_cd0",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def takeoff_landing_cd0(self) -> float:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_cd0_metadata)

    _set_takeoff_landing_cd0_metadata = { "name" : "takeoff_landing_cd0",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @takeoff_landing_cd0.setter
    def takeoff_landing_cd0(self, newVal:float) -> None:
        """The coefficient of drag of the lifting surface at zero angle of attack."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_cd0_metadata, newVal)

    _get_takeoff_landing_k_metadata = { "name" : "takeoff_landing_k",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def takeoff_landing_k(self) -> float:
        """The coefficient of induced drag."""
        return self._intf.get_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._get_takeoff_landing_k_metadata)

    _set_takeoff_landing_k_metadata = { "name" : "takeoff_landing_k",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @takeoff_landing_k.setter
    def takeoff_landing_k(self, newVal:float) -> None:
        """The coefficient of induced drag."""
        return self._intf.set_property(IAircraftBasicFixedWingAero._metadata, IAircraftBasicFixedWingAero._set_takeoff_landing_k_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{cdf3e057-6192-4817-a72b-8f3cba8b38e5}", IAircraftBasicFixedWingAero)
agcls.AgTypeNameMap["IAircraftBasicFixedWingAero"] = IAircraftBasicFixedWingAero

class IAircraftAero(object):
    """Interface used to access the Aerodynamics options for the Basic Acceleration Model of an aircraft."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{cade76fa-36f7-4711-affc-77d00899be77}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_aero_strategy" : 1,
                             "set_aero_strategy" : 2,
                             "get_mode_as_simple" : 3,
                             "get_mode_as_basic_fixed_wing" : 4,
                             "get_mode_as_external" : 5,
                             "get_mode_as_advanced_missile" : 6,
                             "get_lift_factor" : 7,
                             "set_lift_factor" : 8,
                             "get_drag_factor" : 9,
                             "set_drag_factor" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAero._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAero from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAero.__dict__ and type(IAircraftAero.__dict__[attrname]) == property:
            return IAircraftAero.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAero.")
    
    _get_aero_strategy_metadata = { "name" : "aero_strategy",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRCRAFT_AERO_STRATEGY),) }
    @property
    def aero_strategy(self) -> "AIRCRAFT_AERO_STRATEGY":
        """The aerodynamic strategy type."""
        return self._intf.get_property(IAircraftAero._metadata, IAircraftAero._get_aero_strategy_metadata)

    _set_aero_strategy_metadata = { "name" : "aero_strategy",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRCRAFT_AERO_STRATEGY),) }
    @aero_strategy.setter
    def aero_strategy(self, newVal:"AIRCRAFT_AERO_STRATEGY") -> None:
        """The aerodynamic strategy type."""
        return self._intf.set_property(IAircraftAero._metadata, IAircraftAero._set_aero_strategy_metadata, newVal)

    _get_mode_as_simple_metadata = { "name" : "mode_as_simple",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_simple(self) -> "AircraftSimpleAero":
        """Get the interface for a simple aerodynamics strategy."""
        return self._intf.get_property(IAircraftAero._metadata, IAircraftAero._get_mode_as_simple_metadata)

    _get_mode_as_basic_fixed_wing_metadata = { "name" : "mode_as_basic_fixed_wing",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_basic_fixed_wing(self) -> "AircraftBasicFixedWingAero":
        """Get the interface for a basic fixed wing aerodynamics strategy."""
        return self._intf.get_property(IAircraftAero._metadata, IAircraftAero._get_mode_as_basic_fixed_wing_metadata)

    _get_mode_as_external_metadata = { "name" : "mode_as_external",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_external(self) -> "AircraftExternalAero":
        """Get the interface for an external file aerodynamics strategy."""
        return self._intf.get_property(IAircraftAero._metadata, IAircraftAero._get_mode_as_external_metadata)

    _get_mode_as_advanced_missile_metadata = { "name" : "mode_as_advanced_missile",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_advanced_missile(self) -> "MissileAdvancedAero":
        """Get the interface for an advanced missile aerodynamics strategy."""
        return self._intf.get_property(IAircraftAero._metadata, IAircraftAero._get_mode_as_advanced_missile_metadata)

    _get_lift_factor_metadata = { "name" : "lift_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def lift_factor(self) -> float:
        """A scalar value applied to the lift for parametric analysis."""
        return self._intf.get_property(IAircraftAero._metadata, IAircraftAero._get_lift_factor_metadata)

    _set_lift_factor_metadata = { "name" : "lift_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @lift_factor.setter
    def lift_factor(self, newVal:float) -> None:
        """A scalar value applied to the lift for parametric analysis."""
        return self._intf.set_property(IAircraftAero._metadata, IAircraftAero._set_lift_factor_metadata, newVal)

    _get_drag_factor_metadata = { "name" : "drag_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def drag_factor(self) -> float:
        """A scalar value applied to the drag for parametric analysis."""
        return self._intf.get_property(IAircraftAero._metadata, IAircraftAero._get_drag_factor_metadata)

    _set_drag_factor_metadata = { "name" : "drag_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @drag_factor.setter
    def drag_factor(self, newVal:float) -> None:
        """A scalar value applied to the drag for parametric analysis."""
        return self._intf.set_property(IAircraftAero._metadata, IAircraftAero._set_drag_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{cade76fa-36f7-4711-affc-77d00899be77}", IAircraftAero)
agcls.AgTypeNameMap["IAircraftAero"] = IAircraftAero

class IAircraftProp(object):
    """Interface used to access the propulsion options for the Basic Acceleration Model of an aircraft."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f2c9e37e-da9b-4210-94d6-b90c90d1a696}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_prop_strategy" : 1,
                             "set_prop_strategy" : 2,
                             "get_mode_as_simple" : 3,
                             "get_mode_as_basic_fixed_wing" : 4,
                             "get_mode_as_external" : 5,
                             "get_lift_factor" : 6,
                             "set_lift_factor" : 7,
                             "get_drag_factor" : 8,
                             "set_drag_factor" : 9,
                             "get_mode_as_ramjet" : 10,
                             "get_mode_as_turbojet" : 11,
                             "get_mode_as_rocket" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftProp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftProp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftProp.__dict__ and type(IAircraftProp.__dict__[attrname]) == property:
            return IAircraftProp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftProp.")
    
    _get_prop_strategy_metadata = { "name" : "prop_strategy",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRCRAFT_PROP_STRATEGY),) }
    @property
    def prop_strategy(self) -> "AIRCRAFT_PROP_STRATEGY":
        """The propulsion strategy type."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_prop_strategy_metadata)

    _set_prop_strategy_metadata = { "name" : "prop_strategy",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRCRAFT_PROP_STRATEGY),) }
    @prop_strategy.setter
    def prop_strategy(self, newVal:"AIRCRAFT_PROP_STRATEGY") -> None:
        """The propulsion strategy type."""
        return self._intf.set_property(IAircraftProp._metadata, IAircraftProp._set_prop_strategy_metadata, newVal)

    _get_mode_as_simple_metadata = { "name" : "mode_as_simple",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_simple(self) -> "AircraftSimpleProp":
        """Get the interface for a simple propulsion strategy."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_mode_as_simple_metadata)

    _get_mode_as_basic_fixed_wing_metadata = { "name" : "mode_as_basic_fixed_wing",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_basic_fixed_wing(self) -> "AircraftBasicFixedWingProp":
        """Get the interface for a basic fixed wing propulsion strategy."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_mode_as_basic_fixed_wing_metadata)

    _get_mode_as_external_metadata = { "name" : "mode_as_external",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_external(self) -> "AircraftExternalProp":
        """Get the interface for an external file propulsion strategy."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_mode_as_external_metadata)

    _get_lift_factor_metadata = { "name" : "lift_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def lift_factor(self) -> float:
        """A scalar value applied to the lift for parametric analysis."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_lift_factor_metadata)

    _set_lift_factor_metadata = { "name" : "lift_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @lift_factor.setter
    def lift_factor(self, newVal:float) -> None:
        """A scalar value applied to the lift for parametric analysis."""
        return self._intf.set_property(IAircraftProp._metadata, IAircraftProp._set_lift_factor_metadata, newVal)

    _get_drag_factor_metadata = { "name" : "drag_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def drag_factor(self) -> float:
        """A scalar value applied to the drag for parametric analysis."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_drag_factor_metadata)

    _set_drag_factor_metadata = { "name" : "drag_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @drag_factor.setter
    def drag_factor(self, newVal:float) -> None:
        """A scalar value applied to the drag for parametric analysis."""
        return self._intf.set_property(IAircraftProp._metadata, IAircraftProp._set_drag_factor_metadata, newVal)

    _get_mode_as_ramjet_metadata = { "name" : "mode_as_ramjet",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_ramjet(self) -> "MissileRamjetProp":
        """Get the interface for a Ramjet propulsion strategy."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_mode_as_ramjet_metadata)

    _get_mode_as_turbojet_metadata = { "name" : "mode_as_turbojet",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_turbojet(self) -> "MissileTurbojetProp":
        """Get the interface for a Turbojet propulsion strategy."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_mode_as_turbojet_metadata)

    _get_mode_as_rocket_metadata = { "name" : "mode_as_rocket",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_rocket(self) -> "MissileRocketProp":
        """Get the interface for a Rocket propulsion strategy."""
        return self._intf.get_property(IAircraftProp._metadata, IAircraftProp._get_mode_as_rocket_metadata)


agcls.AgClassCatalog.add_catalog_entry("{f2c9e37e-da9b-4210-94d6-b90c90d1a696}", IAircraftProp)
agcls.AgTypeNameMap["IAircraftProp"] = IAircraftProp

class IAircraftAccelerationMode(object):
    """Interface used to set the Acceleration Mode for the Advanced Acceleration Model of an aircraft."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ed792861-7946-4e82-bf56-24fd86d3fdb2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_accel_mode" : 1,
                             "set_accel_mode" : 2,
                             "get_accel_g" : 3,
                             "set_accel_g" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAccelerationMode._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAccelerationMode from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAccelerationMode.__dict__ and type(IAircraftAccelerationMode.__dict__[attrname]) == property:
            return IAircraftAccelerationMode.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAccelerationMode.")
    
    _get_accel_mode_metadata = { "name" : "accel_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ACCELERATION_ADV_ACCEL_MODE),) }
    @property
    def accel_mode(self) -> "ACCELERATION_ADV_ACCEL_MODE":
        """Opt whether to override the acceleration or deceleration of the aircraft."""
        return self._intf.get_property(IAircraftAccelerationMode._metadata, IAircraftAccelerationMode._get_accel_mode_metadata)

    _set_accel_mode_metadata = { "name" : "accel_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ACCELERATION_ADV_ACCEL_MODE),) }
    @accel_mode.setter
    def accel_mode(self, newVal:"ACCELERATION_ADV_ACCEL_MODE") -> None:
        """Opt whether to override the acceleration or deceleration of the aircraft."""
        return self._intf.set_property(IAircraftAccelerationMode._metadata, IAircraftAccelerationMode._set_accel_mode_metadata, newVal)

    _get_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_g(self) -> float:
        """The rate of acceleration or deceleration of the aircraft if the accleeration mode is set to override."""
        return self._intf.get_property(IAircraftAccelerationMode._metadata, IAircraftAccelerationMode._get_accel_g_metadata)

    _set_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The rate of acceleration or deceleration of the aircraft if the accleeration mode is set to override."""
        return self._intf.set_property(IAircraftAccelerationMode._metadata, IAircraftAccelerationMode._set_accel_g_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{ed792861-7946-4e82-bf56-24fd86d3fdb2}", IAircraftAccelerationMode)
agcls.AgTypeNameMap["IAircraftAccelerationMode"] = IAircraftAccelerationMode

class IAircraftAdvAccelerationModel(object):
    """Interface used to access the Advanced Acceleration Model options of an aircraft."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{bb08fcaa-8e26-49be-bde2-9bbe5408c1fa}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_level_turns" : 1,
                             "get_attitude_transitions" : 2,
                             "get_climb_and_descent_transitions" : 3,
                             "get_acceleration_mode" : 4,
                             "get_as_catalog_item" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAdvAccelerationModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAdvAccelerationModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAdvAccelerationModel.__dict__ and type(IAircraftAdvAccelerationModel.__dict__[attrname]) == property:
            return IAircraftAdvAccelerationModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAdvAccelerationModel.")
    
    _get_level_turns_metadata = { "name" : "level_turns",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def level_turns(self) -> "LevelTurns":
        """Get the level turns interface."""
        return self._intf.get_property(IAircraftAdvAccelerationModel._metadata, IAircraftAdvAccelerationModel._get_level_turns_metadata)

    _get_attitude_transitions_metadata = { "name" : "attitude_transitions",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def attitude_transitions(self) -> "AttitudeTransitions":
        """Get the attitude transitions interface."""
        return self._intf.get_property(IAircraftAdvAccelerationModel._metadata, IAircraftAdvAccelerationModel._get_attitude_transitions_metadata)

    _get_climb_and_descent_transitions_metadata = { "name" : "climb_and_descent_transitions",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def climb_and_descent_transitions(self) -> "ClimbAndDescentTransitions":
        """Get the climb and descent transitions interface."""
        return self._intf.get_property(IAircraftAdvAccelerationModel._metadata, IAircraftAdvAccelerationModel._get_climb_and_descent_transitions_metadata)

    _get_acceleration_mode_metadata = { "name" : "acceleration_mode",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def acceleration_mode(self) -> "AircraftAccelerationMode":
        """Get the acceleration mode interface."""
        return self._intf.get_property(IAircraftAdvAccelerationModel._metadata, IAircraftAdvAccelerationModel._get_acceleration_mode_metadata)

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftAdvAccelerationModel._metadata, IAircraftAdvAccelerationModel._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{bb08fcaa-8e26-49be-bde2-9bbe5408c1fa}", IAircraftAdvAccelerationModel)
agcls.AgTypeNameMap["IAircraftAdvAccelerationModel"] = IAircraftAdvAccelerationModel

class IAeroPropManeuverModeHelper(object):
    """Interface used to access the The calculation mode for the Aero/Prop maneuver mode helper. Helper found in the Basic Acceleration Model of an aircraft."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{52d6c08d-32e5-49f1-bda0-96469ed01a6f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_mode" : 1,
                             "set_mode" : 2,
                             "get_flight_mode" : 3,
                             "set_flight_mode" : 4,
                             "get_use_afterburner" : 5,
                             "set_use_afterburner" : 6,
                             "get_reference_weight" : 7,
                             "set_reference_weight" : 8,
                             "get_reference_altitude" : 9,
                             "set_reference_altitude" : 10,
                             "get_reference_airspeed" : 11,
                             "get_reference_airspeed_type" : 12,
                             "set_reference_airspeed" : 13,
                             "get_reference_load_factor" : 14,
                             "set_reference_load_factor" : 15,
                             "get_estimated_ps" : 16,
                             "get_control_authority" : 17,
                             "set_control_authority" : 18,
                             "get_status_msg" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAeroPropManeuverModeHelper._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAeroPropManeuverModeHelper from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAeroPropManeuverModeHelper.__dict__ and type(IAeroPropManeuverModeHelper.__dict__[attrname]) == property:
            return IAeroPropManeuverModeHelper.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAeroPropManeuverModeHelper.")
    
    _get_mode_metadata = { "name" : "mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_AERO_PROP_MODE),) }
    @property
    def mode(self) -> "ACCEL_MANEUVER_AERO_PROP_MODE":
        """The calculation mode for the Aero/Prop maneuver mode helper."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_mode_metadata)

    _set_mode_metadata = { "name" : "mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MANEUVER_AERO_PROP_MODE),) }
    @mode.setter
    def mode(self, newVal:"ACCEL_MANEUVER_AERO_PROP_MODE") -> None:
        """The calculation mode for the Aero/Prop maneuver mode helper."""
        return self._intf.set_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_mode_metadata, newVal)

    _get_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AERO_PROP_FLIGHT_MODE),) }
    @property
    def flight_mode(self) -> "AERO_PROP_FLIGHT_MODE":
        """The performance flight mode."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_flight_mode_metadata)

    _set_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AERO_PROP_FLIGHT_MODE),) }
    @flight_mode.setter
    def flight_mode(self, newVal:"AERO_PROP_FLIGHT_MODE") -> None:
        """The performance flight mode."""
        return self._intf.set_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_flight_mode_metadata, newVal)

    _get_use_afterburner_metadata = { "name" : "use_afterburner",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_afterburner(self) -> bool:
        """Opt whether to use the afterburner if it is possible."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_use_afterburner_metadata)

    _set_use_afterburner_metadata = { "name" : "use_afterburner",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_afterburner.setter
    def use_afterburner(self, newVal:bool) -> None:
        """Opt whether to use the afterburner if it is possible."""
        return self._intf.set_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_use_afterburner_metadata, newVal)

    _get_reference_weight_metadata = { "name" : "reference_weight",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def reference_weight(self) -> float:
        """The reference weight."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_reference_weight_metadata)

    _set_reference_weight_metadata = { "name" : "reference_weight",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @reference_weight.setter
    def reference_weight(self, newVal:float) -> None:
        """The reference weight."""
        return self._intf.set_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_reference_weight_metadata, newVal)

    _get_reference_altitude_metadata = { "name" : "reference_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def reference_altitude(self) -> float:
        """The reference altitude."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_reference_altitude_metadata)

    _set_reference_altitude_metadata = { "name" : "reference_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @reference_altitude.setter
    def reference_altitude(self, newVal:float) -> None:
        """The reference altitude."""
        return self._intf.set_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_reference_altitude_metadata, newVal)

    _get_reference_airspeed_metadata = { "name" : "reference_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def reference_airspeed(self) -> float:
        """The reference airspeed."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_reference_airspeed_metadata)

    _get_reference_airspeed_type_metadata = { "name" : "reference_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def reference_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The reference airspeed type."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_reference_airspeed_type_metadata)

    _set_reference_airspeed_metadata = { "name" : "set_reference_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_reference_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the reference airspeed and reference airspeed type."""
        return self._intf.invoke(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_reference_airspeed_metadata, airspeedType, airspeed)

    _get_reference_load_factor_metadata = { "name" : "reference_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def reference_load_factor(self) -> float:
        """The reference load factor."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_reference_load_factor_metadata)

    _set_reference_load_factor_metadata = { "name" : "reference_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @reference_load_factor.setter
    def reference_load_factor(self, newVal:float) -> None:
        """The reference load factor."""
        return self._intf.set_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_reference_load_factor_metadata, newVal)

    _get_estimated_ps_metadata = { "name" : "estimated_ps",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def estimated_ps(self) -> float:
        """The estimated specific excess power."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_estimated_ps_metadata)

    _get_control_authority_metadata = { "name" : "control_authority",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_authority(self) -> float:
        """The control authority of how much to factor a turn over push/pull."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_control_authority_metadata)

    _set_control_authority_metadata = { "name" : "control_authority",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @control_authority.setter
    def control_authority(self, newVal:float) -> None:
        """The control authority of how much to factor a turn over push/pull."""
        return self._intf.set_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._set_control_authority_metadata, newVal)

    _get_status_msg_metadata = { "name" : "status_msg",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def status_msg(self) -> str:
        """Get the status message in the message window."""
        return self._intf.get_property(IAeroPropManeuverModeHelper._metadata, IAeroPropManeuverModeHelper._get_status_msg_metadata)


agcls.AgClassCatalog.add_catalog_entry("{52d6c08d-32e5-49f1-bda0-96469ed01a6f}", IAeroPropManeuverModeHelper)
agcls.AgTypeNameMap["IAeroPropManeuverModeHelper"] = IAeroPropManeuverModeHelper

class ICatalogRunway(object):
    """Interface used to access a runway in the Aviator catalog."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{120d6778-93cd-4d78-a63f-c3fb3ca55eb6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalogRunway._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalogRunway from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogRunway.__dict__ and type(ICatalogRunway.__dict__[attrname]) == property:
            return ICatalogRunway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogRunway.")
    

agcls.AgClassCatalog.add_catalog_entry("{120d6778-93cd-4d78-a63f-c3fb3ca55eb6}", ICatalogRunway)
agcls.AgTypeNameMap["ICatalogRunway"] = ICatalogRunway

class ICatalogAirport(object):
    """Interface used to access a airport in the Aviator catalog."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{aed7cf8c-257e-4c91-b829-0d3489bd7bef}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalogAirport._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalogAirport from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogAirport.__dict__ and type(ICatalogAirport.__dict__[attrname]) == property:
            return ICatalogAirport.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogAirport.")
    

agcls.AgClassCatalog.add_catalog_entry("{aed7cf8c-257e-4c91-b829-0d3489bd7bef}", ICatalogAirport)
agcls.AgTypeNameMap["ICatalogAirport"] = ICatalogAirport

class ICatalogNavaid(object):
    """Interface used to access a navaid in the Aviator catalog."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a019db80-a2e3-49bd-9bb0-09d1af40ca00}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalogNavaid._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalogNavaid from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogNavaid.__dict__ and type(ICatalogNavaid.__dict__[attrname]) == property:
            return ICatalogNavaid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogNavaid.")
    

agcls.AgClassCatalog.add_catalog_entry("{a019db80-a2e3-49bd-9bb0-09d1af40ca00}", ICatalogNavaid)
agcls.AgTypeNameMap["ICatalogNavaid"] = ICatalogNavaid

class ICatalogVTOLPoint(object):
    """Interface used to access a VTOL Point in the Aviator catalog."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f4818560-bc87-4fa4-84bc-33d25a14eac5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalogVTOLPoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalogVTOLPoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogVTOLPoint.__dict__ and type(ICatalogVTOLPoint.__dict__[attrname]) == property:
            return ICatalogVTOLPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogVTOLPoint.")
    

agcls.AgClassCatalog.add_catalog_entry("{f4818560-bc87-4fa4-84bc-33d25a14eac5}", ICatalogVTOLPoint)
agcls.AgTypeNameMap["ICatalogVTOLPoint"] = ICatalogVTOLPoint

class ICatalogWaypoint(object):
    """Interface used to access a waypoint in the Aviator catalog."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a3a67fca-89f4-4cc8-9ef0-194707369ef9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalogWaypoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalogWaypoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalogWaypoint.__dict__ and type(ICatalogWaypoint.__dict__[attrname]) == property:
            return ICatalogWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalogWaypoint.")
    

agcls.AgClassCatalog.add_catalog_entry("{a3a67fca-89f4-4cc8-9ef0-194707369ef9}", ICatalogWaypoint)
agcls.AgTypeNameMap["ICatalogWaypoint"] = ICatalogWaypoint

class IARINC424Airport(object):
    """This interface is deprecated. Use IARINC424Item instead."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{38a8e2de-6ca0-42b4-a5c9-9a2ae40ac0d7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_catalog_item" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IARINC424Airport._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Airport from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Airport.__dict__ and type(IARINC424Airport.__dict__[attrname]) == property:
            return IARINC424Airport.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Airport.")
    
    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IARINC424Airport._metadata, IARINC424Airport._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{38a8e2de-6ca0-42b4-a5c9-9a2ae40ac0d7}", IARINC424Airport)
agcls.AgTypeNameMap["IARINC424Airport"] = IARINC424Airport

class IDAFIFItem(object):
    """Interface used to access the options for an DAFIF Item found in the Aviator catalog."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5725c989-94a3-47c9-8115-6d5b88b992aa}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_value" : 1,
                             "get_all_fields" : 2,
                             "get_all_fields_and_values" : 3,
                             "copy_site" : 4,
                             "get_as_catalog_item" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IDAFIFItem._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IDAFIFItem from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDAFIFItem.__dict__ and type(IDAFIFItem.__dict__[attrname]) == property:
            return IDAFIFItem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDAFIFItem.")
    
    _get_value_metadata = { "name" : "get_value",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_arg,) }
    def get_value(self, fieldName:str) -> typing.Any:
        """Get the value of the field with the given name."""
        return self._intf.invoke(IDAFIFItem._metadata, IDAFIFItem._get_value_metadata, fieldName, out_arg())

    _get_all_fields_metadata = { "name" : "get_all_fields",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_all_fields(self) -> list:
        """Get all the field names."""
        return self._intf.invoke(IDAFIFItem._metadata, IDAFIFItem._get_all_fields_metadata, out_arg())

    _get_all_fields_and_values_metadata = { "name" : "get_all_fields_and_values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_all_fields_and_values(self) -> list:
        """Get all the field names along with the corresponding value."""
        return self._intf.invoke(IDAFIFItem._metadata, IDAFIFItem._get_all_fields_and_values_metadata, out_arg())

    _copy_site_metadata = { "name" : "copy_site",
            "arg_types" : (),
            "marshallers" : () }
    def copy_site(self) -> None:
        """Copy the site to the clipboard."""
        return self._intf.invoke(IDAFIFItem._metadata, IDAFIFItem._copy_site_metadata, )

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IDAFIFItem._metadata, IDAFIFItem._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{5725c989-94a3-47c9-8115-6d5b88b992aa}", IDAFIFItem)
agcls.AgTypeNameMap["IDAFIFItem"] = IDAFIFItem

class IARINC424Runway(object):
    """This interface is deprecated. Use IARINC424Item instead."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{fafcfc3b-d259-498d-9000-8ec380048afa}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_catalog_item" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IARINC424Runway._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IARINC424Runway from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IARINC424Runway.__dict__ and type(IARINC424Runway.__dict__[attrname]) == property:
            return IARINC424Runway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IARINC424Runway.")
    
    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IARINC424Runway._metadata, IARINC424Runway._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{fafcfc3b-d259-498d-9000-8ec380048afa}", IARINC424Runway)
agcls.AgTypeNameMap["IARINC424Runway"] = IARINC424Runway

class IAirportCategory(object):
    """Interface used to access the airports in the Aviator catalog."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b1430df6-bb64-4173-af26-0b8c42724d29}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_arinc424_airports" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAirportCategory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAirportCategory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAirportCategory.__dict__ and type(IAirportCategory.__dict__[attrname]) == property:
            return IAirportCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAirportCategory.")
    
    _get_arinc424_airports_metadata = { "name" : "arinc424_airports",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_airports(self) -> "ARINC424Source":
        """Get the ARINC-424 airports."""
        return self._intf.get_property(IAirportCategory._metadata, IAirportCategory._get_arinc424_airports_metadata)


agcls.AgClassCatalog.add_catalog_entry("{b1430df6-bb64-4173-af26-0b8c42724d29}", IAirportCategory)
agcls.AgTypeNameMap["IAirportCategory"] = IAirportCategory

class INavaidCategory(object):
    """Interface used to access the navaids in the Aviator catalog."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5b17c73b-f045-4228-bd66-9b0ed6eb40a1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_arinc424_navaids" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(INavaidCategory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create INavaidCategory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INavaidCategory.__dict__ and type(INavaidCategory.__dict__[attrname]) == property:
            return INavaidCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INavaidCategory.")
    
    _get_arinc424_navaids_metadata = { "name" : "arinc424_navaids",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_navaids(self) -> "ARINC424Source":
        """Get the ARINC-424 navaids."""
        return self._intf.get_property(INavaidCategory._metadata, INavaidCategory._get_arinc424_navaids_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5b17c73b-f045-4228-bd66-9b0ed6eb40a1}", INavaidCategory)
agcls.AgTypeNameMap["INavaidCategory"] = INavaidCategory

class IVTOLPointCategory(object):
    """Interface used to access the VTOL Points in the Aviator catalog."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1753d173-fd39-4755-932f-88a091f1ac63}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_user_vtol_points" : 1,
                             "get_arinc424_helipads" : 2,
                             "get_dafif_helipads" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IVTOLPointCategory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IVTOLPointCategory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVTOLPointCategory.__dict__ and type(IVTOLPointCategory.__dict__[attrname]) == property:
            return IVTOLPointCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVTOLPointCategory.")
    
    _get_user_vtol_points_metadata = { "name" : "user_vtol_points",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def user_vtol_points(self) -> "UserVTOLPointSource":
        """Get the User VTOL Points."""
        return self._intf.get_property(IVTOLPointCategory._metadata, IVTOLPointCategory._get_user_vtol_points_metadata)

    _get_arinc424_helipads_metadata = { "name" : "arinc424_helipads",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_helipads(self) -> "ARINC424Source":
        """Get the ARINC-424 helipads."""
        return self._intf.get_property(IVTOLPointCategory._metadata, IVTOLPointCategory._get_arinc424_helipads_metadata)

    _get_dafif_helipads_metadata = { "name" : "dafif_helipads",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def dafif_helipads(self) -> "DAFIFSource":
        """Get the DAFIF helipads."""
        return self._intf.get_property(IVTOLPointCategory._metadata, IVTOLPointCategory._get_dafif_helipads_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1753d173-fd39-4755-932f-88a091f1ac63}", IVTOLPointCategory)
agcls.AgTypeNameMap["IVTOLPointCategory"] = IVTOLPointCategory

class IWaypointCategory(object):
    """Interface used to access the waypoints in the Aviator catalog."""
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3bdd04fa-d1ac-42ea-9978-f3a9c6718899}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_user_waypoints" : 1,
                             "get_user_runways" : 2,
                             "get_user_vtol_points" : 3,
                             "get_arinc424_airports" : 4,
                             "get_arinc424_helipads" : 5,
                             "get_arinc424_navaids" : 6,
                             "get_arinc424_runways" : 7,
                             "get_arinc424_waypoints" : 8,
                             "get_dafif_helipads" : 9,
                             "get_dafif_runways" : 10,
                             "get_dafif_waypoints" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IWaypointCategory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IWaypointCategory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IWaypointCategory.__dict__ and type(IWaypointCategory.__dict__[attrname]) == property:
            return IWaypointCategory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IWaypointCategory.")
    
    _get_user_waypoints_metadata = { "name" : "user_waypoints",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def user_waypoints(self) -> "UserWaypointSource":
        """Get the User Waypoints."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_user_waypoints_metadata)

    _get_user_runways_metadata = { "name" : "user_runways",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def user_runways(self) -> "UserRunwaySource":
        """Get the User Runways."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_user_runways_metadata)

    _get_user_vtol_points_metadata = { "name" : "user_vtol_points",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def user_vtol_points(self) -> "UserVTOLPointSource":
        """Get the User VTOL Points."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_user_vtol_points_metadata)

    _get_arinc424_airports_metadata = { "name" : "arinc424_airports",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_airports(self) -> "ARINC424Source":
        """Get the ARINC-424 airports."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_arinc424_airports_metadata)

    _get_arinc424_helipads_metadata = { "name" : "arinc424_helipads",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_helipads(self) -> "ARINC424Source":
        """Get the ARINC-424 helipads."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_arinc424_helipads_metadata)

    _get_arinc424_navaids_metadata = { "name" : "arinc424_navaids",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_navaids(self) -> "ARINC424Source":
        """Get the ARINC-424 navaids."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_arinc424_navaids_metadata)

    _get_arinc424_runways_metadata = { "name" : "arinc424_runways",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_runways(self) -> "ARINC424Source":
        """Get the ARINC-424 runways."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_arinc424_runways_metadata)

    _get_arinc424_waypoints_metadata = { "name" : "arinc424_waypoints",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arinc424_waypoints(self) -> "ARINC424Source":
        """Get the ARINC-424 waypoints."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_arinc424_waypoints_metadata)

    _get_dafif_helipads_metadata = { "name" : "dafif_helipads",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def dafif_helipads(self) -> "DAFIFSource":
        """Get the DAFIF helipads."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_dafif_helipads_metadata)

    _get_dafif_runways_metadata = { "name" : "dafif_runways",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def dafif_runways(self) -> "DAFIFSource":
        """Get the DAFIF runways."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_dafif_runways_metadata)

    _get_dafif_waypoints_metadata = { "name" : "dafif_waypoints",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def dafif_waypoints(self) -> "DAFIFSource":
        """Get the DAFIF waypoints."""
        return self._intf.get_property(IWaypointCategory._metadata, IWaypointCategory._get_dafif_waypoints_metadata)


agcls.AgClassCatalog.add_catalog_entry("{3bdd04fa-d1ac-42ea-9978-f3a9c6718899}", IWaypointCategory)
agcls.AgTypeNameMap["IWaypointCategory"] = IWaypointCategory

class IAircraftClimb(object):
    """Interface used to access the climb options for an aircraft in the Aviator catalog."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{66bca11a-e1e6-490a-8127-3aeb9e2f1aab}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_built_in_model" : 1,
                             "get_basic_climb_by_name" : 2,
                             "get_adv_climb_by_name" : 3,
                             "get_as_catalog_item" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftClimb._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftClimb from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftClimb.__dict__ and type(IAircraftClimb.__dict__[attrname]) == property:
            return IAircraftClimb.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftClimb.")
    
    _get_built_in_model_metadata = { "name" : "get_built_in_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_built_in_model(self) -> "AircraftBasicClimbModel":
        """Get the built-in model."""
        return self._intf.invoke(IAircraftClimb._metadata, IAircraftClimb._get_built_in_model_metadata, out_arg())

    _get_basic_climb_by_name_metadata = { "name" : "get_basic_climb_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_basic_climb_by_name(self, name:str) -> "AircraftBasicClimbModel":
        """Gets the basic climb model with the given name."""
        return self._intf.invoke(IAircraftClimb._metadata, IAircraftClimb._get_basic_climb_by_name_metadata, name, out_arg())

    _get_adv_climb_by_name_metadata = { "name" : "get_adv_climb_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_adv_climb_by_name(self, name:str) -> "AircraftAdvClimbModel":
        """Gets the advanced climb model with the given name."""
        return self._intf.invoke(IAircraftClimb._metadata, IAircraftClimb._get_adv_climb_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftClimb._metadata, IAircraftClimb._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{66bca11a-e1e6-490a-8127-3aeb9e2f1aab}", IAircraftClimb)
agcls.AgTypeNameMap["IAircraftClimb"] = IAircraftClimb

class IAircraftCruise(object):
    """Interface used to access the cruise options for an aircraft in the Aviator catalog."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b67511c7-87c1-472c-89a5-59da8c09f07c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_built_in_model" : 1,
                             "get_basic_cruise_by_name" : 2,
                             "get_adv_cruise_by_name" : 3,
                             "get_as_catalog_item" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftCruise._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftCruise from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftCruise.__dict__ and type(IAircraftCruise.__dict__[attrname]) == property:
            return IAircraftCruise.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftCruise.")
    
    _get_built_in_model_metadata = { "name" : "get_built_in_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_built_in_model(self) -> "AircraftBasicCruiseModel":
        """Get the built-in model."""
        return self._intf.invoke(IAircraftCruise._metadata, IAircraftCruise._get_built_in_model_metadata, out_arg())

    _get_basic_cruise_by_name_metadata = { "name" : "get_basic_cruise_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_basic_cruise_by_name(self, name:str) -> "AircraftBasicCruiseModel":
        """Gets the basic cruise model with the given name."""
        return self._intf.invoke(IAircraftCruise._metadata, IAircraftCruise._get_basic_cruise_by_name_metadata, name, out_arg())

    _get_adv_cruise_by_name_metadata = { "name" : "get_adv_cruise_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_adv_cruise_by_name(self, name:str) -> "AircraftAdvCruiseModel":
        """Gets the advanced cruise model with the given name."""
        return self._intf.invoke(IAircraftCruise._metadata, IAircraftCruise._get_adv_cruise_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftCruise._metadata, IAircraftCruise._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{b67511c7-87c1-472c-89a5-59da8c09f07c}", IAircraftCruise)
agcls.AgTypeNameMap["IAircraftCruise"] = IAircraftCruise

class IAircraftDescent(object):
    """Interface used to access the descent options for an aircraft in the Aviator catalog."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{568db25b-e93e-4982-9131-82e1527ab875}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_built_in_model" : 1,
                             "get_basic_descent_by_name" : 2,
                             "get_adv_descent_by_name" : 3,
                             "get_as_catalog_item" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftDescent._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftDescent from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftDescent.__dict__ and type(IAircraftDescent.__dict__[attrname]) == property:
            return IAircraftDescent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftDescent.")
    
    _get_built_in_model_metadata = { "name" : "get_built_in_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_built_in_model(self) -> "AircraftBasicDescentModel":
        """Get the built-in model."""
        return self._intf.invoke(IAircraftDescent._metadata, IAircraftDescent._get_built_in_model_metadata, out_arg())

    _get_basic_descent_by_name_metadata = { "name" : "get_basic_descent_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_basic_descent_by_name(self, name:str) -> "AircraftBasicDescentModel":
        """Gets the basic descent model with the given name."""
        return self._intf.invoke(IAircraftDescent._metadata, IAircraftDescent._get_basic_descent_by_name_metadata, name, out_arg())

    _get_adv_descent_by_name_metadata = { "name" : "get_adv_descent_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_adv_descent_by_name(self, name:str) -> "AircraftAdvDescentModel":
        """Gets the advanced descent model with the given name."""
        return self._intf.invoke(IAircraftDescent._metadata, IAircraftDescent._get_adv_descent_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftDescent._metadata, IAircraftDescent._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{568db25b-e93e-4982-9131-82e1527ab875}", IAircraftDescent)
agcls.AgTypeNameMap["IAircraftDescent"] = IAircraftDescent

class IAircraftLanding(object):
    """Interface used to access the landing options for an aircraft in the Aviator catalog."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4a0055a5-4224-42c3-b113-704c110093e8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_built_in_model" : 1,
                             "get_basic_landing_by_name" : 2,
                             "get_adv_landing_by_name" : 3,
                             "get_as_catalog_item" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftLanding._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftLanding from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftLanding.__dict__ and type(IAircraftLanding.__dict__[attrname]) == property:
            return IAircraftLanding.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftLanding.")
    
    _get_built_in_model_metadata = { "name" : "get_built_in_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_built_in_model(self) -> "AircraftBasicLandingModel":
        """Get the built-in model."""
        return self._intf.invoke(IAircraftLanding._metadata, IAircraftLanding._get_built_in_model_metadata, out_arg())

    _get_basic_landing_by_name_metadata = { "name" : "get_basic_landing_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_basic_landing_by_name(self, name:str) -> "AircraftBasicLandingModel":
        """Gets the basic Landing model with the given name."""
        return self._intf.invoke(IAircraftLanding._metadata, IAircraftLanding._get_basic_landing_by_name_metadata, name, out_arg())

    _get_adv_landing_by_name_metadata = { "name" : "get_adv_landing_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_adv_landing_by_name(self, name:str) -> "AircraftAdvLandingModel":
        """Gets the advanced Landing model with the given name."""
        return self._intf.invoke(IAircraftLanding._metadata, IAircraftLanding._get_adv_landing_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftLanding._metadata, IAircraftLanding._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4a0055a5-4224-42c3-b113-704c110093e8}", IAircraftLanding)
agcls.AgTypeNameMap["IAircraftLanding"] = IAircraftLanding

class IAircraftTakeoff(object):
    """Interface used to access the takeoff options for an aircraft in the Aviator catalog."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0a5a6393-8473-4f08-8501-9ca2a66494f4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_built_in_model" : 1,
                             "get_basic_takeoff_by_name" : 2,
                             "get_adv_takeoff_by_name" : 3,
                             "get_as_catalog_item" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftTakeoff._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftTakeoff from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftTakeoff.__dict__ and type(IAircraftTakeoff.__dict__[attrname]) == property:
            return IAircraftTakeoff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftTakeoff.")
    
    _get_built_in_model_metadata = { "name" : "get_built_in_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_built_in_model(self) -> "AircraftBasicTakeoffModel":
        """Get the built-in model."""
        return self._intf.invoke(IAircraftTakeoff._metadata, IAircraftTakeoff._get_built_in_model_metadata, out_arg())

    _get_basic_takeoff_by_name_metadata = { "name" : "get_basic_takeoff_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_basic_takeoff_by_name(self, name:str) -> "AircraftBasicTakeoffModel":
        """Gets the basic Takeoff model with the given name."""
        return self._intf.invoke(IAircraftTakeoff._metadata, IAircraftTakeoff._get_basic_takeoff_by_name_metadata, name, out_arg())

    _get_adv_takeoff_by_name_metadata = { "name" : "get_adv_takeoff_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_adv_takeoff_by_name(self, name:str) -> "AircraftAdvTakeoffModel":
        """Gets the advanced Takeoff model with the given name."""
        return self._intf.invoke(IAircraftTakeoff._metadata, IAircraftTakeoff._get_adv_takeoff_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftTakeoff._metadata, IAircraftTakeoff._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{0a5a6393-8473-4f08-8501-9ca2a66494f4}", IAircraftTakeoff)
agcls.AgTypeNameMap["IAircraftTakeoff"] = IAircraftTakeoff

class IAircraftAcceleration(object):
    """Interface used to access the acceleration options for an aircraft in the Aviator catalog."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f40c1168-8650-4aad-9790-192041602734}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_built_in_model" : 1,
                             "get_basic_acceleration_by_name" : 2,
                             "get_adv_acceleration_by_name" : 3,
                             "get_as_catalog_item" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftAcceleration._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftAcceleration from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftAcceleration.__dict__ and type(IAircraftAcceleration.__dict__[attrname]) == property:
            return IAircraftAcceleration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftAcceleration.")
    
    _get_built_in_model_metadata = { "name" : "get_built_in_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_built_in_model(self) -> "AircraftBasicAccelerationModel":
        """Get the built-in model."""
        return self._intf.invoke(IAircraftAcceleration._metadata, IAircraftAcceleration._get_built_in_model_metadata, out_arg())

    _get_basic_acceleration_by_name_metadata = { "name" : "get_basic_acceleration_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_basic_acceleration_by_name(self, name:str) -> "AircraftBasicAccelerationModel":
        """Get the basic acceleration model with the given name."""
        return self._intf.invoke(IAircraftAcceleration._metadata, IAircraftAcceleration._get_basic_acceleration_by_name_metadata, name, out_arg())

    _get_adv_acceleration_by_name_metadata = { "name" : "get_adv_acceleration_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_adv_acceleration_by_name(self, name:str) -> "AircraftAdvAccelerationModel":
        """Get the advanced acceleration model with the given name."""
        return self._intf.invoke(IAircraftAcceleration._metadata, IAircraftAcceleration._get_adv_acceleration_by_name_metadata, name, out_arg())

    _get_as_catalog_item_metadata = { "name" : "get_as_catalog_item",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_catalog_item(self) -> "ICatalogItem":
        """Get the catalog item interface for this object."""
        return self._intf.invoke(IAircraftAcceleration._metadata, IAircraftAcceleration._get_as_catalog_item_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{f40c1168-8650-4aad-9790-192041602734}", IAircraftAcceleration)
agcls.AgTypeNameMap["IAircraftAcceleration"] = IAircraftAcceleration

class ICatalog(object):
    """Interface used to access the Aviator catalog."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a9756132-0cd0-438d-bc8c-77fb748cebbd}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_aircraft_category" : 1,
                             "get_runway_category" : 2,
                             "get_airport_category" : 3,
                             "get_navaid_category" : 4,
                             "get_vtol_point_category" : 5,
                             "get_waypoint_category" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICatalog._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICatalog from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICatalog.__dict__ and type(ICatalog.__dict__[attrname]) == property:
            return ICatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICatalog.")
    
    _get_aircraft_category_metadata = { "name" : "aircraft_category",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def aircraft_category(self) -> "AircraftCategory":
        """Get the aircraft category."""
        return self._intf.get_property(ICatalog._metadata, ICatalog._get_aircraft_category_metadata)

    _get_runway_category_metadata = { "name" : "runway_category",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def runway_category(self) -> "RunwayCategory":
        """Get the runway category."""
        return self._intf.get_property(ICatalog._metadata, ICatalog._get_runway_category_metadata)

    _get_airport_category_metadata = { "name" : "airport_category",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airport_category(self) -> "AirportCategory":
        """Get the airport category."""
        return self._intf.get_property(ICatalog._metadata, ICatalog._get_airport_category_metadata)

    _get_navaid_category_metadata = { "name" : "navaid_category",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def navaid_category(self) -> "NavaidCategory":
        """Get the navaid category."""
        return self._intf.get_property(ICatalog._metadata, ICatalog._get_navaid_category_metadata)

    _get_vtol_point_category_metadata = { "name" : "vtol_point_category",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vtol_point_category(self) -> "VTOLPointCategory":
        """Get the vtol point category."""
        return self._intf.get_property(ICatalog._metadata, ICatalog._get_vtol_point_category_metadata)

    _get_waypoint_category_metadata = { "name" : "waypoint_category",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def waypoint_category(self) -> "WaypointCategory":
        """Get the waypoint category."""
        return self._intf.get_property(ICatalog._metadata, ICatalog._get_waypoint_category_metadata)


agcls.AgClassCatalog.add_catalog_entry("{a9756132-0cd0-438d-bc8c-77fb748cebbd}", ICatalog)
agcls.AgTypeNameMap["ICatalog"] = ICatalog

class IProcedureTimeOptions(object):
    """Interface used to access the time options for the current procedure. Use this interface to set an Interrupt Time or Fixed Duration for a procedure."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{19d372f4-0dce-4b60-8517-cbdfc1e5939c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_time_enabled" : 1,
                             "get_use_start_time" : 2,
                             "set_use_start_time" : 3,
                             "get_start_time" : 4,
                             "set_start_time" : 5,
                             "get_interrupt_time_enabled" : 6,
                             "get_use_interrupt_time" : 7,
                             "set_use_interrupt_time" : 8,
                             "get_interrupt_time" : 9,
                             "set_interrupt_time" : 10,
                             "get_stop_time_enabled" : 11,
                             "get_use_stop_time" : 12,
                             "set_use_stop_time" : 13,
                             "get_stop_time" : 14,
                             "set_stop_time" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureTimeOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTimeOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTimeOptions.__dict__ and type(IProcedureTimeOptions.__dict__[attrname]) == property:
            return IProcedureTimeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTimeOptions.")
    
    _get_start_time_enabled_metadata = { "name" : "start_time_enabled",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def start_time_enabled(self) -> bool:
        """Check to see if the start time is enabled for this procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_start_time_enabled_metadata)

    _get_use_start_time_metadata = { "name" : "use_start_time",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_start_time(self) -> bool:
        """Opt whether to set a start time for the procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_use_start_time_metadata)

    _set_use_start_time_metadata = { "name" : "use_start_time",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_start_time.setter
    def use_start_time(self, newVal:bool) -> None:
        """Opt whether to set a start time for the procedure."""
        return self._intf.set_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._set_use_start_time_metadata, newVal)

    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_time(self) -> typing.Any:
        """Start time for the procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_start_time_metadata)

    _set_start_time_metadata = { "name" : "set_start_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_start_time(self, time:typing.Any) -> None:
        """Set the start time for the procedure."""
        return self._intf.invoke(IProcedureTimeOptions._metadata, IProcedureTimeOptions._set_start_time_metadata, time)

    _get_interrupt_time_enabled_metadata = { "name" : "interrupt_time_enabled",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def interrupt_time_enabled(self) -> bool:
        """Check to see if the interrupt time is enabled for this procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_interrupt_time_enabled_metadata)

    _get_use_interrupt_time_metadata = { "name" : "use_interrupt_time",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_interrupt_time(self) -> bool:
        """Opt whether to set an interrupt time for the procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_use_interrupt_time_metadata)

    _set_use_interrupt_time_metadata = { "name" : "use_interrupt_time",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_interrupt_time.setter
    def use_interrupt_time(self, newVal:bool) -> None:
        """Opt whether to set an interrupt time for the procedure."""
        return self._intf.set_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._set_use_interrupt_time_metadata, newVal)

    _get_interrupt_time_metadata = { "name" : "interrupt_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def interrupt_time(self) -> typing.Any:
        """Interrupt time for the procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_interrupt_time_metadata)

    _set_interrupt_time_metadata = { "name" : "set_interrupt_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_interrupt_time(self, time:typing.Any) -> None:
        """Set the interrupt time for the procedure."""
        return self._intf.invoke(IProcedureTimeOptions._metadata, IProcedureTimeOptions._set_interrupt_time_metadata, time)

    _get_stop_time_enabled_metadata = { "name" : "stop_time_enabled",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_time_enabled(self) -> bool:
        """Check to see if the stop time is enabled for this procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_stop_time_enabled_metadata)

    _get_use_stop_time_metadata = { "name" : "use_stop_time",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_time(self) -> bool:
        """Opt whether to set a stop  time for the procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_use_stop_time_metadata)

    _set_use_stop_time_metadata = { "name" : "use_stop_time",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_stop_time.setter
    def use_stop_time(self, newVal:bool) -> None:
        """Opt whether to set a stop time for the procedure."""
        return self._intf.set_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._set_use_stop_time_metadata, newVal)

    _get_stop_time_metadata = { "name" : "stop_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_time(self) -> typing.Any:
        """Stop time for the procedure."""
        return self._intf.get_property(IProcedureTimeOptions._metadata, IProcedureTimeOptions._get_stop_time_metadata)

    _set_stop_time_metadata = { "name" : "set_stop_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_stop_time(self, time:typing.Any) -> None:
        """Set the stop time for the procedure."""
        return self._intf.invoke(IProcedureTimeOptions._metadata, IProcedureTimeOptions._set_stop_time_metadata, time)


agcls.AgClassCatalog.add_catalog_entry("{19d372f4-0dce-4b60-8517-cbdfc1e5939c}", IProcedureTimeOptions)
agcls.AgTypeNameMap["IProcedureTimeOptions"] = IProcedureTimeOptions

class ICalculationOptions(object):
    """Interface used to access the calculation options for a procedure or phase."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B398DB5E-FA44-446B-B1AE-31761CB12D50}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_rel_motion_factor" : 1,
                             "set_max_rel_motion_factor" : 2,
                             "get_state_cache_time_interval" : 3,
                             "set_state_cache_time_interval" : 4,
                             "get_time_resolution" : 5,
                             "set_time_resolution" : 6,
                             "get_max_iterations" : 7,
                             "set_max_iterations" : 8,
                             "get_max_bad_steps" : 9,
                             "set_max_bad_steps" : 10,
                             "get_integrator_type" : 11,
                             "set_integrator_type" : 12,
                             "get_integrator_type_string" : 13,
                             "set_integrator_type_string" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICalculationOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICalculationOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationOptions.__dict__ and type(ICalculationOptions.__dict__[attrname]) == property:
            return ICalculationOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationOptions.")
    
    _get_max_rel_motion_factor_metadata = { "name" : "max_rel_motion_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_rel_motion_factor(self) -> float:
        """The maximum motion allowed between sampling points."""
        return self._intf.get_property(ICalculationOptions._metadata, ICalculationOptions._get_max_rel_motion_factor_metadata)

    _set_max_rel_motion_factor_metadata = { "name" : "max_rel_motion_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_rel_motion_factor.setter
    def max_rel_motion_factor(self, newVal:float) -> None:
        """The maximum motion allowed between sampling points."""
        return self._intf.set_property(ICalculationOptions._metadata, ICalculationOptions._set_max_rel_motion_factor_metadata, newVal)

    _get_state_cache_time_interval_metadata = { "name" : "state_cache_time_interval",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def state_cache_time_interval(self) -> float:
        """The time interval used to store the state information."""
        return self._intf.get_property(ICalculationOptions._metadata, ICalculationOptions._get_state_cache_time_interval_metadata)

    _set_state_cache_time_interval_metadata = { "name" : "state_cache_time_interval",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @state_cache_time_interval.setter
    def state_cache_time_interval(self, newVal:float) -> None:
        """The time interval used to store the state information."""
        return self._intf.set_property(ICalculationOptions._metadata, ICalculationOptions._set_state_cache_time_interval_metadata, newVal)

    _get_time_resolution_metadata = { "name" : "time_resolution",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_resolution(self) -> float:
        """The tolerance for resolving time calculations."""
        return self._intf.get_property(ICalculationOptions._metadata, ICalculationOptions._get_time_resolution_metadata)

    _set_time_resolution_metadata = { "name" : "time_resolution",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_resolution.setter
    def time_resolution(self, newVal:float) -> None:
        """The tolerance for resolving time calculations."""
        return self._intf.set_property(ICalculationOptions._metadata, ICalculationOptions._set_time_resolution_metadata, newVal)

    _get_max_iterations_metadata = { "name" : "max_iterations",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def max_iterations(self) -> int:
        """The maximum number of iterations per time step Aviator will attempt."""
        return self._intf.get_property(ICalculationOptions._metadata, ICalculationOptions._get_max_iterations_metadata)

    _set_max_iterations_metadata = { "name" : "max_iterations",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @max_iterations.setter
    def max_iterations(self, newVal:int) -> None:
        """The maximum number of iterations per time step Aviator will attempt."""
        return self._intf.set_property(ICalculationOptions._metadata, ICalculationOptions._set_max_iterations_metadata, newVal)

    _get_max_bad_steps_metadata = { "name" : "max_bad_steps",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def max_bad_steps(self) -> int:
        """The maximum number of bad steps Aviator will allow before ceasing calculation."""
        return self._intf.get_property(ICalculationOptions._metadata, ICalculationOptions._get_max_bad_steps_metadata)

    _set_max_bad_steps_metadata = { "name" : "max_bad_steps",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @max_bad_steps.setter
    def max_bad_steps(self, newVal:int) -> None:
        """The maximum number of bad steps Aviator will allow before ceasing calculation."""
        return self._intf.set_property(ICalculationOptions._metadata, ICalculationOptions._set_max_bad_steps_metadata, newVal)

    _get_integrator_type_metadata = { "name" : "integrator_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(NUMERICAL_INTEGRATOR),) }
    @property
    def integrator_type(self) -> "NUMERICAL_INTEGRATOR":
        """The integrator type."""
        return self._intf.get_property(ICalculationOptions._metadata, ICalculationOptions._get_integrator_type_metadata)

    _set_integrator_type_metadata = { "name" : "integrator_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(NUMERICAL_INTEGRATOR),) }
    @integrator_type.setter
    def integrator_type(self, pVal:"NUMERICAL_INTEGRATOR") -> None:
        """The integrator type."""
        return self._intf.set_property(ICalculationOptions._metadata, ICalculationOptions._set_integrator_type_metadata, pVal)

    _get_integrator_type_string_metadata = { "name" : "integrator_type_string",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def integrator_type_string(self) -> str:
        """The integrator type as a string value. Use this for custom integrators."""
        return self._intf.get_property(ICalculationOptions._metadata, ICalculationOptions._get_integrator_type_string_metadata)

    _set_integrator_type_string_metadata = { "name" : "integrator_type_string",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @integrator_type_string.setter
    def integrator_type_string(self, pVal:str) -> None:
        """The integrator type as a string value. Use this for custom integrators."""
        return self._intf.set_property(ICalculationOptions._metadata, ICalculationOptions._set_integrator_type_string_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{B398DB5E-FA44-446B-B1AE-31761CB12D50}", ICalculationOptions)
agcls.AgTypeNameMap["ICalculationOptions"] = ICalculationOptions

class INavigationOptions(object):
    """Interface used to access the navigation options for an Aviator procedure."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d0b367a7-0df0-454b-b059-e27f55a04730}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_nav_mode" : 1,
                             "set_nav_mode" : 2,
                             "get_arrive_on_course" : 3,
                             "set_arrive_on_course" : 4,
                             "get_use_magnetic_heading" : 5,
                             "set_use_magnetic_heading" : 6,
                             "get_enroute_first_turn" : 7,
                             "set_enroute_first_turn" : 8,
                             "get_enroute_second_turn" : 9,
                             "set_enroute_second_turn" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(INavigationOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create INavigationOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INavigationOptions.__dict__ and type(INavigationOptions.__dict__[attrname]) == property:
            return INavigationOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INavigationOptions.")
    
    _get_nav_mode_metadata = { "name" : "nav_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(POINT_TO_POINT_MODE),) }
    @property
    def nav_mode(self) -> "POINT_TO_POINT_MODE":
        """The navigation mode."""
        return self._intf.get_property(INavigationOptions._metadata, INavigationOptions._get_nav_mode_metadata)

    _set_nav_mode_metadata = { "name" : "nav_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(POINT_TO_POINT_MODE),) }
    @nav_mode.setter
    def nav_mode(self, newVal:"POINT_TO_POINT_MODE") -> None:
        """The navigation mode."""
        return self._intf.set_property(INavigationOptions._metadata, INavigationOptions._set_nav_mode_metadata, newVal)

    _get_arrive_on_course_metadata = { "name" : "arrive_on_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def arrive_on_course(self) -> typing.Any:
        """The aircraft will start or arrive at the procedure site with the specified course. The nav mode must be set to Arrive on Course to set this value."""
        return self._intf.get_property(INavigationOptions._metadata, INavigationOptions._get_arrive_on_course_metadata)

    _set_arrive_on_course_metadata = { "name" : "arrive_on_course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @arrive_on_course.setter
    def arrive_on_course(self, newVal:typing.Any) -> None:
        """The aircraft will start or arrive at the procedure site with the specified course. The nav mode must be set to Arrive on Course to set this value."""
        return self._intf.set_property(INavigationOptions._metadata, INavigationOptions._set_arrive_on_course_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """Opt whether to use a magnetic heading to arrive on course. The nav mode must be set to Arrive on Course to set this value."""
        return self._intf.get_property(INavigationOptions._metadata, INavigationOptions._get_use_magnetic_heading_metadata)

    _set_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """Opt whether to use a magnetic heading to arrive on course. The nav mode must be set to Arrive on Course to set this value."""
        return self._intf.set_property(INavigationOptions._metadata, INavigationOptions._set_use_magnetic_heading_metadata, newVal)

    _get_enroute_first_turn_metadata = { "name" : "enroute_first_turn",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @property
    def enroute_first_turn(self) -> "NAVIGATOR_TURN_DIRECTION":
        """Option for the first turn."""
        return self._intf.get_property(INavigationOptions._metadata, INavigationOptions._get_enroute_first_turn_metadata)

    _set_enroute_first_turn_metadata = { "name" : "enroute_first_turn",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @enroute_first_turn.setter
    def enroute_first_turn(self, newVal:"NAVIGATOR_TURN_DIRECTION") -> None:
        """Option for the first turn."""
        return self._intf.set_property(INavigationOptions._metadata, INavigationOptions._set_enroute_first_turn_metadata, newVal)

    _get_enroute_second_turn_metadata = { "name" : "enroute_second_turn",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @property
    def enroute_second_turn(self) -> "NAVIGATOR_TURN_DIRECTION":
        """Option for the second turn."""
        return self._intf.get_property(INavigationOptions._metadata, INavigationOptions._get_enroute_second_turn_metadata)

    _set_enroute_second_turn_metadata = { "name" : "enroute_second_turn",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @enroute_second_turn.setter
    def enroute_second_turn(self, newVal:"NAVIGATOR_TURN_DIRECTION") -> None:
        """Option for the second turn."""
        return self._intf.set_property(INavigationOptions._metadata, INavigationOptions._set_enroute_second_turn_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{d0b367a7-0df0-454b-b059-e27f55a04730}", INavigationOptions)
agcls.AgTypeNameMap["INavigationOptions"] = INavigationOptions

class IAltitudeMSLAndLevelOffOptions(object):
    """Interface used to access the altitude MSL and Level off options for an Aviator procedure."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{c7939666-f5a2-44fa-9a4b-9e2d84e93aa5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_default_cruise_altitude" : 1,
                             "set_use_default_cruise_altitude" : 2,
                             "get_msl_altitude" : 3,
                             "set_msl_altitude" : 4,
                             "get_must_level_off" : 5,
                             "set_must_level_off" : 6,
                             "get_level_off_mode" : 7,
                             "set_level_off_mode" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAltitudeMSLAndLevelOffOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeMSLAndLevelOffOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeMSLAndLevelOffOptions.__dict__ and type(IAltitudeMSLAndLevelOffOptions.__dict__[attrname]) == property:
            return IAltitudeMSLAndLevelOffOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeMSLAndLevelOffOptions.")
    
    _get_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        return self._intf.get_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._get_use_default_cruise_altitude_metadata)

    _set_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        return self._intf.set_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._set_use_default_cruise_altitude_metadata, newVal)

    _get_msl_altitude_metadata = { "name" : "msl_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def msl_altitude(self) -> float:
        """The MSL altitude. Can only be used when the option to use the default cruise altitude is off."""
        return self._intf.get_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._get_msl_altitude_metadata)

    _set_msl_altitude_metadata = { "name" : "msl_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @msl_altitude.setter
    def msl_altitude(self, newVal:float) -> None:
        """Set the MSLAltitude"""
        return self._intf.set_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._set_msl_altitude_metadata, newVal)

    _get_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        return self._intf.get_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._get_must_level_off_metadata)

    _set_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        return self._intf.set_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._set_must_level_off_metadata, newVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.get_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, newVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.set_property(IAltitudeMSLAndLevelOffOptions._metadata, IAltitudeMSLAndLevelOffOptions._set_level_off_mode_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{c7939666-f5a2-44fa-9a4b-9e2d84e93aa5}", IAltitudeMSLAndLevelOffOptions)
agcls.AgTypeNameMap["IAltitudeMSLAndLevelOffOptions"] = IAltitudeMSLAndLevelOffOptions

class IAltitudeMSLOptions(object):
    """Interface used to access the altitude MSL options for an Aviator procedure."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{bde058f8-a355-4a4f-9884-7e2961b212e7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_default_cruise_altitude" : 1,
                             "set_use_default_cruise_altitude" : 2,
                             "get_msl_altitude" : 3,
                             "set_msl_altitude" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAltitudeMSLOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeMSLOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeMSLOptions.__dict__ and type(IAltitudeMSLOptions.__dict__[attrname]) == property:
            return IAltitudeMSLOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeMSLOptions.")
    
    _get_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        return self._intf.get_property(IAltitudeMSLOptions._metadata, IAltitudeMSLOptions._get_use_default_cruise_altitude_metadata)

    _set_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        return self._intf.set_property(IAltitudeMSLOptions._metadata, IAltitudeMSLOptions._set_use_default_cruise_altitude_metadata, newVal)

    _get_msl_altitude_metadata = { "name" : "msl_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def msl_altitude(self) -> float:
        """The MSL altitude. Can only be used when the option to use the default cruise altitude is off."""
        return self._intf.get_property(IAltitudeMSLOptions._metadata, IAltitudeMSLOptions._get_msl_altitude_metadata)

    _set_msl_altitude_metadata = { "name" : "msl_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @msl_altitude.setter
    def msl_altitude(self, newVal:float) -> None:
        """Set the MSLAltitude"""
        return self._intf.set_property(IAltitudeMSLOptions._metadata, IAltitudeMSLOptions._set_msl_altitude_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{bde058f8-a355-4a4f-9884-7e2961b212e7}", IAltitudeMSLOptions)
agcls.AgTypeNameMap["IAltitudeMSLOptions"] = IAltitudeMSLOptions

class IAltitudeOptions(object):
    """Interface used to access the altitude options for an Aviator procedure."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{be4fccc8-7fe4-443b-9dc9-c337369c4560}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_default_cruise_altitude" : 1,
                             "set_use_default_cruise_altitude" : 2,
                             "get_altitude_reference" : 3,
                             "set_altitude_reference" : 4,
                             "get_altitude" : 5,
                             "set_altitude" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAltitudeOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAltitudeOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAltitudeOptions.__dict__ and type(IAltitudeOptions.__dict__[attrname]) == property:
            return IAltitudeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAltitudeOptions.")
    
    _get_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        return self._intf.get_property(IAltitudeOptions._metadata, IAltitudeOptions._get_use_default_cruise_altitude_metadata)

    _set_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        return self._intf.set_property(IAltitudeOptions._metadata, IAltitudeOptions._set_use_default_cruise_altitude_metadata, newVal)

    _get_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @property
    def altitude_reference(self) -> "AGL_MSL":
        """The altitude reference."""
        return self._intf.get_property(IAltitudeOptions._metadata, IAltitudeOptions._get_altitude_reference_metadata)

    _set_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @altitude_reference.setter
    def altitude_reference(self, newVal:"AGL_MSL") -> None:
        """The altitude reference."""
        return self._intf.set_property(IAltitudeOptions._metadata, IAltitudeOptions._set_altitude_reference_metadata, newVal)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The altitude for the procedure."""
        return self._intf.get_property(IAltitudeOptions._metadata, IAltitudeOptions._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the procedure."""
        return self._intf.set_property(IAltitudeOptions._metadata, IAltitudeOptions._set_altitude_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{be4fccc8-7fe4-443b-9dc9-c337369c4560}", IAltitudeOptions)
agcls.AgTypeNameMap["IAltitudeOptions"] = IAltitudeOptions

class IHoverAltitudeOptions(object):
    """Interface used to access the altitude options for VTOL procedure."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{61d092fc-5b7c-4056-9f82-ac024ea4d4bd}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_reference" : 1,
                             "set_altitude_reference" : 2,
                             "get_altitude" : 3,
                             "set_altitude" : 4,
                             "get_final_altitude_rate" : 5,
                             "set_final_altitude_rate" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IHoverAltitudeOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IHoverAltitudeOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IHoverAltitudeOptions.__dict__ and type(IHoverAltitudeOptions.__dict__[attrname]) == property:
            return IHoverAltitudeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IHoverAltitudeOptions.")
    
    _get_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @property
    def altitude_reference(self) -> "AGL_MSL":
        """The altitude reference."""
        return self._intf.get_property(IHoverAltitudeOptions._metadata, IHoverAltitudeOptions._get_altitude_reference_metadata)

    _set_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @altitude_reference.setter
    def altitude_reference(self, newVal:"AGL_MSL") -> None:
        """The altitude reference."""
        return self._intf.set_property(IHoverAltitudeOptions._metadata, IHoverAltitudeOptions._set_altitude_reference_metadata, newVal)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The altitude for the procedure."""
        return self._intf.get_property(IHoverAltitudeOptions._metadata, IHoverAltitudeOptions._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the procedure."""
        return self._intf.set_property(IHoverAltitudeOptions._metadata, IHoverAltitudeOptions._set_altitude_metadata, newVal)

    _get_final_altitude_rate_metadata = { "name" : "final_altitude_rate",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @property
    def final_altitude_rate(self) -> "VTOL_RATE_MODE":
        """The altitude rate of the aircraft at the end of the procedure."""
        return self._intf.get_property(IHoverAltitudeOptions._metadata, IHoverAltitudeOptions._get_final_altitude_rate_metadata)

    _set_final_altitude_rate_metadata = { "name" : "final_altitude_rate",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @final_altitude_rate.setter
    def final_altitude_rate(self, newVal:"VTOL_RATE_MODE") -> None:
        """The altitude rate of the aircraft at the end of the procedure."""
        return self._intf.set_property(IHoverAltitudeOptions._metadata, IHoverAltitudeOptions._set_final_altitude_rate_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{61d092fc-5b7c-4056-9f82-ac024ea4d4bd}", IHoverAltitudeOptions)
agcls.AgTypeNameMap["IHoverAltitudeOptions"] = IHoverAltitudeOptions

class IArcAltitudeOptions(object):
    """Interface used to access the altitude options for an Arc procedure."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5aa7a535-fbc0-49b5-99e7-c93309863a6d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_default_cruise_altitude" : 1,
                             "set_use_default_cruise_altitude" : 2,
                             "get_start_arc_altitude" : 3,
                             "set_start_arc_altitude" : 4,
                             "get_stop_arc_altitude" : 5,
                             "set_stop_arc_altitude" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IArcAltitudeOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IArcAltitudeOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcAltitudeOptions.__dict__ and type(IArcAltitudeOptions.__dict__[attrname]) == property:
            return IArcAltitudeOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcAltitudeOptions.")
    
    _get_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        return self._intf.get_property(IArcAltitudeOptions._metadata, IArcAltitudeOptions._get_use_default_cruise_altitude_metadata)

    _set_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        return self._intf.set_property(IArcAltitudeOptions._metadata, IArcAltitudeOptions._set_use_default_cruise_altitude_metadata, newVal)

    _get_start_arc_altitude_metadata = { "name" : "start_arc_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_arc_altitude(self) -> float:
        """The altitude at the beginning of the arc."""
        return self._intf.get_property(IArcAltitudeOptions._metadata, IArcAltitudeOptions._get_start_arc_altitude_metadata)

    _set_start_arc_altitude_metadata = { "name" : "start_arc_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_arc_altitude.setter
    def start_arc_altitude(self, newVal:float) -> None:
        """The altitude at the beginning of the arc."""
        return self._intf.set_property(IArcAltitudeOptions._metadata, IArcAltitudeOptions._set_start_arc_altitude_metadata, newVal)

    _get_stop_arc_altitude_metadata = { "name" : "stop_arc_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_arc_altitude(self) -> float:
        """The altitude at the end of the arc."""
        return self._intf.get_property(IArcAltitudeOptions._metadata, IArcAltitudeOptions._get_stop_arc_altitude_metadata)

    _set_stop_arc_altitude_metadata = { "name" : "stop_arc_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_arc_altitude.setter
    def stop_arc_altitude(self, newVal:float) -> None:
        """The altitude at the end of the arc."""
        return self._intf.set_property(IArcAltitudeOptions._metadata, IArcAltitudeOptions._set_stop_arc_altitude_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{5aa7a535-fbc0-49b5-99e7-c93309863a6d}", IArcAltitudeOptions)
agcls.AgTypeNameMap["IArcAltitudeOptions"] = IArcAltitudeOptions

class IArcAltitudeAndDelayOptions(object):
    """Interface used to access the altitude options for an Arc procedure."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{826dc7a9-7fad-46a9-8587-7b879ea6d53e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_default_cruise_altitude" : 1,
                             "set_use_default_cruise_altitude" : 2,
                             "get_delay_arc_climb_descents" : 3,
                             "set_delay_arc_climb_descents" : 4,
                             "get_start_arc_altitude" : 5,
                             "set_start_arc_altitude" : 6,
                             "get_stop_arc_altitude" : 7,
                             "set_stop_arc_altitude" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IArcAltitudeAndDelayOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IArcAltitudeAndDelayOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcAltitudeAndDelayOptions.__dict__ and type(IArcAltitudeAndDelayOptions.__dict__[attrname]) == property:
            return IArcAltitudeAndDelayOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcAltitudeAndDelayOptions.")
    
    _get_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        return self._intf.get_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._get_use_default_cruise_altitude_metadata)

    _set_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        return self._intf.set_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._set_use_default_cruise_altitude_metadata, newVal)

    _get_delay_arc_climb_descents_metadata = { "name" : "delay_arc_climb_descents",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def delay_arc_climb_descents(self) -> bool:
        """Delay the climb/descend such that the stop arc altitude will be achieved by the end of the procedure."""
        return self._intf.get_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._get_delay_arc_climb_descents_metadata)

    _set_delay_arc_climb_descents_metadata = { "name" : "delay_arc_climb_descents",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @delay_arc_climb_descents.setter
    def delay_arc_climb_descents(self, newVal:bool) -> None:
        """Delay the climb/descend such that the stop arc altitude will be achieved by the end of the procedure."""
        return self._intf.set_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._set_delay_arc_climb_descents_metadata, newVal)

    _get_start_arc_altitude_metadata = { "name" : "start_arc_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_arc_altitude(self) -> float:
        """The altitude at the beginning of the arc."""
        return self._intf.get_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._get_start_arc_altitude_metadata)

    _set_start_arc_altitude_metadata = { "name" : "start_arc_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_arc_altitude.setter
    def start_arc_altitude(self, newVal:float) -> None:
        """The altitude at the beginning of the arc."""
        return self._intf.set_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._set_start_arc_altitude_metadata, newVal)

    _get_stop_arc_altitude_metadata = { "name" : "stop_arc_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_arc_altitude(self) -> float:
        """The altitude at the end of the arc."""
        return self._intf.get_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._get_stop_arc_altitude_metadata)

    _set_stop_arc_altitude_metadata = { "name" : "stop_arc_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_arc_altitude.setter
    def stop_arc_altitude(self, newVal:float) -> None:
        """The altitude at the end of the arc."""
        return self._intf.set_property(IArcAltitudeAndDelayOptions._metadata, IArcAltitudeAndDelayOptions._set_stop_arc_altitude_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{826dc7a9-7fad-46a9-8587-7b879ea6d53e}", IArcAltitudeAndDelayOptions)
agcls.AgTypeNameMap["IArcAltitudeAndDelayOptions"] = IArcAltitudeAndDelayOptions

class IArcOptions(object):
    """Interface used to access the arc options for a procedure."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{436c4ca7-5994-43bf-a975-a9c29c328ec0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_turn_direction" : 1,
                             "set_turn_direction" : 2,
                             "get_start_bearing" : 3,
                             "set_start_bearing" : 4,
                             "get_use_magnetic_heading" : 5,
                             "set_use_magnetic_heading" : 6,
                             "get_radius" : 7,
                             "set_radius" : 8,
                             "get_turn_angle" : 9,
                             "set_turn_angle" : 10,
                             "get_join_arc" : 11,
                             "set_join_arc" : 12,
                             "get_exit_arc" : 13,
                             "set_exit_arc" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IArcOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IArcOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcOptions.__dict__ and type(IArcOptions.__dict__[attrname]) == property:
            return IArcOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcOptions.")
    
    _get_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TURN_DIRECTION),) }
    @property
    def turn_direction(self) -> "TURN_DIRECTION":
        """The turn direction to the arc."""
        return self._intf.get_property(IArcOptions._metadata, IArcOptions._get_turn_direction_metadata)

    _set_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TURN_DIRECTION),) }
    @turn_direction.setter
    def turn_direction(self, newVal:"TURN_DIRECTION") -> None:
        """The turn direction to the arc."""
        return self._intf.set_property(IArcOptions._metadata, IArcOptions._set_turn_direction_metadata, newVal)

    _get_start_bearing_metadata = { "name" : "start_bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_bearing(self) -> typing.Any:
        """The bearing from the site to the arc."""
        return self._intf.get_property(IArcOptions._metadata, IArcOptions._get_start_bearing_metadata)

    _set_start_bearing_metadata = { "name" : "start_bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @start_bearing.setter
    def start_bearing(self, newVal:typing.Any) -> None:
        """The bearing from the site to the arc."""
        return self._intf.set_property(IArcOptions._metadata, IArcOptions._set_start_bearing_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the start bearing."""
        return self._intf.get_property(IArcOptions._metadata, IArcOptions._get_use_magnetic_heading_metadata)

    _set_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading for the start bearing."""
        return self._intf.set_property(IArcOptions._metadata, IArcOptions._set_use_magnetic_heading_metadata, newVal)

    _get_radius_metadata = { "name" : "radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def radius(self) -> float:
        """The radius of the arc."""
        return self._intf.get_property(IArcOptions._metadata, IArcOptions._get_radius_metadata)

    _set_radius_metadata = { "name" : "radius",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @radius.setter
    def radius(self, newVal:float) -> None:
        """The radius of the arc."""
        return self._intf.set_property(IArcOptions._metadata, IArcOptions._set_radius_metadata, newVal)

    _get_turn_angle_metadata = { "name" : "turn_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def turn_angle(self) -> typing.Any:
        """The length of the arc the aircraft will fly."""
        return self._intf.get_property(IArcOptions._metadata, IArcOptions._get_turn_angle_metadata)

    _set_turn_angle_metadata = { "name" : "turn_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @turn_angle.setter
    def turn_angle(self, newVal:typing.Any) -> None:
        """The length of the arc the aircraft will fly."""
        return self._intf.set_property(IArcOptions._metadata, IArcOptions._set_turn_angle_metadata, newVal)

    _get_join_arc_metadata = { "name" : "join_arc",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JOIN_EXIT_ARC_METHOD),) }
    @property
    def join_arc(self) -> "JOIN_EXIT_ARC_METHOD":
        """The method to join the arc."""
        return self._intf.get_property(IArcOptions._metadata, IArcOptions._get_join_arc_metadata)

    _set_join_arc_metadata = { "name" : "join_arc",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JOIN_EXIT_ARC_METHOD),) }
    @join_arc.setter
    def join_arc(self, newVal:"JOIN_EXIT_ARC_METHOD") -> None:
        """The method to join the arc."""
        return self._intf.set_property(IArcOptions._metadata, IArcOptions._set_join_arc_metadata, newVal)

    _get_exit_arc_metadata = { "name" : "exit_arc",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(JOIN_EXIT_ARC_METHOD),) }
    @property
    def exit_arc(self) -> "JOIN_EXIT_ARC_METHOD":
        """The method to exit the arc."""
        return self._intf.get_property(IArcOptions._metadata, IArcOptions._get_exit_arc_metadata)

    _set_exit_arc_metadata = { "name" : "exit_arc",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(JOIN_EXIT_ARC_METHOD),) }
    @exit_arc.setter
    def exit_arc(self, newVal:"JOIN_EXIT_ARC_METHOD") -> None:
        """The method to exit the arc."""
        return self._intf.set_property(IArcOptions._metadata, IArcOptions._set_exit_arc_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{436c4ca7-5994-43bf-a975-a9c29c328ec0}", IArcOptions)
agcls.AgTypeNameMap["IArcOptions"] = IArcOptions

class IVerticalPlaneOptions(object):
    """Interface used to access the Vertical Plane options for an Aviator procedure."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2f4e9933-f0e0-4c9c-96ad-7b210faf7a05}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_min_enroute_flight_path_angle" : 1,
                             "set_min_enroute_flight_path_angle" : 2,
                             "get_max_enroute_flight_path_angle" : 3,
                             "set_max_enroute_flight_path_angle" : 4,
                             "get_max_vert_plane_radius_factor" : 5,
                             "set_max_vert_plane_radius_factor" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IVerticalPlaneOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IVerticalPlaneOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVerticalPlaneOptions.__dict__ and type(IVerticalPlaneOptions.__dict__[attrname]) == property:
            return IVerticalPlaneOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVerticalPlaneOptions.")
    
    _get_min_enroute_flight_path_angle_metadata = { "name" : "min_enroute_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def min_enroute_flight_path_angle(self) -> typing.Any:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.get_property(IVerticalPlaneOptions._metadata, IVerticalPlaneOptions._get_min_enroute_flight_path_angle_metadata)

    _set_min_enroute_flight_path_angle_metadata = { "name" : "min_enroute_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @min_enroute_flight_path_angle.setter
    def min_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.set_property(IVerticalPlaneOptions._metadata, IVerticalPlaneOptions._set_min_enroute_flight_path_angle_metadata, newVal)

    _get_max_enroute_flight_path_angle_metadata = { "name" : "max_enroute_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_enroute_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.get_property(IVerticalPlaneOptions._metadata, IVerticalPlaneOptions._get_max_enroute_flight_path_angle_metadata)

    _set_max_enroute_flight_path_angle_metadata = { "name" : "max_enroute_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_enroute_flight_path_angle.setter
    def max_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.set_property(IVerticalPlaneOptions._metadata, IVerticalPlaneOptions._set_max_enroute_flight_path_angle_metadata, newVal)

    _get_max_vert_plane_radius_factor_metadata = { "name" : "max_vert_plane_radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_vert_plane_radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.get_property(IVerticalPlaneOptions._metadata, IVerticalPlaneOptions._get_max_vert_plane_radius_factor_metadata)

    _set_max_vert_plane_radius_factor_metadata = { "name" : "max_vert_plane_radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_vert_plane_radius_factor.setter
    def max_vert_plane_radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.set_property(IVerticalPlaneOptions._metadata, IVerticalPlaneOptions._set_max_vert_plane_radius_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{2f4e9933-f0e0-4c9c-96ad-7b210faf7a05}", IVerticalPlaneOptions)
agcls.AgTypeNameMap["IVerticalPlaneOptions"] = IVerticalPlaneOptions

class IVerticalPlaneAndFlightPathOptions(object):
    """Interface used to access the Vertical Plane and Final Flight Path Angle options for an Aviator procedure."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4a177d89-4a7d-4388-a5db-05a9b35ebece}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_final_flight_path_angle" : 1,
                             "set_final_flight_path_angle" : 2,
                             "get_min_enroute_flight_path_angle" : 3,
                             "set_min_enroute_flight_path_angle" : 4,
                             "get_max_enroute_flight_path_angle" : 5,
                             "set_max_enroute_flight_path_angle" : 6,
                             "get_max_vert_plane_radius_factor" : 7,
                             "set_max_vert_plane_radius_factor" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IVerticalPlaneAndFlightPathOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IVerticalPlaneAndFlightPathOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVerticalPlaneAndFlightPathOptions.__dict__ and type(IVerticalPlaneAndFlightPathOptions.__dict__[attrname]) == property:
            return IVerticalPlaneAndFlightPathOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVerticalPlaneAndFlightPathOptions.")
    
    _get_final_flight_path_angle_metadata = { "name" : "final_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def final_flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the end of the procedure."""
        return self._intf.get_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._get_final_flight_path_angle_metadata)

    _set_final_flight_path_angle_metadata = { "name" : "final_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @final_flight_path_angle.setter
    def final_flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the end of the procedure."""
        return self._intf.set_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._set_final_flight_path_angle_metadata, newVal)

    _get_min_enroute_flight_path_angle_metadata = { "name" : "min_enroute_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def min_enroute_flight_path_angle(self) -> typing.Any:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.get_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._get_min_enroute_flight_path_angle_metadata)

    _set_min_enroute_flight_path_angle_metadata = { "name" : "min_enroute_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @min_enroute_flight_path_angle.setter
    def min_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.set_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._set_min_enroute_flight_path_angle_metadata, newVal)

    _get_max_enroute_flight_path_angle_metadata = { "name" : "max_enroute_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_enroute_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.get_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._get_max_enroute_flight_path_angle_metadata)

    _set_max_enroute_flight_path_angle_metadata = { "name" : "max_enroute_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_enroute_flight_path_angle.setter
    def max_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.set_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._set_max_enroute_flight_path_angle_metadata, newVal)

    _get_max_vert_plane_radius_factor_metadata = { "name" : "max_vert_plane_radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_vert_plane_radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.get_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._get_max_vert_plane_radius_factor_metadata)

    _set_max_vert_plane_radius_factor_metadata = { "name" : "max_vert_plane_radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_vert_plane_radius_factor.setter
    def max_vert_plane_radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.set_property(IVerticalPlaneAndFlightPathOptions._metadata, IVerticalPlaneAndFlightPathOptions._set_max_vert_plane_radius_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{4a177d89-4a7d-4388-a5db-05a9b35ebece}", IVerticalPlaneAndFlightPathOptions)
agcls.AgTypeNameMap["IVerticalPlaneAndFlightPathOptions"] = IVerticalPlaneAndFlightPathOptions

class IArcVerticalPlaneOptions(object):
    """Interface used to access the Vertical Plane options for an arc procedure."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{402feacd-0f43-4af6-8c56-9aa61240e2b0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_arc_flight_path_angle" : 1,
                             "set_start_arc_flight_path_angle" : 2,
                             "get_stop_arc_flight_path_angle" : 3,
                             "set_stop_arc_flight_path_angle" : 4,
                             "get_min_enroute_flight_path_angle" : 5,
                             "set_min_enroute_flight_path_angle" : 6,
                             "get_max_enroute_flight_path_angle" : 7,
                             "set_max_enroute_flight_path_angle" : 8,
                             "get_max_vert_plane_radius_factor" : 9,
                             "set_max_vert_plane_radius_factor" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IArcVerticalPlaneOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IArcVerticalPlaneOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IArcVerticalPlaneOptions.__dict__ and type(IArcVerticalPlaneOptions.__dict__[attrname]) == property:
            return IArcVerticalPlaneOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IArcVerticalPlaneOptions.")
    
    _get_start_arc_flight_path_angle_metadata = { "name" : "start_arc_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_arc_flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the start of the arc."""
        return self._intf.get_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._get_start_arc_flight_path_angle_metadata)

    _set_start_arc_flight_path_angle_metadata = { "name" : "start_arc_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @start_arc_flight_path_angle.setter
    def start_arc_flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the start of the arc."""
        return self._intf.set_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._set_start_arc_flight_path_angle_metadata, newVal)

    _get_stop_arc_flight_path_angle_metadata = { "name" : "stop_arc_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_arc_flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the end of the arc."""
        return self._intf.get_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._get_stop_arc_flight_path_angle_metadata)

    _set_stop_arc_flight_path_angle_metadata = { "name" : "stop_arc_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @stop_arc_flight_path_angle.setter
    def stop_arc_flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the end of the arc."""
        return self._intf.set_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._set_stop_arc_flight_path_angle_metadata, newVal)

    _get_min_enroute_flight_path_angle_metadata = { "name" : "min_enroute_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def min_enroute_flight_path_angle(self) -> typing.Any:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.get_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._get_min_enroute_flight_path_angle_metadata)

    _set_min_enroute_flight_path_angle_metadata = { "name" : "min_enroute_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @min_enroute_flight_path_angle.setter
    def min_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The minimum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.set_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._set_min_enroute_flight_path_angle_metadata, newVal)

    _get_max_enroute_flight_path_angle_metadata = { "name" : "max_enroute_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_enroute_flight_path_angle(self) -> typing.Any:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.get_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._get_max_enroute_flight_path_angle_metadata)

    _set_max_enroute_flight_path_angle_metadata = { "name" : "max_enroute_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_enroute_flight_path_angle.setter
    def max_enroute_flight_path_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle of the flight path during enroute segments of the procedure."""
        return self._intf.set_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._set_max_enroute_flight_path_angle_metadata, newVal)

    _get_max_vert_plane_radius_factor_metadata = { "name" : "max_vert_plane_radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_vert_plane_radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.get_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._get_max_vert_plane_radius_factor_metadata)

    _set_max_vert_plane_radius_factor_metadata = { "name" : "max_vert_plane_radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_vert_plane_radius_factor.setter
    def max_vert_plane_radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.set_property(IArcVerticalPlaneOptions._metadata, IArcVerticalPlaneOptions._set_max_vert_plane_radius_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{402feacd-0f43-4af6-8c56-9aa61240e2b0}", IArcVerticalPlaneOptions)
agcls.AgTypeNameMap["IArcVerticalPlaneOptions"] = IArcVerticalPlaneOptions

class IEnrouteOptions(object):
    """Interface used to access the Enroute options for an Aviator procedure."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{cd8774fa-5dd0-4ac6-8292-0914fa1cff61}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_max_speed_turns" : 1,
                             "set_use_max_speed_turns" : 2,
                             "get_max_turn_radius_factor" : 3,
                             "set_max_turn_radius_factor" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IEnrouteOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IEnrouteOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEnrouteOptions.__dict__ and type(IEnrouteOptions.__dict__[attrname]) == property:
            return IEnrouteOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEnrouteOptions.")
    
    _get_use_max_speed_turns_metadata = { "name" : "use_max_speed_turns",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_speed_turns(self) -> bool:
        """Opt whether to use the max speed turns."""
        return self._intf.get_property(IEnrouteOptions._metadata, IEnrouteOptions._get_use_max_speed_turns_metadata)

    _set_use_max_speed_turns_metadata = { "name" : "use_max_speed_turns",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_max_speed_turns.setter
    def use_max_speed_turns(self, newVal:bool) -> None:
        """Opt whether to use the max speed turns."""
        return self._intf.set_property(IEnrouteOptions._metadata, IEnrouteOptions._set_use_max_speed_turns_metadata, newVal)

    _get_max_turn_radius_factor_metadata = { "name" : "max_turn_radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_turn_radius_factor(self) -> float:
        """The maximum turn radius factor."""
        return self._intf.get_property(IEnrouteOptions._metadata, IEnrouteOptions._get_max_turn_radius_factor_metadata)

    _set_max_turn_radius_factor_metadata = { "name" : "max_turn_radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_turn_radius_factor.setter
    def max_turn_radius_factor(self, newVal:float) -> None:
        """The maximum turn radius factor."""
        return self._intf.set_property(IEnrouteOptions._metadata, IEnrouteOptions._set_max_turn_radius_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{cd8774fa-5dd0-4ac6-8292-0914fa1cff61}", IEnrouteOptions)
agcls.AgTypeNameMap["IEnrouteOptions"] = IEnrouteOptions

class IEnrouteAndDelayOptions(object):
    """Interface used to access the Enroute options for an Aviator procedure."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{cabcbefb-211d-4657-a9eb-fec703b42b11}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_delay_enroute_climb_descents" : 1,
                             "set_delay_enroute_climb_descents" : 2,
                             "get_use_max_speed_turns" : 3,
                             "set_use_max_speed_turns" : 4,
                             "get_max_turn_radius_factor" : 5,
                             "set_max_turn_radius_factor" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IEnrouteAndDelayOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IEnrouteAndDelayOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEnrouteAndDelayOptions.__dict__ and type(IEnrouteAndDelayOptions.__dict__[attrname]) == property:
            return IEnrouteAndDelayOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEnrouteAndDelayOptions.")
    
    _get_delay_enroute_climb_descents_metadata = { "name" : "delay_enroute_climb_descents",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def delay_enroute_climb_descents(self) -> bool:
        """Opt whether to delay the enroute climb or descent."""
        return self._intf.get_property(IEnrouteAndDelayOptions._metadata, IEnrouteAndDelayOptions._get_delay_enroute_climb_descents_metadata)

    _set_delay_enroute_climb_descents_metadata = { "name" : "delay_enroute_climb_descents",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @delay_enroute_climb_descents.setter
    def delay_enroute_climb_descents(self, newVal:bool) -> None:
        """Opt whether to delay the enroute climb or descent."""
        return self._intf.set_property(IEnrouteAndDelayOptions._metadata, IEnrouteAndDelayOptions._set_delay_enroute_climb_descents_metadata, newVal)

    _get_use_max_speed_turns_metadata = { "name" : "use_max_speed_turns",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_speed_turns(self) -> bool:
        """Opt whether to use the max speed turns."""
        return self._intf.get_property(IEnrouteAndDelayOptions._metadata, IEnrouteAndDelayOptions._get_use_max_speed_turns_metadata)

    _set_use_max_speed_turns_metadata = { "name" : "use_max_speed_turns",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_max_speed_turns.setter
    def use_max_speed_turns(self, newVal:bool) -> None:
        """Opt whether to use the max speed turns."""
        return self._intf.set_property(IEnrouteAndDelayOptions._metadata, IEnrouteAndDelayOptions._set_use_max_speed_turns_metadata, newVal)

    _get_max_turn_radius_factor_metadata = { "name" : "max_turn_radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_turn_radius_factor(self) -> float:
        """The maximum turn radius factor."""
        return self._intf.get_property(IEnrouteAndDelayOptions._metadata, IEnrouteAndDelayOptions._get_max_turn_radius_factor_metadata)

    _set_max_turn_radius_factor_metadata = { "name" : "max_turn_radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_turn_radius_factor.setter
    def max_turn_radius_factor(self, newVal:float) -> None:
        """The maximum turn radius factor."""
        return self._intf.set_property(IEnrouteAndDelayOptions._metadata, IEnrouteAndDelayOptions._set_max_turn_radius_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{cabcbefb-211d-4657-a9eb-fec703b42b11}", IEnrouteAndDelayOptions)
agcls.AgTypeNameMap["IEnrouteAndDelayOptions"] = IEnrouteAndDelayOptions

class IEnrouteTurnDirectionOptions(object):
    """Interface used to access the Enroute Turn Direction options for an Aviator procedure."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{cfb34c54-d768-42f8-a7bc-1a079bdea24e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_enroute_first_turn" : 1,
                             "set_enroute_first_turn" : 2,
                             "get_enroute_second_turn" : 3,
                             "set_enroute_second_turn" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IEnrouteTurnDirectionOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IEnrouteTurnDirectionOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEnrouteTurnDirectionOptions.__dict__ and type(IEnrouteTurnDirectionOptions.__dict__[attrname]) == property:
            return IEnrouteTurnDirectionOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEnrouteTurnDirectionOptions.")
    
    _get_enroute_first_turn_metadata = { "name" : "enroute_first_turn",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @property
    def enroute_first_turn(self) -> "NAVIGATOR_TURN_DIRECTION":
        """Option for the first turn."""
        return self._intf.get_property(IEnrouteTurnDirectionOptions._metadata, IEnrouteTurnDirectionOptions._get_enroute_first_turn_metadata)

    _set_enroute_first_turn_metadata = { "name" : "enroute_first_turn",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @enroute_first_turn.setter
    def enroute_first_turn(self, newVal:"NAVIGATOR_TURN_DIRECTION") -> None:
        """Option for the first turn."""
        return self._intf.set_property(IEnrouteTurnDirectionOptions._metadata, IEnrouteTurnDirectionOptions._set_enroute_first_turn_metadata, newVal)

    _get_enroute_second_turn_metadata = { "name" : "enroute_second_turn",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @property
    def enroute_second_turn(self) -> "NAVIGATOR_TURN_DIRECTION":
        """Option for the second turn."""
        return self._intf.get_property(IEnrouteTurnDirectionOptions._metadata, IEnrouteTurnDirectionOptions._get_enroute_second_turn_metadata)

    _set_enroute_second_turn_metadata = { "name" : "enroute_second_turn",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @enroute_second_turn.setter
    def enroute_second_turn(self, newVal:"NAVIGATOR_TURN_DIRECTION") -> None:
        """Option for the second turn."""
        return self._intf.set_property(IEnrouteTurnDirectionOptions._metadata, IEnrouteTurnDirectionOptions._set_enroute_second_turn_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{cfb34c54-d768-42f8-a7bc-1a079bdea24e}", IEnrouteTurnDirectionOptions)
agcls.AgTypeNameMap["IEnrouteTurnDirectionOptions"] = IEnrouteTurnDirectionOptions

class ICruiseAirspeedOptions(object):
    """Interface used to access the Cruise Airspeed options for an Aviator procedure."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8c88b752-5739-4244-9db7-9fd404b3c0c6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_cruise_speed_type" : 1,
                             "set_cruise_speed_type" : 2,
                             "get_other_airspeed_type" : 3,
                             "get_other_airspeed" : 4,
                             "set_other_airspeed" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICruiseAirspeedOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICruiseAirspeedOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICruiseAirspeedOptions.__dict__ and type(ICruiseAirspeedOptions.__dict__[attrname]) == property:
            return ICruiseAirspeedOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICruiseAirspeedOptions.")
    
    _get_cruise_speed_type_metadata = { "name" : "cruise_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRUISE_SPEED),) }
    @property
    def cruise_speed_type(self) -> "CRUISE_SPEED":
        """The method for determining the aircraft's airspeed."""
        return self._intf.get_property(ICruiseAirspeedOptions._metadata, ICruiseAirspeedOptions._get_cruise_speed_type_metadata)

    _set_cruise_speed_type_metadata = { "name" : "cruise_speed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRUISE_SPEED),) }
    @cruise_speed_type.setter
    def cruise_speed_type(self, newVal:"CRUISE_SPEED") -> None:
        """The method for determining the aircraft's airspeed."""
        return self._intf.set_property(ICruiseAirspeedOptions._metadata, ICruiseAirspeedOptions._set_cruise_speed_type_metadata, newVal)

    _get_other_airspeed_type_metadata = { "name" : "other_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def other_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type for the other airspeed option."""
        return self._intf.get_property(ICruiseAirspeedOptions._metadata, ICruiseAirspeedOptions._get_other_airspeed_type_metadata)

    _get_other_airspeed_metadata = { "name" : "other_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def other_airspeed(self) -> float:
        """The airspeed for the other airspeed option."""
        return self._intf.get_property(ICruiseAirspeedOptions._metadata, ICruiseAirspeedOptions._get_other_airspeed_metadata)

    _set_other_airspeed_metadata = { "name" : "set_other_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_other_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the cruise airspeed. This option is only enabled if the cruise speed type is set to other."""
        return self._intf.invoke(ICruiseAirspeedOptions._metadata, ICruiseAirspeedOptions._set_other_airspeed_metadata, airspeedType, airspeed)


agcls.AgClassCatalog.add_catalog_entry("{8c88b752-5739-4244-9db7-9fd404b3c0c6}", ICruiseAirspeedOptions)
agcls.AgTypeNameMap["ICruiseAirspeedOptions"] = ICruiseAirspeedOptions

class ICruiseAirspeedProfile(object):
    """Interface used to access the Cruise Profile options for an Aviator procedure"""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{fc8fb409-7067-4474-9c5e-4a77ac894426}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_fly_cruise_airspeed_profile" : 1,
                             "set_fly_cruise_airspeed_profile" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICruiseAirspeedProfile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICruiseAirspeedProfile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICruiseAirspeedProfile.__dict__ and type(ICruiseAirspeedProfile.__dict__[attrname]) == property:
            return ICruiseAirspeedProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICruiseAirspeedProfile.")
    
    _get_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.get_property(ICruiseAirspeedProfile._metadata, ICruiseAirspeedProfile._get_fly_cruise_airspeed_profile_metadata)

    _set_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, newVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.set_property(ICruiseAirspeedProfile._metadata, ICruiseAirspeedProfile._set_fly_cruise_airspeed_profile_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{fc8fb409-7067-4474-9c5e-4a77ac894426}", ICruiseAirspeedProfile)
agcls.AgTypeNameMap["ICruiseAirspeedProfile"] = ICruiseAirspeedProfile

class ICruiseAirspeedAndProfileOptions(object):
    """Interface used to access the cruise airspeed options that also include a profile field."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{639730b3-bc2b-4615-afd6-8184af1fb948}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_cruise_speed_type" : 1,
                             "set_cruise_speed_type" : 2,
                             "get_other_airspeed_type" : 3,
                             "get_other_airspeed" : 4,
                             "set_other_airspeed" : 5,
                             "get_fly_cruise_airspeed_profile" : 6,
                             "set_fly_cruise_airspeed_profile" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ICruiseAirspeedAndProfileOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ICruiseAirspeedAndProfileOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICruiseAirspeedAndProfileOptions.__dict__ and type(ICruiseAirspeedAndProfileOptions.__dict__[attrname]) == property:
            return ICruiseAirspeedAndProfileOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICruiseAirspeedAndProfileOptions.")
    
    _get_cruise_speed_type_metadata = { "name" : "cruise_speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRUISE_SPEED),) }
    @property
    def cruise_speed_type(self) -> "CRUISE_SPEED":
        """The method for determining the aircraft's airspeed."""
        return self._intf.get_property(ICruiseAirspeedAndProfileOptions._metadata, ICruiseAirspeedAndProfileOptions._get_cruise_speed_type_metadata)

    _set_cruise_speed_type_metadata = { "name" : "cruise_speed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRUISE_SPEED),) }
    @cruise_speed_type.setter
    def cruise_speed_type(self, newVal:"CRUISE_SPEED") -> None:
        """The method for determining the aircraft's airspeed."""
        return self._intf.set_property(ICruiseAirspeedAndProfileOptions._metadata, ICruiseAirspeedAndProfileOptions._set_cruise_speed_type_metadata, newVal)

    _get_other_airspeed_type_metadata = { "name" : "other_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def other_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type for the other airspeed option."""
        return self._intf.get_property(ICruiseAirspeedAndProfileOptions._metadata, ICruiseAirspeedAndProfileOptions._get_other_airspeed_type_metadata)

    _get_other_airspeed_metadata = { "name" : "other_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def other_airspeed(self) -> float:
        """The airspeed for the other airspeed option."""
        return self._intf.get_property(ICruiseAirspeedAndProfileOptions._metadata, ICruiseAirspeedAndProfileOptions._get_other_airspeed_metadata)

    _set_other_airspeed_metadata = { "name" : "set_other_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_other_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the cruise airspeed. This option is only enabled if the cruise speed type is set to other."""
        return self._intf.invoke(ICruiseAirspeedAndProfileOptions._metadata, ICruiseAirspeedAndProfileOptions._set_other_airspeed_metadata, airspeedType, airspeed)

    _get_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.get_property(ICruiseAirspeedAndProfileOptions._metadata, ICruiseAirspeedAndProfileOptions._get_fly_cruise_airspeed_profile_metadata)

    _set_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, newVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.set_property(ICruiseAirspeedAndProfileOptions._metadata, ICruiseAirspeedAndProfileOptions._set_fly_cruise_airspeed_profile_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{639730b3-bc2b-4615-afd6-8184af1fb948}", ICruiseAirspeedAndProfileOptions)
agcls.AgTypeNameMap["ICruiseAirspeedAndProfileOptions"] = ICruiseAirspeedAndProfileOptions

class IAutomationStrategyFactory(object):
    """Interface used to send connect commands to Aviator objects."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{310e51d5-81bf-4fc5-8260-b2eb2de0e1ed}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "construct_strategy" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAutomationStrategyFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAutomationStrategyFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAutomationStrategyFactory.__dict__ and type(IAutomationStrategyFactory.__dict__[attrname]) == property:
            return IAutomationStrategyFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAutomationStrategyFactory.")
    
    _construct_strategy_metadata = { "name" : "construct_strategy",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IUnknown"), agmarshall.AgInterface_out_arg,) }
    def construct_strategy(self, pUnk:"IUnknown") -> "IBasicManeuverStrategy":
        """Construct the strategy."""
        return self._intf.invoke(IAutomationStrategyFactory._metadata, IAutomationStrategyFactory._construct_strategy_metadata, pUnk, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{310e51d5-81bf-4fc5-8260-b2eb2de0e1ed}", IAutomationStrategyFactory)
agcls.AgTypeNameMap["IAutomationStrategyFactory"] = IAutomationStrategyFactory

class IConnect(object):
    """Interface used to send connect commands to Aviator objects."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{beb8d5ff-ae82-49d9-bff6-aa88fa3125ed}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "execute_command" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IConnect._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IConnect from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConnect.__dict__ and type(IConnect.__dict__[attrname]) == property:
            return IConnect.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConnect.")
    
    _execute_command_metadata = { "name" : "execute_command",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def execute_command(self, command:str) -> typing.Any:
        """Send a connect command to an Aviator object."""
        return self._intf.invoke(IConnect._metadata, IConnect._execute_command_metadata, command, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{beb8d5ff-ae82-49d9-bff6-aa88fa3125ed}", IConnect)
agcls.AgTypeNameMap["IConnect"] = IConnect

class IRunwayHeadingOptions(object):
    """Interface for the Runway Heading Options found in a Takeoff or Landing procedure."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8e456b0d-eb7a-423c-acc3-467bc13b6375}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_runway_mode" : 1,
                             "set_runway_mode" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IRunwayHeadingOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IRunwayHeadingOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRunwayHeadingOptions.__dict__ and type(IRunwayHeadingOptions.__dict__[attrname]) == property:
            return IRunwayHeadingOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRunwayHeadingOptions.")
    
    _get_runway_mode_metadata = { "name" : "runway_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(RUNWAY_HIGH_LOW_END),) }
    @property
    def runway_mode(self) -> "RUNWAY_HIGH_LOW_END":
        """The runway heading that the aircraft will use."""
        return self._intf.get_property(IRunwayHeadingOptions._metadata, IRunwayHeadingOptions._get_runway_mode_metadata)

    _set_runway_mode_metadata = { "name" : "runway_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(RUNWAY_HIGH_LOW_END),) }
    @runway_mode.setter
    def runway_mode(self, newVal:"RUNWAY_HIGH_LOW_END") -> None:
        """The runway heading that the aircraft will use."""
        return self._intf.set_property(IRunwayHeadingOptions._metadata, IRunwayHeadingOptions._set_runway_mode_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{8e456b0d-eb7a-423c-acc3-467bc13b6375}", IRunwayHeadingOptions)
agcls.AgTypeNameMap["IRunwayHeadingOptions"] = IRunwayHeadingOptions

class IProcedure(object):
    """Interface used to access the options for a procedure. Use this interface to get the Site and Get the time options for the current procedure."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{df1aaedb-6f1c-4a50-9fdb-9fda3d56d3db}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1,
                             "set_name" : 2,
                             "get_site" : 3,
                             "get_time_options" : 4,
                             "get_wind_model" : 5,
                             "get_atmosphere_model" : 6,
                             "get_calculation_options" : 7,
                             "get_refuel_dump_is_supported" : 8,
                             "get_refuel_dump_properties" : 9,
                             "get_fast_time_options" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedure._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedure from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedure.__dict__ and type(IProcedure.__dict__[attrname]) == property:
            return IProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedure.")
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the procedure."""
        return self._intf.set_property(IProcedure._metadata, IProcedure._set_name_metadata, newVal)

    _get_site_metadata = { "name" : "site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def site(self) -> "ISite":
        """Get the site of the current procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_site_metadata)

    _get_time_options_metadata = { "name" : "time_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def time_options(self) -> "ProcedureTimeOptions":
        """Get the time options for the current procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_time_options_metadata)

    _get_wind_model_metadata = { "name" : "wind_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def wind_model(self) -> "WindModel":
        """Get the wind model for the current procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_wind_model_metadata)

    _get_atmosphere_model_metadata = { "name" : "atmosphere_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def atmosphere_model(self) -> "AtmosphereModel":
        """Get the mission atmosphere model."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_atmosphere_model_metadata)

    _get_calculation_options_metadata = { "name" : "calculation_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def calculation_options(self) -> "CalculationOptions":
        """Get the calculation options for the current procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_calculation_options_metadata)

    _get_refuel_dump_is_supported_metadata = { "name" : "refuel_dump_is_supported",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def refuel_dump_is_supported(self) -> bool:
        """Refuel/dump is supported for the current procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_refuel_dump_is_supported_metadata)

    _get_refuel_dump_properties_metadata = { "name" : "refuel_dump_properties",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def refuel_dump_properties(self) -> "RefuelDumpProperties":
        """Get the refuel/dump properties for the current procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_refuel_dump_properties_metadata)

    _get_fast_time_options_metadata = { "name" : "fast_time_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fast_time_options(self) -> "ProcedureFastTimeOptions":
        """Get the fast time options (without validation or constraints) for the current procedure."""
        return self._intf.get_property(IProcedure._metadata, IProcedure._get_fast_time_options_metadata)


agcls.AgClassCatalog.add_catalog_entry("{df1aaedb-6f1c-4a50-9fdb-9fda3d56d3db}", IProcedure)
agcls.AgTypeNameMap["IProcedure"] = IProcedure

class IProcedureCollection(object):
    """Interface used to access the collection of procedures for a given phase in a mission. Use this interface to Get, Add, or Remove a procedure."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{27c58de8-b8f8-40d6-ae6d-4e31cbbd8a43}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3,
                             "add" : 4,
                             "add_at_index" : 5,
                             "remove" : 6,
                             "remove_at_index" : 7,
                             "enable_auto_propagate" : 8,
                             "disable_auto_propagate" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureCollection.__dict__ and type(IProcedureCollection.__dict__[attrname]) == property:
            return IProcedureCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IProcedure":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        return self._intf.get_property(IProcedureCollection._metadata, IProcedureCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "IProcedure":
        """Given an index, returns an element in the collection."""
        return self._intf.invoke(IProcedureCollection._metadata, IProcedureCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns an enumerator that can iterate through the collection."""
        return self._intf.get_property(IProcedureCollection._metadata, IProcedureCollection._get__NewEnum_metadata)

    _add_metadata = { "name" : "add",
            "arg_types" : (agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgEnum_arg(SITE_TYPE), agmarshall.AgEnum_arg(PROCEDURE_TYPE), agmarshall.AgInterface_out_arg,) }
    def add(self, siteType:"SITE_TYPE", procedureType:"PROCEDURE_TYPE") -> "IProcedure":
        """Adds a procedure with the specified site at the end of the current phase."""
        return self._intf.invoke(IProcedureCollection._metadata, IProcedureCollection._add_metadata, siteType, procedureType, out_arg())

    _add_at_index_metadata = { "name" : "add_at_index",
            "arg_types" : (agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgEnum_arg(SITE_TYPE), agmarshall.AgEnum_arg(PROCEDURE_TYPE), agmarshall.AgInterface_out_arg,) }
    def add_at_index(self, index:int, siteType:"SITE_TYPE", procedureType:"PROCEDURE_TYPE") -> "IProcedure":
        """Adds a procedure with the specified site at the given index."""
        return self._intf.invoke(IProcedureCollection._metadata, IProcedureCollection._add_at_index_metadata, index, siteType, procedureType, out_arg())

    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IProcedure"),) }
    def remove(self, procedure:"IProcedure") -> None:
        """Remove given procedure."""
        return self._intf.invoke(IProcedureCollection._metadata, IProcedureCollection._remove_metadata, procedure)

    _remove_at_index_metadata = { "name" : "remove_at_index",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    def remove_at_index(self, index:int) -> None:
        """Remove procedure at the given index."""
        return self._intf.invoke(IProcedureCollection._metadata, IProcedureCollection._remove_at_index_metadata, index)

    _enable_auto_propagate_metadata = { "name" : "enable_auto_propagate",
            "arg_types" : (),
            "marshallers" : () }
    def enable_auto_propagate(self) -> None:
        """Enable automatically propagating the mission. Aviator will automatically propagate before adding a procedure, ensuring a valid initial state for the new procedure."""
        return self._intf.invoke(IProcedureCollection._metadata, IProcedureCollection._enable_auto_propagate_metadata, )

    _disable_auto_propagate_metadata = { "name" : "disable_auto_propagate",
            "arg_types" : (),
            "marshallers" : () }
    def disable_auto_propagate(self) -> None:
        """Disable automatically propagating the mission. Use with caution. Aviator will not automatically propagate before adding new procedures."""
        return self._intf.invoke(IProcedureCollection._metadata, IProcedureCollection._disable_auto_propagate_metadata, )

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{27c58de8-b8f8-40d6-ae6d-4e31cbbd8a43}", IProcedureCollection)
agcls.AgTypeNameMap["IProcedureCollection"] = IProcedureCollection

class IPhase(object):
    """Interface used to access the phase options for a mission."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1979f1b5-fe60-464b-af70-eb47fd5c096b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_procedures" : 1,
                             "get_name" : 2,
                             "set_name" : 3,
                             "get_performance_model_by_type" : 4,
                             "set_default_perf_models" : 5,
                             "copy_performance_models" : 6,
                             "paste_performance_models" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IPhase._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IPhase from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPhase.__dict__ and type(IPhase.__dict__[attrname]) == property:
            return IPhase.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPhase.")
    
    _get_procedures_metadata = { "name" : "procedures",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def procedures(self) -> "ProcedureCollection":
        """Returns the procedure collection."""
        return self._intf.get_property(IPhase._metadata, IPhase._get_procedures_metadata)

    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """The name of the phase."""
        return self._intf.get_property(IPhase._metadata, IPhase._get_name_metadata)

    _set_name_metadata = { "name" : "name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @name.setter
    def name(self, newVal:str) -> None:
        """The name of the phase."""
        return self._intf.set_property(IPhase._metadata, IPhase._set_name_metadata, newVal)

    _get_performance_model_by_type_metadata = { "name" : "get_performance_model_by_type",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_performance_model_by_type(self, type:str) -> "PerformanceModelOptions":
        """Get the active performance model for the given category type."""
        return self._intf.invoke(IPhase._metadata, IPhase._get_performance_model_by_type_metadata, type, out_arg())

    _set_default_perf_models_metadata = { "name" : "set_default_perf_models",
            "arg_types" : (),
            "marshallers" : () }
    def set_default_perf_models(self) -> None:
        """Set the phase to use the default performance models of the aircraft."""
        return self._intf.invoke(IPhase._metadata, IPhase._set_default_perf_models_metadata, )

    _copy_performance_models_metadata = { "name" : "copy_performance_models",
            "arg_types" : (),
            "marshallers" : () }
    def copy_performance_models(self) -> None:
        """Create a copy of the active performance models for the current phase."""
        return self._intf.invoke(IPhase._metadata, IPhase._copy_performance_models_metadata, )

    _paste_performance_models_metadata = { "name" : "paste_performance_models",
            "arg_types" : (),
            "marshallers" : () }
    def paste_performance_models(self) -> None:
        """Paste the performance models."""
        return self._intf.invoke(IPhase._metadata, IPhase._paste_performance_models_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{1979f1b5-fe60-464b-af70-eb47fd5c096b}", IPhase)
agcls.AgTypeNameMap["IPhase"] = IPhase

class IPhaseCollection(object):
    """Interface used to access the collection of phases for a mission."""
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{d7309dde-9887-48e6-9a10-dfadfaa3c48b}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3,
                             "add" : 4,
                             "add_at_index" : 5,
                             "remove" : 6,
                             "remove_at_index" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IPhaseCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IPhaseCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPhaseCollection.__dict__ and type(IPhaseCollection.__dict__[attrname]) == property:
            return IPhaseCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPhaseCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IPhase":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Returns the number of elements in a collection."""
        return self._intf.get_property(IPhaseCollection._metadata, IPhaseCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "Phase":
        """Given an index, returns an element in the collection."""
        return self._intf.invoke(IPhaseCollection._metadata, IPhaseCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns an enumerator that can iterate through the collection."""
        return self._intf.get_property(IPhaseCollection._metadata, IPhaseCollection._get__NewEnum_metadata)

    _add_metadata = { "name" : "add",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def add(self) -> "Phase":
        """Adds a phase at the end of the mission."""
        return self._intf.invoke(IPhaseCollection._metadata, IPhaseCollection._add_metadata, out_arg())

    _add_at_index_metadata = { "name" : "add_at_index",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def add_at_index(self, index:int) -> "Phase":
        """Adds a phase at the given index."""
        return self._intf.invoke(IPhaseCollection._metadata, IPhaseCollection._add_at_index_metadata, index, out_arg())

    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IPhase"),) }
    def remove(self, phase:"IPhase") -> None:
        """Remove given phase."""
        return self._intf.invoke(IPhaseCollection._metadata, IPhaseCollection._remove_metadata, phase)

    _remove_at_index_metadata = { "name" : "remove_at_index",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    def remove_at_index(self, index:int) -> None:
        """Remove phase at the given index."""
        return self._intf.invoke(IPhaseCollection._metadata, IPhaseCollection._remove_at_index_metadata, index)

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{d7309dde-9887-48e6-9a10-dfadfaa3c48b}", IPhaseCollection)
agcls.AgTypeNameMap["IPhaseCollection"] = IPhaseCollection

class IMission(object):
    """Interface for the mission of an aircraft using the Aviator propagator."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e4467d52-6a09-47b2-943c-7e24ae375f6b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_phases" : 1,
                             "get_vehicle" : 2,
                             "set_vehicle" : 3,
                             "get_configuration" : 4,
                             "get_wind_model" : 5,
                             "get_atmosphere_model" : 6,
                             "get_is_valid" : 7,
                             "get_first_invalid_procedure" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IMission._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IMission from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMission.__dict__ and type(IMission.__dict__[attrname]) == property:
            return IMission.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMission.")
    
    _get_phases_metadata = { "name" : "phases",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def phases(self) -> "PhaseCollection":
        """Get the mission phases."""
        return self._intf.get_property(IMission._metadata, IMission._get_phases_metadata)

    _get_vehicle_metadata = { "name" : "vehicle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vehicle(self) -> "IAviatorVehicle":
        """The vehicle used in the mission."""
        return self._intf.get_property(IMission._metadata, IMission._get_vehicle_metadata)

    _set_vehicle_metadata = { "name" : "vehicle",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAviatorVehicle"),) }
    @vehicle.setter
    def vehicle(self, pAvtrVehicle:"IAviatorVehicle") -> None:
        """The vehicle used in the mission."""
        return self._intf.set_property(IMission._metadata, IMission._set_vehicle_metadata, pAvtrVehicle)

    _get_configuration_metadata = { "name" : "configuration",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def configuration(self) -> "Configuration":
        """The aircraft's configuration for the mission."""
        return self._intf.get_property(IMission._metadata, IMission._get_configuration_metadata)

    _get_wind_model_metadata = { "name" : "wind_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def wind_model(self) -> "WindModel":
        """Get the mission wind model."""
        return self._intf.get_property(IMission._metadata, IMission._get_wind_model_metadata)

    _get_atmosphere_model_metadata = { "name" : "atmosphere_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def atmosphere_model(self) -> "AtmosphereModel":
        """Get the mission atmosphere model."""
        return self._intf.get_property(IMission._metadata, IMission._get_atmosphere_model_metadata)

    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Check whether the mission is valid. Calling this property will propagate the mission."""
        return self._intf.get_property(IMission._metadata, IMission._get_is_valid_metadata)

    _get_first_invalid_procedure_metadata = { "name" : "get_first_invalid_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_first_invalid_procedure(self) -> "IProcedure":
        """Get the first invalid procedure in the mission. Calling this method will propagate the mission."""
        return self._intf.invoke(IMission._metadata, IMission._get_first_invalid_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{e4467d52-6a09-47b2-943c-7e24ae375f6b}", IMission)
agcls.AgTypeNameMap["IMission"] = IMission

class IAviatorPropagator(object):
    """Interface used to access the Aviator interface for an aircraft. Use this interface to get the mission or Aviator catalog."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f7e3993a-52ed-4e91-8655-79063c0a3e94}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_avtr_mission" : 1,
                             "propagate" : 2,
                             "get_auto_recalculate" : 3,
                             "set_auto_recalculate" : 4,
                             "get_avtr_catalog" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAviatorPropagator._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAviatorPropagator from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAviatorPropagator.__dict__ and type(IAviatorPropagator.__dict__[attrname]) == property:
            return IAviatorPropagator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAviatorPropagator.")
    
    _get_avtr_mission_metadata = { "name" : "avtr_mission",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def avtr_mission(self) -> "Mission":
        """The Aviator mission."""
        return self._intf.get_property(IAviatorPropagator._metadata, IAviatorPropagator._get_avtr_mission_metadata)

    _propagate_metadata = { "name" : "propagate",
            "arg_types" : (),
            "marshallers" : () }
    def propagate(self) -> None:
        """Applies All Change."""
        return self._intf.invoke(IAviatorPropagator._metadata, IAviatorPropagator._propagate_metadata, )

    _get_auto_recalculate_metadata = { "name" : "auto_recalculate",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def auto_recalculate(self) -> bool:
        """Opt whether to have the propagator auto recalculate."""
        return self._intf.get_property(IAviatorPropagator._metadata, IAviatorPropagator._get_auto_recalculate_metadata)

    _set_auto_recalculate_metadata = { "name" : "auto_recalculate",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @auto_recalculate.setter
    def auto_recalculate(self, vbAutoRecalc:bool) -> None:
        """Opt whether to have the propagator auto recalculate."""
        return self._intf.set_property(IAviatorPropagator._metadata, IAviatorPropagator._set_auto_recalculate_metadata, vbAutoRecalc)

    _get_avtr_catalog_metadata = { "name" : "avtr_catalog",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def avtr_catalog(self) -> "Catalog":
        """The Aviator catalog."""
        return self._intf.get_property(IAviatorPropagator._metadata, IAviatorPropagator._get_avtr_catalog_metadata)


agcls.AgClassCatalog.add_catalog_entry("{f7e3993a-52ed-4e91-8655-79063c0a3e94}", IAviatorPropagator)
agcls.AgTypeNameMap["IAviatorPropagator"] = IAviatorPropagator

class IPerformanceModel(object):
    """Interface for a performance model of an Aviator vehicle."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8fb55502-c401-4188-adc9-7a889fdbe996}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IPerformanceModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IPerformanceModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPerformanceModel.__dict__ and type(IPerformanceModel.__dict__[attrname]) == property:
            return IPerformanceModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPerformanceModel.")
    

agcls.AgClassCatalog.add_catalog_entry("{8fb55502-c401-4188-adc9-7a889fdbe996}", IPerformanceModel)
agcls.AgTypeNameMap["IPerformanceModel"] = IPerformanceModel

class IAdvFixedWingGeometry(object):
    """Interface used to access the options for the wing geometry in the advanced fixed wing tool."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d3b3af6e-7b5a-4491-aaca-c05eb901afa0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingGeometry._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingGeometry from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingGeometry.__dict__ and type(IAdvFixedWingGeometry.__dict__[attrname]) == property:
            return IAdvFixedWingGeometry.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingGeometry.")
    

agcls.AgClassCatalog.add_catalog_entry("{d3b3af6e-7b5a-4491-aaca-c05eb901afa0}", IAdvFixedWingGeometry)
agcls.AgTypeNameMap["IAdvFixedWingGeometry"] = IAdvFixedWingGeometry

class IAdvFixedWingTurbofanBasicABPowerplant(object):
    """This interface is deprecated. Use AdvFixedWingTurbofanBasicABProp instead."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9bc7e978-48ec-487d-8460-014c8fe376bd}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingTurbofanBasicABPowerplant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbofanBasicABPowerplant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbofanBasicABPowerplant.__dict__ and type(IAdvFixedWingTurbofanBasicABPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingTurbofanBasicABPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbofanBasicABPowerplant.")
    

agcls.AgClassCatalog.add_catalog_entry("{9bc7e978-48ec-487d-8460-014c8fe376bd}", IAdvFixedWingTurbofanBasicABPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingTurbofanBasicABPowerplant"] = IAdvFixedWingTurbofanBasicABPowerplant

class IAdvFixedWingTurbojetBasicABPowerplant(object):
    """This interface is deprecated. Use AdvFixedWingTurbojetBasicABProp instead."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{552db5f4-fe5d-4709-80b4-7ba074c673ff}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingTurbojetBasicABPowerplant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingTurbojetBasicABPowerplant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingTurbojetBasicABPowerplant.__dict__ and type(IAdvFixedWingTurbojetBasicABPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingTurbojetBasicABPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingTurbojetBasicABPowerplant.")
    

agcls.AgClassCatalog.add_catalog_entry("{552db5f4-fe5d-4709-80b4-7ba074c673ff}", IAdvFixedWingTurbojetBasicABPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingTurbojetBasicABPowerplant"] = IAdvFixedWingTurbojetBasicABPowerplant

class IAdvFixedWingPowerplant(object):
    """Interface for a powerplant strategy in the advanced fixed wing tool."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{79824361-d702-4f4b-81ac-001876fb51ef}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAdvFixedWingPowerplant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAdvFixedWingPowerplant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAdvFixedWingPowerplant.__dict__ and type(IAdvFixedWingPowerplant.__dict__[attrname]) == property:
            return IAdvFixedWingPowerplant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAdvFixedWingPowerplant.")
    

agcls.AgClassCatalog.add_catalog_entry("{79824361-d702-4f4b-81ac-001876fb51ef}", IAdvFixedWingPowerplant)
agcls.AgTypeNameMap["IAdvFixedWingPowerplant"] = IAdvFixedWingPowerplant

class ISiteUnknown(object):
    """Interface of an unknown site."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0921dbaf-ee11-4460-8355-01fc207a6803}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteUnknown._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteUnknown from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteUnknown.__dict__ and type(ISiteUnknown.__dict__[attrname]) == property:
            return ISiteUnknown.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteUnknown.")
    

agcls.AgClassCatalog.add_catalog_entry("{0921dbaf-ee11-4460-8355-01fc207a6803}", ISiteUnknown)
agcls.AgTypeNameMap["ISiteUnknown"] = ISiteUnknown

class IAircraftTerrainFollowModel(object):
    """Interface used to access the options for a TerrainFollow performance model of an aircraft."""
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{34e47cb6-b418-468b-b5bf-df98428b7691}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_airspeed_type" : 1,
                             "set_airspeed_type" : 2,
                             "get_use_aero_prop_fuel" : 3,
                             "set_use_aero_prop_fuel" : 4,
                             "get_scale_fuel_flow_by_non_std_density" : 5,
                             "set_scale_fuel_flow_by_non_std_density" : 6,
                             "get_min_airspeed" : 7,
                             "set_min_airspeed" : 8,
                             "get_max_endurance_airspeed" : 9,
                             "set_max_endurance_airspeed" : 10,
                             "get_max_range_airspeed" : 11,
                             "set_max_range_airspeed" : 12,
                             "get_max_airspeed" : 13,
                             "set_max_airspeed" : 14,
                             "get_max_perf_airspeed" : 15,
                             "set_max_perf_airspeed" : 16,
                             "get_min_airspeed_fuel_flow" : 17,
                             "set_min_airspeed_fuel_flow" : 18,
                             "get_max_endurance_fuel_flow" : 19,
                             "set_max_endurance_fuel_flow" : 20,
                             "get_max_range_fuel_flow" : 21,
                             "set_max_range_fuel_flow" : 22,
                             "get_max_airspeed_fuel_flow" : 23,
                             "set_max_airspeed_fuel_flow" : 24,
                             "get_max_perf_airspeed_fuel_flow" : 25,
                             "set_max_perf_airspeed_fuel_flow" : 26,
                             "get_max_pitch_angle" : 27,
                             "set_max_pitch_angle" : 28,
                             "get_terrain_window" : 29,
                             "set_terrain_window" : 30,
                             "get_max_load_factor" : 31, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAircraftTerrainFollowModel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAircraftTerrainFollowModel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAircraftTerrainFollowModel.__dict__ and type(IAircraftTerrainFollowModel.__dict__[attrname]) == property:
            return IAircraftTerrainFollowModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAircraftTerrainFollowModel.")
    
    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_airspeed_type_metadata)

    _set_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @airspeed_type.setter
    def airspeed_type(self, newVal:"AIRSPEED_TYPE") -> None:
        """The airspeed type."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_airspeed_type_metadata, newVal)

    _get_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_aero_prop_fuel(self) -> bool:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_use_aero_prop_fuel_metadata)

    _set_use_aero_prop_fuel_metadata = { "name" : "use_aero_prop_fuel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_aero_prop_fuel.setter
    def use_aero_prop_fuel(self, newVal:bool) -> None:
        """Opt to use the fuel flow calculated by the acceleration performance model."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_use_aero_prop_fuel_metadata, newVal)

    _get_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow_by_non_std_density(self) -> bool:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_scale_fuel_flow_by_non_std_density_metadata)

    _set_scale_fuel_flow_by_non_std_density_metadata = { "name" : "scale_fuel_flow_by_non_std_density",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow_by_non_std_density.setter
    def scale_fuel_flow_by_non_std_density(self, newVal:bool) -> None:
        """Opt to scale the fuel flow by the aircraft's actual altitude."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_scale_fuel_flow_by_non_std_density_metadata, newVal)

    _get_min_airspeed_metadata = { "name" : "min_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_airspeed(self) -> float:
        """The minimum airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_min_airspeed_metadata)

    _set_min_airspeed_metadata = { "name" : "min_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_airspeed.setter
    def min_airspeed(self, newVal:float) -> None:
        """The minimum airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_min_airspeed_metadata, newVal)

    _get_max_endurance_airspeed_metadata = { "name" : "max_endurance_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_endurance_airspeed(self) -> float:
        """The airspeed that will provide the maximum flying time for the aircraft."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_endurance_airspeed_metadata)

    _set_max_endurance_airspeed_metadata = { "name" : "max_endurance_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_endurance_airspeed.setter
    def max_endurance_airspeed(self, newVal:float) -> None:
        """The airspeed that will provide the maximum flying time for the aircraft."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_endurance_airspeed_metadata, newVal)

    _get_max_range_airspeed_metadata = { "name" : "max_range_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_range_airspeed(self) -> float:
        """The maximum range airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_range_airspeed_metadata)

    _set_max_range_airspeed_metadata = { "name" : "max_range_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_range_airspeed.setter
    def max_range_airspeed(self, newVal:float) -> None:
        """The maximum range airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_range_airspeed_metadata, newVal)

    _get_max_airspeed_metadata = { "name" : "max_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_airspeed(self) -> float:
        """The maximum airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_airspeed_metadata)

    _set_max_airspeed_metadata = { "name" : "max_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_airspeed.setter
    def max_airspeed(self, newVal:float) -> None:
        """The maximum airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_airspeed_metadata, newVal)

    _get_max_perf_airspeed_metadata = { "name" : "max_perf_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_perf_airspeed(self) -> float:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_perf_airspeed_metadata)

    _set_max_perf_airspeed_metadata = { "name" : "max_perf_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_perf_airspeed.setter
    def max_perf_airspeed(self, newVal:float) -> None:
        """A custom performance airspeed that can be used to model specific flight conditions."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_perf_airspeed_metadata, newVal)

    _get_min_airspeed_fuel_flow_metadata = { "name" : "min_airspeed_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the minimum airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_min_airspeed_fuel_flow_metadata)

    _set_min_airspeed_fuel_flow_metadata = { "name" : "min_airspeed_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_airspeed_fuel_flow.setter
    def min_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the minimum airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_min_airspeed_fuel_flow_metadata, newVal)

    _get_max_endurance_fuel_flow_metadata = { "name" : "max_endurance_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_endurance_fuel_flow(self) -> float:
        """The fuel flow for the maximum endurance airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_endurance_fuel_flow_metadata)

    _set_max_endurance_fuel_flow_metadata = { "name" : "max_endurance_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_endurance_fuel_flow.setter
    def max_endurance_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum endurance airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_endurance_fuel_flow_metadata, newVal)

    _get_max_range_fuel_flow_metadata = { "name" : "max_range_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_range_fuel_flow(self) -> float:
        """The fuel flow for the maximum range airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_range_fuel_flow_metadata)

    _set_max_range_fuel_flow_metadata = { "name" : "max_range_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_range_fuel_flow.setter
    def max_range_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum range airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_range_fuel_flow_metadata, newVal)

    _get_max_airspeed_fuel_flow_metadata = { "name" : "max_airspeed_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_airspeed_fuel_flow_metadata)

    _set_max_airspeed_fuel_flow_metadata = { "name" : "max_airspeed_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_airspeed_fuel_flow.setter
    def max_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_airspeed_fuel_flow_metadata, newVal)

    _get_max_perf_airspeed_fuel_flow_metadata = { "name" : "max_perf_airspeed_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_perf_airspeed_fuel_flow(self) -> float:
        """The fuel flow for the maximum performance airspeed."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_perf_airspeed_fuel_flow_metadata)

    _set_max_perf_airspeed_fuel_flow_metadata = { "name" : "max_perf_airspeed_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_perf_airspeed_fuel_flow.setter
    def max_perf_airspeed_fuel_flow(self, newVal:float) -> None:
        """The fuel flow for the maximum performance airspeed."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_perf_airspeed_fuel_flow_metadata, newVal)

    _get_max_pitch_angle_metadata = { "name" : "max_pitch_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_pitch_angle(self) -> typing.Any:
        """The maximum pitch angle the aircraft will be allowed to use."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_pitch_angle_metadata)

    _set_max_pitch_angle_metadata = { "name" : "max_pitch_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_pitch_angle.setter
    def max_pitch_angle(self, newVal:typing.Any) -> None:
        """The maximum pitch angle the aircraft will be allowed to use."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_max_pitch_angle_metadata, newVal)

    _get_terrain_window_metadata = { "name" : "terrain_window",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def terrain_window(self) -> float:
        """The time interval over which terrain points are sampled."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_terrain_window_metadata)

    _set_terrain_window_metadata = { "name" : "terrain_window",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @terrain_window.setter
    def terrain_window(self, newVal:float) -> None:
        """The time interval over which terrain points are sampled."""
        return self._intf.set_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._set_terrain_window_metadata, newVal)

    _get_max_load_factor_metadata = { "name" : "max_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_load_factor(self) -> float:
        """The maximum load factor - during straight and level flight - that the aircraft can bear."""
        return self._intf.get_property(IAircraftTerrainFollowModel._metadata, IAircraftTerrainFollowModel._get_max_load_factor_metadata)


agcls.AgClassCatalog.add_catalog_entry("{34e47cb6-b418-468b-b5bf-df98428b7691}", IAircraftTerrainFollowModel)
agcls.AgTypeNameMap["IAircraftTerrainFollowModel"] = IAircraftTerrainFollowModel

class IBasicManeuverTargetPositionVel(object):
    """Interface used to access target position and velocity strategies for basic maneuvers."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F86E4ECC-DBF4-4D49-B2CC-11C71022C1A5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_position_vel_type" : 1,
                             "set_target_position_vel_type" : 2,
                             "get_target_position_vel_type_string" : 3,
                             "set_target_position_vel_type_string" : 4,
                             "get_mode_as_noisy_brn_rng" : 5,
                             "get_mode_as_noisy_surf_tgt" : 6,
                             "apply_position_vel" : 7,
                             "cancel_position_vel" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverTargetPositionVel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverTargetPositionVel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverTargetPositionVel.__dict__ and type(IBasicManeuverTargetPositionVel.__dict__[attrname]) == property:
            return IBasicManeuverTargetPositionVel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverTargetPositionVel.")
    
    _get_target_position_vel_type_metadata = { "name" : "target_position_vel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TARGET_POSITION_VEL_TYPE),) }
    @property
    def target_position_vel_type(self) -> "TARGET_POSITION_VEL_TYPE":
        """The target pos vel type."""
        return self._intf.get_property(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._get_target_position_vel_type_metadata)

    _set_target_position_vel_type_metadata = { "name" : "target_position_vel_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TARGET_POSITION_VEL_TYPE),) }
    @target_position_vel_type.setter
    def target_position_vel_type(self, pVal:"TARGET_POSITION_VEL_TYPE") -> None:
        """The target pos vel type."""
        return self._intf.set_property(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._set_target_position_vel_type_metadata, pVal)

    _get_target_position_vel_type_string_metadata = { "name" : "target_position_vel_type_string",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_position_vel_type_string(self) -> str:
        """The target pos vel as a string value. Use this for custom models."""
        return self._intf.get_property(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._get_target_position_vel_type_string_metadata)

    _set_target_position_vel_type_string_metadata = { "name" : "target_position_vel_type_string",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_position_vel_type_string.setter
    def target_position_vel_type_string(self, pVal:str) -> None:
        """The target pos vel as a string value. Use this for custom models."""
        return self._intf.set_property(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._set_target_position_vel_type_string_metadata, pVal)

    _get_mode_as_noisy_brn_rng_metadata = { "name" : "mode_as_noisy_brn_rng",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_noisy_brn_rng(self) -> "BasicManeuverTargetPositionVelNoisyBrnRng":
        """Get the options for a noisy bearing range velocity strategy."""
        return self._intf.get_property(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._get_mode_as_noisy_brn_rng_metadata)

    _get_mode_as_noisy_surf_tgt_metadata = { "name" : "mode_as_noisy_surf_tgt",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_noisy_surf_tgt(self) -> "BasicManeuverTargetPositionVelNoisySurfTgt":
        """Get the options for a noisy surface target position velocity strategy."""
        return self._intf.get_property(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._get_mode_as_noisy_surf_tgt_metadata)

    _apply_position_vel_metadata = { "name" : "apply_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def apply_position_vel(self) -> None:
        """Apply the current position velocity strategy."""
        return self._intf.invoke(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._apply_position_vel_metadata, )

    _cancel_position_vel_metadata = { "name" : "cancel_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def cancel_position_vel(self) -> None:
        """Cancel the current position velocity strategy."""
        return self._intf.invoke(IBasicManeuverTargetPositionVel._metadata, IBasicManeuverTargetPositionVel._cancel_position_vel_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{F86E4ECC-DBF4-4D49-B2CC-11C71022C1A5}", IBasicManeuverTargetPositionVel)
agcls.AgTypeNameMap["IBasicManeuverTargetPositionVel"] = IBasicManeuverTargetPositionVel

class IPropulsionThrust(object):
    """Interface used to access propulsion thrust for basic maneuver strategies."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{fea63cff-6fa0-406e-ad12-8b17617cb34d}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_constant_thrust" : 1,
                             "set_use_constant_thrust" : 2,
                             "get_constant_thrust" : 3,
                             "set_constant_thrust" : 4,
                             "get_boost_thrust" : 5,
                             "set_boost_thrust" : 6,
                             "get_boost_thrust_time_limit" : 7,
                             "set_boost_thrust_time_limit" : 8,
                             "get_sustain_thrust" : 9,
                             "set_sustain_thrust" : 10,
                             "get_sustain_thrust_time_limit" : 11,
                             "set_sustain_thrust_time_limit" : 12,
                             "get_min_airspeed_type" : 13,
                             "get_min_airspeed" : 14,
                             "set_min_airspeed" : 15,
                             "get_max_airspeed_type" : 16,
                             "get_max_airspeed" : 17,
                             "set_max_airspeed" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IPropulsionThrust._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IPropulsionThrust from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPropulsionThrust.__dict__ and type(IPropulsionThrust.__dict__[attrname]) == property:
            return IPropulsionThrust.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPropulsionThrust.")
    
    _get_use_constant_thrust_metadata = { "name" : "use_constant_thrust",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_constant_thrust(self) -> bool:
        """The option to use a constant thrust for a thrust model."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_use_constant_thrust_metadata)

    _set_use_constant_thrust_metadata = { "name" : "use_constant_thrust",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_constant_thrust.setter
    def use_constant_thrust(self, newVal:bool) -> None:
        """The option to use a constant thrust for a thrust model."""
        return self._intf.set_property(IPropulsionThrust._metadata, IPropulsionThrust._set_use_constant_thrust_metadata, newVal)

    _get_constant_thrust_metadata = { "name" : "constant_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def constant_thrust(self) -> float:
        """The constant thrust value for a thrust model set to Constant Thrust mode."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_constant_thrust_metadata)

    _set_constant_thrust_metadata = { "name" : "constant_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @constant_thrust.setter
    def constant_thrust(self, newVal:float) -> None:
        """The constant thrust value for a thrust model set to Constant Thrust mode."""
        return self._intf.set_property(IPropulsionThrust._metadata, IPropulsionThrust._set_constant_thrust_metadata, newVal)

    _get_boost_thrust_metadata = { "name" : "boost_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def boost_thrust(self) -> float:
        """The boost thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_boost_thrust_metadata)

    _set_boost_thrust_metadata = { "name" : "boost_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @boost_thrust.setter
    def boost_thrust(self, newVal:float) -> None:
        """The boost thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.set_property(IPropulsionThrust._metadata, IPropulsionThrust._set_boost_thrust_metadata, newVal)

    _get_boost_thrust_time_limit_metadata = { "name" : "boost_thrust_time_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def boost_thrust_time_limit(self) -> float:
        """The boost thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_boost_thrust_time_limit_metadata)

    _set_boost_thrust_time_limit_metadata = { "name" : "boost_thrust_time_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @boost_thrust_time_limit.setter
    def boost_thrust_time_limit(self, newVal:float) -> None:
        """The boost thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.set_property(IPropulsionThrust._metadata, IPropulsionThrust._set_boost_thrust_time_limit_metadata, newVal)

    _get_sustain_thrust_metadata = { "name" : "sustain_thrust",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def sustain_thrust(self) -> float:
        """The sustain thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_sustain_thrust_metadata)

    _set_sustain_thrust_metadata = { "name" : "sustain_thrust",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @sustain_thrust.setter
    def sustain_thrust(self, newVal:float) -> None:
        """The sustain thrust value for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.set_property(IPropulsionThrust._metadata, IPropulsionThrust._set_sustain_thrust_metadata, newVal)

    _get_sustain_thrust_time_limit_metadata = { "name" : "sustain_thrust_time_limit",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def sustain_thrust_time_limit(self) -> float:
        """The sustain thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_sustain_thrust_time_limit_metadata)

    _set_sustain_thrust_time_limit_metadata = { "name" : "sustain_thrust_time_limit",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @sustain_thrust_time_limit.setter
    def sustain_thrust_time_limit(self, newVal:float) -> None:
        """The sustain thrust time limit for a thrust model set to Boost/Sustain Thrust mode."""
        return self._intf.set_property(IPropulsionThrust._metadata, IPropulsionThrust._set_sustain_thrust_time_limit_metadata, newVal)

    _get_min_airspeed_type_metadata = { "name" : "min_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def min_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The min airspeed type for a thrust model."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_min_airspeed_type_metadata)

    _get_min_airspeed_metadata = { "name" : "min_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_airspeed(self) -> float:
        """The min airspeed for a thrust model."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_min_airspeed_metadata)

    _set_min_airspeed_metadata = { "name" : "set_min_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_min_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the min airspeed type and value for a thrust model."""
        return self._intf.invoke(IPropulsionThrust._metadata, IPropulsionThrust._set_min_airspeed_metadata, airspeedType, airspeed)

    _get_max_airspeed_type_metadata = { "name" : "max_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def max_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The max airspeed type for a thrust model."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_max_airspeed_type_metadata)

    _get_max_airspeed_metadata = { "name" : "max_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_airspeed(self) -> float:
        """The max airspeed for a thrust model."""
        return self._intf.get_property(IPropulsionThrust._metadata, IPropulsionThrust._get_max_airspeed_metadata)

    _set_max_airspeed_metadata = { "name" : "set_max_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_max_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the max airspeed type and value for a thrust model."""
        return self._intf.invoke(IPropulsionThrust._metadata, IPropulsionThrust._set_max_airspeed_metadata, airspeedType, airspeed)


agcls.AgClassCatalog.add_catalog_entry("{fea63cff-6fa0-406e-ad12-8b17617cb34d}", IPropulsionThrust)
agcls.AgTypeNameMap["IPropulsionThrust"] = IPropulsionThrust

class IBasicManeuverAirspeedOptions(object):
    """Interface used to access airspeed options for basic maneuver strategies."""
    _num_methods = 35
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9c4162c8-e759-4bd7-abfa-05bf5dbe816c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_airspeed_mode" : 1,
                             "set_airspeed_mode" : 2,
                             "get_min_speed_limits" : 3,
                             "set_min_speed_limits" : 4,
                             "get_max_speed_limits" : 5,
                             "set_max_speed_limits" : 6,
                             "get_maintain_airspeed_type" : 7,
                             "set_maintain_airspeed_type" : 8,
                             "get_specified_airspeed_type" : 9,
                             "set_specified_airspeed_type" : 10,
                             "get_specified_accel_decel_mode" : 11,
                             "set_specified_accel_decel_mode" : 12,
                             "get_specified_airspeed" : 13,
                             "set_specified_airspeed" : 14,
                             "get_specified_accel_decel_g" : 15,
                             "set_specified_accel_decel_g" : 16,
                             "get_accel_g" : 17,
                             "set_accel_g" : 18,
                             "get_decel_g" : 19,
                             "set_decel_g" : 20,
                             "get_accel_mode" : 21,
                             "set_accel_mode" : 22,
                             "get_decel_mode" : 23,
                             "set_decel_mode" : 24,
                             "get_throttle" : 25,
                             "set_throttle" : 26,
                             "get_interpolate_init_g" : 27,
                             "set_interpolate_init_g" : 28,
                             "get_interpolate_end_g" : 29,
                             "set_interpolate_end_g" : 30,
                             "get_interpolate_end_time" : 31,
                             "set_interpolate_end_time" : 32,
                             "get_interpolate_stop_at_end_time" : 33,
                             "set_interpolate_stop_at_end_time" : 34,
                             "get_thrust" : 35, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverAirspeedOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverAirspeedOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverAirspeedOptions.__dict__ and type(IBasicManeuverAirspeedOptions.__dict__[attrname]) == property:
            return IBasicManeuverAirspeedOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverAirspeedOptions.")
    
    _get_airspeed_mode_metadata = { "name" : "airspeed_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_AIRSPEED_MODE),) }
    @property
    def airspeed_mode(self) -> "BASIC_MANEUVER_AIRSPEED_MODE":
        """The active airspeed mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_airspeed_mode_metadata)

    _set_airspeed_mode_metadata = { "name" : "airspeed_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_AIRSPEED_MODE),) }
    @airspeed_mode.setter
    def airspeed_mode(self, newVal:"BASIC_MANEUVER_AIRSPEED_MODE") -> None:
        """The active airspeed mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_airspeed_mode_metadata, newVal)

    _get_min_speed_limits_metadata = { "name" : "min_speed_limits",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS),) }
    @property
    def min_speed_limits(self) -> "BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS":
        """The minimum speed limit type to enforce."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_min_speed_limits_metadata)

    _set_min_speed_limits_metadata = { "name" : "min_speed_limits",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS),) }
    @min_speed_limits.setter
    def min_speed_limits(self, newVal:"BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS") -> None:
        """The minimum speed limit type to enforce."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_min_speed_limits_metadata, newVal)

    _get_max_speed_limits_metadata = { "name" : "max_speed_limits",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS),) }
    @property
    def max_speed_limits(self) -> "BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS":
        """The maximum speed limit type to enforce."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_max_speed_limits_metadata)

    _set_max_speed_limits_metadata = { "name" : "max_speed_limits",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS),) }
    @max_speed_limits.setter
    def max_speed_limits(self, newVal:"BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS") -> None:
        """The maximum speed limit type to enforce."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_max_speed_limits_metadata, newVal)

    _get_maintain_airspeed_type_metadata = { "name" : "maintain_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def maintain_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type option in the Maintain Current Airspeed mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_maintain_airspeed_type_metadata)

    _set_maintain_airspeed_type_metadata = { "name" : "maintain_airspeed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @maintain_airspeed_type.setter
    def maintain_airspeed_type(self, newVal:"AIRSPEED_TYPE") -> None:
        """The airspeed type option in the Maintain Current Airspeed mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_maintain_airspeed_type_metadata, newVal)

    _get_specified_airspeed_type_metadata = { "name" : "specified_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def specified_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type option in the Maintain Specified Airspeed mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_specified_airspeed_type_metadata)

    _set_specified_airspeed_type_metadata = { "name" : "specified_airspeed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @specified_airspeed_type.setter
    def specified_airspeed_type(self, newVal:"AIRSPEED_TYPE") -> None:
        """The airspeed type option in the Maintain Specified Airspeed mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_specified_airspeed_type_metadata, newVal)

    _get_specified_accel_decel_mode_metadata = { "name" : "specified_accel_decel_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def specified_accel_decel_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The accel/decel mode for the Maintain Specified Airspeed mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_specified_accel_decel_mode_metadata)

    _set_specified_accel_decel_mode_metadata = { "name" : "specified_accel_decel_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @specified_accel_decel_mode.setter
    def specified_accel_decel_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The accel/decel mode for the Maintain Specified Airspeed mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_specified_accel_decel_mode_metadata, newVal)

    _get_specified_airspeed_metadata = { "name" : "specified_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def specified_airspeed(self) -> float:
        """The airspeed for the Maintain Specified Airspeed mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_specified_airspeed_metadata)

    _set_specified_airspeed_metadata = { "name" : "specified_airspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @specified_airspeed.setter
    def specified_airspeed(self, newVal:float) -> None:
        """The airspeed for the Maintain Specified Airspeed mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_specified_airspeed_metadata, newVal)

    _get_specified_accel_decel_g_metadata = { "name" : "specified_accel_decel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def specified_accel_decel_g(self) -> float:
        """The accel/decel G for the Maintain Specified Airspeed mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_specified_accel_decel_g_metadata)

    _set_specified_accel_decel_g_metadata = { "name" : "specified_accel_decel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @specified_accel_decel_g.setter
    def specified_accel_decel_g(self, newVal:float) -> None:
        """The accel/decel G for the Maintain Specified Airspeed mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_specified_accel_decel_g_metadata, newVal)

    _get_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_g(self) -> float:
        """The accel G for the Accelerate at mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_accel_g_metadata)

    _set_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The accel G for the Accelerate at mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_accel_g_metadata, newVal)

    _get_decel_g_metadata = { "name" : "decel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def decel_g(self) -> float:
        """The decel G for the Decelerate at mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_decel_g_metadata)

    _set_decel_g_metadata = { "name" : "decel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @decel_g.setter
    def decel_g(self, newVal:float) -> None:
        """The decel G for the Decelerate at mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_decel_g_metadata, newVal)

    _get_accel_mode_metadata = { "name" : "accel_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def accel_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The accel mode for the Accelerate at mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_accel_mode_metadata)

    _set_accel_mode_metadata = { "name" : "accel_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @accel_mode.setter
    def accel_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The accel mode for the Accelerate at mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_accel_mode_metadata, newVal)

    _get_decel_mode_metadata = { "name" : "decel_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def decel_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The accel mode for the Decelerate at mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_decel_mode_metadata)

    _set_decel_mode_metadata = { "name" : "decel_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @decel_mode.setter
    def decel_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The accel mode for the Decelerate at mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_decel_mode_metadata, newVal)

    _get_throttle_metadata = { "name" : "throttle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def throttle(self) -> float:
        """The throttle setting for the Accel/Decel using Aero/Propulsion at mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_throttle_metadata)

    _set_throttle_metadata = { "name" : "throttle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @throttle.setter
    def throttle(self, newVal:float) -> None:
        """The throttle setting for the Accel/Decel using Aero/Propulsion at mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_throttle_metadata, newVal)

    _get_interpolate_init_g_metadata = { "name" : "interpolate_init_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def interpolate_init_g(self) -> float:
        """The initial G for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_interpolate_init_g_metadata)

    _set_interpolate_init_g_metadata = { "name" : "interpolate_init_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @interpolate_init_g.setter
    def interpolate_init_g(self, newVal:float) -> None:
        """The initial G for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_interpolate_init_g_metadata, newVal)

    _get_interpolate_end_g_metadata = { "name" : "interpolate_end_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def interpolate_end_g(self) -> float:
        """The end G for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_interpolate_end_g_metadata)

    _set_interpolate_end_g_metadata = { "name" : "interpolate_end_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @interpolate_end_g.setter
    def interpolate_end_g(self, newVal:float) -> None:
        """The end G for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_interpolate_end_g_metadata, newVal)

    _get_interpolate_end_time_metadata = { "name" : "interpolate_end_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def interpolate_end_time(self) -> float:
        """The end time for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_interpolate_end_time_metadata)

    _set_interpolate_end_time_metadata = { "name" : "interpolate_end_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @interpolate_end_time.setter
    def interpolate_end_time(self, newVal:float) -> None:
        """The end time for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_interpolate_end_time_metadata, newVal)

    _get_interpolate_stop_at_end_time_metadata = { "name" : "interpolate_stop_at_end_time",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def interpolate_stop_at_end_time(self) -> bool:
        """The option to stop at the end time for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_interpolate_stop_at_end_time_metadata)

    _set_interpolate_stop_at_end_time_metadata = { "name" : "interpolate_stop_at_end_time",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @interpolate_stop_at_end_time.setter
    def interpolate_stop_at_end_time(self, newVal:bool) -> None:
        """The option to stop at the end time for the Interpolate Accel/Decel over Interval mode."""
        return self._intf.set_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._set_interpolate_stop_at_end_time_metadata, newVal)

    _get_thrust_metadata = { "name" : "thrust",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def thrust(self) -> "PropulsionThrust":
        """Get the thrust options for the Specify Thrust mode."""
        return self._intf.get_property(IBasicManeuverAirspeedOptions._metadata, IBasicManeuverAirspeedOptions._get_thrust_metadata)


agcls.AgClassCatalog.add_catalog_entry("{9c4162c8-e759-4bd7-abfa-05bf5dbe816c}", IBasicManeuverAirspeedOptions)
agcls.AgTypeNameMap["IBasicManeuverAirspeedOptions"] = IBasicManeuverAirspeedOptions

class IBasicManeuverStrategyAileronRoll(object):
    """Interface used to access options for a Aileron Roll Strategy of a Basic Maneuver Procedure."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{75e11578-6c8f-4875-8b72-e678d80510d7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_flight_path_option" : 1,
                             "set_flight_path_option" : 2,
                             "get_active_mode" : 3,
                             "set_active_mode" : 4,
                             "get_active_turn_direction" : 5,
                             "set_active_turn_direction" : 6,
                             "get_active_angle" : 7,
                             "set_active_angle" : 8,
                             "get_roll_orientation" : 9,
                             "set_roll_orientation" : 10,
                             "get_roll_rate_mode" : 11,
                             "set_roll_rate_mode" : 12,
                             "get_override_roll_rate" : 13,
                             "set_override_roll_rate" : 14,
                             "get_airspeed_options" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyAileronRoll._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyAileronRoll from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyAileronRoll.__dict__ and type(IBasicManeuverStrategyAileronRoll.__dict__[attrname]) == property:
            return IBasicManeuverStrategyAileronRoll.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyAileronRoll.")
    
    _get_flight_path_option_metadata = { "name" : "flight_path_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AILERON_ROLL_FLIGHT_PATH),) }
    @property
    def flight_path_option(self) -> "AILERON_ROLL_FLIGHT_PATH":
        """The flight path option."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_flight_path_option_metadata)

    _set_flight_path_option_metadata = { "name" : "flight_path_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AILERON_ROLL_FLIGHT_PATH),) }
    @flight_path_option.setter
    def flight_path_option(self, newVal:"AILERON_ROLL_FLIGHT_PATH") -> None:
        """The flight path option."""
        return self._intf.set_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._set_flight_path_option_metadata, newVal)

    _get_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AILERON_ROLL_MODE),) }
    @property
    def active_mode(self) -> "AILERON_ROLL_MODE":
        """The aileron roll mode."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_active_mode_metadata)

    _set_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AILERON_ROLL_MODE),) }
    @active_mode.setter
    def active_mode(self, newVal:"AILERON_ROLL_MODE") -> None:
        """The aileron roll mode."""
        return self._intf.set_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._set_active_mode_metadata, newVal)

    _get_active_turn_direction_metadata = { "name" : "active_turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_LEFT_RIGHT),) }
    @property
    def active_turn_direction(self) -> "ROLL_LEFT_RIGHT":
        """The roll turn direction for the active roll mode."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_active_turn_direction_metadata)

    _set_active_turn_direction_metadata = { "name" : "active_turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_LEFT_RIGHT),) }
    @active_turn_direction.setter
    def active_turn_direction(self, newVal:"ROLL_LEFT_RIGHT") -> None:
        """The roll turn direction for the active roll mode."""
        return self._intf.set_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._set_active_turn_direction_metadata, newVal)

    _get_active_angle_metadata = { "name" : "active_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def active_angle(self) -> typing.Any:
        """The roll angle for the active roll mode."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_active_angle_metadata)

    _set_active_angle_metadata = { "name" : "active_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @active_angle.setter
    def active_angle(self, newVal:typing.Any) -> None:
        """The roll angle for the active roll mode."""
        return self._intf.set_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._set_active_angle_metadata, newVal)

    _get_roll_orientation_metadata = { "name" : "roll_orientation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_UPRIGHT_INVERTED),) }
    @property
    def roll_orientation(self) -> "ROLL_UPRIGHT_INVERTED":
        """The orientation to roll to for the roll to orientation mode."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_roll_orientation_metadata)

    _set_roll_orientation_metadata = { "name" : "roll_orientation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_UPRIGHT_INVERTED),) }
    @roll_orientation.setter
    def roll_orientation(self, newVal:"ROLL_UPRIGHT_INVERTED") -> None:
        """The orientation to roll to for the roll to orientation mode."""
        return self._intf.set_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._set_roll_orientation_metadata, newVal)

    _get_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def roll_rate_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The roll rate mode for the aileron roll."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_roll_rate_mode_metadata)

    _set_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for the aileron roll."""
        return self._intf.set_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._set_roll_rate_mode_metadata, newVal)

    _get_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value for the aileron roll turn. The roll rate mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_override_roll_rate_metadata)

    _set_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override value for the aileron roll turn. The roll rate mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._set_override_roll_rate_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyAileronRoll._metadata, IBasicManeuverStrategyAileronRoll._get_airspeed_options_metadata)


agcls.AgClassCatalog.add_catalog_entry("{75e11578-6c8f-4875-8b72-e678d80510d7}", IBasicManeuverStrategyAileronRoll)
agcls.AgTypeNameMap["IBasicManeuverStrategyAileronRoll"] = IBasicManeuverStrategyAileronRoll

class IBasicManeuverStrategyAutopilotNav(object):
    """Interface used to access options for the Autopilot - Horizontal Plane Strategy of a Basic Maneuver Procedure."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{80382b4b-412a-4c57-8685-7d88a0100cb6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_active_mode" : 1,
                             "set_active_mode" : 2,
                             "get_active_heading_course_value" : 3,
                             "set_active_heading_course_value" : 4,
                             "get_damping_ratio" : 5,
                             "set_damping_ratio" : 6,
                             "get_control_limit_mode" : 7,
                             "get_control_limit_turn_radius" : 8,
                             "get_control_limit_turn_rate" : 9,
                             "get_control_limit_horiz_accel" : 10,
                             "set_control_limit" : 11,
                             "get_compensate_for_coriolis_accel" : 12,
                             "set_compensate_for_coriolis_accel" : 13,
                             "get_stop_when_conditions_met" : 14,
                             "set_stop_when_conditions_met" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyAutopilotNav._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyAutopilotNav from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyAutopilotNav.__dict__ and type(IBasicManeuverStrategyAutopilotNav.__dict__[attrname]) == property:
            return IBasicManeuverStrategyAutopilotNav.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyAutopilotNav.")
    
    _get_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AUTOPILOT_HORIZ_PLANE_MODE),) }
    @property
    def active_mode(self) -> "AUTOPILOT_HORIZ_PLANE_MODE":
        """The autopilot - horizontal plane mode."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_active_mode_metadata)

    _set_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AUTOPILOT_HORIZ_PLANE_MODE),) }
    @active_mode.setter
    def active_mode(self, newVal:"AUTOPILOT_HORIZ_PLANE_MODE") -> None:
        """The autopilot - horizontal plane mode."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._set_active_mode_metadata, newVal)

    _get_active_heading_course_value_metadata = { "name" : "active_heading_course_value",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def active_heading_course_value(self) -> typing.Any:
        """The heading/course angle or rate for the active mode."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_active_heading_course_value_metadata)

    _set_active_heading_course_value_metadata = { "name" : "active_heading_course_value",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @active_heading_course_value.setter
    def active_heading_course_value(self, newVal:typing.Any) -> None:
        """The heading/course angle or rate for the active mode."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._set_active_heading_course_value_metadata, newVal)

    _get_damping_ratio_metadata = { "name" : "damping_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def damping_ratio(self) -> float:
        """The damping ratio of the control law."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_damping_ratio_metadata)

    _set_damping_ratio_metadata = { "name" : "damping_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @damping_ratio.setter
    def damping_ratio(self, newVal:float) -> None:
        """The damping ratio of the control law."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._set_damping_ratio_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT),) }
    @property
    def control_limit_mode(self) -> "BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_control_limit_mode_metadata)

    _get_control_limit_turn_radius_metadata = { "name" : "control_limit_turn_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_control_limit_turn_radius_metadata)

    _get_control_limit_turn_rate_metadata = { "name" : "control_limit_turn_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_control_limit_turn_rate_metadata)

    _get_control_limit_horiz_accel_metadata = { "name" : "control_limit_horiz_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_control_limit_horiz_accel_metadata)

    _set_control_limit_metadata = { "name" : "set_control_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT), agmarshall.DOUBLE_arg,) }
    def set_control_limit(self, controlLimitMode:"BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        return self._intf.invoke(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._set_control_limit_metadata, controlLimitMode, controlLimitValue)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_stop_when_conditions_met_metadata = { "name" : "stop_when_conditions_met",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_when_conditions_met(self) -> bool:
        """Stop when conditions are met"""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._get_stop_when_conditions_met_metadata)

    _set_stop_when_conditions_met_metadata = { "name" : "stop_when_conditions_met",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @stop_when_conditions_met.setter
    def stop_when_conditions_met(self, newVal:bool) -> None:
        """Stop when conditions are met"""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotNav._metadata, IBasicManeuverStrategyAutopilotNav._set_stop_when_conditions_met_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{80382b4b-412a-4c57-8685-7d88a0100cb6}", IBasicManeuverStrategyAutopilotNav)
agcls.AgTypeNameMap["IBasicManeuverStrategyAutopilotNav"] = IBasicManeuverStrategyAutopilotNav

class IBasicManeuverStrategyAutopilotProf(object):
    """Interface used to access options for the Autopilot - Vertical Plane Strategy of a Basic Maneuver Procedure."""
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{762406eb-338d-40c1-9ba5-44c38fb65456}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_mode" : 1,
                             "set_altitude_mode" : 2,
                             "get_absolute_altitude" : 3,
                             "set_absolute_altitude" : 4,
                             "get_relative_altitude_change" : 5,
                             "set_relative_altitude_change" : 6,
                             "get_altitude_rate" : 7,
                             "set_altitude_rate" : 8,
                             "get_fpa" : 9,
                             "set_fpa" : 10,
                             "get_altitude_control_mode" : 11,
                             "set_altitude_control_mode" : 12,
                             "get_control_altitude_rate_value" : 13,
                             "set_control_altitude_rate_value" : 14,
                             "get_control_fpa_value" : 15,
                             "set_control_fpa_value" : 16,
                             "get_control_limit_mode" : 17,
                             "set_control_limit_mode" : 18,
                             "get_max_pitch_rate" : 19,
                             "set_max_pitch_rate" : 20,
                             "get_fly_ballistic" : 21,
                             "set_fly_ballistic" : 22,
                             "get_damping_ratio" : 23,
                             "set_damping_ratio" : 24,
                             "get_airspeed_options" : 25,
                             "get_compensate_for_coriolis_accel" : 26,
                             "set_compensate_for_coriolis_accel" : 27,
                             "get_stop_when_conditions_met" : 28,
                             "set_stop_when_conditions_met" : 29, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyAutopilotProf._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyAutopilotProf from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyAutopilotProf.__dict__ and type(IBasicManeuverStrategyAutopilotProf.__dict__[attrname]) == property:
            return IBasicManeuverStrategyAutopilotProf.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyAutopilotProf.")
    
    _get_altitude_mode_metadata = { "name" : "altitude_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AUTOPILOT_ALTITUDE_MODE),) }
    @property
    def altitude_mode(self) -> "AUTOPILOT_ALTITUDE_MODE":
        """The altitude mode of the autopilot - vertical plane strategy."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_altitude_mode_metadata)

    _set_altitude_mode_metadata = { "name" : "altitude_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AUTOPILOT_ALTITUDE_MODE),) }
    @altitude_mode.setter
    def altitude_mode(self, newVal:"AUTOPILOT_ALTITUDE_MODE") -> None:
        """The altitude mode of the autopilot - vertical plane strategy."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_altitude_mode_metadata, newVal)

    _get_absolute_altitude_metadata = { "name" : "absolute_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def absolute_altitude(self) -> float:
        """The absolute altitude for the specify altitude mode."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_absolute_altitude_metadata)

    _set_absolute_altitude_metadata = { "name" : "absolute_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @absolute_altitude.setter
    def absolute_altitude(self, newVal:float) -> None:
        """The absolute altitude for the specify altitude mode."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_absolute_altitude_metadata, newVal)

    _get_relative_altitude_change_metadata = { "name" : "relative_altitude_change",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_altitude_change(self) -> float:
        """The relative altitude change for the specify altitude change mode."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_relative_altitude_change_metadata)

    _set_relative_altitude_change_metadata = { "name" : "relative_altitude_change",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_altitude_change.setter
    def relative_altitude_change(self, newVal:float) -> None:
        """The relative altitude change for the specify altitude change mode."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_relative_altitude_change_metadata, newVal)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """The altitude rate for the specify altitude rate mode."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_altitude_rate_metadata)

    _set_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The altitude rate for the specify altitude rate mode."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_altitude_rate_metadata, newVal)

    _get_fpa_metadata = { "name" : "fpa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def fpa(self) -> typing.Any:
        """The flight path angle for the specify wind frame flight path angle mode."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_fpa_metadata)

    _set_fpa_metadata = { "name" : "fpa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @fpa.setter
    def fpa(self, newVal:typing.Any) -> None:
        """The flight path angle for the specify wind frame flight path angle mode."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_fpa_metadata, newVal)

    _get_altitude_control_mode_metadata = { "name" : "altitude_control_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AUTOPILOT_ALTITUDE_CONTROL_MODE),) }
    @property
    def altitude_control_mode(self) -> "AUTOPILOT_ALTITUDE_CONTROL_MODE":
        """The altitude control mode for the hold initial altitude, specify altitude, and specify altitude change modes."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_altitude_control_mode_metadata)

    _set_altitude_control_mode_metadata = { "name" : "altitude_control_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AUTOPILOT_ALTITUDE_CONTROL_MODE),) }
    @altitude_control_mode.setter
    def altitude_control_mode(self, newVal:"AUTOPILOT_ALTITUDE_CONTROL_MODE") -> None:
        """The altitude control mode for the hold initial altitude, specify altitude, and specify altitude change modes."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_altitude_control_mode_metadata, newVal)

    _get_control_altitude_rate_value_metadata = { "name" : "control_altitude_rate_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_altitude_rate_value(self) -> float:
        """The altitude rate control value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_control_altitude_rate_value_metadata)

    _set_control_altitude_rate_value_metadata = { "name" : "control_altitude_rate_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @control_altitude_rate_value.setter
    def control_altitude_rate_value(self, newVal:float) -> None:
        """The altitude rate control value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_control_altitude_rate_value_metadata, newVal)

    _get_control_fpa_value_metadata = { "name" : "control_fpa_value",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_fpa_value(self) -> typing.Any:
        """The control flight path angle value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_control_fpa_value_metadata)

    _set_control_fpa_value_metadata = { "name" : "control_fpa_value",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @control_fpa_value.setter
    def control_fpa_value(self, newVal:typing.Any) -> None:
        """The control flight path angle value for the hold initial altitude, specify altitude, and specify altitude change modes."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_control_fpa_value_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def control_limit_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The control limits mode."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_control_limit_mode_metadata)

    _set_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @control_limit_mode.setter
    def control_limit_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The control limits mode."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_control_limit_mode_metadata, newVal)

    _get_max_pitch_rate_metadata = { "name" : "max_pitch_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_pitch_rate(self) -> typing.Any:
        """The max pitch rate for the control limits."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_max_pitch_rate_metadata)

    _set_max_pitch_rate_metadata = { "name" : "max_pitch_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_pitch_rate.setter
    def max_pitch_rate(self, newVal:typing.Any) -> None:
        """The max pitch rate for the control limits."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_max_pitch_rate_metadata, newVal)

    _get_fly_ballistic_metadata = { "name" : "fly_ballistic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def fly_ballistic(self) -> bool:
        """The option to fly a ballistic trajectory when the performance is insufficient."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_fly_ballistic_metadata)

    _set_fly_ballistic_metadata = { "name" : "fly_ballistic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @fly_ballistic.setter
    def fly_ballistic(self, newVal:bool) -> None:
        """The option to fly a ballistic trajectory when the performance is insufficient."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_fly_ballistic_metadata, newVal)

    _get_damping_ratio_metadata = { "name" : "damping_ratio",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def damping_ratio(self) -> float:
        """The damping ratio of the control law."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_damping_ratio_metadata)

    _set_damping_ratio_metadata = { "name" : "damping_ratio",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @damping_ratio.setter
    def damping_ratio(self, newVal:float) -> None:
        """The damping ratio of the control law."""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_damping_ratio_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_airspeed_options_metadata)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_stop_when_conditions_met_metadata = { "name" : "stop_when_conditions_met",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_when_conditions_met(self) -> bool:
        """Stop when conditions are met"""
        return self._intf.get_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._get_stop_when_conditions_met_metadata)

    _set_stop_when_conditions_met_metadata = { "name" : "stop_when_conditions_met",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @stop_when_conditions_met.setter
    def stop_when_conditions_met(self, newVal:bool) -> None:
        """Stop when conditions are met"""
        return self._intf.set_property(IBasicManeuverStrategyAutopilotProf._metadata, IBasicManeuverStrategyAutopilotProf._set_stop_when_conditions_met_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{762406eb-338d-40c1-9ba5-44c38fb65456}", IBasicManeuverStrategyAutopilotProf)
agcls.AgTypeNameMap["IBasicManeuverStrategyAutopilotProf"] = IBasicManeuverStrategyAutopilotProf

class IBasicManeuverStrategyBarrelRoll(object):
    """Interface used to access options for a Barrel Roll Strategy of a Basic Maneuver Procedure."""
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7709326e-8835-4118-bf07-714c5983ec58}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_helix_angle" : 1,
                             "set_helix_angle" : 2,
                             "get_helix_angle_mode" : 3,
                             "set_helix_angle_mode" : 4,
                             "get_top_load_factor" : 5,
                             "set_top_load_factor" : 6,
                             "get_bottom_load_factor" : 7,
                             "set_bottom_load_factor" : 8,
                             "get_torsion_angle" : 9,
                             "set_torsion_angle" : 10,
                             "get_hold_init_tas" : 11,
                             "set_hold_init_tas" : 12,
                             "get_airspeed_type" : 13,
                             "get_top_airspeed" : 14,
                             "get_bottom_airspeed" : 15,
                             "set_airspeeds" : 16, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyBarrelRoll._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyBarrelRoll from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyBarrelRoll.__dict__ and type(IBasicManeuverStrategyBarrelRoll.__dict__[attrname]) == property:
            return IBasicManeuverStrategyBarrelRoll.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyBarrelRoll.")
    
    _get_helix_angle_metadata = { "name" : "helix_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def helix_angle(self) -> typing.Any:
        """The helix angle for the barrel roll. The angle that the aircraft travels around the velocity vector."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_helix_angle_metadata)

    _set_helix_angle_metadata = { "name" : "helix_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @helix_angle.setter
    def helix_angle(self, newVal:typing.Any) -> None:
        """The helix angle for the barrel roll. The angle that the aircraft travels around the velocity vector."""
        return self._intf.set_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._set_helix_angle_metadata, newVal)

    _get_helix_angle_mode_metadata = { "name" : "helix_angle_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ANGLE_MODE),) }
    @property
    def helix_angle_mode(self) -> "ANGLE_MODE":
        """The helix angle mode for the barrel roll."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_helix_angle_mode_metadata)

    _set_helix_angle_mode_metadata = { "name" : "helix_angle_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ANGLE_MODE),) }
    @helix_angle_mode.setter
    def helix_angle_mode(self, newVal:"ANGLE_MODE") -> None:
        """The helix angle mode for the barrel roll."""
        return self._intf.set_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._set_helix_angle_mode_metadata, newVal)

    _get_top_load_factor_metadata = { "name" : "top_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def top_load_factor(self) -> float:
        """The load factor at the top of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_top_load_factor_metadata)

    _set_top_load_factor_metadata = { "name" : "top_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @top_load_factor.setter
    def top_load_factor(self, newVal:float) -> None:
        """The load factor at the top of the loop."""
        return self._intf.set_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._set_top_load_factor_metadata, newVal)

    _get_bottom_load_factor_metadata = { "name" : "bottom_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def bottom_load_factor(self) -> float:
        """The load factor at the bottom of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_bottom_load_factor_metadata)

    _set_bottom_load_factor_metadata = { "name" : "bottom_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @bottom_load_factor.setter
    def bottom_load_factor(self, newVal:float) -> None:
        """The load factor at the bottom of the loop."""
        return self._intf.set_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._set_bottom_load_factor_metadata, newVal)

    _get_torsion_angle_metadata = { "name" : "torsion_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def torsion_angle(self) -> typing.Any:
        """The torsion angle for the barrel roll. The angle of the turn from the aircraft's velocity vector."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_torsion_angle_metadata)

    _set_torsion_angle_metadata = { "name" : "torsion_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @torsion_angle.setter
    def torsion_angle(self, newVal:typing.Any) -> None:
        """The torsion angle for the barrel roll. The angle of the turn from the aircraft's velocity vector."""
        return self._intf.set_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._set_torsion_angle_metadata, newVal)

    _get_hold_init_tas_metadata = { "name" : "hold_init_tas",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def hold_init_tas(self) -> bool:
        """The option to hold the initial true airspeed."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_hold_init_tas_metadata)

    _set_hold_init_tas_metadata = { "name" : "hold_init_tas",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @hold_init_tas.setter
    def hold_init_tas(self, newVal:bool) -> None:
        """The option to hold the initial true airspeed."""
        return self._intf.set_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._set_hold_init_tas_metadata, newVal)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_airspeed_type_metadata)

    _get_top_airspeed_metadata = { "name" : "top_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def top_airspeed(self) -> float:
        """The speed at the top of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_top_airspeed_metadata)

    _get_bottom_airspeed_metadata = { "name" : "bottom_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def bottom_airspeed(self) -> float:
        """The speed at the bottom of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._get_bottom_airspeed_metadata)

    _set_airspeeds_metadata = { "name" : "set_airspeeds",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_airspeeds(self, airspeedType:"AIRSPEED_TYPE", topAirspeed:float, bottomAirspeed:float) -> None:
        """Set the speeds at the top and bottom of the loop."""
        return self._intf.invoke(IBasicManeuverStrategyBarrelRoll._metadata, IBasicManeuverStrategyBarrelRoll._set_airspeeds_metadata, airspeedType, topAirspeed, bottomAirspeed)


agcls.AgClassCatalog.add_catalog_entry("{7709326e-8835-4118-bf07-714c5983ec58}", IBasicManeuverStrategyBarrelRoll)
agcls.AgTypeNameMap["IBasicManeuverStrategyBarrelRoll"] = IBasicManeuverStrategyBarrelRoll

class IBasicManeuverStrategyLoop(object):
    """Interface used to access options for a Loop Strategy of a Basic Maneuver Procedure."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{812dd3a8-77ec-44eb-8a7d-e51b6e9e4942}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_loop_angle" : 1,
                             "set_loop_angle" : 2,
                             "get_loop_angle_mode" : 3,
                             "set_loop_angle_mode" : 4,
                             "get_top_load_factor" : 5,
                             "set_top_load_factor" : 6,
                             "get_bottom_load_factor" : 7,
                             "set_bottom_load_factor" : 8,
                             "get_hold_init_tas" : 9,
                             "set_hold_init_tas" : 10,
                             "get_airspeed_type" : 11,
                             "get_top_airspeed" : 12,
                             "get_bottom_airspeed" : 13,
                             "set_airspeeds" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyLoop._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyLoop from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyLoop.__dict__ and type(IBasicManeuverStrategyLoop.__dict__[attrname]) == property:
            return IBasicManeuverStrategyLoop.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyLoop.")
    
    _get_loop_angle_metadata = { "name" : "loop_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def loop_angle(self) -> typing.Any:
        """The loop angle for maneuver. The total change in pitch angle the aircraft flies."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_loop_angle_metadata)

    _set_loop_angle_metadata = { "name" : "loop_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @loop_angle.setter
    def loop_angle(self, newVal:typing.Any) -> None:
        """The loop angle for maneuver. The total change in pitch angle the aircraft flies."""
        return self._intf.set_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._set_loop_angle_metadata, newVal)

    _get_loop_angle_mode_metadata = { "name" : "loop_angle_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ANGLE_MODE),) }
    @property
    def loop_angle_mode(self) -> "ANGLE_MODE":
        """The loop angle mode for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_loop_angle_mode_metadata)

    _set_loop_angle_mode_metadata = { "name" : "loop_angle_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ANGLE_MODE),) }
    @loop_angle_mode.setter
    def loop_angle_mode(self, newVal:"ANGLE_MODE") -> None:
        """The loop angle mode for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._set_loop_angle_mode_metadata, newVal)

    _get_top_load_factor_metadata = { "name" : "top_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def top_load_factor(self) -> float:
        """The load factor at the top of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_top_load_factor_metadata)

    _set_top_load_factor_metadata = { "name" : "top_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @top_load_factor.setter
    def top_load_factor(self, newVal:float) -> None:
        """The load factor at the top of the loop."""
        return self._intf.set_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._set_top_load_factor_metadata, newVal)

    _get_bottom_load_factor_metadata = { "name" : "bottom_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def bottom_load_factor(self) -> float:
        """The load factor at the bottom of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_bottom_load_factor_metadata)

    _set_bottom_load_factor_metadata = { "name" : "bottom_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @bottom_load_factor.setter
    def bottom_load_factor(self, newVal:float) -> None:
        """The load factor at the bottom of the loop."""
        return self._intf.set_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._set_bottom_load_factor_metadata, newVal)

    _get_hold_init_tas_metadata = { "name" : "hold_init_tas",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def hold_init_tas(self) -> bool:
        """The option to hold the initial true airspeed."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_hold_init_tas_metadata)

    _set_hold_init_tas_metadata = { "name" : "hold_init_tas",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @hold_init_tas.setter
    def hold_init_tas(self, newVal:bool) -> None:
        """The option to hold the initial true airspeed."""
        return self._intf.set_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._set_hold_init_tas_metadata, newVal)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_airspeed_type_metadata)

    _get_top_airspeed_metadata = { "name" : "top_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def top_airspeed(self) -> float:
        """The speed at the top of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_top_airspeed_metadata)

    _get_bottom_airspeed_metadata = { "name" : "bottom_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def bottom_airspeed(self) -> float:
        """The speed at the bottom of the loop."""
        return self._intf.get_property(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._get_bottom_airspeed_metadata)

    _set_airspeeds_metadata = { "name" : "set_airspeeds",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_airspeeds(self, airspeedType:"AIRSPEED_TYPE", topAirspeed:float, bottomAirspeed:float) -> None:
        """Set the speeds at the top and bottom of the loop."""
        return self._intf.invoke(IBasicManeuverStrategyLoop._metadata, IBasicManeuverStrategyLoop._set_airspeeds_metadata, airspeedType, topAirspeed, bottomAirspeed)


agcls.AgClassCatalog.add_catalog_entry("{812dd3a8-77ec-44eb-8a7d-e51b6e9e4942}", IBasicManeuverStrategyLoop)
agcls.AgTypeNameMap["IBasicManeuverStrategyLoop"] = IBasicManeuverStrategyLoop

class IBasicManeuverStrategyLTAHover(object):
    """Interface used to access options for a Lighter than Air Hover Strategy of a Basic Maneuver Procedure."""
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d3684b67-cb9c-4b8a-a774-226363c4f090}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_heading_mode" : 1,
                             "set_heading_mode" : 2,
                             "get_relative_heading" : 3,
                             "set_relative_heading" : 4,
                             "get_absolute_heading" : 5,
                             "set_absolute_heading" : 6,
                             "get_use_magnetic_heading" : 7,
                             "set_use_magnetic_heading" : 8,
                             "get_heading_rate" : 9,
                             "set_heading_rate" : 10,
                             "get_altitude_mode" : 11,
                             "set_altitude_mode" : 12,
                             "get_absolute_altitude" : 13,
                             "set_absolute_altitude" : 14,
                             "get_relative_altitude_change" : 15,
                             "set_relative_altitude_change" : 16,
                             "get_control_altitude_rate" : 17,
                             "set_control_altitude_rate" : 18,
                             "get_altitude_rate" : 19,
                             "set_altitude_rate" : 20,
                             "get_parachute_area" : 21,
                             "set_parachute_area" : 22,
                             "get_parachute_cd" : 23,
                             "set_parachute_cd" : 24, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyLTAHover._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyLTAHover from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyLTAHover.__dict__ and type(IBasicManeuverStrategyLTAHover.__dict__[attrname]) == property:
            return IBasicManeuverStrategyLTAHover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyLTAHover.")
    
    _get_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOVER_HEADING_MODE),) }
    @property
    def heading_mode(self) -> "HOVER_HEADING_MODE":
        """The heading mode for the lighter than air hover."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_heading_mode_metadata)

    _set_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOVER_HEADING_MODE),) }
    @heading_mode.setter
    def heading_mode(self, newVal:"HOVER_HEADING_MODE") -> None:
        """The heading mode for the lighter than air hover."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_heading_mode_metadata, newVal)

    _get_relative_heading_metadata = { "name" : "relative_heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def relative_heading(self) -> typing.Any:
        """The relative heading for the relative to start heading mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_relative_heading_metadata)

    _set_relative_heading_metadata = { "name" : "relative_heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @relative_heading.setter
    def relative_heading(self, newVal:typing.Any) -> None:
        """The relative heading for the relative to start heading mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_relative_heading_metadata, newVal)

    _get_absolute_heading_metadata = { "name" : "absolute_heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def absolute_heading(self) -> typing.Any:
        """The absolute heading for the absolute heading mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_absolute_heading_metadata)

    _set_absolute_heading_metadata = { "name" : "absolute_heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @absolute_heading.setter
    def absolute_heading(self, newVal:typing.Any) -> None:
        """The absolute heading for the absolute heading mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_absolute_heading_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magentic heading for the absolute heading mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_use_magnetic_heading_metadata)

    _set_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magentic heading for the absolute heading mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_use_magnetic_heading_metadata, newVal)

    _get_heading_rate_metadata = { "name" : "heading_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_rate(self) -> typing.Any:
        """The maximum heading rate."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_heading_rate_metadata)

    _set_heading_rate_metadata = { "name" : "heading_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading_rate.setter
    def heading_rate(self, newVal:typing.Any) -> None:
        """The maximum heading rate."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_heading_rate_metadata, newVal)

    _get_altitude_mode_metadata = { "name" : "altitude_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOVER_ALTITUDE_MODE),) }
    @property
    def altitude_mode(self) -> "HOVER_ALTITUDE_MODE":
        """The altitude mode for the lighter than air hover."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_altitude_mode_metadata)

    _set_altitude_mode_metadata = { "name" : "altitude_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOVER_ALTITUDE_MODE),) }
    @altitude_mode.setter
    def altitude_mode(self, newVal:"HOVER_ALTITUDE_MODE") -> None:
        """The altitude mode for the lighter than air hover."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_altitude_mode_metadata, newVal)

    _get_absolute_altitude_metadata = { "name" : "absolute_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def absolute_altitude(self) -> float:
        """The absolute altitude for the Specify Altitude mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_absolute_altitude_metadata)

    _set_absolute_altitude_metadata = { "name" : "absolute_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @absolute_altitude.setter
    def absolute_altitude(self, newVal:float) -> None:
        """The absolute altitude for the Specify Altitude mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_absolute_altitude_metadata, newVal)

    _get_relative_altitude_change_metadata = { "name" : "relative_altitude_change",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_altitude_change(self) -> float:
        """The relative altitude change for the Specify Altitude Change mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_relative_altitude_change_metadata)

    _set_relative_altitude_change_metadata = { "name" : "relative_altitude_change",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_altitude_change.setter
    def relative_altitude_change(self, newVal:float) -> None:
        """The relative altitude change for the Specify Altitude Change mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_relative_altitude_change_metadata, newVal)

    _get_control_altitude_rate_metadata = { "name" : "control_altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_altitude_rate(self) -> float:
        """The controlled altitude rate for the Specify Altitude or Specify Altitude Change mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_control_altitude_rate_metadata)

    _set_control_altitude_rate_metadata = { "name" : "control_altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @control_altitude_rate.setter
    def control_altitude_rate(self, newVal:float) -> None:
        """The controlled altitude rate for the Specify Altitude or Specify Altitude Change mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_control_altitude_rate_metadata, newVal)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """The altitude rate for the Specify Altitude Rate mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_altitude_rate_metadata)

    _set_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The altitude rate for the Specify Altitude Rate mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_altitude_rate_metadata, newVal)

    _get_parachute_area_metadata = { "name" : "parachute_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def parachute_area(self) -> float:
        """The parachute area for the Parachute mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_parachute_area_metadata)

    _set_parachute_area_metadata = { "name" : "parachute_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @parachute_area.setter
    def parachute_area(self, newVal:float) -> None:
        """The parachute area for the Parachute mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_parachute_area_metadata, newVal)

    _get_parachute_cd_metadata = { "name" : "parachute_cd",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def parachute_cd(self) -> float:
        """The parachute drag coefficient for the Parachute mode."""
        return self._intf.get_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._get_parachute_cd_metadata)

    _set_parachute_cd_metadata = { "name" : "parachute_cd",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @parachute_cd.setter
    def parachute_cd(self, newVal:float) -> None:
        """The parachute drag coefficient for the Parachute mode."""
        return self._intf.set_property(IBasicManeuverStrategyLTAHover._metadata, IBasicManeuverStrategyLTAHover._set_parachute_cd_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{d3684b67-cb9c-4b8a-a774-226363c4f090}", IBasicManeuverStrategyLTAHover)
agcls.AgTypeNameMap["IBasicManeuverStrategyLTAHover"] = IBasicManeuverStrategyLTAHover

class IBasicManeuverStrategyFlyAOA(object):
    """Interface used to access options for a Fly AOA Strategy of a Basic Maneuver Procedure."""
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{aac777b5-967c-4e54-b09a-2ec30898fc53}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_turn_direction" : 1,
                             "set_turn_direction" : 2,
                             "get_roll_rate_mode" : 3,
                             "set_roll_rate_mode" : 4,
                             "get_override_roll_rate" : 5,
                             "set_override_roll_rate" : 6,
                             "get_roll_rate_dot" : 7,
                             "set_roll_rate_dot" : 8,
                             "get_control_roll_angle" : 9,
                             "set_control_roll_angle" : 10,
                             "get_roll_angle" : 11,
                             "set_roll_angle" : 12,
                             "get_stop_on_roll_angle" : 13,
                             "set_stop_on_roll_angle" : 14,
                             "get_aoa" : 15,
                             "set_aoa" : 16,
                             "get_airspeed_options" : 17, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyFlyAOA._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyFlyAOA from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyFlyAOA.__dict__ and type(IBasicManeuverStrategyFlyAOA.__dict__[attrname]) == property:
            return IBasicManeuverStrategyFlyAOA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyFlyAOA.")
    
    _get_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FLY_AOA_LEFT_RIGHT),) }
    @property
    def turn_direction(self) -> "FLY_AOA_LEFT_RIGHT":
        """The roll turn direction for a Fly AOA basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_turn_direction_metadata)

    _set_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FLY_AOA_LEFT_RIGHT),) }
    @turn_direction.setter
    def turn_direction(self, newVal:"FLY_AOA_LEFT_RIGHT") -> None:
        """The roll turn direction for a Fly AOA basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_turn_direction_metadata, newVal)

    _get_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def roll_rate_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The roll rate mode for a Fly AOA basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_roll_rate_mode_metadata)

    _set_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for a Fly AOA basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_roll_rate_mode_metadata, newVal)

    _get_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value for the Fly AOA basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_override_roll_rate_metadata)

    _set_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override value for the Fly AOA basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_override_roll_rate_metadata, newVal)

    _get_roll_rate_dot_metadata = { "name" : "roll_rate_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_rate_dot(self) -> typing.Any:
        """The rate of change of the roll rate."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_roll_rate_dot_metadata)

    _set_roll_rate_dot_metadata = { "name" : "roll_rate_dot",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_rate_dot.setter
    def roll_rate_dot(self, newVal:typing.Any) -> None:
        """The rate of change of the roll rate."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_roll_rate_dot_metadata, newVal)

    _get_control_roll_angle_metadata = { "name" : "control_roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def control_roll_angle(self) -> bool:
        """The option to define a goal value for the aircraft's roll angle."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_control_roll_angle_metadata)

    _set_control_roll_angle_metadata = { "name" : "control_roll_angle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @control_roll_angle.setter
    def control_roll_angle(self, newVal:bool) -> None:
        """The option to define a goal value for the aircraft's roll angle."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_control_roll_angle_metadata, newVal)

    _get_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_angle(self) -> typing.Any:
        """The goal value for the roll angle."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_roll_angle_metadata)

    _set_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The goal value for the roll angle."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_roll_angle_metadata, newVal)

    _get_stop_on_roll_angle_metadata = { "name" : "stop_on_roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_on_roll_angle(self) -> bool:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_stop_on_roll_angle_metadata)

    _set_stop_on_roll_angle_metadata = { "name" : "stop_on_roll_angle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @stop_on_roll_angle.setter
    def stop_on_roll_angle(self, newVal:bool) -> None:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_stop_on_roll_angle_metadata, newVal)

    _get_aoa_metadata = { "name" : "aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def aoa(self) -> typing.Any:
        """The angle of attack."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_aoa_metadata)

    _set_aoa_metadata = { "name" : "aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The angle of attack."""
        return self._intf.set_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._set_aoa_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyFlyAOA._metadata, IBasicManeuverStrategyFlyAOA._get_airspeed_options_metadata)


agcls.AgClassCatalog.add_catalog_entry("{aac777b5-967c-4e54-b09a-2ec30898fc53}", IBasicManeuverStrategyFlyAOA)
agcls.AgTypeNameMap["IBasicManeuverStrategyFlyAOA"] = IBasicManeuverStrategyFlyAOA

class IBasicManeuverStrategyPull(object):
    """Interface used to access options for a Pull Strategy of a Basic Maneuver Procedure."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{53ecb06b-3d2f-4e3b-b179-95686a71c7e1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_active_mode" : 1,
                             "set_active_mode" : 2,
                             "get_active_angle" : 3,
                             "set_active_angle" : 4,
                             "get_pull_g_mode" : 5,
                             "set_pull_g_mode" : 6,
                             "get_override_pull_g" : 7,
                             "set_override_pull_g" : 8,
                             "get_airspeed_options" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyPull._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyPull from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyPull.__dict__ and type(IBasicManeuverStrategyPull.__dict__[attrname]) == property:
            return IBasicManeuverStrategyPull.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyPull.")
    
    _get_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PULL_MODE),) }
    @property
    def active_mode(self) -> "PULL_MODE":
        """The pull mode for the pull basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._get_active_mode_metadata)

    _set_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PULL_MODE),) }
    @active_mode.setter
    def active_mode(self, newVal:"PULL_MODE") -> None:
        """The pull mode for the pull basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._set_active_mode_metadata, newVal)

    _get_active_angle_metadata = { "name" : "active_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def active_angle(self) -> typing.Any:
        """The pull angle for the active mode."""
        return self._intf.get_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._get_active_angle_metadata)

    _set_active_angle_metadata = { "name" : "active_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @active_angle.setter
    def active_angle(self, newVal:typing.Any) -> None:
        """The roll angle for the active mode."""
        return self._intf.set_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._set_active_angle_metadata, newVal)

    _get_pull_g_mode_metadata = { "name" : "pull_g_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def pull_g_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The pull G mode for a pull basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._get_pull_g_mode_metadata)

    _set_pull_g_mode_metadata = { "name" : "pull_g_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @pull_g_mode.setter
    def pull_g_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The pull G mode for a pull basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._set_pull_g_mode_metadata, newVal)

    _get_override_pull_g_metadata = { "name" : "override_pull_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_pull_g(self) -> float:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._get_override_pull_g_metadata)

    _set_override_pull_g_metadata = { "name" : "override_pull_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_pull_g.setter
    def override_pull_g(self, newVal:float) -> None:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._set_override_pull_g_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyPull._metadata, IBasicManeuverStrategyPull._get_airspeed_options_metadata)


agcls.AgClassCatalog.add_catalog_entry("{53ecb06b-3d2f-4e3b-b179-95686a71c7e1}", IBasicManeuverStrategyPull)
agcls.AgTypeNameMap["IBasicManeuverStrategyPull"] = IBasicManeuverStrategyPull

class IBasicManeuverStrategyRollingPull(object):
    """Interface used to access options for a Rolling Pull Strategy of a Basic Maneuver Procedure."""
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1481380c-fbad-46f2-bab0-8bba39fb3edc}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_active_mode" : 1,
                             "set_active_mode" : 2,
                             "get_turn_direction" : 3,
                             "set_turn_direction" : 4,
                             "get_angle" : 5,
                             "set_angle" : 6,
                             "get_roll_orientation" : 7,
                             "set_roll_orientation" : 8,
                             "get_roll_rate_mode" : 9,
                             "set_roll_rate_mode" : 10,
                             "get_override_roll_rate" : 11,
                             "set_override_roll_rate" : 12,
                             "get_pull_g_mode" : 13,
                             "set_pull_g_mode" : 14,
                             "get_override_pull_g" : 15,
                             "set_override_pull_g" : 16,
                             "get_airspeed_options" : 17, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyRollingPull._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRollingPull from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRollingPull.__dict__ and type(IBasicManeuverStrategyRollingPull.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRollingPull.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRollingPull.")
    
    _get_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ROLLING_PULL_MODE),) }
    @property
    def active_mode(self) -> "ROLLING_PULL_MODE":
        """The active mode for the rolling pull basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_active_mode_metadata)

    _set_active_mode_metadata = { "name" : "active_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ROLLING_PULL_MODE),) }
    @active_mode.setter
    def active_mode(self, newVal:"ROLLING_PULL_MODE") -> None:
        """The active mode for the rolling pull basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_active_mode_metadata, newVal)

    _get_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_LEFT_RIGHT),) }
    @property
    def turn_direction(self) -> "ROLL_LEFT_RIGHT":
        """The turn direction for the active mode."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_turn_direction_metadata)

    _set_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_LEFT_RIGHT),) }
    @turn_direction.setter
    def turn_direction(self, newVal:"ROLL_LEFT_RIGHT") -> None:
        """The turn direction for the active mode."""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_turn_direction_metadata, newVal)

    _get_angle_metadata = { "name" : "angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle(self) -> typing.Any:
        """The angle value for the active mode."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_angle_metadata)

    _set_angle_metadata = { "name" : "angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @angle.setter
    def angle(self, newVal:typing.Any) -> None:
        """The angle value for the active mode"""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_angle_metadata, newVal)

    _get_roll_orientation_metadata = { "name" : "roll_orientation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_UPRIGHT_INVERTED),) }
    @property
    def roll_orientation(self) -> "ROLL_UPRIGHT_INVERTED":
        """The orientation to roll to for the roll to orientation mode."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_roll_orientation_metadata)

    _set_roll_orientation_metadata = { "name" : "roll_orientation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ROLL_UPRIGHT_INVERTED),) }
    @roll_orientation.setter
    def roll_orientation(self, newVal:"ROLL_UPRIGHT_INVERTED") -> None:
        """The orientation to roll to for the roll to orientation mode."""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_roll_orientation_metadata, newVal)

    _get_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def roll_rate_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The roll rate mode for the rolling pull."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_roll_rate_mode_metadata)

    _set_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for the rolling pull."""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_roll_rate_mode_metadata, newVal)

    _get_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value. The roll rate mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_override_roll_rate_metadata)

    _set_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override. The roll rate mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_override_roll_rate_metadata, newVal)

    _get_pull_g_mode_metadata = { "name" : "pull_g_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def pull_g_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The pull G mode for a rolling pull."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_pull_g_mode_metadata)

    _set_pull_g_mode_metadata = { "name" : "pull_g_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @pull_g_mode.setter
    def pull_g_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The pull G mode for a rolling pull."""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_pull_g_mode_metadata, newVal)

    _get_override_pull_g_metadata = { "name" : "override_pull_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_pull_g(self) -> float:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_override_pull_g_metadata)

    _set_override_pull_g_metadata = { "name" : "override_pull_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_pull_g.setter
    def override_pull_g(self, newVal:float) -> None:
        """The pull G override value. The pull G mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._set_override_pull_g_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyRollingPull._metadata, IBasicManeuverStrategyRollingPull._get_airspeed_options_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1481380c-fbad-46f2-bab0-8bba39fb3edc}", IBasicManeuverStrategyRollingPull)
agcls.AgTypeNameMap["IBasicManeuverStrategyRollingPull"] = IBasicManeuverStrategyRollingPull

class IBasicManeuverStrategySmoothAccel(object):
    """Interface used to access options for a Smooth Accel Strategy of a Basic Maneuver Procedure."""
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b7dbc9ce-b749-4d60-bea1-d6f88415bc6e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_turn_direction" : 1,
                             "set_turn_direction" : 2,
                             "get_roll_rate_mode" : 3,
                             "set_roll_rate_mode" : 4,
                             "get_override_roll_rate" : 5,
                             "set_override_roll_rate" : 6,
                             "get_roll_rate_dot" : 7,
                             "set_roll_rate_dot" : 8,
                             "get_control_roll_angle" : 9,
                             "set_control_roll_angle" : 10,
                             "get_roll_angle" : 11,
                             "set_roll_angle" : 12,
                             "get_load_factor_mode" : 13,
                             "set_load_factor_mode" : 14,
                             "get_override_load_factor" : 15,
                             "set_override_load_factor" : 16,
                             "get_load_factor_dot" : 17,
                             "set_load_factor_dot" : 18,
                             "get_control_pitch_angle" : 19,
                             "set_control_pitch_angle" : 20,
                             "get_pitch_angle" : 21,
                             "set_pitch_angle" : 22,
                             "get_stop_conditions" : 23,
                             "set_stop_conditions" : 24,
                             "get_stop_on_roll_angle" : 25,
                             "set_stop_on_roll_angle" : 26,
                             "get_stop_on_pitch_angle" : 27,
                             "set_stop_on_pitch_angle" : 28,
                             "get_airspeed_options" : 29, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategySmoothAccel._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategySmoothAccel from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategySmoothAccel.__dict__ and type(IBasicManeuverStrategySmoothAccel.__dict__[attrname]) == property:
            return IBasicManeuverStrategySmoothAccel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategySmoothAccel.")
    
    _get_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_ACCEL_LEFT_RIGHT),) }
    @property
    def turn_direction(self) -> "SMOOTH_ACCEL_LEFT_RIGHT":
        """The roll turn direction for a Smooth Accel basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_turn_direction_metadata)

    _set_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_ACCEL_LEFT_RIGHT),) }
    @turn_direction.setter
    def turn_direction(self, newVal:"SMOOTH_ACCEL_LEFT_RIGHT") -> None:
        """The roll turn direction for a Smooth Accel  basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_turn_direction_metadata, newVal)

    _get_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def roll_rate_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The roll rate mode for a Smooth Accel basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_roll_rate_mode_metadata)

    _set_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for a Smooth Accel basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_roll_rate_mode_metadata, newVal)

    _get_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def override_roll_rate(self) -> typing.Any:
        """The roll rate override value for the Smooth Accel basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_override_roll_rate_metadata)

    _set_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The roll rate override value for the Smooth Accel basic maneuver strategy. The roll rate mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_override_roll_rate_metadata, newVal)

    _get_roll_rate_dot_metadata = { "name" : "roll_rate_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_rate_dot(self) -> typing.Any:
        """The rate of change of the roll rate."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_roll_rate_dot_metadata)

    _set_roll_rate_dot_metadata = { "name" : "roll_rate_dot",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_rate_dot.setter
    def roll_rate_dot(self, newVal:typing.Any) -> None:
        """The rate of change of the roll rate."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_roll_rate_dot_metadata, newVal)

    _get_control_roll_angle_metadata = { "name" : "control_roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def control_roll_angle(self) -> bool:
        """The option to define a goal value for the aircraft's roll angle."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_control_roll_angle_metadata)

    _set_control_roll_angle_metadata = { "name" : "control_roll_angle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @control_roll_angle.setter
    def control_roll_angle(self, newVal:bool) -> None:
        """The option to define a goal value for the aircraft's roll angle."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_control_roll_angle_metadata, newVal)

    _get_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_angle(self) -> typing.Any:
        """The goal value for the roll angle."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_roll_angle_metadata)

    _set_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The goal value for the roll angle."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_roll_angle_metadata, newVal)

    _get_load_factor_mode_metadata = { "name" : "load_factor_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def load_factor_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The load factor mode for the Smooth Accel basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_load_factor_mode_metadata)

    _set_load_factor_mode_metadata = { "name" : "load_factor_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @load_factor_mode.setter
    def load_factor_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The load factormode for the Smooth Accel basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_load_factor_mode_metadata, newVal)

    _get_override_load_factor_metadata = { "name" : "override_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_load_factor(self) -> float:
        """The load factor override value for the smooth accel. The load factor mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_override_load_factor_metadata)

    _set_override_load_factor_metadata = { "name" : "override_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_load_factor.setter
    def override_load_factor(self, newVal:float) -> None:
        """The load factor override value for the smooth accel. The load factor mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_override_load_factor_metadata, newVal)

    _get_load_factor_dot_metadata = { "name" : "load_factor_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def load_factor_dot(self) -> float:
        """The rate of change of the load factor."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_load_factor_dot_metadata)

    _set_load_factor_dot_metadata = { "name" : "load_factor_dot",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @load_factor_dot.setter
    def load_factor_dot(self, newVal:float) -> None:
        """The rate of change of the load factor."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_load_factor_dot_metadata, newVal)

    _get_control_pitch_angle_metadata = { "name" : "control_pitch_angle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def control_pitch_angle(self) -> bool:
        """The option to define a goal value for the aircraft's pitch angle."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_control_pitch_angle_metadata)

    _set_control_pitch_angle_metadata = { "name" : "control_pitch_angle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @control_pitch_angle.setter
    def control_pitch_angle(self, newVal:bool) -> None:
        """The option to define a goal value for the aircraft's pitch angle."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_control_pitch_angle_metadata, newVal)

    _get_pitch_angle_metadata = { "name" : "pitch_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def pitch_angle(self) -> typing.Any:
        """The goal value for the pitch angle."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_pitch_angle_metadata)

    _set_pitch_angle_metadata = { "name" : "pitch_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @pitch_angle.setter
    def pitch_angle(self, newVal:typing.Any) -> None:
        """The goal value for the pitch angle."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_pitch_angle_metadata, newVal)

    _get_stop_conditions_metadata = { "name" : "stop_conditions",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_ACCEL_STOP_CONDITIONS),) }
    @property
    def stop_conditions(self) -> "SMOOTH_ACCEL_STOP_CONDITIONS":
        """The stop condition for the Smooth Accel basic maneuver strategy."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_stop_conditions_metadata)

    _set_stop_conditions_metadata = { "name" : "stop_conditions",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_ACCEL_STOP_CONDITIONS),) }
    @stop_conditions.setter
    def stop_conditions(self, newVal:"SMOOTH_ACCEL_STOP_CONDITIONS") -> None:
        """The stop condition for the Smooth Accel  basic maneuver strategy."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_stop_conditions_metadata, newVal)

    _get_stop_on_roll_angle_metadata = { "name" : "stop_on_roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_on_roll_angle(self) -> bool:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_stop_on_roll_angle_metadata)

    _set_stop_on_roll_angle_metadata = { "name" : "stop_on_roll_angle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @stop_on_roll_angle.setter
    def stop_on_roll_angle(self, newVal:bool) -> None:
        """The option to stop the maneuver if the specified roll angle is achieved."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_stop_on_roll_angle_metadata, newVal)

    _get_stop_on_pitch_angle_metadata = { "name" : "stop_on_pitch_angle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_on_pitch_angle(self) -> bool:
        """The option to stop the maneuver if the specified pitch angle is achieved."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_stop_on_pitch_angle_metadata)

    _set_stop_on_pitch_angle_metadata = { "name" : "stop_on_pitch_angle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @stop_on_pitch_angle.setter
    def stop_on_pitch_angle(self, newVal:bool) -> None:
        """The option to stop the maneuver if the specified pitch angle is achieved."""
        return self._intf.set_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._set_stop_on_pitch_angle_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategySmoothAccel._metadata, IBasicManeuverStrategySmoothAccel._get_airspeed_options_metadata)


agcls.AgClassCatalog.add_catalog_entry("{b7dbc9ce-b749-4d60-bea1-d6f88415bc6e}", IBasicManeuverStrategySmoothAccel)
agcls.AgTypeNameMap["IBasicManeuverStrategySmoothAccel"] = IBasicManeuverStrategySmoothAccel

class IBasicManeuverStrategySmoothTurn(object):
    """Interface used to access options for a Smooth Turn Strategy of a Basic Maneuver Procedure."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{888b4f4a-ffe2-4c3b-a8b0-5cdd45e4adcd}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_heading_change" : 1,
                             "set_heading_change" : 2,
                             "get_turn_mode" : 3,
                             "set_turn_mode" : 4,
                             "get_load_factor_mode" : 5,
                             "set_load_factor_mode" : 6,
                             "get_max_load_factor_rate" : 7,
                             "set_max_load_factor_rate" : 8,
                             "get_override_load_factor" : 9,
                             "set_override_load_factor" : 10,
                             "get_roll_rate_mode" : 11,
                             "set_roll_rate_mode" : 12,
                             "get_roll_angle" : 13,
                             "set_roll_angle" : 14,
                             "get_override_roll_rate" : 15,
                             "set_override_roll_rate" : 16,
                             "get_airspeed_options" : 17,
                             "get_fpa_mode" : 18,
                             "set_fpa_mode" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategySmoothTurn._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategySmoothTurn from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategySmoothTurn.__dict__ and type(IBasicManeuverStrategySmoothTurn.__dict__[attrname]) == property:
            return IBasicManeuverStrategySmoothTurn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategySmoothTurn.")
    
    _get_heading_change_metadata = { "name" : "heading_change",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_change(self) -> typing.Any:
        """The heading change for the smooth turn."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_heading_change_metadata)

    _set_heading_change_metadata = { "name" : "heading_change",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading_change.setter
    def heading_change(self, newVal:typing.Any) -> None:
        """The heading change for the smooth turn."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_heading_change_metadata, newVal)

    _get_turn_mode_metadata = { "name" : "turn_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_TURN_MODE),) }
    @property
    def turn_mode(self) -> "SMOOTH_TURN_MODE":
        """The turn mode for the smooth turn."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_turn_mode_metadata)

    _set_turn_mode_metadata = { "name" : "turn_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_TURN_MODE),) }
    @turn_mode.setter
    def turn_mode(self, newVal:"SMOOTH_TURN_MODE") -> None:
        """The turn mode for the smooth turn."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_turn_mode_metadata, newVal)

    _get_load_factor_mode_metadata = { "name" : "load_factor_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def load_factor_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The load factor mode for the smooth turn."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_load_factor_mode_metadata)

    _set_load_factor_mode_metadata = { "name" : "load_factor_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @load_factor_mode.setter
    def load_factor_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The load factormode for the smooth turn."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_load_factor_mode_metadata, newVal)

    _get_max_load_factor_rate_metadata = { "name" : "max_load_factor_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_load_factor_rate(self) -> float:
        """The max load factor rate for the smooth turn."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_max_load_factor_rate_metadata)

    _set_max_load_factor_rate_metadata = { "name" : "max_load_factor_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_load_factor_rate.setter
    def max_load_factor_rate(self, newVal:float) -> None:
        """The max load factor rate for the smooth turn."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_max_load_factor_rate_metadata, newVal)

    _get_override_load_factor_metadata = { "name" : "override_load_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_load_factor(self) -> float:
        """The max load factor override value for the smooth turn. The load factor mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_override_load_factor_metadata)

    _set_override_load_factor_metadata = { "name" : "override_load_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_load_factor.setter
    def override_load_factor(self, newVal:float) -> None:
        """The max load factor override value for the smooth turn. The load factor mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_override_load_factor_metadata, newVal)

    _get_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @property
    def roll_rate_mode(self) -> "PERF_MODEL_OVERRIDE":
        """The roll rate mode for the smooth turn."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_roll_rate_mode_metadata)

    _set_roll_rate_mode_metadata = { "name" : "roll_rate_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PERF_MODEL_OVERRIDE),) }
    @roll_rate_mode.setter
    def roll_rate_mode(self, newVal:"PERF_MODEL_OVERRIDE") -> None:
        """The roll rate mode for the smooth turn."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_roll_rate_mode_metadata, newVal)

    _get_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_angle(self) -> typing.Any:
        """The roll angle for the smooth turn."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_roll_angle_metadata)

    _set_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The roll angle for the smooth turn."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_roll_angle_metadata, newVal)

    _get_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def override_roll_rate(self) -> typing.Any:
        """The max roll rate override value for the smooth turn. The roll rate mode must be set to override to access this property."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_override_roll_rate_metadata)

    _set_override_roll_rate_metadata = { "name" : "override_roll_rate",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @override_roll_rate.setter
    def override_roll_rate(self, newVal:typing.Any) -> None:
        """The max roll rate override value for the smooth turn. The roll rate mode must be set to override to access this property."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_override_roll_rate_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_airspeed_options_metadata)

    _get_fpa_mode_metadata = { "name" : "fpa_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_TURN_FPA_MODE),) }
    @property
    def fpa_mode(self) -> "SMOOTH_TURN_FPA_MODE":
        """The flight path angle mode."""
        return self._intf.get_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._get_fpa_mode_metadata)

    _set_fpa_mode_metadata = { "name" : "fpa_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(SMOOTH_TURN_FPA_MODE),) }
    @fpa_mode.setter
    def fpa_mode(self, newVal:"SMOOTH_TURN_FPA_MODE") -> None:
        """The flight path angle mode."""
        return self._intf.set_property(IBasicManeuverStrategySmoothTurn._metadata, IBasicManeuverStrategySmoothTurn._set_fpa_mode_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{888b4f4a-ffe2-4c3b-a8b0-5cdd45e4adcd}", IBasicManeuverStrategySmoothTurn)
agcls.AgTypeNameMap["IBasicManeuverStrategySmoothTurn"] = IBasicManeuverStrategySmoothTurn

class IBasicManeuverStrategySimpleTurn(object):
    """Interface used to access options for a Simple Turn Strategy of a Basic Maneuver Procedure."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3bae3110-3f6a-4c3d-914d-8592f3886f66}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_frame" : 1,
                             "set_reference_frame" : 2,
                             "get_turn_angle" : 3,
                             "set_turn_angle" : 4,
                             "get_turn_radius_factor" : 5,
                             "set_turn_radius_factor" : 6,
                             "get_compensate_for_coriolis_accel" : 7,
                             "set_compensate_for_coriolis_accel" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategySimpleTurn._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategySimpleTurn from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategySimpleTurn.__dict__ and type(IBasicManeuverStrategySimpleTurn.__dict__[attrname]) == property:
            return IBasicManeuverStrategySimpleTurn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategySimpleTurn.")
    
    _get_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @property
    def reference_frame(self) -> "BASIC_MANEUVER_REFERENCE_FRAME":
        """The reference frame for the simple turn."""
        return self._intf.get_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @reference_frame.setter
    def reference_frame(self, inVal:"BASIC_MANEUVER_REFERENCE_FRAME") -> None:
        """The reference frame for the simple turn."""
        return self._intf.set_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._set_reference_frame_metadata, inVal)

    _get_turn_angle_metadata = { "name" : "turn_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def turn_angle(self) -> typing.Any:
        """The turn angle for the simple turn."""
        return self._intf.get_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._get_turn_angle_metadata)

    _set_turn_angle_metadata = { "name" : "turn_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @turn_angle.setter
    def turn_angle(self, newVal:typing.Any) -> None:
        """The turn angle for the simple turn."""
        return self._intf.set_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._set_turn_angle_metadata, newVal)

    _get_turn_radius_factor_metadata = { "name" : "turn_radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turn_radius_factor(self) -> float:
        """The turn radius factor for the simple turn."""
        return self._intf.get_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._get_turn_radius_factor_metadata)

    _set_turn_radius_factor_metadata = { "name" : "turn_radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @turn_radius_factor.setter
    def turn_radius_factor(self, newVal:float) -> None:
        """The turn radius factor for the simple turn."""
        return self._intf.set_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._set_turn_radius_factor_metadata, newVal)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategySimpleTurn._metadata, IBasicManeuverStrategySimpleTurn._set_compensate_for_coriolis_accel_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{3bae3110-3f6a-4c3d-914d-8592f3886f66}", IBasicManeuverStrategySimpleTurn)
agcls.AgTypeNameMap["IBasicManeuverStrategySimpleTurn"] = IBasicManeuverStrategySimpleTurn

class IBasicManeuverStrategyIntercept(object):
    """Interface used to access options for an Intercept Strategy of a Basic Maneuver Procedure."""
    _num_methods = 34
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ab1da5c8-fd9b-49bc-adfd-69754a5376f5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_name" : 1,
                             "set_target_name" : 2,
                             "get_valid_target_names" : 3,
                             "get_target_resolution" : 4,
                             "set_target_resolution" : 5,
                             "get_use_stop_time_to_go" : 6,
                             "get_stop_time_to_go" : 7,
                             "set_stop_time_to_go" : 8,
                             "get_use_stop_slant_range" : 9,
                             "get_stop_slant_range" : 10,
                             "set_stop_slant_range" : 11,
                             "get_intercept_mode" : 12,
                             "set_intercept_mode" : 13,
                             "get_target_aspect" : 14,
                             "set_target_aspect" : 15,
                             "get_lateral_separation" : 16,
                             "set_lateral_separation" : 17,
                             "get_maneuver_factor" : 18,
                             "set_maneuver_factor" : 19,
                             "get_control_limit_mode" : 20,
                             "get_control_limit_turn_radius" : 21,
                             "get_control_limit_turn_rate" : 22,
                             "get_control_limit_horiz_accel" : 23,
                             "set_control_limit" : 24,
                             "get_closure_mode" : 25,
                             "set_closure_mode" : 26,
                             "get_hobs_max_angle" : 27,
                             "set_hobs_max_angle" : 28,
                             "get_hobs_angle_tol" : 29,
                             "set_hobs_angle_tol" : 30,
                             "get_compensate_for_coriolis_accel" : 31,
                             "set_compensate_for_coriolis_accel" : 32,
                             "get_position_vel_strategies" : 33,
                             "cancel_tgt_position_vel" : 34, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyIntercept._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyIntercept from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyIntercept.__dict__ and type(IBasicManeuverStrategyIntercept.__dict__[attrname]) == property:
            return IBasicManeuverStrategyIntercept.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyIntercept.")
    
    _get_target_name_metadata = { "name" : "target_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_name(self) -> str:
        """The target name."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_target_name_metadata)

    _set_target_name_metadata = { "name" : "target_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_target_name_metadata, newVal)

    _get_valid_target_names_metadata = { "name" : "valid_target_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_valid_target_names_metadata)

    _get_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_target_resolution_metadata)

    _set_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_target_resolution_metadata, newVal)

    _get_use_stop_time_to_go_metadata = { "name" : "use_stop_time_to_go",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_time_to_go(self) -> bool:
        """The option to specify a time to go stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_use_stop_time_to_go_metadata)

    _get_stop_time_to_go_metadata = { "name" : "stop_time_to_go",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_time_to_go(self) -> float:
        """The stop time from the target at which the maneuver will stop."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_stop_time_to_go_metadata)

    _set_stop_time_to_go_metadata = { "name" : "set_stop_time_to_go",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_stop_time_to_go(self, enable:bool, time:float) -> None:
        """Set the option to use the stop time from target stopping condition and set the according value."""
        return self._intf.invoke(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_stop_time_to_go_metadata, enable, time)

    _get_use_stop_slant_range_metadata = { "name" : "use_stop_slant_range",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_slant_range(self) -> bool:
        """The option to specify a range from target stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_use_stop_slant_range_metadata)

    _get_stop_slant_range_metadata = { "name" : "stop_slant_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_slant_range(self) -> float:
        """The range from the target at which the maneuver will stop."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_stop_slant_range_metadata)

    _set_stop_slant_range_metadata = { "name" : "set_stop_slant_range",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_stop_slant_range(self, enable:bool, range:float) -> None:
        """Set the option to use the stop slant range stopping condition and set the according value."""
        return self._intf.invoke(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_stop_slant_range_metadata, enable, range)

    _get_intercept_mode_metadata = { "name" : "intercept_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(INTERCEPT_MODE),) }
    @property
    def intercept_mode(self) -> "INTERCEPT_MODE":
        """The intercept mode."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_intercept_mode_metadata)

    _set_intercept_mode_metadata = { "name" : "intercept_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(INTERCEPT_MODE),) }
    @intercept_mode.setter
    def intercept_mode(self, newVal:"INTERCEPT_MODE") -> None:
        """The intercept mode."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_intercept_mode_metadata, newVal)

    _get_target_aspect_metadata = { "name" : "target_aspect",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def target_aspect(self) -> typing.Any:
        """The angle relative to the target that the aircraft should maintain until intercept."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_target_aspect_metadata)

    _set_target_aspect_metadata = { "name" : "target_aspect",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @target_aspect.setter
    def target_aspect(self, newVal:typing.Any) -> None:
        """The angle relative to the target that the aircraft should maintain until intercept."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_target_aspect_metadata, newVal)

    _get_lateral_separation_metadata = { "name" : "lateral_separation",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def lateral_separation(self) -> float:
        """The distance from the target that the aircraft will guide to before intercepting."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_lateral_separation_metadata)

    _set_lateral_separation_metadata = { "name" : "lateral_separation",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @lateral_separation.setter
    def lateral_separation(self, newVal:float) -> None:
        """The distance from the target that the aircraft will guide to before intercepting."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_lateral_separation_metadata, newVal)

    _get_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_maneuver_factor_metadata)

    _set_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_maneuver_factor_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT),) }
    @property
    def control_limit_mode(self) -> "BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_control_limit_mode_metadata)

    _get_control_limit_turn_radius_metadata = { "name" : "control_limit_turn_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_control_limit_turn_radius_metadata)

    _get_control_limit_turn_rate_metadata = { "name" : "control_limit_turn_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_control_limit_turn_rate_metadata)

    _get_control_limit_horiz_accel_metadata = { "name" : "control_limit_horiz_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_control_limit_horiz_accel_metadata)

    _set_control_limit_metadata = { "name" : "set_control_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT), agmarshall.DOUBLE_arg,) }
    def set_control_limit(self, controlLimitMode:"BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        return self._intf.invoke(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_control_limit_metadata, controlLimitMode, controlLimitValue)

    _get_closure_mode_metadata = { "name" : "closure_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CLOSURE_MODE),) }
    @property
    def closure_mode(self) -> "CLOSURE_MODE":
        """The closure mode for the guidance strategy."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_closure_mode_metadata)

    _set_closure_mode_metadata = { "name" : "closure_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CLOSURE_MODE),) }
    @closure_mode.setter
    def closure_mode(self, newVal:"CLOSURE_MODE") -> None:
        """The closure mode for the guidance strategy."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_closure_mode_metadata, newVal)

    _get_hobs_max_angle_metadata = { "name" : "hobs_max_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hobs_max_angle(self) -> typing.Any:
        """The closure high off boresight max angle."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_hobs_max_angle_metadata)

    _set_hobs_max_angle_metadata = { "name" : "hobs_max_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hobs_max_angle.setter
    def hobs_max_angle(self, newVal:typing.Any) -> None:
        """The closure high off boresight max angle."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_hobs_max_angle_metadata, newVal)

    _get_hobs_angle_tol_metadata = { "name" : "hobs_angle_tol",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hobs_angle_tol(self) -> typing.Any:
        """The closure high off boresight angle tolerance."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_hobs_angle_tol_metadata)

    _set_hobs_angle_tol_metadata = { "name" : "hobs_angle_tol",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hobs_angle_tol.setter
    def hobs_angle_tol(self, newVal:typing.Any) -> None:
        """The closure high off boresight angle tolerance."""
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_hobs_angle_tol_metadata, newVal)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_position_vel_strategies_metadata = { "name" : "position_vel_strategies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position_vel_strategies(self) -> "BasicManeuverTargetPositionVel":
        """The position velocity strategies for Intercept."""
        return self._intf.get_property(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._get_position_vel_strategies_metadata)

    _cancel_tgt_position_vel_metadata = { "name" : "cancel_tgt_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def cancel_tgt_position_vel(self) -> None:
        """Cancel the position velocity strategies for Intercept."""
        return self._intf.invoke(IBasicManeuverStrategyIntercept._metadata, IBasicManeuverStrategyIntercept._cancel_tgt_position_vel_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{ab1da5c8-fd9b-49bc-adfd-69754a5376f5}", IBasicManeuverStrategyIntercept)
agcls.AgTypeNameMap["IBasicManeuverStrategyIntercept"] = IBasicManeuverStrategyIntercept

class IBasicManeuverStrategyRelativeBearing(object):
    """Interface used to access options for a Relative Bearing Strategy of a Basic Maneuver Procedure."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2fefbc0f-5a8a-4388-9bb9-0376305315c8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_name" : 1,
                             "set_target_name" : 2,
                             "get_valid_target_names" : 3,
                             "get_target_resolution" : 4,
                             "set_target_resolution" : 5,
                             "get_rel_bearing" : 6,
                             "set_rel_bearing" : 7,
                             "get_min_range" : 8,
                             "set_min_range" : 9,
                             "get_control_limit_mode" : 10,
                             "get_control_limit_turn_radius" : 11,
                             "get_control_limit_turn_rate" : 12,
                             "get_control_limit_horiz_accel" : 13,
                             "set_control_limit" : 14,
                             "get_compensate_for_coriolis_accel" : 15,
                             "set_compensate_for_coriolis_accel" : 16,
                             "get_position_vel_strategies" : 17,
                             "cancel_tgt_position_vel" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyRelativeBearing._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelativeBearing from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelativeBearing.__dict__ and type(IBasicManeuverStrategyRelativeBearing.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelativeBearing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelativeBearing.")
    
    _get_target_name_metadata = { "name" : "target_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_name(self) -> str:
        """The target name."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_target_name_metadata)

    _set_target_name_metadata = { "name" : "target_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._set_target_name_metadata, newVal)

    _get_valid_target_names_metadata = { "name" : "valid_target_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_valid_target_names_metadata)

    _get_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_target_resolution_metadata)

    _set_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._set_target_resolution_metadata, newVal)

    _get_rel_bearing_metadata = { "name" : "rel_bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def rel_bearing(self) -> typing.Any:
        """The relative bearing angle."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_rel_bearing_metadata)

    _set_rel_bearing_metadata = { "name" : "rel_bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @rel_bearing.setter
    def rel_bearing(self, newVal:typing.Any) -> None:
        """The relative bearing angle."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._set_rel_bearing_metadata, newVal)

    _get_min_range_metadata = { "name" : "min_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_range(self) -> float:
        """The range from the target at which the aircraft will stop."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_min_range_metadata)

    _set_min_range_metadata = { "name" : "min_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_range.setter
    def min_range(self, newVal:float) -> None:
        """The range from the target at which the aircraft will stop."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._set_min_range_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT),) }
    @property
    def control_limit_mode(self) -> "BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_control_limit_mode_metadata)

    _get_control_limit_turn_radius_metadata = { "name" : "control_limit_turn_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_control_limit_turn_radius_metadata)

    _get_control_limit_turn_rate_metadata = { "name" : "control_limit_turn_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_control_limit_turn_rate_metadata)

    _get_control_limit_horiz_accel_metadata = { "name" : "control_limit_horiz_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_control_limit_horiz_accel_metadata)

    _set_control_limit_metadata = { "name" : "set_control_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT), agmarshall.DOUBLE_arg,) }
    def set_control_limit(self, controlLimitMode:"BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._set_control_limit_metadata, controlLimitMode, controlLimitValue)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_position_vel_strategies_metadata = { "name" : "position_vel_strategies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position_vel_strategies(self) -> "BasicManeuverTargetPositionVel":
        """The position velocity strategies for Relative Bearing."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._get_position_vel_strategies_metadata)

    _cancel_tgt_position_vel_metadata = { "name" : "cancel_tgt_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def cancel_tgt_position_vel(self) -> None:
        """Cancel the position velocity strategies for Relative Bearing."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeBearing._metadata, IBasicManeuverStrategyRelativeBearing._cancel_tgt_position_vel_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{2fefbc0f-5a8a-4388-9bb9-0376305315c8}", IBasicManeuverStrategyRelativeBearing)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelativeBearing"] = IBasicManeuverStrategyRelativeBearing

class IBasicManeuverStrategyRelativeCourse(object):
    """Interface used to access options for a Relative Course Strategy of a Basic Maneuver Procedure."""
    _num_methods = 34
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3b0436c1-b6c4-4623-aeeb-db55f1fce56f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_name" : 1,
                             "set_target_name" : 2,
                             "get_valid_target_names" : 3,
                             "get_target_resolution" : 4,
                             "set_target_resolution" : 5,
                             "get_use_relative_course" : 6,
                             "set_use_relative_course" : 7,
                             "get_course" : 8,
                             "set_course" : 9,
                             "get_in_track" : 10,
                             "set_in_track" : 11,
                             "get_cross_track" : 12,
                             "set_cross_track" : 13,
                             "get_maneuver_factor" : 14,
                             "set_maneuver_factor" : 15,
                             "get_use_approach_turn_mode" : 16,
                             "set_use_approach_turn_mode" : 17,
                             "get_control_limit_mode" : 18,
                             "get_control_limit_turn_radius" : 19,
                             "get_control_limit_turn_rate" : 20,
                             "get_control_limit_horiz_accel" : 21,
                             "set_control_limit" : 22,
                             "get_closure_mode" : 23,
                             "set_closure_mode" : 24,
                             "get_downrange_offset" : 25,
                             "set_downrange_offset" : 26,
                             "get_hobs_max_angle" : 27,
                             "set_hobs_max_angle" : 28,
                             "get_hobs_angle_tol" : 29,
                             "set_hobs_angle_tol" : 30,
                             "get_compensate_for_coriolis_accel" : 31,
                             "set_compensate_for_coriolis_accel" : 32,
                             "get_position_vel_strategies" : 33,
                             "cancel_tgt_position_vel" : 34, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyRelativeCourse._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelativeCourse from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelativeCourse.__dict__ and type(IBasicManeuverStrategyRelativeCourse.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelativeCourse.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelativeCourse.")
    
    _get_target_name_metadata = { "name" : "target_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_name(self) -> str:
        """The target name."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_target_name_metadata)

    _set_target_name_metadata = { "name" : "target_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_target_name_metadata, newVal)

    _get_valid_target_names_metadata = { "name" : "valid_target_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_valid_target_names_metadata)

    _get_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_target_resolution_metadata)

    _set_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_target_resolution_metadata, newVal)

    _get_use_relative_course_metadata = { "name" : "use_relative_course",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_relative_course(self) -> bool:
        """The option to specify a relative course as opposed to a true course."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_use_relative_course_metadata)

    _set_use_relative_course_metadata = { "name" : "use_relative_course",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_relative_course.setter
    def use_relative_course(self, newVal:bool) -> None:
        """The option to specify a relative course as opposed to a true course."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_use_relative_course_metadata, newVal)

    _get_course_metadata = { "name" : "course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course(self) -> typing.Any:
        """The course value."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_course_metadata)

    _set_course_metadata = { "name" : "course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The course value."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_course_metadata, newVal)

    _get_in_track_metadata = { "name" : "in_track",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def in_track(self) -> float:
        """The in track offset from the center of the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_in_track_metadata)

    _set_in_track_metadata = { "name" : "in_track",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @in_track.setter
    def in_track(self, newVal:float) -> None:
        """The in track offset from the center of the target."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_in_track_metadata, newVal)

    _get_cross_track_metadata = { "name" : "cross_track",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cross_track(self) -> float:
        """The cross track offset from the center of the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_cross_track_metadata)

    _set_cross_track_metadata = { "name" : "cross_track",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cross_track.setter
    def cross_track(self, newVal:float) -> None:
        """The cross track offset from the center of the target."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_cross_track_metadata, newVal)

    _get_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_maneuver_factor_metadata)

    _set_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_maneuver_factor_metadata, newVal)

    _get_use_approach_turn_mode_metadata = { "name" : "use_approach_turn_mode",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_approach_turn_mode(self) -> bool:
        """The option to fly the base leg of the maneuver with a constant radius turn."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_use_approach_turn_mode_metadata)

    _set_use_approach_turn_mode_metadata = { "name" : "use_approach_turn_mode",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_approach_turn_mode.setter
    def use_approach_turn_mode(self, newVal:bool) -> None:
        """The option to fly the base leg of the maneuver with a constant radius turn."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_use_approach_turn_mode_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT),) }
    @property
    def control_limit_mode(self) -> "BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_control_limit_mode_metadata)

    _get_control_limit_turn_radius_metadata = { "name" : "control_limit_turn_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_control_limit_turn_radius_metadata)

    _get_control_limit_turn_rate_metadata = { "name" : "control_limit_turn_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_control_limit_turn_rate_metadata)

    _get_control_limit_horiz_accel_metadata = { "name" : "control_limit_horiz_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_control_limit_horiz_accel_metadata)

    _set_control_limit_metadata = { "name" : "set_control_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT), agmarshall.DOUBLE_arg,) }
    def set_control_limit(self, controlLimitMode:"BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_control_limit_metadata, controlLimitMode, controlLimitValue)

    _get_closure_mode_metadata = { "name" : "closure_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CLOSURE_MODE),) }
    @property
    def closure_mode(self) -> "CLOSURE_MODE":
        """The closure mode for the guidance strategy."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_closure_mode_metadata)

    _set_closure_mode_metadata = { "name" : "closure_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CLOSURE_MODE),) }
    @closure_mode.setter
    def closure_mode(self, newVal:"CLOSURE_MODE") -> None:
        """The closure mode for the guidance strategy."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_closure_mode_metadata, newVal)

    _get_downrange_offset_metadata = { "name" : "downrange_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def downrange_offset(self) -> float:
        """The downrange offset for the closure options."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_downrange_offset_metadata)

    _set_downrange_offset_metadata = { "name" : "downrange_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @downrange_offset.setter
    def downrange_offset(self, newVal:float) -> None:
        """The downrange offset for the closure options."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_downrange_offset_metadata, newVal)

    _get_hobs_max_angle_metadata = { "name" : "hobs_max_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hobs_max_angle(self) -> typing.Any:
        """The closure high off boresight max angle."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_hobs_max_angle_metadata)

    _set_hobs_max_angle_metadata = { "name" : "hobs_max_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hobs_max_angle.setter
    def hobs_max_angle(self, newVal:typing.Any) -> None:
        """The closure high off boresight max angle."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_hobs_max_angle_metadata, newVal)

    _get_hobs_angle_tol_metadata = { "name" : "hobs_angle_tol",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hobs_angle_tol(self) -> typing.Any:
        """The closure high off boresight angle tolerance."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_hobs_angle_tol_metadata)

    _set_hobs_angle_tol_metadata = { "name" : "hobs_angle_tol",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hobs_angle_tol.setter
    def hobs_angle_tol(self, newVal:typing.Any) -> None:
        """The closure high off boresight angle tolerance."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_hobs_angle_tol_metadata, newVal)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_position_vel_strategies_metadata = { "name" : "position_vel_strategies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position_vel_strategies(self) -> "BasicManeuverTargetPositionVel":
        """The position velocity strategies for Relative Course."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._get_position_vel_strategies_metadata)

    _cancel_tgt_position_vel_metadata = { "name" : "cancel_tgt_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def cancel_tgt_position_vel(self) -> None:
        """Cancel the position velocity strategies for Relative Course."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeCourse._metadata, IBasicManeuverStrategyRelativeCourse._cancel_tgt_position_vel_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{3b0436c1-b6c4-4623-aeeb-db55f1fce56f}", IBasicManeuverStrategyRelativeCourse)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelativeCourse"] = IBasicManeuverStrategyRelativeCourse

class IBasicManeuverStrategyRendezvous(object):
    """Interface used to access options for a Rendezvous Formation Strategy of a Basic Maneuver Procedure."""
    _num_methods = 39
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{49b4a1d7-e2dd-4956-892e-e3d042b5c3ae}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_name" : 1,
                             "set_target_name" : 2,
                             "get_valid_target_names" : 3,
                             "get_target_resolution" : 4,
                             "set_target_resolution" : 5,
                             "get_use_counter_turn_logic" : 6,
                             "set_use_counter_turn_logic" : 7,
                             "get_enable_collision_avoidance" : 8,
                             "get_cpa" : 9,
                             "set_cpa" : 10,
                             "get_relative_bearing" : 11,
                             "set_relative_bearing" : 12,
                             "get_relative_range" : 13,
                             "set_relative_range" : 14,
                             "get_altitude_split" : 15,
                             "set_altitude_split" : 16,
                             "get_maneuver_factor" : 17,
                             "set_maneuver_factor" : 18,
                             "get_use_perf_model_limits" : 19,
                             "set_use_perf_model_limits" : 20,
                             "get_altitude_rate_control" : 21,
                             "set_altitude_rate_control" : 22,
                             "get_min_load_factor_g" : 23,
                             "set_min_load_factor_g" : 24,
                             "get_max_load_factor_g" : 25,
                             "set_max_load_factor_g" : 26,
                             "get_max_speed_advantage" : 27,
                             "set_max_speed_advantage" : 28,
                             "get_airspeed_control_mode" : 29,
                             "set_airspeed_control_mode" : 30,
                             "get_accel_decel_g" : 31,
                             "set_accel_decel_g" : 32,
                             "get_use_separate_airspeed_control" : 33,
                             "get_airspeed_factor" : 34,
                             "set_airspeed_factor" : 35,
                             "get_stop_condition" : 36,
                             "set_stop_condition" : 37,
                             "get_position_vel_strategies" : 38,
                             "cancel_tgt_position_vel" : 39, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyRendezvous._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRendezvous from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRendezvous.__dict__ and type(IBasicManeuverStrategyRendezvous.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRendezvous.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRendezvous.")
    
    _get_target_name_metadata = { "name" : "target_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_name(self) -> str:
        """The target name."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_target_name_metadata)

    _set_target_name_metadata = { "name" : "target_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_target_name_metadata, newVal)

    _get_valid_target_names_metadata = { "name" : "valid_target_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_valid_target_names_metadata)

    _get_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_target_resolution_metadata)

    _set_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_target_resolution_metadata, newVal)

    _get_use_counter_turn_logic_metadata = { "name" : "use_counter_turn_logic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_counter_turn_logic(self) -> bool:
        """The option to improve performance when flying with a target on a straight and level flight path."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_use_counter_turn_logic_metadata)

    _set_use_counter_turn_logic_metadata = { "name" : "use_counter_turn_logic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_counter_turn_logic.setter
    def use_counter_turn_logic(self, newVal:bool) -> None:
        """The option to improve performance when flying with a target on a straight and level flight path."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_use_counter_turn_logic_metadata, newVal)

    _get_enable_collision_avoidance_metadata = { "name" : "enable_collision_avoidance",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def enable_collision_avoidance(self) -> bool:
        """The option to enable collision avoidance."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_enable_collision_avoidance_metadata)

    _get_cpa_metadata = { "name" : "cpa",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cpa(self) -> float:
        """The minimum distance between this aircraft and the target aircraft."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_cpa_metadata)

    _set_cpa_metadata = { "name" : "set_cpa",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_cpa(self, enable:bool, cPA:float) -> None:
        """Set whether to enable collision avoidance and the corresponding minimum distance between this aircraft and the target aircraft."""
        return self._intf.invoke(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_cpa_metadata, enable, cPA)

    _get_relative_bearing_metadata = { "name" : "relative_bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def relative_bearing(self) -> typing.Any:
        """The bearing relative to the target the aircraft will achieve and maintain."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_relative_bearing_metadata)

    _set_relative_bearing_metadata = { "name" : "relative_bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @relative_bearing.setter
    def relative_bearing(self, newVal:typing.Any) -> None:
        """The bearing relative to the target the aircraft will achieve and maintain."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_relative_bearing_metadata, newVal)

    _get_relative_range_metadata = { "name" : "relative_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_range(self) -> float:
        """The range to the target the aircraft will achieve and maintain."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_relative_range_metadata)

    _set_relative_range_metadata = { "name" : "relative_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_range.setter
    def relative_range(self, newVal:float) -> None:
        """The range to the target the aircraft will achieve and maintain."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_relative_range_metadata, newVal)

    _get_altitude_split_metadata = { "name" : "altitude_split",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_split(self) -> float:
        """The altitude difference between the aircraft and target."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_altitude_split_metadata)

    _set_altitude_split_metadata = { "name" : "altitude_split",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_split.setter
    def altitude_split(self, newVal:float) -> None:
        """The altitude difference between the aircraft and target."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_altitude_split_metadata, newVal)

    _get_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_maneuver_factor_metadata)

    _set_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_maneuver_factor_metadata, newVal)

    _get_use_perf_model_limits_metadata = { "name" : "use_perf_model_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_perf_model_limits(self) -> bool:
        """The option to derive the control limits of the aircraft from the applicable performance model."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_use_perf_model_limits_metadata)

    _set_use_perf_model_limits_metadata = { "name" : "use_perf_model_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_perf_model_limits.setter
    def use_perf_model_limits(self, newVal:bool) -> None:
        """The option to derive the control limits of the aircraft from the applicable performance model."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_use_perf_model_limits_metadata, newVal)

    _get_altitude_rate_control_metadata = { "name" : "altitude_rate_control",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate_control(self) -> float:
        """The rate at which the aircraft will change altitude to achieve or maintain the ALtitude Split."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_altitude_rate_control_metadata)

    _set_altitude_rate_control_metadata = { "name" : "altitude_rate_control",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate_control.setter
    def altitude_rate_control(self, newVal:float) -> None:
        """The rate at which the aircraft will change altitude to achieve or maintain the ALtitude Split."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_altitude_rate_control_metadata, newVal)

    _get_min_load_factor_g_metadata = { "name" : "min_load_factor_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_load_factor_g(self) -> float:
        """The minimum load factor the aircraft can bear while maneuvering in formation."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_min_load_factor_g_metadata)

    _set_min_load_factor_g_metadata = { "name" : "min_load_factor_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_load_factor_g.setter
    def min_load_factor_g(self, newVal:float) -> None:
        """The minimum load factor the aircraft can bear while maneuvering in formation."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_min_load_factor_g_metadata, newVal)

    _get_max_load_factor_g_metadata = { "name" : "max_load_factor_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_load_factor_g(self) -> float:
        """The maximum load factor the aircraft can bear while maneuvering in formation."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_max_load_factor_g_metadata)

    _set_max_load_factor_g_metadata = { "name" : "max_load_factor_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_load_factor_g.setter
    def max_load_factor_g(self, newVal:float) -> None:
        """The maximum load factor the aircraft can bear while maneuvering in formation."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_max_load_factor_g_metadata, newVal)

    _get_max_speed_advantage_metadata = { "name" : "max_speed_advantage",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_speed_advantage(self) -> float:
        """The limit to the airspeed difference between the aircraft and target."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_max_speed_advantage_metadata)

    _set_max_speed_advantage_metadata = { "name" : "max_speed_advantage",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_speed_advantage.setter
    def max_speed_advantage(self, newVal:float) -> None:
        """The limit to the airspeed difference between the aircraft and target."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_max_speed_advantage_metadata, newVal)

    _get_airspeed_control_mode_metadata = { "name" : "airspeed_control_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_PERF_MODEL_OVERRIDE),) }
    @property
    def airspeed_control_mode(self) -> "ACCEL_PERF_MODEL_OVERRIDE":
        """The method to define the aircraft's acceleration performance in formation."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_airspeed_control_mode_metadata)

    _set_airspeed_control_mode_metadata = { "name" : "airspeed_control_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_PERF_MODEL_OVERRIDE),) }
    @airspeed_control_mode.setter
    def airspeed_control_mode(self, newVal:"ACCEL_PERF_MODEL_OVERRIDE") -> None:
        """The method to define the aircraft's acceleration performance in formation."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_airspeed_control_mode_metadata, newVal)

    _get_accel_decel_g_metadata = { "name" : "accel_decel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_decel_g(self) -> float:
        """The aircraft's specified acceleration rate for an airspeed control mode set to override."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_accel_decel_g_metadata)

    _set_accel_decel_g_metadata = { "name" : "accel_decel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_decel_g.setter
    def accel_decel_g(self, newVal:float) -> None:
        """The aircraft's specified acceleration rate for an airspeed control mode set to override."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_accel_decel_g_metadata, newVal)

    _get_use_separate_airspeed_control_metadata = { "name" : "use_separate_airspeed_control",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_separate_airspeed_control(self) -> bool:
        """The option to control how fine the control is over the airspeed adjustments in formation flight."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_use_separate_airspeed_control_metadata)

    _get_airspeed_factor_metadata = { "name" : "airspeed_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed_factor(self) -> float:
        """A dimensionless factor defining how fine the control is over airspeed adjustments in formation flight."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_airspeed_factor_metadata)

    _set_airspeed_factor_metadata = { "name" : "set_airspeed_factor",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_airspeed_factor(self, enable:bool, airspeedFactor:float) -> None:
        """Set whether to enable the option to control how fine the control is and the corresponding dimensionless factor."""
        return self._intf.invoke(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_airspeed_factor_metadata, enable, airspeedFactor)

    _get_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(RENDEZVOUS_STOP_CONDITION),) }
    @property
    def stop_condition(self) -> "RENDEZVOUS_STOP_CONDITION":
        """The stopping condition for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_stop_condition_metadata)

    _set_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(RENDEZVOUS_STOP_CONDITION),) }
    @stop_condition.setter
    def stop_condition(self, newVal:"RENDEZVOUS_STOP_CONDITION") -> None:
        """The stopping condition for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._set_stop_condition_metadata, newVal)

    _get_position_vel_strategies_metadata = { "name" : "position_vel_strategies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position_vel_strategies(self) -> "BasicManeuverTargetPositionVel":
        """The position velocity strategies for Rendezvous."""
        return self._intf.get_property(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._get_position_vel_strategies_metadata)

    _cancel_tgt_position_vel_metadata = { "name" : "cancel_tgt_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def cancel_tgt_position_vel(self) -> None:
        """Cancel the position velocity strategies for Rendezvous."""
        return self._intf.invoke(IBasicManeuverStrategyRendezvous._metadata, IBasicManeuverStrategyRendezvous._cancel_tgt_position_vel_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{49b4a1d7-e2dd-4956-892e-e3d042b5c3ae}", IBasicManeuverStrategyRendezvous)
agcls.AgTypeNameMap["IBasicManeuverStrategyRendezvous"] = IBasicManeuverStrategyRendezvous

class IBasicManeuverStrategyStationkeeping(object):
    """Interface used to access options for a Stationkeeping Strategy of a Basic Maneuver Procedure."""
    _num_methods = 38
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b6ab25a8-fcef-49c4-a804-c55471f61f76}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_name" : 1,
                             "set_target_name" : 2,
                             "get_valid_target_names" : 3,
                             "get_target_resolution" : 4,
                             "set_target_resolution" : 5,
                             "get_max_target_speed_fraction" : 6,
                             "set_max_target_speed_fraction" : 7,
                             "get_rel_bearing" : 8,
                             "set_rel_bearing" : 9,
                             "get_rel_range" : 10,
                             "set_rel_range" : 11,
                             "get_desired_radius" : 12,
                             "set_desired_radius" : 13,
                             "get_turn_direction" : 14,
                             "set_turn_direction" : 15,
                             "get_maneuver_factor" : 16,
                             "set_maneuver_factor" : 17,
                             "get_stop_condition" : 18,
                             "set_stop_condition" : 19,
                             "get_use_relative_course" : 20,
                             "set_use_relative_course" : 21,
                             "get_stop_course" : 22,
                             "set_stop_course" : 23,
                             "get_stop_after_turn_count" : 24,
                             "set_stop_after_turn_count" : 25,
                             "get_stop_after_duration" : 26,
                             "set_stop_after_duration" : 27,
                             "get_stop_after_time" : 28,
                             "set_stop_after_time" : 29,
                             "get_control_limit_mode" : 30,
                             "get_control_limit_turn_radius" : 31,
                             "get_control_limit_turn_rate" : 32,
                             "get_control_limit_horiz_accel" : 33,
                             "set_control_limit" : 34,
                             "get_compensate_for_coriolis_accel" : 35,
                             "set_compensate_for_coriolis_accel" : 36,
                             "get_position_vel_strategies" : 37,
                             "cancel_tgt_position_vel" : 38, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyStationkeeping._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyStationkeeping from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyStationkeeping.__dict__ and type(IBasicManeuverStrategyStationkeeping.__dict__[attrname]) == property:
            return IBasicManeuverStrategyStationkeeping.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyStationkeeping.")
    
    _get_target_name_metadata = { "name" : "target_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_name(self) -> str:
        """The target name."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_target_name_metadata)

    _set_target_name_metadata = { "name" : "target_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_target_name_metadata, newVal)

    _get_valid_target_names_metadata = { "name" : "valid_target_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_valid_target_names_metadata)

    _get_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_target_resolution_metadata)

    _set_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_target_resolution_metadata, newVal)

    _get_max_target_speed_fraction_metadata = { "name" : "max_target_speed_fraction",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_target_speed_fraction(self) -> float:
        """The maximum speed relative to the target."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_max_target_speed_fraction_metadata)

    _set_max_target_speed_fraction_metadata = { "name" : "max_target_speed_fraction",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_target_speed_fraction.setter
    def max_target_speed_fraction(self, newVal:float) -> None:
        """The maximum speed relative to the target."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_max_target_speed_fraction_metadata, newVal)

    _get_rel_bearing_metadata = { "name" : "rel_bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def rel_bearing(self) -> typing.Any:
        """The bearing relative to the target that the aircraft will hold."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_rel_bearing_metadata)

    _set_rel_bearing_metadata = { "name" : "rel_bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @rel_bearing.setter
    def rel_bearing(self, newVal:typing.Any) -> None:
        """The bearing relative to the target that the aircraft will hold."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_rel_bearing_metadata, newVal)

    _get_rel_range_metadata = { "name" : "rel_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def rel_range(self) -> float:
        """The range from the target where the aircraft will hold."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_rel_range_metadata)

    _set_rel_range_metadata = { "name" : "rel_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @rel_range.setter
    def rel_range(self, newVal:float) -> None:
        """The range from the target where the aircraft will hold."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_rel_range_metadata, newVal)

    _get_desired_radius_metadata = { "name" : "desired_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def desired_radius(self) -> float:
        """The goal radius of the holding circle."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_desired_radius_metadata)

    _set_desired_radius_metadata = { "name" : "desired_radius",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @desired_radius.setter
    def desired_radius(self, newVal:float) -> None:
        """The goal radius of the holding circle."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_desired_radius_metadata, newVal)

    _get_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TURN_DIRECTION),) }
    @property
    def turn_direction(self) -> "TURN_DIRECTION":
        """Define if the aircraft turns left or right into the holding circle."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_turn_direction_metadata)

    _set_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TURN_DIRECTION),) }
    @turn_direction.setter
    def turn_direction(self, newVal:"TURN_DIRECTION") -> None:
        """Define if the aircraft turns left or right into the holding circle."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_turn_direction_metadata, newVal)

    _get_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_maneuver_factor_metadata)

    _set_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_maneuver_factor_metadata, newVal)

    _get_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(STATIONKEEPING_STOP_CONDITION),) }
    @property
    def stop_condition(self) -> "STATIONKEEPING_STOP_CONDITION":
        """The stopping condition for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_stop_condition_metadata)

    _set_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(STATIONKEEPING_STOP_CONDITION),) }
    @stop_condition.setter
    def stop_condition(self, newVal:"STATIONKEEPING_STOP_CONDITION") -> None:
        """The stopping condition for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_stop_condition_metadata, newVal)

    _get_use_relative_course_metadata = { "name" : "use_relative_course",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_relative_course(self) -> bool:
        """Option to use a relative course as opposed to an absolute course."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_use_relative_course_metadata)

    _set_use_relative_course_metadata = { "name" : "use_relative_course",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_relative_course.setter
    def use_relative_course(self, newVal:bool) -> None:
        """Option to use a relative course as opposed to an absolute course."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_use_relative_course_metadata, newVal)

    _get_stop_course_metadata = { "name" : "stop_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_course(self) -> typing.Any:
        """The course stop condition."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_stop_course_metadata)

    _set_stop_course_metadata = { "name" : "stop_course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @stop_course.setter
    def stop_course(self, newVal:typing.Any) -> None:
        """The course stop condition."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_stop_course_metadata, newVal)

    _get_stop_after_turn_count_metadata = { "name" : "stop_after_turn_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def stop_after_turn_count(self) -> int:
        """The number of turns stop condition."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_stop_after_turn_count_metadata)

    _set_stop_after_turn_count_metadata = { "name" : "stop_after_turn_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @stop_after_turn_count.setter
    def stop_after_turn_count(self, newVal:int) -> None:
        """The number of turns stop condition."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_stop_after_turn_count_metadata, newVal)

    _get_stop_after_duration_metadata = { "name" : "stop_after_duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_after_duration(self) -> float:
        """The duration stop condition."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_stop_after_duration_metadata)

    _set_stop_after_duration_metadata = { "name" : "stop_after_duration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_after_duration.setter
    def stop_after_duration(self, newVal:float) -> None:
        """The duration stop condition."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_stop_after_duration_metadata, newVal)

    _get_stop_after_time_metadata = { "name" : "stop_after_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_after_time(self) -> typing.Any:
        """The time stop condition."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_stop_after_time_metadata)

    _set_stop_after_time_metadata = { "name" : "stop_after_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @stop_after_time.setter
    def stop_after_time(self, newVal:typing.Any) -> None:
        """The time stop condition."""
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_stop_after_time_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT),) }
    @property
    def control_limit_mode(self) -> "BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_control_limit_mode_metadata)

    _get_control_limit_turn_radius_metadata = { "name" : "control_limit_turn_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_control_limit_turn_radius_metadata)

    _get_control_limit_turn_rate_metadata = { "name" : "control_limit_turn_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_control_limit_turn_rate_metadata)

    _get_control_limit_horiz_accel_metadata = { "name" : "control_limit_horiz_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_control_limit_horiz_accel_metadata)

    _set_control_limit_metadata = { "name" : "set_control_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT), agmarshall.DOUBLE_arg,) }
    def set_control_limit(self, controlLimitMode:"BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        return self._intf.invoke(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_control_limit_metadata, controlLimitMode, controlLimitValue)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_position_vel_strategies_metadata = { "name" : "position_vel_strategies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position_vel_strategies(self) -> "BasicManeuverTargetPositionVel":
        """The position velocity strategies for Station Keeping."""
        return self._intf.get_property(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._get_position_vel_strategies_metadata)

    _cancel_tgt_position_vel_metadata = { "name" : "cancel_tgt_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def cancel_tgt_position_vel(self) -> None:
        """Cancel the position velocity strategies for Station Keeping."""
        return self._intf.invoke(IBasicManeuverStrategyStationkeeping._metadata, IBasicManeuverStrategyStationkeeping._cancel_tgt_position_vel_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{b6ab25a8-fcef-49c4-a804-c55471f61f76}", IBasicManeuverStrategyStationkeeping)
agcls.AgTypeNameMap["IBasicManeuverStrategyStationkeeping"] = IBasicManeuverStrategyStationkeeping

class IBasicManeuverStrategyRelativeFPA(object):
    """Interface used to access options for the Relative Flight Path Angle Strategy of a Basic Maneuver Procedure."""
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d2066432-a9ef-48f0-aeb2-e75f6b4323e2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_fpa" : 1,
                             "set_fpa" : 2,
                             "get_anchor_altitude_offset" : 3,
                             "set_anchor_altitude_offset" : 4,
                             "get_maneuver_factor" : 5,
                             "set_maneuver_factor" : 6,
                             "get_control_limit_mode" : 7,
                             "get_control_limit_pitch_rate" : 8,
                             "set_control_limit" : 9,
                             "get_airspeed_options" : 10,
                             "get_min_absolute_altitude" : 11,
                             "get_use_min_absolute_altitude" : 12,
                             "set_min_absolute_altitude" : 13,
                             "get_max_absolute_altitude" : 14,
                             "get_use_max_absolute_altitude" : 15,
                             "set_max_absolute_altitude" : 16,
                             "get_min_altitude_rel_anchor" : 17,
                             "get_use_min_altitude_rel_anchor" : 18,
                             "set_min_altitude_rel_anchor" : 19,
                             "get_max_altitude_rel_anchor" : 20,
                             "get_use_max_altitude_rel_anchor" : 21,
                             "set_max_altitude_rel_anchor" : 22,
                             "get_compensate_for_coriolis_accel" : 23,
                             "set_compensate_for_coriolis_accel" : 24, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyRelativeFPA._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelativeFPA from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelativeFPA.__dict__ and type(IBasicManeuverStrategyRelativeFPA.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelativeFPA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelativeFPA.")
    
    _get_fpa_metadata = { "name" : "fpa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def fpa(self) -> typing.Any:
        """The flight path angle for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_fpa_metadata)

    _set_fpa_metadata = { "name" : "fpa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @fpa.setter
    def fpa(self, newVal:typing.Any) -> None:
        """The flight path angle for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_fpa_metadata, newVal)

    _get_anchor_altitude_offset_metadata = { "name" : "anchor_altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def anchor_altitude_offset(self) -> float:
        """The goal height above or below the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_anchor_altitude_offset_metadata)

    _set_anchor_altitude_offset_metadata = { "name" : "anchor_altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @anchor_altitude_offset.setter
    def anchor_altitude_offset(self, newVal:float) -> None:
        """The goal height above or below the target."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_anchor_altitude_offset_metadata, newVal)

    _get_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maneuver_factor(self) -> float:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_maneuver_factor_metadata)

    _set_maneuver_factor_metadata = { "name" : "maneuver_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maneuver_factor.setter
    def maneuver_factor(self, newVal:float) -> None:
        """A dimensionless factor that determines how tightly or gently the aircraft will maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_maneuver_factor_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PROFILE_CONTROL_LIMIT),) }
    @property
    def control_limit_mode(self) -> "PROFILE_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_control_limit_mode_metadata)

    _get_control_limit_pitch_rate_metadata = { "name" : "control_limit_pitch_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_limit_pitch_rate(self) -> typing.Any:
        """The specified pitch rate for a control limit mode of specify max pitch rate."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_control_limit_pitch_rate_metadata)

    _set_control_limit_metadata = { "name" : "set_control_limit",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(PROFILE_CONTROL_LIMIT), agmarshall.VARIANT_arg,) }
    def set_control_limit(self, controlLimitMode:"PROFILE_CONTROL_LIMIT", controlLimitValue:typing.Any) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_control_limit_metadata, controlLimitMode, controlLimitValue)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_airspeed_options_metadata)

    _get_min_absolute_altitude_metadata = { "name" : "min_absolute_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_absolute_altitude(self) -> float:
        """The minimum absolute altitude."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_min_absolute_altitude_metadata)

    _get_use_min_absolute_altitude_metadata = { "name" : "use_min_absolute_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_min_absolute_altitude(self) -> bool:
        """The option to specify a minimum absolute altitude."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_use_min_absolute_altitude_metadata)

    _set_min_absolute_altitude_metadata = { "name" : "set_min_absolute_altitude",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_min_absolute_altitude(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the minimum absolute altitude."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_min_absolute_altitude_metadata, enable, altitude)

    _get_max_absolute_altitude_metadata = { "name" : "max_absolute_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_absolute_altitude(self) -> float:
        """The maximum absolute altitude."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_max_absolute_altitude_metadata)

    _get_use_max_absolute_altitude_metadata = { "name" : "use_max_absolute_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_absolute_altitude(self) -> bool:
        """The option to specify a maximum absolute altitude."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_use_max_absolute_altitude_metadata)

    _set_max_absolute_altitude_metadata = { "name" : "set_max_absolute_altitude",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_max_absolute_altitude(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the maximum absolute altitude."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_max_absolute_altitude_metadata, enable, altitude)

    _get_min_altitude_rel_anchor_metadata = { "name" : "min_altitude_rel_anchor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_altitude_rel_anchor(self) -> float:
        """The minimum altitude offset from the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_min_altitude_rel_anchor_metadata)

    _get_use_min_altitude_rel_anchor_metadata = { "name" : "use_min_altitude_rel_anchor",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_min_altitude_rel_anchor(self) -> bool:
        """The option to specify a minimum altitude offset from the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_use_min_altitude_rel_anchor_metadata)

    _set_min_altitude_rel_anchor_metadata = { "name" : "set_min_altitude_rel_anchor",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_min_altitude_rel_anchor(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the minimum altitude offset from the target."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_min_altitude_rel_anchor_metadata, enable, altitude)

    _get_max_altitude_rel_anchor_metadata = { "name" : "max_altitude_rel_anchor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_altitude_rel_anchor(self) -> float:
        """The maximum altitude offset from the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_max_altitude_rel_anchor_metadata)

    _get_use_max_altitude_rel_anchor_metadata = { "name" : "use_max_altitude_rel_anchor",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_altitude_rel_anchor(self) -> bool:
        """The option to specify a maximum altitude offset from the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_use_max_altitude_rel_anchor_metadata)

    _set_max_altitude_rel_anchor_metadata = { "name" : "set_max_altitude_rel_anchor",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_max_altitude_rel_anchor(self, enable:bool, altitude:float) -> None:
        """Set whether to enable and a value for the maximum altitude offset from the target."""
        return self._intf.invoke(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_max_altitude_rel_anchor_metadata, enable, altitude)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyRelativeFPA._metadata, IBasicManeuverStrategyRelativeFPA._set_compensate_for_coriolis_accel_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{d2066432-a9ef-48f0-aeb2-e75f6b4323e2}", IBasicManeuverStrategyRelativeFPA)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelativeFPA"] = IBasicManeuverStrategyRelativeFPA

class IBasicManeuverStrategyRelSpeedAltitude(object):
    """Interface used to access options for a Relative Speed/Altitude Strategy of a Basic Maneuver Procedure."""
    _num_methods = 38
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1770600b-1329-4efb-8836-200a0d8ed802}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_name" : 1,
                             "set_target_name" : 2,
                             "get_valid_target_names" : 3,
                             "get_target_resolution" : 4,
                             "set_target_resolution" : 5,
                             "get_relative_altitude_mode" : 6,
                             "set_relative_altitude_mode" : 7,
                             "get_elevation_angle" : 8,
                             "set_elevation_angle" : 9,
                             "get_altitude_offset" : 10,
                             "set_altitude_offset" : 11,
                             "get_airspeed_offset_type" : 12,
                             "get_airspeed_offset" : 13,
                             "set_airspeed_offset" : 14,
                             "get_use_tgt_aspect_for_airspeed" : 15,
                             "set_use_tgt_aspect_for_airspeed" : 16,
                             "get_use_perf_model_limits" : 17,
                             "set_use_perf_model_limits" : 18,
                             "get_range_for_equal_speed" : 19,
                             "set_range_for_equal_speed" : 20,
                             "get_range_to_transition_speed" : 21,
                             "set_range_to_transition_speed" : 22,
                             "get_min_altitude" : 23,
                             "set_min_altitude" : 24,
                             "get_max_altitude" : 25,
                             "set_max_altitude" : 26,
                             "get_min_airspeed" : 27,
                             "get_min_airspeed_type" : 28,
                             "set_min_airspeed" : 29,
                             "get_max_airspeed" : 30,
                             "get_max_airspeed_type" : 31,
                             "set_max_airspeed" : 32,
                             "get_stop_condition" : 33,
                             "set_stop_condition" : 34,
                             "get_compensate_for_coriolis_accel" : 35,
                             "set_compensate_for_coriolis_accel" : 36,
                             "get_position_vel_strategies" : 37,
                             "cancel_tgt_position_vel" : 38, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyRelSpeedAltitude._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyRelSpeedAltitude from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyRelSpeedAltitude.__dict__ and type(IBasicManeuverStrategyRelSpeedAltitude.__dict__[attrname]) == property:
            return IBasicManeuverStrategyRelSpeedAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyRelSpeedAltitude.")
    
    _get_target_name_metadata = { "name" : "target_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_name(self) -> str:
        """The target name."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_target_name_metadata)

    _set_target_name_metadata = { "name" : "target_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_name.setter
    def target_name(self, newVal:str) -> None:
        """The target name."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_target_name_metadata, newVal)

    _get_valid_target_names_metadata = { "name" : "valid_target_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_target_names(self) -> list:
        """Returns the valid target names."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_valid_target_names_metadata)

    _get_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def target_resolution(self) -> float:
        """The target position/velocity sampling resolution."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_target_resolution_metadata)

    _set_target_resolution_metadata = { "name" : "target_resolution",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @target_resolution.setter
    def target_resolution(self, newVal:float) -> None:
        """The target position/velocity sampling resolution."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_target_resolution_metadata, newVal)

    _get_relative_altitude_mode_metadata = { "name" : "relative_altitude_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(RELATIVE_ALTITUDE_MODE),) }
    @property
    def relative_altitude_mode(self) -> "RELATIVE_ALTITUDE_MODE":
        """The mode to define the hold objective for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_relative_altitude_mode_metadata)

    _set_relative_altitude_mode_metadata = { "name" : "relative_altitude_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(RELATIVE_ALTITUDE_MODE),) }
    @relative_altitude_mode.setter
    def relative_altitude_mode(self, newVal:"RELATIVE_ALTITUDE_MODE") -> None:
        """The mode to define the hold objective for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_relative_altitude_mode_metadata, newVal)

    _get_elevation_angle_metadata = { "name" : "elevation_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def elevation_angle(self) -> typing.Any:
        """The goal elevation angle from the target to the aircraft."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_elevation_angle_metadata)

    _set_elevation_angle_metadata = { "name" : "elevation_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @elevation_angle.setter
    def elevation_angle(self, newVal:typing.Any) -> None:
        """The goal elevation angle from the target to the aircraft."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_elevation_angle_metadata, newVal)

    _get_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_offset(self) -> float:
        """The goal altitude offset from the target to the aircraft."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_altitude_offset_metadata)

    _set_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The goal altitude offset from the target to the aircraft."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_altitude_offset_metadata, newVal)

    _get_airspeed_offset_type_metadata = { "name" : "airspeed_offset_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_offset_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_airspeed_offset_type_metadata)

    _get_airspeed_offset_metadata = { "name" : "airspeed_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed_offset(self) -> float:
        """The airspeed offset from the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_airspeed_offset_metadata)

    _set_airspeed_offset_metadata = { "name" : "set_airspeed_offset",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed_offset(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the airspeed offset value and type."""
        return self._intf.invoke(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_airspeed_offset_metadata, airspeedType, airspeed)

    _get_use_tgt_aspect_for_airspeed_metadata = { "name" : "use_tgt_aspect_for_airspeed",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_tgt_aspect_for_airspeed(self) -> bool:
        """The option to use the target aspect to compute the enforced airspeed difference."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_use_tgt_aspect_for_airspeed_metadata)

    _set_use_tgt_aspect_for_airspeed_metadata = { "name" : "use_tgt_aspect_for_airspeed",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_tgt_aspect_for_airspeed.setter
    def use_tgt_aspect_for_airspeed(self, newVal:bool) -> None:
        """The option to use the target aspect to compute the enforced airspeed difference."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_use_tgt_aspect_for_airspeed_metadata, newVal)

    _get_use_perf_model_limits_metadata = { "name" : "use_perf_model_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_perf_model_limits(self) -> bool:
        """The option to use the performance model limits for the aircraft."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_use_perf_model_limits_metadata)

    _set_use_perf_model_limits_metadata = { "name" : "use_perf_model_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_perf_model_limits.setter
    def use_perf_model_limits(self, newVal:bool) -> None:
        """The option to use the performance model limits for the aircraft."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_use_perf_model_limits_metadata, newVal)

    _get_range_for_equal_speed_metadata = { "name" : "range_for_equal_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range_for_equal_speed(self) -> float:
        """The range at which the aircraft will achieve the same airspeed as the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_range_for_equal_speed_metadata)

    _set_range_for_equal_speed_metadata = { "name" : "range_for_equal_speed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range_for_equal_speed.setter
    def range_for_equal_speed(self, newVal:float) -> None:
        """The range at which the aircraft will achieve the same airspeed as the target."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_range_for_equal_speed_metadata, newVal)

    _get_range_to_transition_speed_metadata = { "name" : "range_to_transition_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range_to_transition_speed(self) -> float:
        """The range at which the aircraft will begin to slow down to match the speed of the target."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_range_to_transition_speed_metadata)

    _set_range_to_transition_speed_metadata = { "name" : "range_to_transition_speed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range_to_transition_speed.setter
    def range_to_transition_speed(self, newVal:float) -> None:
        """The range at which the aircraft will begin to slow down to match the speed of the target."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_range_to_transition_speed_metadata, newVal)

    _get_min_altitude_metadata = { "name" : "min_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_altitude(self) -> float:
        """The minimum altitude boundary for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_min_altitude_metadata)

    _set_min_altitude_metadata = { "name" : "min_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_altitude.setter
    def min_altitude(self, newVal:float) -> None:
        """The minimum altitude boundary for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_min_altitude_metadata, newVal)

    _get_max_altitude_metadata = { "name" : "max_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_altitude(self) -> float:
        """The maximum altitude boundary for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_max_altitude_metadata)

    _set_max_altitude_metadata = { "name" : "max_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_altitude.setter
    def max_altitude(self, newVal:float) -> None:
        """The maximum altitude boundary for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_max_altitude_metadata, newVal)

    _get_min_airspeed_metadata = { "name" : "min_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_airspeed(self) -> float:
        """The minimum airspeed limit for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_min_airspeed_metadata)

    _get_min_airspeed_type_metadata = { "name" : "min_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def min_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_min_airspeed_type_metadata)

    _set_min_airspeed_metadata = { "name" : "set_min_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_min_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the minimum airspeed value and type."""
        return self._intf.invoke(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_min_airspeed_metadata, airspeedType, airspeed)

    _get_max_airspeed_metadata = { "name" : "max_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_airspeed(self) -> float:
        """The maximum airspeed limit for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_max_airspeed_metadata)

    _get_max_airspeed_type_metadata = { "name" : "max_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def max_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_max_airspeed_type_metadata)

    _set_max_airspeed_metadata = { "name" : "set_max_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_max_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the maximum airspeed value and type."""
        return self._intf.invoke(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_max_airspeed_metadata, airspeedType, airspeed)

    _get_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REL_SPEED_ALTITUDE_STOP_CONDITION),) }
    @property
    def stop_condition(self) -> "REL_SPEED_ALTITUDE_STOP_CONDITION":
        """The stopping condition for the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_stop_condition_metadata)

    _set_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(REL_SPEED_ALTITUDE_STOP_CONDITION),) }
    @stop_condition.setter
    def stop_condition(self, newVal:"REL_SPEED_ALTITUDE_STOP_CONDITION") -> None:
        """The stopping condition for the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_stop_condition_metadata, newVal)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_position_vel_strategies_metadata = { "name" : "position_vel_strategies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position_vel_strategies(self) -> "BasicManeuverTargetPositionVel":
        """The position velocity strategies for Rel Speed Alt."""
        return self._intf.get_property(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._get_position_vel_strategies_metadata)

    _cancel_tgt_position_vel_metadata = { "name" : "cancel_tgt_position_vel",
            "arg_types" : (),
            "marshallers" : () }
    def cancel_tgt_position_vel(self) -> None:
        """Cancel the position velocity strategies for Rel Speed Alt."""
        return self._intf.invoke(IBasicManeuverStrategyRelSpeedAltitude._metadata, IBasicManeuverStrategyRelSpeedAltitude._cancel_tgt_position_vel_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{1770600b-1329-4efb-8836-200a0d8ed802}", IBasicManeuverStrategyRelSpeedAltitude)
agcls.AgTypeNameMap["IBasicManeuverStrategyRelSpeedAltitude"] = IBasicManeuverStrategyRelSpeedAltitude

class IBasicManeuverStrategyBezier(object):
    """Interface used to access options for a Bezier Strategy of a Basic Maneuver Procedure."""
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{fe815e13-cfab-4da7-8beb-9d8efd93d9f3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_frame" : 1,
                             "set_reference_frame" : 2,
                             "get_altitude" : 3,
                             "set_altitude" : 4,
                             "get_downrange" : 5,
                             "set_downrange" : 6,
                             "get_airspeed" : 7,
                             "get_airspeed_type" : 8,
                             "set_airspeed" : 9,
                             "get_vertical_velocity_mode" : 10,
                             "get_flight_path_angle" : 11,
                             "get_altitude_rate" : 12,
                             "set_vertical_velocity" : 13,
                             "get_use_stop_at_altitude_rate" : 14,
                             "get_stop_altitude_rate" : 15,
                             "set_stop_altitude_rate" : 16,
                             "get_use_stop_at_airspeed" : 17,
                             "get_stop_airspeed" : 18,
                             "get_stop_airspeed_type" : 19,
                             "set_stop_airspeed" : 20,
                             "get_compensate_for_coriolis_accel" : 21,
                             "set_compensate_for_coriolis_accel" : 22, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyBezier._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyBezier from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyBezier.__dict__ and type(IBasicManeuverStrategyBezier.__dict__[attrname]) == property:
            return IBasicManeuverStrategyBezier.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyBezier.")
    
    _get_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @property
    def reference_frame(self) -> "BASIC_MANEUVER_REFERENCE_FRAME":
        """The reference frame the aircraft will use."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @reference_frame.setter
    def reference_frame(self, newVal:"BASIC_MANEUVER_REFERENCE_FRAME") -> None:
        """The reference frame the aircraft will use."""
        return self._intf.set_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_reference_frame_metadata, newVal)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The aircraft's altitude."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The aircraft's altitude."""
        return self._intf.set_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_altitude_metadata, newVal)

    _get_downrange_metadata = { "name" : "downrange",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def downrange(self) -> float:
        """The ground distance from the beginning of the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_downrange_metadata)

    _set_downrange_metadata = { "name" : "downrange",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @downrange.setter
    def downrange(self, newVal:float) -> None:
        """The ground distance from the beginning of the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_downrange_metadata, newVal)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """The aircraft's airspeed."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_airspeed_metadata)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_airspeed_type_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the fly to airspeed value and type."""
        return self._intf.invoke(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_airspeed_metadata, airspeedType, airspeed)

    _get_vertical_velocity_mode_metadata = { "name" : "vertical_velocity_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FLY_TO_FLIGHT_PATH_ANGLE_MODE),) }
    @property
    def vertical_velocity_mode(self) -> "FLY_TO_FLIGHT_PATH_ANGLE_MODE":
        """The option to specify the flight path angle or the altitude rate."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_vertical_velocity_mode_metadata)

    _get_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def flight_path_angle(self) -> typing.Any:
        """The initial pitch angle of the flight path."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_flight_path_angle_metadata)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """The constant rate at which the aircraft will climb or descend."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_altitude_rate_metadata)

    _set_vertical_velocity_metadata = { "name" : "set_vertical_velocity",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(FLY_TO_FLIGHT_PATH_ANGLE_MODE), agmarshall.VARIANT_arg,) }
    def set_vertical_velocity(self, mode:"FLY_TO_FLIGHT_PATH_ANGLE_MODE", value:typing.Any) -> None:
        """Set the flight path angle or altitude rate."""
        return self._intf.invoke(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_vertical_velocity_metadata, mode, value)

    _get_use_stop_at_altitude_rate_metadata = { "name" : "use_stop_at_altitude_rate",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_at_altitude_rate(self) -> bool:
        """The option to stop the maneuver if a specified altitude rate is achieved."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_use_stop_at_altitude_rate_metadata)

    _get_stop_altitude_rate_metadata = { "name" : "stop_altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_altitude_rate(self) -> float:
        """The altitude rate stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_stop_altitude_rate_metadata)

    _set_stop_altitude_rate_metadata = { "name" : "set_stop_altitude_rate",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_stop_altitude_rate(self, enable:bool, altitudeRate:float) -> None:
        """Set whether to enable the altitude rate stopping condition and the corresponding value."""
        return self._intf.invoke(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_stop_altitude_rate_metadata, enable, altitudeRate)

    _get_use_stop_at_airspeed_metadata = { "name" : "use_stop_at_airspeed",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_at_airspeed(self) -> bool:
        """The option to stop the maneuver if a specified airspeed is achieved."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_use_stop_at_airspeed_metadata)

    _get_stop_airspeed_metadata = { "name" : "stop_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_airspeed(self) -> float:
        """The airspeed stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_stop_airspeed_metadata)

    _get_stop_airspeed_type_metadata = { "name" : "stop_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def stop_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type for the airspeed stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_stop_airspeed_type_metadata)

    _set_stop_airspeed_metadata = { "name" : "set_stop_airspeed",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_stop_airspeed(self, enable:bool, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set whether to enable the airspeed stopping condition and the corresponding value."""
        return self._intf.invoke(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_stop_airspeed_metadata, enable, airspeedType, airspeed)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyBezier._metadata, IBasicManeuverStrategyBezier._set_compensate_for_coriolis_accel_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{fe815e13-cfab-4da7-8beb-9d8efd93d9f3}", IBasicManeuverStrategyBezier)
agcls.AgTypeNameMap["IBasicManeuverStrategyBezier"] = IBasicManeuverStrategyBezier

class IBasicManeuverStrategyPushPull(object):
    """Interface used to access options for a Push/Pull Strategy of a Basic Maneuver Procedure."""
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8000621a-e9ce-4aa7-bf8e-565f579a4675}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_frame" : 1,
                             "set_reference_frame" : 2,
                             "get_push_pull" : 3,
                             "set_push_pull" : 4,
                             "get_push_pull_g" : 5,
                             "set_push_pull_g" : 6,
                             "get_accel_mode" : 7,
                             "set_accel_mode" : 8,
                             "get_accel_decel_g" : 9,
                             "set_accel_decel_g" : 10,
                             "get_maintain_airspeed_type" : 11,
                             "set_maintain_airspeed_type" : 12,
                             "get_maintain_airspeed" : 13,
                             "get_stop_flight_path_angle" : 14,
                             "set_stop_flight_path_angle" : 15,
                             "get_use_stop_at_altitude" : 16,
                             "get_stop_altitude" : 17,
                             "set_stop_altitude" : 18,
                             "get_use_stop_at_altitude_rate" : 19,
                             "get_stop_altitude_rate" : 20,
                             "set_stop_altitude_rate" : 21,
                             "get_use_stop_at_airspeed" : 22,
                             "get_stop_airspeed" : 23,
                             "get_stop_airspeed_type" : 24,
                             "set_stop_airspeed" : 25,
                             "get_compensate_for_coriolis_accel" : 26,
                             "set_compensate_for_coriolis_accel" : 27, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyPushPull._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyPushPull from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyPushPull.__dict__ and type(IBasicManeuverStrategyPushPull.__dict__[attrname]) == property:
            return IBasicManeuverStrategyPushPull.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyPushPull.")
    
    _get_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @property
    def reference_frame(self) -> "BASIC_MANEUVER_REFERENCE_FRAME":
        """The reference frame the aircraft will use."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @reference_frame.setter
    def reference_frame(self, newVal:"BASIC_MANEUVER_REFERENCE_FRAME") -> None:
        """The reference frame the aircraft will use."""
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_reference_frame_metadata, newVal)

    _get_push_pull_metadata = { "name" : "push_pull",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PUSH_PULL),) }
    @property
    def push_pull(self) -> "PUSH_PULL":
        """The option to push over or pull up."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_push_pull_metadata)

    _set_push_pull_metadata = { "name" : "push_pull",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PUSH_PULL),) }
    @push_pull.setter
    def push_pull(self, newVal:"PUSH_PULL") -> None:
        """The option to push over or pull up."""
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_push_pull_metadata, newVal)

    _get_push_pull_g_metadata = { "name" : "push_pull_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def push_pull_g(self) -> float:
        """The G force of the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_push_pull_g_metadata)

    _set_push_pull_g_metadata = { "name" : "push_pull_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @push_pull_g.setter
    def push_pull_g(self, newVal:float) -> None:
        """The G force of the maneuver."""
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_push_pull_g_metadata, newVal)

    _get_accel_mode_metadata = { "name" : "accel_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MODE),) }
    @property
    def accel_mode(self) -> "ACCEL_MODE":
        """The option to accelerate, decelerate, or maintain the current airspeed."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_accel_mode_metadata)

    _set_accel_mode_metadata = { "name" : "accel_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ACCEL_MODE),) }
    @accel_mode.setter
    def accel_mode(self, newVal:"ACCEL_MODE") -> None:
        """The option to accelerate, decelerate, or maintain the current airspeed."""
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_accel_mode_metadata, newVal)

    _get_accel_decel_g_metadata = { "name" : "accel_decel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_decel_g(self) -> float:
        """The specific G force rate to accelerate/decelerate at."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_accel_decel_g_metadata)

    _set_accel_decel_g_metadata = { "name" : "accel_decel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_decel_g.setter
    def accel_decel_g(self, newVal:float) -> None:
        """The specific G force rate to accelerate/decelerate at."""
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_accel_decel_g_metadata, newVal)

    _get_maintain_airspeed_type_metadata = { "name" : "maintain_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def maintain_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type for the maintain airspeed."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_maintain_airspeed_type_metadata)

    _set_maintain_airspeed_type_metadata = { "name" : "maintain_airspeed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @maintain_airspeed_type.setter
    def maintain_airspeed_type(self, newVal:"AIRSPEED_TYPE") -> None:
        """The airspeed type for the maintain airspeed."""
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_maintain_airspeed_type_metadata, newVal)

    _get_maintain_airspeed_metadata = { "name" : "maintain_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maintain_airspeed(self) -> float:
        """The airspeed to maintain."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_maintain_airspeed_metadata)

    _get_stop_flight_path_angle_metadata = { "name" : "stop_flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_flight_path_angle(self) -> typing.Any:
        """The flight path angle the maneuver will stop at if achieved."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_stop_flight_path_angle_metadata)

    _set_stop_flight_path_angle_metadata = { "name" : "stop_flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @stop_flight_path_angle.setter
    def stop_flight_path_angle(self, newVal:typing.Any) -> None:
        """The flight path angle the maneuver will stop at if achieved."""
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_stop_flight_path_angle_metadata, newVal)

    _get_use_stop_at_altitude_metadata = { "name" : "use_stop_at_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_at_altitude(self) -> bool:
        """The option to stop the maneuver if a specified altitude is achieved."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_use_stop_at_altitude_metadata)

    _get_stop_altitude_metadata = { "name" : "stop_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_altitude(self) -> float:
        """The altitude stopping condition"""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_stop_altitude_metadata)

    _set_stop_altitude_metadata = { "name" : "set_stop_altitude",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_stop_altitude(self, enable:bool, altitudeRate:float) -> None:
        """Set whether to enable the altitude stopping condition and the corresponding value."""
        return self._intf.invoke(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_stop_altitude_metadata, enable, altitudeRate)

    _get_use_stop_at_altitude_rate_metadata = { "name" : "use_stop_at_altitude_rate",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_at_altitude_rate(self) -> bool:
        """The option to stop the maneuver if a specified altitude rate is achieved."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_use_stop_at_altitude_rate_metadata)

    _get_stop_altitude_rate_metadata = { "name" : "stop_altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_altitude_rate(self) -> float:
        """The altitude rate stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_stop_altitude_rate_metadata)

    _set_stop_altitude_rate_metadata = { "name" : "set_stop_altitude_rate",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg,) }
    def set_stop_altitude_rate(self, enable:bool, altitudeRate:float) -> None:
        """Set whether to enable the altitude rate stopping condition and the corresponding value."""
        return self._intf.invoke(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_stop_altitude_rate_metadata, enable, altitudeRate)

    _get_use_stop_at_airspeed_metadata = { "name" : "use_stop_at_airspeed",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_at_airspeed(self) -> bool:
        """The option to stop the maneuver if a specified airspeed is achieved."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_use_stop_at_airspeed_metadata)

    _get_stop_airspeed_metadata = { "name" : "stop_airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_airspeed(self) -> float:
        """The airspeed stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_stop_airspeed_metadata)

    _get_stop_airspeed_type_metadata = { "name" : "stop_airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def stop_airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type for the airspeed stopping condition."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_stop_airspeed_type_metadata)

    _set_stop_airspeed_metadata = { "name" : "set_stop_airspeed",
            "arg_types" : (agcom.VARIANT_BOOL, agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_stop_airspeed(self, enable:bool, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set whether to enable the airspeed stopping condition and the corresponding value."""
        return self._intf.invoke(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_stop_airspeed_metadata, enable, airspeedType, airspeed)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyPushPull._metadata, IBasicManeuverStrategyPushPull._set_compensate_for_coriolis_accel_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{8000621a-e9ce-4aa7-bf8e-565f579a4675}", IBasicManeuverStrategyPushPull)
agcls.AgTypeNameMap["IBasicManeuverStrategyPushPull"] = IBasicManeuverStrategyPushPull

class IBasicManeuverStrategyGlideProfile(object):
    """Interface used to access options for a Glide Profile Strategy of a Basic Maneuver Procedure."""
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7c0a4dd8-59ed-403d-96bb-8f45d3e71ca6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_hold_initial_airspeed" : 1,
                             "set_hold_initial_airspeed" : 2,
                             "get_airspeed" : 3,
                             "get_airspeed_type" : 4,
                             "get_min_g" : 5,
                             "set_min_g" : 6,
                             "get_max_g" : 7,
                             "set_max_g" : 8,
                             "get_max_speed_limits" : 9,
                             "set_max_speed_limits" : 10,
                             "set_airspeed" : 11,
                             "get_compensate_for_coriolis_accel" : 12,
                             "set_compensate_for_coriolis_accel" : 13,
                             "get_powered_cruise_mode" : 14,
                             "set_powered_cruise_mode" : 15,
                             "get_powered_cruise_throttle" : 16,
                             "set_powered_cruise_throttle" : 17,
                             "get_powered_cruise_thrust_model" : 18,
                             "get_glide_speed_control_mode" : 19,
                             "get_glide_speed_control_altitude" : 20,
                             "set_glide_speed_control_mode" : 21, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyGlideProfile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyGlideProfile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyGlideProfile.__dict__ and type(IBasicManeuverStrategyGlideProfile.__dict__[attrname]) == property:
            return IBasicManeuverStrategyGlideProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyGlideProfile.")
    
    _get_hold_initial_airspeed_metadata = { "name" : "hold_initial_airspeed",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def hold_initial_airspeed(self) -> bool:
        """Select whether to maintain the airspeed of the aircraft at the beginning of the procedure throughout the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_hold_initial_airspeed_metadata)

    _set_hold_initial_airspeed_metadata = { "name" : "hold_initial_airspeed",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @hold_initial_airspeed.setter
    def hold_initial_airspeed(self, pVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_hold_initial_airspeed_metadata, pVal)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """Get the airspeed the aircraft will attempt to achieve and maintain if the hold initial airspeed option is not enabled."""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_airspeed_metadata)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """Get the airspeed type."""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_airspeed_type_metadata)

    _get_min_g_metadata = { "name" : "min_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_g(self) -> float:
        """The minimum load factor the aircraft can withstand."""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_min_g_metadata)

    _set_min_g_metadata = { "name" : "min_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_g.setter
    def min_g(self, pVal:float) -> None:
        return self._intf.set_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_min_g_metadata, pVal)

    _get_max_g_metadata = { "name" : "max_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_g(self) -> float:
        """The maximum load factor the aircraft can withstand."""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_max_g_metadata)

    _set_max_g_metadata = { "name" : "max_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_g.setter
    def max_g(self, pVal:float) -> None:
        return self._intf.set_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_max_g_metadata, pVal)

    _get_max_speed_limits_metadata = { "name" : "max_speed_limits",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS),) }
    @property
    def max_speed_limits(self) -> "BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS":
        """The options of what the procedure will do if the aircraft has exceeded the maximum speed limits."""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_max_speed_limits_metadata)

    _set_max_speed_limits_metadata = { "name" : "max_speed_limits",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS),) }
    @max_speed_limits.setter
    def max_speed_limits(self, pVal:"BASIC_MANEUVER_STRATEGY_AIRSPEED_PERF_LIMITS") -> None:
        return self._intf.set_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_max_speed_limits_metadata, pVal)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the airspeed and airspeed type that the aircraft will attempt to achieve and maintain if the hold initial airspeed option is not enabled."""
        return self._intf.invoke(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_airspeed_metadata, airspeedType, airspeed)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_compensate_for_coriolis_accel_metadata, newVal)

    _get_powered_cruise_mode_metadata = { "name" : "powered_cruise_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE),) }
    @property
    def powered_cruise_mode(self) -> "BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE":
        """The powered cruise mode"""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_powered_cruise_mode_metadata)

    _set_powered_cruise_mode_metadata = { "name" : "powered_cruise_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE),) }
    @powered_cruise_mode.setter
    def powered_cruise_mode(self, newVal:"BASIC_MANEUVER_STRATEGY_POWERED_CRUISE_MODE") -> None:
        return self._intf.set_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_powered_cruise_mode_metadata, newVal)

    _get_powered_cruise_throttle_metadata = { "name" : "powered_cruise_throttle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def powered_cruise_throttle(self) -> float:
        """The powered cruise throttle"""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_powered_cruise_throttle_metadata)

    _set_powered_cruise_throttle_metadata = { "name" : "powered_cruise_throttle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @powered_cruise_throttle.setter
    def powered_cruise_throttle(self, newVal:float) -> None:
        return self._intf.set_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_powered_cruise_throttle_metadata, newVal)

    _get_powered_cruise_thrust_model_metadata = { "name" : "powered_cruise_thrust_model",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def powered_cruise_thrust_model(self) -> "PropulsionThrust":
        """The powered cruise thrust model"""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_powered_cruise_thrust_model_metadata)

    _get_glide_speed_control_mode_metadata = { "name" : "glide_speed_control_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE),) }
    @property
    def glide_speed_control_mode(self) -> "BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE":
        """The glide speed control mode"""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_glide_speed_control_mode_metadata)

    _get_glide_speed_control_altitude_metadata = { "name" : "glide_speed_control_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def glide_speed_control_altitude(self) -> float:
        """The glide speed altitude when using the altitude control mode"""
        return self._intf.get_property(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._get_glide_speed_control_altitude_metadata)

    _set_glide_speed_control_mode_metadata = { "name" : "set_glide_speed_control_mode",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE), agmarshall.DOUBLE_arg,) }
    def set_glide_speed_control_mode(self, eGSMode:"BASIC_MANEUVER_GLIDE_SPEED_CONTROL_MODE", dControlAlt:float) -> None:
        """Set the glide speed control mode and altitude"""
        return self._intf.invoke(IBasicManeuverStrategyGlideProfile._metadata, IBasicManeuverStrategyGlideProfile._set_glide_speed_control_mode_metadata, eGSMode, dControlAlt)


agcls.AgClassCatalog.add_catalog_entry("{7c0a4dd8-59ed-403d-96bb-8f45d3e71ca6}", IBasicManeuverStrategyGlideProfile)
agcls.AgTypeNameMap["IBasicManeuverStrategyGlideProfile"] = IBasicManeuverStrategyGlideProfile

class IBasicManeuverStrategyCruiseProfile(object):
    """Interface used to access options for a Cruise Profile Strategy of a Basic Maneuver Procedure."""
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{bd2d3a58-6602-4909-bb0f-98fa9c84d535}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_frame" : 1,
                             "set_reference_frame" : 2,
                             "get_use_default_cruise_altitude" : 3,
                             "set_use_default_cruise_altitude" : 4,
                             "get_level_off" : 5,
                             "set_level_off" : 6,
                             "get_requested_altitude" : 7,
                             "set_requested_altitude" : 8,
                             "get_cruise_airspeed_options" : 9,
                             "get_stop_after_level_off" : 10,
                             "set_stop_after_level_off" : 11,
                             "get_compensate_for_coriolis_accel" : 12,
                             "set_compensate_for_coriolis_accel" : 13, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyCruiseProfile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyCruiseProfile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyCruiseProfile.__dict__ and type(IBasicManeuverStrategyCruiseProfile.__dict__[attrname]) == property:
            return IBasicManeuverStrategyCruiseProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyCruiseProfile.")
    
    _get_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @property
    def reference_frame(self) -> "BASIC_MANEUVER_REFERENCE_FRAME":
        """The reference frame the aircraft will use. Earth Frame will force the aircraft to overcome wind effects. Wind frame will allow the maneuver to be perturbed by wind."""
        return self._intf.get_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @reference_frame.setter
    def reference_frame(self, pVal:"BASIC_MANEUVER_REFERENCE_FRAME") -> None:
        return self._intf.set_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._set_reference_frame_metadata, pVal)

    _get_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the aircraft's default cruise altitude."""
        return self._intf.get_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._get_use_default_cruise_altitude_metadata)

    _set_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, pVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._set_use_default_cruise_altitude_metadata, pVal)

    _get_level_off_metadata = { "name" : "level_off",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def level_off(self) -> bool:
        """Opt whether to require the aircraft to level off at the specified altitude. This altitude is only enabled of the Default Cruise Altitude option is not selected."""
        return self._intf.get_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._get_level_off_metadata)

    _set_level_off_metadata = { "name" : "level_off",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @level_off.setter
    def level_off(self, pVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._set_level_off_metadata, pVal)

    _get_requested_altitude_metadata = { "name" : "requested_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def requested_altitude(self) -> float:
        """The desired MSL Altitude for the maneuver. This altitude is only enabled of the Default Cruise Altitude option is not selected."""
        return self._intf.get_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._get_requested_altitude_metadata)

    _set_requested_altitude_metadata = { "name" : "requested_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @requested_altitude.setter
    def requested_altitude(self, newVal:float) -> None:
        return self._intf.set_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._set_requested_altitude_metadata, newVal)

    _get_cruise_airspeed_options_metadata = { "name" : "cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the interface for the cruise airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._get_cruise_airspeed_options_metadata)

    _get_stop_after_level_off_metadata = { "name" : "stop_after_level_off",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_after_level_off(self) -> bool:
        """Select to stop the maneuver as soon as the aircraft achieves its goal altitude and levels off, regardless if any basic stopping conditions have been triggered."""
        return self._intf.get_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._get_stop_after_level_off_metadata)

    _set_stop_after_level_off_metadata = { "name" : "stop_after_level_off",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @stop_after_level_off.setter
    def stop_after_level_off(self, pVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._set_stop_after_level_off_metadata, pVal)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyCruiseProfile._metadata, IBasicManeuverStrategyCruiseProfile._set_compensate_for_coriolis_accel_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{bd2d3a58-6602-4909-bb0f-98fa9c84d535}", IBasicManeuverStrategyCruiseProfile)
agcls.AgTypeNameMap["IBasicManeuverStrategyCruiseProfile"] = IBasicManeuverStrategyCruiseProfile

class IBasicManeuverStrategyStraightAhead(object):
    """Interface used to access options for a Straight Ahead Strategy of a Basic Maneuver Procedure."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b20bf35c-8f9c-4a09-9b2c-b57124e657aa}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_frame" : 1,
                             "set_reference_frame" : 2,
                             "get_compensate_for_coriolis_accel" : 3,
                             "set_compensate_for_coriolis_accel" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyStraightAhead._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyStraightAhead from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyStraightAhead.__dict__ and type(IBasicManeuverStrategyStraightAhead.__dict__[attrname]) == property:
            return IBasicManeuverStrategyStraightAhead.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyStraightAhead.")
    
    _get_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(STRAIGHT_AHEAD_REFERENCE_FRAME),) }
    @property
    def reference_frame(self) -> "STRAIGHT_AHEAD_REFERENCE_FRAME":
        """The reference frame the aircraft will use to fly straight ahead."""
        return self._intf.get_property(IBasicManeuverStrategyStraightAhead._metadata, IBasicManeuverStrategyStraightAhead._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(STRAIGHT_AHEAD_REFERENCE_FRAME),) }
    @reference_frame.setter
    def reference_frame(self, pVal:"STRAIGHT_AHEAD_REFERENCE_FRAME") -> None:
        return self._intf.set_property(IBasicManeuverStrategyStraightAhead._metadata, IBasicManeuverStrategyStraightAhead._set_reference_frame_metadata, pVal)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyStraightAhead._metadata, IBasicManeuverStrategyStraightAhead._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyStraightAhead._metadata, IBasicManeuverStrategyStraightAhead._set_compensate_for_coriolis_accel_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{b20bf35c-8f9c-4a09-9b2c-b57124e657aa}", IBasicManeuverStrategyStraightAhead)
agcls.AgTypeNameMap["IBasicManeuverStrategyStraightAhead"] = IBasicManeuverStrategyStraightAhead

class IBasicManeuverStrategyWeave(object):
    """Interface used to access options for a weave strategy of a basic maneuver procedure."""
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3ec446e4-6454-4c4d-936c-7094ec85ddd0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_heading_change" : 1,
                             "set_heading_change" : 2,
                             "get_max_num_cycles" : 3,
                             "set_max_num_cycles" : 4,
                             "get_max_distance" : 5,
                             "set_max_distance" : 6,
                             "get_control_limit_mode" : 7,
                             "get_control_limit_turn_radius" : 8,
                             "get_control_limit_turn_rate" : 9,
                             "get_control_limit_horiz_accel" : 10,
                             "set_control_limit" : 11,
                             "get_compensate_for_coriolis_accel" : 12,
                             "set_compensate_for_coriolis_accel" : 13, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyWeave._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyWeave from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyWeave.__dict__ and type(IBasicManeuverStrategyWeave.__dict__[attrname]) == property:
            return IBasicManeuverStrategyWeave.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyWeave.")
    
    _get_heading_change_metadata = { "name" : "heading_change",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_change(self) -> typing.Any:
        """The direction in which the aircraft will begin the weave pattern."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_heading_change_metadata)

    _set_heading_change_metadata = { "name" : "heading_change",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading_change.setter
    def heading_change(self, newVal:typing.Any) -> None:
        return self._intf.set_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._set_heading_change_metadata, newVal)

    _get_max_num_cycles_metadata = { "name" : "max_num_cycles",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_num_cycles(self) -> float:
        """The number of times the aircraft will fly the pattern."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_max_num_cycles_metadata)

    _set_max_num_cycles_metadata = { "name" : "max_num_cycles",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_num_cycles.setter
    def max_num_cycles(self, newVal:float) -> None:
        return self._intf.set_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._set_max_num_cycles_metadata, newVal)

    _get_max_distance_metadata = { "name" : "max_distance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_distance(self) -> float:
        """The maximum ground distance the aircraft will travel while performing the weave cyces."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_max_distance_metadata)

    _set_max_distance_metadata = { "name" : "max_distance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_distance.setter
    def max_distance(self, newVal:float) -> None:
        return self._intf.set_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._set_max_distance_metadata, newVal)

    _get_control_limit_mode_metadata = { "name" : "control_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT),) }
    @property
    def control_limit_mode(self) -> "BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT":
        """Get the method to define the control limits of the aircraft during the maneuver."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_control_limit_mode_metadata)

    _get_control_limit_turn_radius_metadata = { "name" : "control_limit_turn_radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_turn_radius(self) -> float:
        """The specified turn radius for a control limit mode of specify min turn radius."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_control_limit_turn_radius_metadata)

    _get_control_limit_turn_rate_metadata = { "name" : "control_limit_turn_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_limit_turn_rate(self) -> typing.Any:
        """The specified turn rate for a control limit mode of specify max turn rate."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_control_limit_turn_rate_metadata)

    _get_control_limit_horiz_accel_metadata = { "name" : "control_limit_horiz_accel",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_limit_horiz_accel(self) -> float:
        """The specified horizontal acceleration for a control limit mode of specify max horiz accel."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_control_limit_horiz_accel_metadata)

    _set_control_limit_metadata = { "name" : "set_control_limit",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT), agmarshall.DOUBLE_arg,) }
    def set_control_limit(self, controlLimitMode:"BASIC_MANEUVER_STRATEGY_NAV_CONTROL_LIMIT", controlLimitValue:float) -> None:
        """Set the method and corresponding value to define the control limits of the aircraft during the maneuver."""
        return self._intf.invoke(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._set_control_limit_metadata, controlLimitMode, controlLimitValue)

    _get_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compensate_for_coriolis_accel(self) -> bool:
        """The option to compensate for the acceleration due to the Coriolis effect."""
        return self._intf.get_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._get_compensate_for_coriolis_accel_metadata)

    _set_compensate_for_coriolis_accel_metadata = { "name" : "compensate_for_coriolis_accel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compensate_for_coriolis_accel.setter
    def compensate_for_coriolis_accel(self, newVal:bool) -> None:
        return self._intf.set_property(IBasicManeuverStrategyWeave._metadata, IBasicManeuverStrategyWeave._set_compensate_for_coriolis_accel_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{3ec446e4-6454-4c4d-936c-7094ec85ddd0}", IBasicManeuverStrategyWeave)
agcls.AgTypeNameMap["IBasicManeuverStrategyWeave"] = IBasicManeuverStrategyWeave

class IBasicManeuverStrategyBallistic3D(object):
    """Interface used to access options for a balistic 3D strategy of a basic maneuver procedure."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{49C1E15C-785F-4C84-AA50-2B29256811A6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_control_mode" : 1,
                             "set_control_mode" : 2,
                             "get_airspeed_options" : 3,
                             "get_parachute_area" : 4,
                             "set_parachute_area" : 5,
                             "get_parachute_cd" : 6,
                             "set_parachute_cd" : 7,
                             "get_wind_force_effective_area" : 8,
                             "set_wind_force_effective_area" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyBallistic3D._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyBallistic3D from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyBallistic3D.__dict__ and type(IBasicManeuverStrategyBallistic3D.__dict__[attrname]) == property:
            return IBasicManeuverStrategyBallistic3D.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyBallistic3D.")
    
    _get_control_mode_metadata = { "name" : "control_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BALLISTIC_3D_CONTROL_MODE),) }
    @property
    def control_mode(self) -> "BALLISTIC_3D_CONTROL_MODE":
        """The control mode for the ballistic 3D strategy."""
        return self._intf.get_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._get_control_mode_metadata)

    _set_control_mode_metadata = { "name" : "control_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BALLISTIC_3D_CONTROL_MODE),) }
    @control_mode.setter
    def control_mode(self, newVal:"BALLISTIC_3D_CONTROL_MODE") -> None:
        """The control mode for the ballistic 3D strategy."""
        return self._intf.set_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._set_control_mode_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._get_airspeed_options_metadata)

    _get_parachute_area_metadata = { "name" : "parachute_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def parachute_area(self) -> float:
        """The parachute area used as part of the Parachute control mode for the ballistic 3D strategy."""
        return self._intf.get_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._get_parachute_area_metadata)

    _set_parachute_area_metadata = { "name" : "parachute_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @parachute_area.setter
    def parachute_area(self, newVal:float) -> None:
        """The parachute area used as part of the Parachute control mode for the ballistic 3D strategy."""
        return self._intf.set_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._set_parachute_area_metadata, newVal)

    _get_parachute_cd_metadata = { "name" : "parachute_cd",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def parachute_cd(self) -> float:
        """The parachute coefficient of drag used as part of the Parachute control mode for the ballistic 3D strategy."""
        return self._intf.get_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._get_parachute_cd_metadata)

    _set_parachute_cd_metadata = { "name" : "parachute_cd",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @parachute_cd.setter
    def parachute_cd(self, newVal:float) -> None:
        """The parachute coefficient of drag used as part of the Parachute control mode for the ballistic 3D strategy."""
        return self._intf.set_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._set_parachute_cd_metadata, newVal)

    _get_wind_force_effective_area_metadata = { "name" : "wind_force_effective_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wind_force_effective_area(self) -> float:
        """The vehicle's wind force effective area."""
        return self._intf.get_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._get_wind_force_effective_area_metadata)

    _set_wind_force_effective_area_metadata = { "name" : "wind_force_effective_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wind_force_effective_area.setter
    def wind_force_effective_area(self, newVal:float) -> None:
        """The vehicle's wind force effective area."""
        return self._intf.set_property(IBasicManeuverStrategyBallistic3D._metadata, IBasicManeuverStrategyBallistic3D._set_wind_force_effective_area_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{49C1E15C-785F-4C84-AA50-2B29256811A6}", IBasicManeuverStrategyBallistic3D)
agcls.AgTypeNameMap["IBasicManeuverStrategyBallistic3D"] = IBasicManeuverStrategyBallistic3D

class IBasicManeuverStrategyPitch3D(object):
    """Interface used to access options for a pitch 3D strategy of a basic maneuver procedure."""
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FF7B545D-B15A-46D9-BFB3-204C38672231}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_control_mode" : 1,
                             "set_control_mode" : 2,
                             "get_command_fpa" : 3,
                             "set_command_fpa" : 4,
                             "get_control_fpa_dot" : 5,
                             "set_control_fpa_dot" : 6,
                             "get_stop_when_fpa_achieved" : 7,
                             "set_stop_when_fpa_achieved" : 8,
                             "get_airspeed_options" : 9,
                             "get_wind_force_effective_area" : 10,
                             "set_wind_force_effective_area" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverStrategyPitch3D._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverStrategyPitch3D from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverStrategyPitch3D.__dict__ and type(IBasicManeuverStrategyPitch3D.__dict__[attrname]) == property:
            return IBasicManeuverStrategyPitch3D.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverStrategyPitch3D.")
    
    _get_control_mode_metadata = { "name" : "control_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PITCH_3D_CONTROL_MODE),) }
    @property
    def control_mode(self) -> "PITCH_3D_CONTROL_MODE":
        """The control mode for the pitch 3D strategy."""
        return self._intf.get_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._get_control_mode_metadata)

    _set_control_mode_metadata = { "name" : "control_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PITCH_3D_CONTROL_MODE),) }
    @control_mode.setter
    def control_mode(self, newVal:"PITCH_3D_CONTROL_MODE") -> None:
        """The control mode for the pitch 3D strategy."""
        return self._intf.set_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._set_control_mode_metadata, newVal)

    _get_command_fpa_metadata = { "name" : "command_fpa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def command_fpa(self) -> typing.Any:
        """The commanded flight path angle."""
        return self._intf.get_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._get_command_fpa_metadata)

    _set_command_fpa_metadata = { "name" : "command_fpa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @command_fpa.setter
    def command_fpa(self, newVal:typing.Any) -> None:
        """The commanded flight path angle."""
        return self._intf.set_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._set_command_fpa_metadata, newVal)

    _get_control_fpa_dot_metadata = { "name" : "control_fpa_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def control_fpa_dot(self) -> typing.Any:
        """The flight path angle rate."""
        return self._intf.get_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._get_control_fpa_dot_metadata)

    _set_control_fpa_dot_metadata = { "name" : "control_fpa_dot",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @control_fpa_dot.setter
    def control_fpa_dot(self, newVal:typing.Any) -> None:
        """The flight path angle rate."""
        return self._intf.set_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._set_control_fpa_dot_metadata, newVal)

    _get_stop_when_fpa_achieved_metadata = { "name" : "stop_when_fpa_achieved",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def stop_when_fpa_achieved(self) -> bool:
        """Stop when the commanded flight path angle is achieved."""
        return self._intf.get_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._get_stop_when_fpa_achieved_metadata)

    _set_stop_when_fpa_achieved_metadata = { "name" : "stop_when_fpa_achieved",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @stop_when_fpa_achieved.setter
    def stop_when_fpa_achieved(self, newVal:bool) -> None:
        """Stop when the commanded flight path angle is achieved."""
        return self._intf.set_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._set_stop_when_fpa_achieved_metadata, newVal)

    _get_airspeed_options_metadata = { "name" : "airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def airspeed_options(self) -> "BasicManeuverAirspeedOptions":
        """Get the airspeed options."""
        return self._intf.get_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._get_airspeed_options_metadata)

    _get_wind_force_effective_area_metadata = { "name" : "wind_force_effective_area",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def wind_force_effective_area(self) -> float:
        """The vehicle's wind force effective area."""
        return self._intf.get_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._get_wind_force_effective_area_metadata)

    _set_wind_force_effective_area_metadata = { "name" : "wind_force_effective_area",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @wind_force_effective_area.setter
    def wind_force_effective_area(self, newVal:float) -> None:
        """The vehicle's wind force effective area."""
        return self._intf.set_property(IBasicManeuverStrategyPitch3D._metadata, IBasicManeuverStrategyPitch3D._set_wind_force_effective_area_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{FF7B545D-B15A-46D9-BFB3-204C38672231}", IBasicManeuverStrategyPitch3D)
agcls.AgTypeNameMap["IBasicManeuverStrategyPitch3D"] = IBasicManeuverStrategyPitch3D

class IBasicManeuverTargetPositionVelNoisyBrnRng(object):
    """Interface used to access target position and velocity strategy, NoisyBrnRng."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{72B71952-ADE3-45E5-A567-B7EA0EFDE5F6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "new_random_engine_seed" : 1,
                             "get_smoothing_constant" : 2,
                             "set_smoothing_constant" : 3,
                             "get_velocity_time_step" : 4,
                             "set_velocity_time_step" : 5,
                             "get_angle_error_std_dev" : 6,
                             "set_angle_error_std_dev" : 7,
                             "get_range_error_std_dev" : 8,
                             "set_range_error_std_dev" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverTargetPositionVelNoisyBrnRng from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverTargetPositionVelNoisyBrnRng.__dict__ and type(IBasicManeuverTargetPositionVelNoisyBrnRng.__dict__[attrname]) == property:
            return IBasicManeuverTargetPositionVelNoisyBrnRng.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverTargetPositionVelNoisyBrnRng.")
    
    _new_random_engine_seed_metadata = { "name" : "new_random_engine_seed",
            "arg_types" : (),
            "marshallers" : () }
    def new_random_engine_seed(self) -> None:
        """method NewRandomEngineSeed"""
        return self._intf.invoke(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._new_random_engine_seed_metadata, )

    _get_smoothing_constant_metadata = { "name" : "smoothing_constant",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def smoothing_constant(self) -> float:
        """property SmoothingConstant"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._get_smoothing_constant_metadata)

    _set_smoothing_constant_metadata = { "name" : "smoothing_constant",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @smoothing_constant.setter
    def smoothing_constant(self, newVal:float) -> None:
        """property SmoothingConstant"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._set_smoothing_constant_metadata, newVal)

    _get_velocity_time_step_metadata = { "name" : "velocity_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def velocity_time_step(self) -> float:
        """property VelocityTimeStep"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._get_velocity_time_step_metadata)

    _set_velocity_time_step_metadata = { "name" : "velocity_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @velocity_time_step.setter
    def velocity_time_step(self, newVal:float) -> None:
        """property VelocityTimeStep"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._set_velocity_time_step_metadata, newVal)

    _get_angle_error_std_dev_metadata = { "name" : "angle_error_std_dev",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def angle_error_std_dev(self) -> float:
        """property AngleErrorStdDev"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._get_angle_error_std_dev_metadata)

    _set_angle_error_std_dev_metadata = { "name" : "angle_error_std_dev",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @angle_error_std_dev.setter
    def angle_error_std_dev(self, newVal:float) -> None:
        """property AngleErrorStdDev"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._set_angle_error_std_dev_metadata, newVal)

    _get_range_error_std_dev_metadata = { "name" : "range_error_std_dev",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range_error_std_dev(self) -> float:
        """property RangeErrorStdDev"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._get_range_error_std_dev_metadata)

    _set_range_error_std_dev_metadata = { "name" : "range_error_std_dev",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range_error_std_dev.setter
    def range_error_std_dev(self, newVal:float) -> None:
        """property RangeErrorStdDev"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisyBrnRng._metadata, IBasicManeuverTargetPositionVelNoisyBrnRng._set_range_error_std_dev_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{72B71952-ADE3-45E5-A567-B7EA0EFDE5F6}", IBasicManeuverTargetPositionVelNoisyBrnRng)
agcls.AgTypeNameMap["IBasicManeuverTargetPositionVelNoisyBrnRng"] = IBasicManeuverTargetPositionVelNoisyBrnRng

class IBasicManeuverTargetPositionVelNoisySurfTgt(object):
    """Interface used to access target position and velocity strategy, Surf Tgt Pos Vel."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E5391DAF-FEC9-4DC2-9726-C9B1B0A44BB6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "new_random_engine_seed" : 1,
                             "get_measurement_time_step" : 2,
                             "set_measurement_time_step" : 3,
                             "get_position_cep" : 4,
                             "set_position_cep" : 5,
                             "get_course_error" : 6,
                             "set_course_error" : 7,
                             "get_speed_error" : 8,
                             "set_speed_error" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IBasicManeuverTargetPositionVelNoisySurfTgt from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBasicManeuverTargetPositionVelNoisySurfTgt.__dict__ and type(IBasicManeuverTargetPositionVelNoisySurfTgt.__dict__[attrname]) == property:
            return IBasicManeuverTargetPositionVelNoisySurfTgt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBasicManeuverTargetPositionVelNoisySurfTgt.")
    
    _new_random_engine_seed_metadata = { "name" : "new_random_engine_seed",
            "arg_types" : (),
            "marshallers" : () }
    def new_random_engine_seed(self) -> None:
        """method NewRandomEngineSeed"""
        return self._intf.invoke(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._new_random_engine_seed_metadata, )

    _get_measurement_time_step_metadata = { "name" : "measurement_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def measurement_time_step(self) -> float:
        """property MeasurementTimeStep"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._get_measurement_time_step_metadata)

    _set_measurement_time_step_metadata = { "name" : "measurement_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @measurement_time_step.setter
    def measurement_time_step(self, newVal:float) -> None:
        """property MeasurementTimeStep"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._set_measurement_time_step_metadata, newVal)

    _get_position_cep_metadata = { "name" : "position_cep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def position_cep(self) -> float:
        """property PositionCEP"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._get_position_cep_metadata)

    _set_position_cep_metadata = { "name" : "position_cep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @position_cep.setter
    def position_cep(self, newVal:float) -> None:
        """property PositionCEP"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._set_position_cep_metadata, newVal)

    _get_course_error_metadata = { "name" : "course_error",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def course_error(self) -> float:
        """property CourseError"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._get_course_error_metadata)

    _set_course_error_metadata = { "name" : "course_error",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @course_error.setter
    def course_error(self, newVal:float) -> None:
        """property CourseError"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._set_course_error_metadata, newVal)

    _get_speed_error_metadata = { "name" : "speed_error",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def speed_error(self) -> float:
        """property SpeedError"""
        return self._intf.get_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._get_speed_error_metadata)

    _set_speed_error_metadata = { "name" : "speed_error",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @speed_error.setter
    def speed_error(self, newVal:float) -> None:
        """property SpeedError"""
        return self._intf.set_property(IBasicManeuverTargetPositionVelNoisySurfTgt._metadata, IBasicManeuverTargetPositionVelNoisySurfTgt._set_speed_error_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{E5391DAF-FEC9-4DC2-9726-C9B1B0A44BB6}", IBasicManeuverTargetPositionVelNoisySurfTgt)
agcls.AgTypeNameMap["IBasicManeuverTargetPositionVelNoisySurfTgt"] = IBasicManeuverTargetPositionVelNoisySurfTgt

class ITakeoffNormal(object):
    """The interface used to access the options for a Normal takeoff mode. The mode must be set to Normal to access this interface."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0a373629-d29b-4c4f-a59f-54fc567022cb}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_takeoff_climb_angle" : 1,
                             "set_takeoff_climb_angle" : 2,
                             "get_departure_altitude" : 3,
                             "set_departure_altitude" : 4,
                             "get_use_runway_terrain" : 5,
                             "set_use_runway_terrain" : 6,
                             "get_runway_altitude_offset" : 7,
                             "set_runway_altitude_offset" : 8,
                             "get_hold_on_deck" : 9,
                             "set_hold_on_deck" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ITakeoffNormal._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ITakeoffNormal from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITakeoffNormal.__dict__ and type(ITakeoffNormal.__dict__[attrname]) == property:
            return ITakeoffNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITakeoffNormal.")
    
    _get_takeoff_climb_angle_metadata = { "name" : "takeoff_climb_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def takeoff_climb_angle(self) -> typing.Any:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        return self._intf.get_property(ITakeoffNormal._metadata, ITakeoffNormal._get_takeoff_climb_angle_metadata)

    _set_takeoff_climb_angle_metadata = { "name" : "takeoff_climb_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @takeoff_climb_angle.setter
    def takeoff_climb_angle(self, inVal:typing.Any) -> None:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        return self._intf.set_property(ITakeoffNormal._metadata, ITakeoffNormal._set_takeoff_climb_angle_metadata, inVal)

    _get_departure_altitude_metadata = { "name" : "departure_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def departure_altitude(self) -> float:
        """The aircraft's altitude when it departs the runway."""
        return self._intf.get_property(ITakeoffNormal._metadata, ITakeoffNormal._get_departure_altitude_metadata)

    _set_departure_altitude_metadata = { "name" : "departure_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @departure_altitude.setter
    def departure_altitude(self, inVal:float) -> None:
        """The aircraft's altitude when it departs the runway."""
        return self._intf.set_property(ITakeoffNormal._metadata, ITakeoffNormal._set_departure_altitude_metadata, inVal)

    _get_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.get_property(ITakeoffNormal._metadata, ITakeoffNormal._get_use_runway_terrain_metadata)

    _set_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.set_property(ITakeoffNormal._metadata, ITakeoffNormal._set_use_runway_terrain_metadata, inVal)

    _get_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        return self._intf.get_property(ITakeoffNormal._metadata, ITakeoffNormal._get_runway_altitude_offset_metadata)

    _set_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        return self._intf.set_property(ITakeoffNormal._metadata, ITakeoffNormal._set_runway_altitude_offset_metadata, inVal)

    _get_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.get_property(ITakeoffNormal._metadata, ITakeoffNormal._get_hold_on_deck_metadata)

    _set_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.set_property(ITakeoffNormal._metadata, ITakeoffNormal._set_hold_on_deck_metadata, inVal)


agcls.AgClassCatalog.add_catalog_entry("{0a373629-d29b-4c4f-a59f-54fc567022cb}", ITakeoffNormal)
agcls.AgTypeNameMap["ITakeoffNormal"] = ITakeoffNormal

class ITakeoffDeparturePoint(object):
    """The interface used to access the options for a Departure Point takeoff mode. The mode must be set to Departure Point to access this interface."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{24e5949d-456b-4abb-9d46-7095d8ad0fb3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_takeoff_climb_angle" : 1,
                             "set_takeoff_climb_angle" : 2,
                             "get_departure_altitude" : 3,
                             "set_departure_altitude" : 4,
                             "get_departure_point_range" : 5,
                             "set_departure_point_range" : 6,
                             "get_use_runway_terrain" : 7,
                             "set_use_runway_terrain" : 8,
                             "get_runway_altitude_offset" : 9,
                             "set_runway_altitude_offset" : 10,
                             "get_hold_on_deck" : 11,
                             "set_hold_on_deck" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ITakeoffDeparturePoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ITakeoffDeparturePoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITakeoffDeparturePoint.__dict__ and type(ITakeoffDeparturePoint.__dict__[attrname]) == property:
            return ITakeoffDeparturePoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITakeoffDeparturePoint.")
    
    _get_takeoff_climb_angle_metadata = { "name" : "takeoff_climb_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def takeoff_climb_angle(self) -> typing.Any:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        return self._intf.get_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._get_takeoff_climb_angle_metadata)

    _set_takeoff_climb_angle_metadata = { "name" : "takeoff_climb_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @takeoff_climb_angle.setter
    def takeoff_climb_angle(self, inVal:typing.Any) -> None:
        """The angle at which the aircraft will climb from the procedure site to the departure point."""
        return self._intf.set_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._set_takeoff_climb_angle_metadata, inVal)

    _get_departure_altitude_metadata = { "name" : "departure_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def departure_altitude(self) -> float:
        """The aircraft's altitude when it departs the runway."""
        return self._intf.get_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._get_departure_altitude_metadata)

    _set_departure_altitude_metadata = { "name" : "departure_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @departure_altitude.setter
    def departure_altitude(self, inVal:float) -> None:
        """The aircraft's altitude when it departs the runway."""
        return self._intf.set_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._set_departure_altitude_metadata, inVal)

    _get_departure_point_range_metadata = { "name" : "departure_point_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def departure_point_range(self) -> float:
        """The downrange distance the aircraft will travel when departing the runway."""
        return self._intf.get_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._get_departure_point_range_metadata)

    _set_departure_point_range_metadata = { "name" : "departure_point_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @departure_point_range.setter
    def departure_point_range(self, inVal:float) -> None:
        """The downrange distance the aircraft will travel when departing the runway."""
        return self._intf.set_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._set_departure_point_range_metadata, inVal)

    _get_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.get_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._get_use_runway_terrain_metadata)

    _set_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.set_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._set_use_runway_terrain_metadata, inVal)

    _get_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        return self._intf.get_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._get_runway_altitude_offset_metadata)

    _set_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        return self._intf.set_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._set_runway_altitude_offset_metadata, inVal)

    _get_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.get_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._get_hold_on_deck_metadata)

    _set_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.set_property(ITakeoffDeparturePoint._metadata, ITakeoffDeparturePoint._set_hold_on_deck_metadata, inVal)


agcls.AgClassCatalog.add_catalog_entry("{24e5949d-456b-4abb-9d46-7095d8ad0fb3}", ITakeoffDeparturePoint)
agcls.AgTypeNameMap["ITakeoffDeparturePoint"] = ITakeoffDeparturePoint

class ITakeoffLowTransition(object):
    """The interface used to access the options for a Low Transition takeoff mode. The mode must be set to Low Transition to access this interface."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f205a7c2-5797-4e9f-aac6-7dfe110bcec0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_runway_terrain" : 1,
                             "set_use_runway_terrain" : 2,
                             "get_runway_altitude_offset" : 3,
                             "set_runway_altitude_offset" : 4,
                             "get_hold_on_deck" : 5,
                             "set_hold_on_deck" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ITakeoffLowTransition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ITakeoffLowTransition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITakeoffLowTransition.__dict__ and type(ITakeoffLowTransition.__dict__[attrname]) == property:
            return ITakeoffLowTransition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITakeoffLowTransition.")
    
    _get_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.get_property(ITakeoffLowTransition._metadata, ITakeoffLowTransition._get_use_runway_terrain_metadata)

    _set_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.set_property(ITakeoffLowTransition._metadata, ITakeoffLowTransition._set_use_runway_terrain_metadata, inVal)

    _get_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        return self._intf.get_property(ITakeoffLowTransition._metadata, ITakeoffLowTransition._get_runway_altitude_offset_metadata)

    _set_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        return self._intf.set_property(ITakeoffLowTransition._metadata, ITakeoffLowTransition._set_runway_altitude_offset_metadata, inVal)

    _get_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.get_property(ITakeoffLowTransition._metadata, ITakeoffLowTransition._get_hold_on_deck_metadata)

    _set_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.set_property(ITakeoffLowTransition._metadata, ITakeoffLowTransition._set_hold_on_deck_metadata, inVal)


agcls.AgClassCatalog.add_catalog_entry("{f205a7c2-5797-4e9f-aac6-7dfe110bcec0}", ITakeoffLowTransition)
agcls.AgTypeNameMap["ITakeoffLowTransition"] = ITakeoffLowTransition

class IReferenceStateForwardFlightOptions(object):
    """Interface used to access the forward flight options for a reference state procedure."""
    _num_methods = 33
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f5baa380-d776-4591-a9c6-4836d6919165}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_airspeed_type" : 1,
                             "get_airspeed" : 2,
                             "set_airspeed" : 3,
                             "get_altitude_rate" : 4,
                             "set_altitude_rate" : 5,
                             "get_flight_path_angle" : 6,
                             "set_flight_path_angle" : 7,
                             "get_tas_dot" : 8,
                             "get_groundspeed_dot" : 9,
                             "get_longitudinal_accel_type" : 10,
                             "set_longitudinal_accel" : 11,
                             "get_heading" : 12,
                             "set_heading" : 13,
                             "get_heading_is_magnetic" : 14,
                             "set_heading_is_magnetic" : 15,
                             "get_course" : 16,
                             "set_course" : 17,
                             "get_course_is_magnetic" : 18,
                             "set_course_is_magnetic" : 19,
                             "get_heading_dot" : 20,
                             "get_course_dot" : 21,
                             "get_lateral_accel_type" : 22,
                             "set_lateral_accel" : 23,
                             "get_roll_angle" : 24,
                             "set_roll_angle" : 25,
                             "get_aoa" : 26,
                             "set_aoa" : 27,
                             "get_sideslip" : 28,
                             "set_sideslip" : 29,
                             "get_pitch_rate" : 30,
                             "get_push_pull_g" : 31,
                             "get_attitude_rate_type" : 32,
                             "set_attitude_rate" : 33, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IReferenceStateForwardFlightOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateForwardFlightOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateForwardFlightOptions.__dict__ and type(IReferenceStateForwardFlightOptions.__dict__[attrname]) == property:
            return IReferenceStateForwardFlightOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateForwardFlightOptions.")
    
    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_airspeed_type_metadata)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_airspeed_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        return self._intf.invoke(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_airspeed_metadata, airspeedType, airspeed)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """The rate at which the aircraft will climb or descend."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_altitude_rate_metadata)

    _set_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The rate at which the aircraft will climb or descend."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_altitude_rate_metadata, newVal)

    _get_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def flight_path_angle(self) -> typing.Any:
        """The initial pitch angle of the flight path."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_flight_path_angle_metadata)

    _set_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The initial pitch angle of the flight path."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_flight_path_angle_metadata, newVal)

    _get_tas_dot_metadata = { "name" : "tas_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_tas_dot_metadata)

    _get_groundspeed_dot_metadata = { "name" : "groundspeed_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_groundspeed_dot_metadata)

    _get_longitudinal_accel_type_metadata = { "name" : "longitudinal_accel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE),) }
    @property
    def longitudinal_accel_type(self) -> "REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_longitudinal_accel_type_metadata)

    _set_longitudinal_accel_metadata = { "name" : "set_longitudinal_accel",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE), agmarshall.DOUBLE_arg,) }
    def set_longitudinal_accel(self, accelType:"REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        return self._intf.invoke(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_longitudinal_accel_metadata, accelType, value)

    _get_heading_metadata = { "name" : "heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_heading_metadata)

    _set_heading_metadata = { "name" : "heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_heading_metadata, newVal)

    _get_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_heading_is_magnetic_metadata)

    _set_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_heading_is_magnetic_metadata, newVal)

    _get_course_metadata = { "name" : "course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course(self) -> typing.Any:
        """The direction the aircraft is traveling."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_course_metadata)

    _set_course_metadata = { "name" : "course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The direction the aircraft is traveling."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_course_metadata, newVal)

    _get_course_is_magnetic_metadata = { "name" : "course_is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def course_is_magnetic(self) -> bool:
        """Opt whether to specify the course using magnetic North."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_course_is_magnetic_metadata)

    _set_course_is_magnetic_metadata = { "name" : "course_is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @course_is_magnetic.setter
    def course_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the course using magnetic North."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_course_is_magnetic_metadata, newVal)

    _get_heading_dot_metadata = { "name" : "heading_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_heading_dot_metadata)

    _get_course_dot_metadata = { "name" : "course_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_course_dot_metadata)

    _get_lateral_accel_type_metadata = { "name" : "lateral_accel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LATERAL_ACCEL_MODE),) }
    @property
    def lateral_accel_type(self) -> "REFERENCE_STATE_LATERAL_ACCEL_MODE":
        """The mode to specify the lateral acceleration."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_lateral_accel_type_metadata)

    _set_lateral_accel_metadata = { "name" : "set_lateral_accel",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LATERAL_ACCEL_MODE), agmarshall.VARIANT_arg,) }
    def set_lateral_accel(self, accelType:"REFERENCE_STATE_LATERAL_ACCEL_MODE", value:typing.Any) -> None:
        """Set the lateral acceleration."""
        return self._intf.invoke(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_lateral_accel_metadata, accelType, value)

    _get_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_angle(self) -> typing.Any:
        """The aircraft's bank angle."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_roll_angle_metadata)

    _set_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The aircraft's bank angle."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_roll_angle_metadata, newVal)

    _get_aoa_metadata = { "name" : "aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def aoa(self) -> typing.Any:
        """The aircraft's angle of attack."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_aoa_metadata)

    _set_aoa_metadata = { "name" : "aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The aircraft's angle of attack."""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_aoa_metadata, newVal)

    _get_sideslip_metadata = { "name" : "sideslip",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def sideslip(self) -> typing.Any:
        """The aircraft's yaw angle."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_sideslip_metadata)

    _set_sideslip_metadata = { "name" : "sideslip",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @sideslip.setter
    def sideslip(self, newVal:typing.Any) -> None:
        """The aircraft's yaw angle"""
        return self._intf.set_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_sideslip_metadata, newVal)

    _get_pitch_rate_metadata = { "name" : "pitch_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def pitch_rate(self) -> typing.Any:
        """The aircraft's pitch rate."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_pitch_rate_metadata)

    _get_push_pull_g_metadata = { "name" : "push_pull_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def push_pull_g(self) -> float:
        """The G force on the aircraft resulting from its attitude."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_push_pull_g_metadata)

    _get_attitude_rate_type_metadata = { "name" : "attitude_rate_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_ATTITUDE_MODE),) }
    @property
    def attitude_rate_type(self) -> "REFERENCE_STATE_ATTITUDE_MODE":
        """The mode to specify the vertical attitude rate."""
        return self._intf.get_property(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._get_attitude_rate_type_metadata)

    _set_attitude_rate_metadata = { "name" : "set_attitude_rate",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_ATTITUDE_MODE), agmarshall.VARIANT_arg,) }
    def set_attitude_rate(self, attitudeRateType:"REFERENCE_STATE_ATTITUDE_MODE", value:typing.Any) -> None:
        """Set the vertical attitude rate."""
        return self._intf.invoke(IReferenceStateForwardFlightOptions._metadata, IReferenceStateForwardFlightOptions._set_attitude_rate_metadata, attitudeRateType, value)


agcls.AgClassCatalog.add_catalog_entry("{f5baa380-d776-4591-a9c6-4836d6919165}", IReferenceStateForwardFlightOptions)
agcls.AgTypeNameMap["IReferenceStateForwardFlightOptions"] = IReferenceStateForwardFlightOptions

class IReferenceStateHoverOptions(object):
    """Interface used to access the hover options for a reference state procedure."""
    _num_methods = 28
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{42eb7689-e629-44f0-b832-44dcbecbeb3e}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_groundspeed" : 1,
                             "set_groundspeed" : 2,
                             "get_altitude_rate" : 3,
                             "set_altitude_rate" : 4,
                             "get_tas_dot" : 5,
                             "get_groundspeed_dot" : 6,
                             "get_longitudinal_accel_type" : 7,
                             "set_longitudinal_accel" : 8,
                             "get_heading" : 9,
                             "set_heading" : 10,
                             "get_heading_is_magnetic" : 11,
                             "set_heading_is_magnetic" : 12,
                             "get_course" : 13,
                             "set_course" : 14,
                             "get_course_is_magnetic" : 15,
                             "set_course_is_magnetic" : 16,
                             "get_heading_dot" : 17,
                             "set_heading_dot" : 18,
                             "get_course_dot" : 19,
                             "set_course_dot" : 20,
                             "get_roll_angle" : 21,
                             "set_roll_angle" : 22,
                             "get_aoa" : 23,
                             "set_aoa" : 24,
                             "get_pitch_rate" : 25,
                             "get_push_pull_g" : 26,
                             "get_attitude_rate_type" : 27,
                             "set_attitude_rate" : 28, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IReferenceStateHoverOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateHoverOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateHoverOptions.__dict__ and type(IReferenceStateHoverOptions.__dict__[attrname]) == property:
            return IReferenceStateHoverOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateHoverOptions.")
    
    _get_groundspeed_metadata = { "name" : "groundspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def groundspeed(self) -> float:
        """The aircraft's speed relative to the ground."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_groundspeed_metadata)

    _set_groundspeed_metadata = { "name" : "groundspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @groundspeed.setter
    def groundspeed(self, newVal:float) -> None:
        """The aircraft's speed relative to the ground."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_groundspeed_metadata, newVal)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """The rate at which the aircraft will climb or descend."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_altitude_rate_metadata)

    _set_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The rate at which the aircraft will climb or descend."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_altitude_rate_metadata, newVal)

    _get_tas_dot_metadata = { "name" : "tas_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_tas_dot_metadata)

    _get_groundspeed_dot_metadata = { "name" : "groundspeed_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_groundspeed_dot_metadata)

    _get_longitudinal_accel_type_metadata = { "name" : "longitudinal_accel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE),) }
    @property
    def longitudinal_accel_type(self) -> "REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_longitudinal_accel_type_metadata)

    _set_longitudinal_accel_metadata = { "name" : "set_longitudinal_accel",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE), agmarshall.DOUBLE_arg,) }
    def set_longitudinal_accel(self, accelType:"REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        return self._intf.invoke(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_longitudinal_accel_metadata, accelType, value)

    _get_heading_metadata = { "name" : "heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_heading_metadata)

    _set_heading_metadata = { "name" : "heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_heading_metadata, newVal)

    _get_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_heading_is_magnetic_metadata)

    _set_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_heading_is_magnetic_metadata, newVal)

    _get_course_metadata = { "name" : "course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course(self) -> typing.Any:
        """The direction the aircraft is traveling."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_course_metadata)

    _set_course_metadata = { "name" : "course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The direction the aircraft is traveling."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_course_metadata, newVal)

    _get_course_is_magnetic_metadata = { "name" : "course_is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def course_is_magnetic(self) -> bool:
        """Opt whether to specify the course using magnetic North."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_course_is_magnetic_metadata)

    _set_course_is_magnetic_metadata = { "name" : "course_is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @course_is_magnetic.setter
    def course_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the course using magnetic North."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_course_is_magnetic_metadata, newVal)

    _get_heading_dot_metadata = { "name" : "heading_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_heading_dot_metadata)

    _set_heading_dot_metadata = { "name" : "heading_dot",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading_dot.setter
    def heading_dot(self, newVal:typing.Any) -> None:
        """The heading rate of change."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_heading_dot_metadata, newVal)

    _get_course_dot_metadata = { "name" : "course_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_course_dot_metadata)

    _set_course_dot_metadata = { "name" : "course_dot",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @course_dot.setter
    def course_dot(self, newVal:typing.Any) -> None:
        """The course rate of change."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_course_dot_metadata, newVal)

    _get_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_angle(self) -> typing.Any:
        """The aircraft's bank angle."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_roll_angle_metadata)

    _set_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The aircraft's bank angle."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_roll_angle_metadata, newVal)

    _get_aoa_metadata = { "name" : "aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def aoa(self) -> typing.Any:
        """The aircraft's angle of attack."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_aoa_metadata)

    _set_aoa_metadata = { "name" : "aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The aircraft's angle of attack."""
        return self._intf.set_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_aoa_metadata, newVal)

    _get_pitch_rate_metadata = { "name" : "pitch_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def pitch_rate(self) -> typing.Any:
        """The aircraft's pitch rate."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_pitch_rate_metadata)

    _get_push_pull_g_metadata = { "name" : "push_pull_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def push_pull_g(self) -> float:
        """The G force on the aircraft resulting from its attitude."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_push_pull_g_metadata)

    _get_attitude_rate_type_metadata = { "name" : "attitude_rate_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_ATTITUDE_MODE),) }
    @property
    def attitude_rate_type(self) -> "REFERENCE_STATE_ATTITUDE_MODE":
        """The mode to specify the vertical attitude rate."""
        return self._intf.get_property(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._get_attitude_rate_type_metadata)

    _set_attitude_rate_metadata = { "name" : "set_attitude_rate",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_ATTITUDE_MODE), agmarshall.VARIANT_arg,) }
    def set_attitude_rate(self, attitudeRateType:"REFERENCE_STATE_ATTITUDE_MODE", value:typing.Any) -> None:
        """Set the vertical attitude rate."""
        return self._intf.invoke(IReferenceStateHoverOptions._metadata, IReferenceStateHoverOptions._set_attitude_rate_metadata, attitudeRateType, value)


agcls.AgClassCatalog.add_catalog_entry("{42eb7689-e629-44f0-b832-44dcbecbeb3e}", IReferenceStateHoverOptions)
agcls.AgTypeNameMap["IReferenceStateHoverOptions"] = IReferenceStateHoverOptions

class IReferenceStateWeightOnWheelsOptions(object):
    """Interface used to access the weight on wheels options for a reference state procedure."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{14db8803-47cd-4009-b496-13caaa53babe}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_groundspeed" : 1,
                             "set_groundspeed" : 2,
                             "get_tas_dot" : 3,
                             "get_groundspeed_dot" : 4,
                             "get_longitudinal_accel_type" : 5,
                             "set_longitudinal_accel" : 6,
                             "get_heading" : 7,
                             "set_heading" : 8,
                             "get_heading_is_magnetic" : 9,
                             "set_heading_is_magnetic" : 10,
                             "get_heading_dot" : 11,
                             "get_course_dot" : 12,
                             "get_lateral_accel_type" : 13,
                             "set_lateral_accel" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IReferenceStateWeightOnWheelsOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateWeightOnWheelsOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateWeightOnWheelsOptions.__dict__ and type(IReferenceStateWeightOnWheelsOptions.__dict__[attrname]) == property:
            return IReferenceStateWeightOnWheelsOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateWeightOnWheelsOptions.")
    
    _get_groundspeed_metadata = { "name" : "groundspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def groundspeed(self) -> float:
        """The aircraft's speed relative to the ground."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_groundspeed_metadata)

    _set_groundspeed_metadata = { "name" : "groundspeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @groundspeed.setter
    def groundspeed(self, newVal:float) -> None:
        """The aircraft's speed relative to the ground."""
        return self._intf.set_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._set_groundspeed_metadata, newVal)

    _get_tas_dot_metadata = { "name" : "tas_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_tas_dot_metadata)

    _get_groundspeed_dot_metadata = { "name" : "groundspeed_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_groundspeed_dot_metadata)

    _get_longitudinal_accel_type_metadata = { "name" : "longitudinal_accel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE),) }
    @property
    def longitudinal_accel_type(self) -> "REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_longitudinal_accel_type_metadata)

    _set_longitudinal_accel_metadata = { "name" : "set_longitudinal_accel",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE), agmarshall.DOUBLE_arg,) }
    def set_longitudinal_accel(self, accelType:"REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        return self._intf.invoke(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._set_longitudinal_accel_metadata, accelType, value)

    _get_heading_metadata = { "name" : "heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_heading_metadata)

    _set_heading_metadata = { "name" : "heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        return self._intf.set_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._set_heading_metadata, newVal)

    _get_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_heading_is_magnetic_metadata)

    _set_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.set_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._set_heading_is_magnetic_metadata, newVal)

    _get_heading_dot_metadata = { "name" : "heading_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_heading_dot_metadata)

    _get_course_dot_metadata = { "name" : "course_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_course_dot_metadata)

    _get_lateral_accel_type_metadata = { "name" : "lateral_accel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LATERAL_ACCEL_MODE),) }
    @property
    def lateral_accel_type(self) -> "REFERENCE_STATE_LATERAL_ACCEL_MODE":
        """The mode to specify the lateral acceleration."""
        return self._intf.get_property(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._get_lateral_accel_type_metadata)

    _set_lateral_accel_metadata = { "name" : "set_lateral_accel",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LATERAL_ACCEL_MODE), agmarshall.VARIANT_arg,) }
    def set_lateral_accel(self, accelType:"REFERENCE_STATE_LATERAL_ACCEL_MODE", value:typing.Any) -> None:
        """Set the lateral acceleration."""
        return self._intf.invoke(IReferenceStateWeightOnWheelsOptions._metadata, IReferenceStateWeightOnWheelsOptions._set_lateral_accel_metadata, accelType, value)


agcls.AgClassCatalog.add_catalog_entry("{14db8803-47cd-4009-b496-13caaa53babe}", IReferenceStateWeightOnWheelsOptions)
agcls.AgTypeNameMap["IReferenceStateWeightOnWheelsOptions"] = IReferenceStateWeightOnWheelsOptions

class IReferenceStateTakeoffLandingOptions(object):
    """Interface used to access the takeoff or landing options for a reference state procedure."""
    _num_methods = 33
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b510a16b-3a33-408e-bed8-33dd61b76617}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_airspeed_type" : 1,
                             "get_airspeed" : 2,
                             "set_airspeed" : 3,
                             "get_altitude_rate" : 4,
                             "set_altitude_rate" : 5,
                             "get_flight_path_angle" : 6,
                             "set_flight_path_angle" : 7,
                             "get_tas_dot" : 8,
                             "get_groundspeed_dot" : 9,
                             "get_longitudinal_accel_type" : 10,
                             "set_longitudinal_accel" : 11,
                             "get_heading" : 12,
                             "set_heading" : 13,
                             "get_heading_is_magnetic" : 14,
                             "set_heading_is_magnetic" : 15,
                             "get_course" : 16,
                             "set_course" : 17,
                             "get_course_is_magnetic" : 18,
                             "set_course_is_magnetic" : 19,
                             "get_heading_dot" : 20,
                             "get_course_dot" : 21,
                             "get_lateral_accel_type" : 22,
                             "set_lateral_accel" : 23,
                             "get_roll_angle" : 24,
                             "set_roll_angle" : 25,
                             "get_aoa" : 26,
                             "set_aoa" : 27,
                             "get_sideslip" : 28,
                             "set_sideslip" : 29,
                             "get_pitch_rate" : 30,
                             "get_push_pull_g" : 31,
                             "get_attitude_rate_type" : 32,
                             "set_attitude_rate" : 33, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IReferenceStateTakeoffLandingOptions._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IReferenceStateTakeoffLandingOptions from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IReferenceStateTakeoffLandingOptions.__dict__ and type(IReferenceStateTakeoffLandingOptions.__dict__[attrname]) == property:
            return IReferenceStateTakeoffLandingOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IReferenceStateTakeoffLandingOptions.")
    
    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_airspeed_type_metadata)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_airspeed_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        return self._intf.invoke(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_airspeed_metadata, airspeedType, airspeed)

    _get_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_rate(self) -> float:
        """The rate at which the aircraft will climb or descend."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_altitude_rate_metadata)

    _set_altitude_rate_metadata = { "name" : "altitude_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        """The rate at which the aircraft will climb or descend."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_altitude_rate_metadata, newVal)

    _get_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def flight_path_angle(self) -> typing.Any:
        """The initial pitch angle of the flight path."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_flight_path_angle_metadata)

    _set_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The initial pitch angle of the flight path."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_flight_path_angle_metadata, newVal)

    _get_tas_dot_metadata = { "name" : "tas_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tas_dot(self) -> float:
        """The true airspeed acceleration."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_tas_dot_metadata)

    _get_groundspeed_dot_metadata = { "name" : "groundspeed_dot",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def groundspeed_dot(self) -> float:
        """The groundspeed acceleration."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_groundspeed_dot_metadata)

    _get_longitudinal_accel_type_metadata = { "name" : "longitudinal_accel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE),) }
    @property
    def longitudinal_accel_type(self) -> "REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE":
        """The mode to specify the longitudinal acceleration."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_longitudinal_accel_type_metadata)

    _set_longitudinal_accel_metadata = { "name" : "set_longitudinal_accel",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE), agmarshall.DOUBLE_arg,) }
    def set_longitudinal_accel(self, accelType:"REFERENCE_STATE_LONGITUDINAL_ACCEL_MODE", value:float) -> None:
        """Set the longitudinal acceleration."""
        return self._intf.invoke(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_longitudinal_accel_metadata, accelType, value)

    _get_heading_metadata = { "name" : "heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading(self) -> typing.Any:
        """The direction the aircraft is pointing."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_heading_metadata)

    _set_heading_metadata = { "name" : "heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @heading.setter
    def heading(self, newVal:typing.Any) -> None:
        """The direction the aircraft is pointing."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_heading_metadata, newVal)

    _get_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def heading_is_magnetic(self) -> bool:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_heading_is_magnetic_metadata)

    _set_heading_is_magnetic_metadata = { "name" : "heading_is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @heading_is_magnetic.setter
    def heading_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the heading using magnetic North."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_heading_is_magnetic_metadata, newVal)

    _get_course_metadata = { "name" : "course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course(self) -> typing.Any:
        """The direction the aircraft is traveling."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_course_metadata)

    _set_course_metadata = { "name" : "course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @course.setter
    def course(self, newVal:typing.Any) -> None:
        """The direction the aircraft is traveling."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_course_metadata, newVal)

    _get_course_is_magnetic_metadata = { "name" : "course_is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def course_is_magnetic(self) -> bool:
        """Opt whether to specify the course using magnetic North."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_course_is_magnetic_metadata)

    _set_course_is_magnetic_metadata = { "name" : "course_is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @course_is_magnetic.setter
    def course_is_magnetic(self, newVal:bool) -> None:
        """Opt whether to specify the course using magnetic North."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_course_is_magnetic_metadata, newVal)

    _get_heading_dot_metadata = { "name" : "heading_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading_dot(self) -> typing.Any:
        """The heading rate of change."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_heading_dot_metadata)

    _get_course_dot_metadata = { "name" : "course_dot",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course_dot(self) -> typing.Any:
        """The course rate of change."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_course_dot_metadata)

    _get_lateral_accel_type_metadata = { "name" : "lateral_accel_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LATERAL_ACCEL_MODE),) }
    @property
    def lateral_accel_type(self) -> "REFERENCE_STATE_LATERAL_ACCEL_MODE":
        """The mode to specify the lateral acceleration."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_lateral_accel_type_metadata)

    _set_lateral_accel_metadata = { "name" : "set_lateral_accel",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_LATERAL_ACCEL_MODE), agmarshall.VARIANT_arg,) }
    def set_lateral_accel(self, accelType:"REFERENCE_STATE_LATERAL_ACCEL_MODE", value:typing.Any) -> None:
        """Set the lateral acceleration."""
        return self._intf.invoke(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_lateral_accel_metadata, accelType, value)

    _get_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def roll_angle(self) -> typing.Any:
        """The aircraft's bank angle."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_roll_angle_metadata)

    _set_roll_angle_metadata = { "name" : "roll_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @roll_angle.setter
    def roll_angle(self, newVal:typing.Any) -> None:
        """The aircraft's bank angle."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_roll_angle_metadata, newVal)

    _get_aoa_metadata = { "name" : "aoa",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def aoa(self) -> typing.Any:
        """The aircraft's angle of attack."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_aoa_metadata)

    _set_aoa_metadata = { "name" : "aoa",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @aoa.setter
    def aoa(self, newVal:typing.Any) -> None:
        """The aircraft's angle of attack."""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_aoa_metadata, newVal)

    _get_sideslip_metadata = { "name" : "sideslip",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def sideslip(self) -> typing.Any:
        """The aircraft's yaw angle."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_sideslip_metadata)

    _set_sideslip_metadata = { "name" : "sideslip",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @sideslip.setter
    def sideslip(self, newVal:typing.Any) -> None:
        """The aircraft's yaw angle"""
        return self._intf.set_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_sideslip_metadata, newVal)

    _get_pitch_rate_metadata = { "name" : "pitch_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def pitch_rate(self) -> typing.Any:
        """The aircraft's pitch rate."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_pitch_rate_metadata)

    _get_push_pull_g_metadata = { "name" : "push_pull_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def push_pull_g(self) -> float:
        """The G force on the aircraft resulting from its attitude."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_push_pull_g_metadata)

    _get_attitude_rate_type_metadata = { "name" : "attitude_rate_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_ATTITUDE_MODE),) }
    @property
    def attitude_rate_type(self) -> "REFERENCE_STATE_ATTITUDE_MODE":
        """The mode to specify the vertical attitude rate."""
        return self._intf.get_property(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._get_attitude_rate_type_metadata)

    _set_attitude_rate_metadata = { "name" : "set_attitude_rate",
            "arg_types" : (agcom.LONG, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_ATTITUDE_MODE), agmarshall.VARIANT_arg,) }
    def set_attitude_rate(self, attitudeRateType:"REFERENCE_STATE_ATTITUDE_MODE", value:typing.Any) -> None:
        """Set the vertical attitude rate."""
        return self._intf.invoke(IReferenceStateTakeoffLandingOptions._metadata, IReferenceStateTakeoffLandingOptions._set_attitude_rate_metadata, attitudeRateType, value)


agcls.AgClassCatalog.add_catalog_entry("{b510a16b-3a33-408e-bed8-33dd61b76617}", IReferenceStateTakeoffLandingOptions)
agcls.AgTypeNameMap["IReferenceStateTakeoffLandingOptions"] = IReferenceStateTakeoffLandingOptions

class ILandingEnterDownwindPattern(object):
    """The interface used to access the options for a Downwind Pattern approach mode for a landing procedure. The approach mode must be set to Downwind Pattern to access this interface."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6206fdbf-5eb3-41b4-8792-d562bb2ec92a}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_approach_fix_range" : 1,
                             "set_approach_fix_range" : 2,
                             "get_approach_fix_range_mode" : 3,
                             "set_approach_fix_range_mode" : 4,
                             "get_abeam_distance" : 5,
                             "set_abeam_distance" : 6,
                             "get_abeam_altitude" : 7,
                             "set_abeam_altitude" : 8,
                             "get_final_turn" : 9,
                             "set_final_turn" : 10,
                             "get_glideslope" : 11,
                             "set_glideslope" : 12,
                             "get_runway_altitude_offset" : 13,
                             "set_runway_altitude_offset" : 14,
                             "get_use_runway_terrain" : 15,
                             "set_use_runway_terrain" : 16,
                             "get_touch_and_go" : 17,
                             "set_touch_and_go" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ILandingEnterDownwindPattern._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ILandingEnterDownwindPattern from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILandingEnterDownwindPattern.__dict__ and type(ILandingEnterDownwindPattern.__dict__[attrname]) == property:
            return ILandingEnterDownwindPattern.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILandingEnterDownwindPattern.")
    
    _get_approach_fix_range_metadata = { "name" : "approach_fix_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def approach_fix_range(self) -> float:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_approach_fix_range_metadata)

    _set_approach_fix_range_metadata = { "name" : "approach_fix_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @approach_fix_range.setter
    def approach_fix_range(self, inVal:float) -> None:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_approach_fix_range_metadata, inVal)

    _get_approach_fix_range_mode_metadata = { "name" : "approach_fix_range_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LANDING_APPROACH_FIX_RANGE_MODE),) }
    @property
    def approach_fix_range_mode(self) -> "LANDING_APPROACH_FIX_RANGE_MODE":
        """The reference point on the runway for the Approach Fix Range."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_approach_fix_range_mode_metadata)

    _set_approach_fix_range_mode_metadata = { "name" : "approach_fix_range_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LANDING_APPROACH_FIX_RANGE_MODE),) }
    @approach_fix_range_mode.setter
    def approach_fix_range_mode(self, inVal:"LANDING_APPROACH_FIX_RANGE_MODE") -> None:
        """The reference point on the runway for the Approach Fix Range."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_approach_fix_range_mode_metadata, inVal)

    _get_abeam_distance_metadata = { "name" : "abeam_distance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def abeam_distance(self) -> float:
        """The distance from the runway that the aircraft will fly the parallel leg of the landing pattern."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_abeam_distance_metadata)

    _set_abeam_distance_metadata = { "name" : "abeam_distance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @abeam_distance.setter
    def abeam_distance(self, inVal:float) -> None:
        """The distance from the runway that the aircraft will fly the parallel leg of the landing pattern."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_abeam_distance_metadata, inVal)

    _get_abeam_altitude_metadata = { "name" : "abeam_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def abeam_altitude(self) -> float:
        """The altitude at which the aircraft will fly the parallel leg of the landing pattern."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_abeam_altitude_metadata)

    _set_abeam_altitude_metadata = { "name" : "abeam_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @abeam_altitude.setter
    def abeam_altitude(self, inVal:float) -> None:
        """The altitude at which the aircraft will fly the parallel leg of the landing pattern."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_abeam_altitude_metadata, inVal)

    _get_final_turn_metadata = { "name" : "final_turn",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @property
    def final_turn(self) -> "NAVIGATOR_TURN_DIRECTION":
        """The direction of the turn that the aircraft will make when it lines up over the runway to land."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_final_turn_metadata)

    _set_final_turn_metadata = { "name" : "final_turn",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @final_turn.setter
    def final_turn(self, inVal:"NAVIGATOR_TURN_DIRECTION") -> None:
        """The direction of the turn that the aircraft will make when it lines up over the runway to land."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_final_turn_metadata, inVal)

    _get_glideslope_metadata = { "name" : "glideslope",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def glideslope(self) -> typing.Any:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_glideslope_metadata)

    _set_glideslope_metadata = { "name" : "glideslope",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @glideslope.setter
    def glideslope(self, inVal:typing.Any) -> None:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_glideslope_metadata, inVal)

    _get_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_runway_altitude_offset_metadata)

    _set_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_runway_altitude_offset_metadata, inVal)

    _get_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_use_runway_terrain_metadata)

    _set_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_use_runway_terrain_metadata, inVal)

    _get_touch_and_go_metadata = { "name" : "touch_and_go",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def touch_and_go(self) -> bool:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        return self._intf.get_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._get_touch_and_go_metadata)

    _set_touch_and_go_metadata = { "name" : "touch_and_go",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @touch_and_go.setter
    def touch_and_go(self, inVal:bool) -> None:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        return self._intf.set_property(ILandingEnterDownwindPattern._metadata, ILandingEnterDownwindPattern._set_touch_and_go_metadata, inVal)


agcls.AgClassCatalog.add_catalog_entry("{6206fdbf-5eb3-41b4-8792-d562bb2ec92a}", ILandingEnterDownwindPattern)
agcls.AgTypeNameMap["ILandingEnterDownwindPattern"] = ILandingEnterDownwindPattern

class ILandingInterceptGlideslope(object):
    """The interface used to access the options for an Intercept Glideslope approach mode for a landing procedure. The approach mode must be set to Intercept Glideslope to access this interface."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{534bfa1e-99e8-4188-a66a-53166e8d6536}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_approach_fix_range" : 1,
                             "set_approach_fix_range" : 2,
                             "get_approach_fix_range_mode" : 3,
                             "set_approach_fix_range_mode" : 4,
                             "get_glideslope" : 5,
                             "set_glideslope" : 6,
                             "get_runway_altitude_offset" : 7,
                             "set_runway_altitude_offset" : 8,
                             "get_use_runway_terrain" : 9,
                             "set_use_runway_terrain" : 10,
                             "get_touch_and_go" : 11,
                             "set_touch_and_go" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ILandingInterceptGlideslope._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ILandingInterceptGlideslope from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILandingInterceptGlideslope.__dict__ and type(ILandingInterceptGlideslope.__dict__[attrname]) == property:
            return ILandingInterceptGlideslope.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILandingInterceptGlideslope.")
    
    _get_approach_fix_range_metadata = { "name" : "approach_fix_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def approach_fix_range(self) -> float:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        return self._intf.get_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._get_approach_fix_range_metadata)

    _set_approach_fix_range_metadata = { "name" : "approach_fix_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @approach_fix_range.setter
    def approach_fix_range(self, inVal:float) -> None:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        return self._intf.set_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._set_approach_fix_range_metadata, inVal)

    _get_approach_fix_range_mode_metadata = { "name" : "approach_fix_range_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LANDING_APPROACH_FIX_RANGE_MODE),) }
    @property
    def approach_fix_range_mode(self) -> "LANDING_APPROACH_FIX_RANGE_MODE":
        """The reference point on the runway for the Approach Fix Range."""
        return self._intf.get_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._get_approach_fix_range_mode_metadata)

    _set_approach_fix_range_mode_metadata = { "name" : "approach_fix_range_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LANDING_APPROACH_FIX_RANGE_MODE),) }
    @approach_fix_range_mode.setter
    def approach_fix_range_mode(self, inVal:"LANDING_APPROACH_FIX_RANGE_MODE") -> None:
        """The reference point on the runway for the Approach Fix Range."""
        return self._intf.set_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._set_approach_fix_range_mode_metadata, inVal)

    _get_glideslope_metadata = { "name" : "glideslope",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def glideslope(self) -> typing.Any:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        return self._intf.get_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._get_glideslope_metadata)

    _set_glideslope_metadata = { "name" : "glideslope",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @glideslope.setter
    def glideslope(self, inVal:typing.Any) -> None:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        return self._intf.set_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._set_glideslope_metadata, inVal)

    _get_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        return self._intf.get_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._get_runway_altitude_offset_metadata)

    _set_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        return self._intf.set_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._set_runway_altitude_offset_metadata, inVal)

    _get_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.get_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._get_use_runway_terrain_metadata)

    _set_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.set_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._set_use_runway_terrain_metadata, inVal)

    _get_touch_and_go_metadata = { "name" : "touch_and_go",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def touch_and_go(self) -> bool:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        return self._intf.get_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._get_touch_and_go_metadata)

    _set_touch_and_go_metadata = { "name" : "touch_and_go",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @touch_and_go.setter
    def touch_and_go(self, inVal:bool) -> None:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        return self._intf.set_property(ILandingInterceptGlideslope._metadata, ILandingInterceptGlideslope._set_touch_and_go_metadata, inVal)


agcls.AgClassCatalog.add_catalog_entry("{534bfa1e-99e8-4188-a66a-53166e8d6536}", ILandingInterceptGlideslope)
agcls.AgTypeNameMap["ILandingInterceptGlideslope"] = ILandingInterceptGlideslope

class ILandingStandardInstrumentApproach(object):
    """The interface used to access the options for a Standard Instrument Approach mode for a landing procedure. The approach mode must be set to Standard Instrument Approach to access this interface."""
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{28c196c4-2768-49ce-a384-d0c37394be0f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_approach_altitude" : 1,
                             "set_approach_altitude" : 2,
                             "get_level_off_mode" : 3,
                             "set_level_off_mode" : 4,
                             "get_approach_fix_range" : 5,
                             "set_approach_fix_range" : 6,
                             "get_approach_fix_range_mode" : 7,
                             "set_approach_fix_range_mode" : 8,
                             "get_glideslope" : 9,
                             "set_glideslope" : 10,
                             "get_runway_altitude_offset" : 11,
                             "set_runway_altitude_offset" : 12,
                             "get_use_runway_terrain" : 13,
                             "set_use_runway_terrain" : 14,
                             "get_touch_and_go" : 15,
                             "set_touch_and_go" : 16, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ILandingStandardInstrumentApproach._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ILandingStandardInstrumentApproach from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILandingStandardInstrumentApproach.__dict__ and type(ILandingStandardInstrumentApproach.__dict__[attrname]) == property:
            return ILandingStandardInstrumentApproach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ILandingStandardInstrumentApproach.")
    
    _get_approach_altitude_metadata = { "name" : "approach_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def approach_altitude(self) -> float:
        """The aircraft's altitude at the Initial Approach Fix Range."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_approach_altitude_metadata)

    _set_approach_altitude_metadata = { "name" : "approach_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @approach_altitude.setter
    def approach_altitude(self, inVal:float) -> None:
        """The aircraft's altitude at the Initial Approach Fix Range."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_approach_altitude_metadata, inVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, inVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_level_off_mode_metadata, inVal)

    _get_approach_fix_range_metadata = { "name" : "approach_fix_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def approach_fix_range(self) -> float:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_approach_fix_range_metadata)

    _set_approach_fix_range_metadata = { "name" : "approach_fix_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @approach_fix_range.setter
    def approach_fix_range(self, inVal:float) -> None:
        """The range from the reference point of the runway at which the aircraft begins its landing approach."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_approach_fix_range_metadata, inVal)

    _get_approach_fix_range_mode_metadata = { "name" : "approach_fix_range_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LANDING_APPROACH_FIX_RANGE_MODE),) }
    @property
    def approach_fix_range_mode(self) -> "LANDING_APPROACH_FIX_RANGE_MODE":
        """The reference point on the runway for the Approach Fix Range."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_approach_fix_range_mode_metadata)

    _set_approach_fix_range_mode_metadata = { "name" : "approach_fix_range_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LANDING_APPROACH_FIX_RANGE_MODE),) }
    @approach_fix_range_mode.setter
    def approach_fix_range_mode(self, inVal:"LANDING_APPROACH_FIX_RANGE_MODE") -> None:
        """The reference point on the runway for the Approach Fix Range."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_approach_fix_range_mode_metadata, inVal)

    _get_glideslope_metadata = { "name" : "glideslope",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def glideslope(self) -> typing.Any:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_glideslope_metadata)

    _set_glideslope_metadata = { "name" : "glideslope",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @glideslope.setter
    def glideslope(self, inVal:typing.Any) -> None:
        """The angle from the horizontal on which the aircraft descends to touchdown."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_glideslope_metadata, inVal)

    _get_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def runway_altitude_offset(self) -> float:
        """The altitude offset above the ground level."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_runway_altitude_offset_metadata)

    _set_runway_altitude_offset_metadata = { "name" : "runway_altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @runway_altitude_offset.setter
    def runway_altitude_offset(self, inVal:float) -> None:
        """The altitude offset above the ground level."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_runway_altitude_offset_metadata, inVal)

    _get_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_runway_terrain(self) -> bool:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_use_runway_terrain_metadata)

    _set_use_runway_terrain_metadata = { "name" : "use_runway_terrain",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_runway_terrain.setter
    def use_runway_terrain(self, inVal:bool) -> None:
        """Opt whether to use terrain data to define the runway's ground level attitude."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_use_runway_terrain_metadata, inVal)

    _get_touch_and_go_metadata = { "name" : "touch_and_go",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def touch_and_go(self) -> bool:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        return self._intf.get_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._get_touch_and_go_metadata)

    _set_touch_and_go_metadata = { "name" : "touch_and_go",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @touch_and_go.setter
    def touch_and_go(self, inVal:bool) -> None:
        """Opt whether to perform a Touch and Go landing. The procedure will stop at wheels down and can be immediately followed by a takeoff procedure."""
        return self._intf.set_property(ILandingStandardInstrumentApproach._metadata, ILandingStandardInstrumentApproach._set_touch_and_go_metadata, inVal)


agcls.AgClassCatalog.add_catalog_entry("{28c196c4-2768-49ce-a384-d0c37394be0f}", ILandingStandardInstrumentApproach)
agcls.AgTypeNameMap["ILandingStandardInstrumentApproach"] = ILandingStandardInstrumentApproach

class IProcedureBasicManeuver(object):
    """Interface used to access the options for a Basic Maneuver procedure"""
    _num_methods = 37
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7cf58344-514c-44a6-aaf0-a45c4472e299}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_max_time_of_flight" : 1,
                             "set_max_time_of_flight" : 2,
                             "get_use_max_time_of_flight" : 3,
                             "set_use_max_time_of_flight" : 4,
                             "get_stop_fuel_state" : 5,
                             "set_stop_fuel_state" : 6,
                             "get_use_stop_fuel_state" : 7,
                             "set_use_stop_fuel_state" : 8,
                             "get_max_downrange" : 9,
                             "set_max_downrange" : 10,
                             "get_use_max_downrange" : 11,
                             "set_use_max_downrange" : 12,
                             "get_altitude_limit_mode" : 13,
                             "set_altitude_limit_mode" : 14,
                             "get_terrain_impact_mode" : 15,
                             "set_terrain_impact_mode" : 16,
                             "get_terrain_impact_time_offset" : 17,
                             "set_terrain_impact_time_offset" : 18,
                             "get_navigation_strategy_type" : 19,
                             "set_navigation_strategy_type" : 20,
                             "get_navigation" : 21,
                             "get_profile_strategy_type" : 22,
                             "set_profile_strategy_type" : 23,
                             "get_profile" : 24,
                             "get_flight_mode" : 25,
                             "set_flight_mode" : 26,
                             "get_fuel_flow_type" : 27,
                             "set_fuel_flow_type" : 28,
                             "get_override_fuel_flow_value" : 29,
                             "set_override_fuel_flow_value" : 30,
                             "get_scale_fuel_flow" : 31,
                             "set_scale_fuel_flow" : 32,
                             "get_attitude_blend_time" : 33,
                             "set_attitude_blend_time" : 34,
                             "get_control_time_constant" : 35,
                             "set_control_time_constant" : 36,
                             "get_as_procedure" : 37, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureBasicManeuver._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureBasicManeuver from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureBasicManeuver.__dict__ and type(IProcedureBasicManeuver.__dict__[attrname]) == property:
            return IProcedureBasicManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureBasicManeuver.")
    
    _get_max_time_of_flight_metadata = { "name" : "max_time_of_flight",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_time_of_flight(self) -> typing.Any:
        """Get the max time of flight."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_max_time_of_flight_metadata)

    _set_max_time_of_flight_metadata = { "name" : "max_time_of_flight",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @max_time_of_flight.setter
    def max_time_of_flight(self, newVal:typing.Any) -> None:
        """Set the max time of flight."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_max_time_of_flight_metadata, newVal)

    _get_use_max_time_of_flight_metadata = { "name" : "use_max_time_of_flight",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_time_of_flight(self) -> bool:
        """Get whether to use max time of flight."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_use_max_time_of_flight_metadata)

    _set_use_max_time_of_flight_metadata = { "name" : "use_max_time_of_flight",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_max_time_of_flight.setter
    def use_max_time_of_flight(self, newVal:bool) -> None:
        """Set whether to use max time of flight."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_use_max_time_of_flight_metadata, newVal)

    _get_stop_fuel_state_metadata = { "name" : "stop_fuel_state",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_fuel_state(self) -> float:
        """Get the stop fuel state value."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_stop_fuel_state_metadata)

    _set_stop_fuel_state_metadata = { "name" : "stop_fuel_state",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_fuel_state.setter
    def stop_fuel_state(self, newVal:float) -> None:
        """Set the stop fuel state value."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_stop_fuel_state_metadata, newVal)

    _get_use_stop_fuel_state_metadata = { "name" : "use_stop_fuel_state",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_stop_fuel_state(self) -> bool:
        """Get whether to use stop fuel state."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_use_stop_fuel_state_metadata)

    _set_use_stop_fuel_state_metadata = { "name" : "use_stop_fuel_state",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_stop_fuel_state.setter
    def use_stop_fuel_state(self, newVal:bool) -> None:
        """Set whether to use stop fuel state."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_use_stop_fuel_state_metadata, newVal)

    _get_max_downrange_metadata = { "name" : "max_downrange",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_downrange(self) -> float:
        """Get the max down range."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_max_downrange_metadata)

    _set_max_downrange_metadata = { "name" : "max_downrange",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_downrange.setter
    def max_downrange(self, newVal:float) -> None:
        """Set the max down range."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_max_downrange_metadata, newVal)

    _get_use_max_downrange_metadata = { "name" : "use_max_downrange",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_downrange(self) -> bool:
        """Get whether to use max down range."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_use_max_downrange_metadata)

    _set_use_max_downrange_metadata = { "name" : "use_max_downrange",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_max_downrange.setter
    def use_max_downrange(self, newVal:bool) -> None:
        """Set whether to use max down range."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_use_max_downrange_metadata, newVal)

    _get_altitude_limit_mode_metadata = { "name" : "altitude_limit_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_ALTITUDE_LIMIT),) }
    @property
    def altitude_limit_mode(self) -> "BASIC_MANEUVER_ALTITUDE_LIMIT":
        """Get the altitude limit mode."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_altitude_limit_mode_metadata)

    _set_altitude_limit_mode_metadata = { "name" : "altitude_limit_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_ALTITUDE_LIMIT),) }
    @altitude_limit_mode.setter
    def altitude_limit_mode(self, newVal:"BASIC_MANEUVER_ALTITUDE_LIMIT") -> None:
        """Set the altitude limit mode."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_altitude_limit_mode_metadata, newVal)

    _get_terrain_impact_mode_metadata = { "name" : "terrain_impact_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_ALTITUDE_LIMIT),) }
    @property
    def terrain_impact_mode(self) -> "BASIC_MANEUVER_ALTITUDE_LIMIT":
        """Get the terrain impact mode."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_terrain_impact_mode_metadata)

    _set_terrain_impact_mode_metadata = { "name" : "terrain_impact_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_ALTITUDE_LIMIT),) }
    @terrain_impact_mode.setter
    def terrain_impact_mode(self, newVal:"BASIC_MANEUVER_ALTITUDE_LIMIT") -> None:
        """Set the terrain impact mode."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_terrain_impact_mode_metadata, newVal)

    _get_terrain_impact_time_offset_metadata = { "name" : "terrain_impact_time_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def terrain_impact_time_offset(self) -> float:
        """Get the terrain impact time offset."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_terrain_impact_time_offset_metadata)

    _set_terrain_impact_time_offset_metadata = { "name" : "terrain_impact_time_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @terrain_impact_time_offset.setter
    def terrain_impact_time_offset(self, newVal:float) -> None:
        """Set the terrain impact time offset."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_terrain_impact_time_offset_metadata, newVal)

    _get_navigation_strategy_type_metadata = { "name" : "navigation_strategy_type",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def navigation_strategy_type(self) -> str:
        """Get the navigation strategy type."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_navigation_strategy_type_metadata)

    _set_navigation_strategy_type_metadata = { "name" : "navigation_strategy_type",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @navigation_strategy_type.setter
    def navigation_strategy_type(self, newVal:str) -> None:
        """Set the navigation strategy type."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_navigation_strategy_type_metadata, newVal)

    _get_navigation_metadata = { "name" : "navigation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def navigation(self) -> "IBasicManeuverStrategy":
        """Get the interface for the navigation strategy."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_navigation_metadata)

    _get_profile_strategy_type_metadata = { "name" : "profile_strategy_type",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def profile_strategy_type(self) -> str:
        """Get the profile strategy type."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_profile_strategy_type_metadata)

    _set_profile_strategy_type_metadata = { "name" : "profile_strategy_type",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @profile_strategy_type.setter
    def profile_strategy_type(self, newVal:str) -> None:
        """Set the profile strategy type."""
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_profile_strategy_type_metadata, newVal)

    _get_profile_metadata = { "name" : "profile",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def profile(self) -> "IBasicManeuverStrategy":
        """Get the interface for the profile strategy."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_profile_metadata)

    _get_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @property
    def flight_mode(self) -> "PHASE_OF_FLIGHT":
        """The type of performance model  that the aircraft will use to fly the maneuver."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_flight_mode_metadata)

    _set_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @flight_mode.setter
    def flight_mode(self, newVal:"PHASE_OF_FLIGHT") -> None:
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_flight_mode_metadata, newVal)

    _get_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_FUEL_FLOW_TYPE),) }
    @property
    def fuel_flow_type(self) -> "BASIC_MANEUVER_FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_fuel_flow_type_metadata)

    _set_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_FUEL_FLOW_TYPE),) }
    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"BASIC_MANEUVER_FUEL_FLOW_TYPE") -> None:
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_fuel_flow_type_metadata, newVal)

    _get_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_override_fuel_flow_value_metadata)

    _set_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_override_fuel_flow_value_metadata, newVal)

    _get_scale_fuel_flow_metadata = { "name" : "scale_fuel_flow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def scale_fuel_flow(self) -> bool:
        """Opt whether to scale the fuel flow based on the aircraft's actual attitude."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_scale_fuel_flow_metadata)

    _set_scale_fuel_flow_metadata = { "name" : "scale_fuel_flow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @scale_fuel_flow.setter
    def scale_fuel_flow(self, pVal:bool) -> None:
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_scale_fuel_flow_metadata, pVal)

    _get_attitude_blend_time_metadata = { "name" : "attitude_blend_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def attitude_blend_time(self) -> float:
        """The amount of time that the aircraft will spend transitioning from the attitude of the previous maneuver to the attitude at the beginning of the current maneuver."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_attitude_blend_time_metadata)

    _set_attitude_blend_time_metadata = { "name" : "attitude_blend_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @attitude_blend_time.setter
    def attitude_blend_time(self, newVal:float) -> None:
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_attitude_blend_time_metadata, newVal)

    _get_control_time_constant_metadata = { "name" : "control_time_constant",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def control_time_constant(self) -> float:
        """A smoothing constant for the performance of control surfaces."""
        return self._intf.get_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_control_time_constant_metadata)

    _set_control_time_constant_metadata = { "name" : "control_time_constant",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @control_time_constant.setter
    def control_time_constant(self, newVal:float) -> None:
        return self._intf.set_property(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._set_control_time_constant_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureBasicManeuver._metadata, IProcedureBasicManeuver._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7cf58344-514c-44a6-aaf0-a45c4472e299}", IProcedureBasicManeuver)
agcls.AgTypeNameMap["IProcedureBasicManeuver"] = IProcedureBasicManeuver

class ISiteWaypoint(object):
    """Interface used to access the options for a waypoint site."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{caca5c56-6c49-4de7-ae28-8361d3f8cdee}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_latitude" : 1,
                             "set_latitude" : 2,
                             "get_longitude" : 3,
                             "set_longitude" : 4,
                             "get_as_site" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteWaypoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteWaypoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteWaypoint.__dict__ and type(ISiteWaypoint.__dict__[attrname]) == property:
            return ISiteWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteWaypoint.")
    
    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def latitude(self) -> typing.Any:
        """The waypoint latitude."""
        return self._intf.get_property(ISiteWaypoint._metadata, ISiteWaypoint._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The waypoint latitude."""
        return self._intf.set_property(ISiteWaypoint._metadata, ISiteWaypoint._set_latitude_metadata, newVal)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def longitude(self) -> typing.Any:
        """The waypoint longitude."""
        return self._intf.get_property(ISiteWaypoint._metadata, ISiteWaypoint._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The waypoint longitude."""
        return self._intf.set_property(ISiteWaypoint._metadata, ISiteWaypoint._set_longitude_metadata, newVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteWaypoint._metadata, ISiteWaypoint._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{caca5c56-6c49-4de7-ae28-8361d3f8cdee}", ISiteWaypoint)
agcls.AgTypeNameMap["ISiteWaypoint"] = ISiteWaypoint

class ISiteEndOfPrevProcedure(object):
    """Interface used to access the options for an End of Previous Procedure site type."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{338fad56-1c3d-4572-97e4-24e01b1d7e65}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_site" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteEndOfPrevProcedure._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteEndOfPrevProcedure from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteEndOfPrevProcedure.__dict__ and type(ISiteEndOfPrevProcedure.__dict__[attrname]) == property:
            return ISiteEndOfPrevProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteEndOfPrevProcedure.")
    
    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteEndOfPrevProcedure._metadata, ISiteEndOfPrevProcedure._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{338fad56-1c3d-4572-97e4-24e01b1d7e65}", ISiteEndOfPrevProcedure)
agcls.AgTypeNameMap["ISiteEndOfPrevProcedure"] = ISiteEndOfPrevProcedure

class ISiteVTOLPoint(object):
    """Interface used to access the options for a VTOL Point site."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{168a5693-2f2c-4db8-822e-dd3571fe8fac}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_latitude" : 1,
                             "set_latitude" : 2,
                             "get_longitude" : 3,
                             "set_longitude" : 4,
                             "get_altitude" : 5,
                             "set_altitude" : 6,
                             "get_altitude_reference" : 7,
                             "set_altitude_reference" : 8,
                             "get_as_site" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteVTOLPoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteVTOLPoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteVTOLPoint.__dict__ and type(ISiteVTOLPoint.__dict__[attrname]) == property:
            return ISiteVTOLPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteVTOLPoint.")
    
    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def latitude(self) -> typing.Any:
        """The VTOL Point latitude."""
        return self._intf.get_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The VTOL Point latitude."""
        return self._intf.set_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._set_latitude_metadata, newVal)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def longitude(self) -> typing.Any:
        """The VTOL Point longitude."""
        return self._intf.get_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The VTOL Point longitude."""
        return self._intf.set_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._set_longitude_metadata, newVal)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The altitude for the site."""
        return self._intf.get_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the site."""
        return self._intf.set_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._set_altitude_metadata, newVal)

    _get_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @property
    def altitude_reference(self) -> "AGL_MSL":
        """The altitude reference."""
        return self._intf.get_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._get_altitude_reference_metadata)

    _set_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @altitude_reference.setter
    def altitude_reference(self, newVal:"AGL_MSL") -> None:
        """The altitude reference."""
        return self._intf.set_property(ISiteVTOLPoint._metadata, ISiteVTOLPoint._set_altitude_reference_metadata, newVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteVTOLPoint._metadata, ISiteVTOLPoint._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{168a5693-2f2c-4db8-822e-dd3571fe8fac}", ISiteVTOLPoint)
agcls.AgTypeNameMap["ISiteVTOLPoint"] = ISiteVTOLPoint

class ISiteSTKVehicle(object):
    """Interface used to access the options for a STK Vehicle site."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a0260a3b-b3fc-48e8-8708-01c1d9edc6c5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_object_name" : 1,
                             "set_object_name" : 2,
                             "get_valid_object_names" : 3,
                             "get_as_site" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteSTKVehicle._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKVehicle from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKVehicle.__dict__ and type(ISiteSTKVehicle.__dict__[attrname]) == property:
            return ISiteSTKVehicle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKVehicle.")
    
    _get_object_name_metadata = { "name" : "object_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        return self._intf.get_property(ISiteSTKVehicle._metadata, ISiteSTKVehicle._get_object_name_metadata)

    _set_object_name_metadata = { "name" : "object_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        return self._intf.set_property(ISiteSTKVehicle._metadata, ISiteSTKVehicle._set_object_name_metadata, newVal)

    _get_valid_object_names_metadata = { "name" : "valid_object_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        return self._intf.get_property(ISiteSTKVehicle._metadata, ISiteSTKVehicle._get_valid_object_names_metadata)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteSTKVehicle._metadata, ISiteSTKVehicle._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{a0260a3b-b3fc-48e8-8708-01c1d9edc6c5}", ISiteSTKVehicle)
agcls.AgTypeNameMap["ISiteSTKVehicle"] = ISiteSTKVehicle

class ISiteReferenceState(object):
    """Interface used to access the options for a Reference State site."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3366da2b-74d8-47ef-8578-a304409e9401}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_site" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteReferenceState._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteReferenceState from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteReferenceState.__dict__ and type(ISiteReferenceState.__dict__[attrname]) == property:
            return ISiteReferenceState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteReferenceState.")
    
    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteReferenceState._metadata, ISiteReferenceState._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{3366da2b-74d8-47ef-8578-a304409e9401}", ISiteReferenceState)
agcls.AgTypeNameMap["ISiteReferenceState"] = ISiteReferenceState

class ISiteSuperProcedure(object):
    """Interface used to access the options for a Super Procedure site."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0f56f3fe-b661-4d53-84f6-14df85184626}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_site" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteSuperProcedure._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteSuperProcedure from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSuperProcedure.__dict__ and type(ISiteSuperProcedure.__dict__[attrname]) == property:
            return ISiteSuperProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSuperProcedure.")
    
    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteSuperProcedure._metadata, ISiteSuperProcedure._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{0f56f3fe-b661-4d53-84f6-14df85184626}", ISiteSuperProcedure)
agcls.AgTypeNameMap["ISiteSuperProcedure"] = ISiteSuperProcedure

class ISiteRelToPrevProcedure(object):
    """Interface used to access the options for a Relative to Previous Procedure site."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5875fefc-17f1-4fed-a7d8-cde213515f2b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_bearing_mode" : 1,
                             "set_bearing_mode" : 2,
                             "get_bearing" : 3,
                             "set_bearing" : 4,
                             "get_range" : 5,
                             "set_range" : 6,
                             "get_as_site" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteRelToPrevProcedure._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteRelToPrevProcedure from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRelToPrevProcedure.__dict__ and type(ISiteRelToPrevProcedure.__dict__[attrname]) == property:
            return ISiteRelToPrevProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRelToPrevProcedure.")
    
    _get_bearing_mode_metadata = { "name" : "bearing_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REL_ABS_BEARING),) }
    @property
    def bearing_mode(self) -> "REL_ABS_BEARING":
        """The bearing reference."""
        return self._intf.get_property(ISiteRelToPrevProcedure._metadata, ISiteRelToPrevProcedure._get_bearing_mode_metadata)

    _set_bearing_mode_metadata = { "name" : "bearing_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(REL_ABS_BEARING),) }
    @bearing_mode.setter
    def bearing_mode(self, newVal:"REL_ABS_BEARING") -> None:
        """The bearing reference."""
        return self._intf.set_property(ISiteRelToPrevProcedure._metadata, ISiteRelToPrevProcedure._set_bearing_mode_metadata, newVal)

    _get_bearing_metadata = { "name" : "bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bearing(self) -> typing.Any:
        """The bearing to define the site."""
        return self._intf.get_property(ISiteRelToPrevProcedure._metadata, ISiteRelToPrevProcedure._get_bearing_metadata)

    _set_bearing_metadata = { "name" : "bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing to define the site."""
        return self._intf.set_property(ISiteRelToPrevProcedure._metadata, ISiteRelToPrevProcedure._set_bearing_metadata, newVal)

    _get_range_metadata = { "name" : "range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range(self) -> float:
        """The range from the previous procedure."""
        return self._intf.get_property(ISiteRelToPrevProcedure._metadata, ISiteRelToPrevProcedure._get_range_metadata)

    _set_range_metadata = { "name" : "range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range.setter
    def range(self, newVal:float) -> None:
        """The range from the previous procedure."""
        return self._intf.set_property(ISiteRelToPrevProcedure._metadata, ISiteRelToPrevProcedure._set_range_metadata, newVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteRelToPrevProcedure._metadata, ISiteRelToPrevProcedure._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{5875fefc-17f1-4fed-a7d8-cde213515f2b}", ISiteRelToPrevProcedure)
agcls.AgTypeNameMap["ISiteRelToPrevProcedure"] = ISiteRelToPrevProcedure

class ISiteSTKObjectWaypoint(object):
    """Interface used to access the options for a STK Object Waypoint site."""
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b6021d54-bf89-41b2-a5bc-0ee0c064a0f3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_object_name" : 1,
                             "set_object_name" : 2,
                             "get_valid_object_names" : 3,
                             "get_min_time" : 4,
                             "get_waypoint_time" : 5,
                             "set_waypoint_time" : 6,
                             "get_minimize_site_proc_time_diff" : 7,
                             "set_minimize_site_proc_time_diff" : 8,
                             "get_max_time" : 9,
                             "get_offset_mode" : 10,
                             "set_offset_mode" : 11,
                             "get_bearing" : 12,
                             "set_bearing" : 13,
                             "get_use_magnetic_bearing" : 14,
                             "set_use_magnetic_bearing" : 15,
                             "get_range" : 16,
                             "set_range" : 17,
                             "get_vgt_point" : 18,
                             "set_vgt_point" : 19,
                             "get_as_site" : 20, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteSTKObjectWaypoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKObjectWaypoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKObjectWaypoint.__dict__ and type(ISiteSTKObjectWaypoint.__dict__[attrname]) == property:
            return ISiteSTKObjectWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKObjectWaypoint.")
    
    _get_object_name_metadata = { "name" : "object_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_object_name_metadata)

    _set_object_name_metadata = { "name" : "object_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_object_name_metadata, newVal)

    _get_valid_object_names_metadata = { "name" : "valid_object_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_valid_object_names_metadata)

    _get_min_time_metadata = { "name" : "min_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def min_time(self) -> typing.Any:
        """The earliest time that the object is available as a site."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_min_time_metadata)

    _get_waypoint_time_metadata = { "name" : "waypoint_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def waypoint_time(self) -> typing.Any:
        """The time at which the object's position will be used as a waypoint."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_waypoint_time_metadata)

    _set_waypoint_time_metadata = { "name" : "waypoint_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @waypoint_time.setter
    def waypoint_time(self, newVal:typing.Any) -> None:
        """The time at which the object's position will be used as a waypoint."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_waypoint_time_metadata, newVal)

    _get_minimize_site_proc_time_diff_metadata = { "name" : "minimize_site_proc_time_diff",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(MINIMIZE_SITE_PROC_TIME_DIFF),) }
    @property
    def minimize_site_proc_time_diff(self) -> "MINIMIZE_SITE_PROC_TIME_DIFF":
        """The mode to minimize the time difference between the procedure and site times."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_minimize_site_proc_time_diff_metadata)

    _set_minimize_site_proc_time_diff_metadata = { "name" : "minimize_site_proc_time_diff",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(MINIMIZE_SITE_PROC_TIME_DIFF),) }
    @minimize_site_proc_time_diff.setter
    def minimize_site_proc_time_diff(self, newVal:"MINIMIZE_SITE_PROC_TIME_DIFF") -> None:
        """The mode to minimize the time difference between the procedure and site times."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_minimize_site_proc_time_diff_metadata, newVal)

    _get_max_time_metadata = { "name" : "max_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def max_time(self) -> typing.Any:
        """The latest time that the object is available as a site."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_max_time_metadata)

    _get_offset_mode_metadata = { "name" : "offset_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(STK_OBJECT_WAYPOINT_OFFSET_MODE),) }
    @property
    def offset_mode(self) -> "STK_OBJECT_WAYPOINT_OFFSET_MODE":
        """The mode to offset the site location relative from the STK Object."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_offset_mode_metadata)

    _set_offset_mode_metadata = { "name" : "offset_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(STK_OBJECT_WAYPOINT_OFFSET_MODE),) }
    @offset_mode.setter
    def offset_mode(self, newVal:"STK_OBJECT_WAYPOINT_OFFSET_MODE") -> None:
        """The mode to offset the site location relative from the STK Object."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_offset_mode_metadata, newVal)

    _get_bearing_metadata = { "name" : "bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bearing(self) -> typing.Any:
        """The bearing offset of the site location relative to the object's position."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_bearing_metadata)

    _set_bearing_metadata = { "name" : "bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing offset of the site location relative to the object's position."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_bearing_metadata, newVal)

    _get_use_magnetic_bearing_metadata = { "name" : "use_magnetic_bearing",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_bearing(self) -> bool:
        """The option to use a magnetic heading for the bearing."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_use_magnetic_bearing_metadata)

    _set_use_magnetic_bearing_metadata = { "name" : "use_magnetic_bearing",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_bearing.setter
    def use_magnetic_bearing(self, newVal:bool) -> None:
        """The option to use a magnetic heading for the bearing."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_use_magnetic_bearing_metadata, newVal)

    _get_range_metadata = { "name" : "range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range(self) -> float:
        """The range offset of the site location relative to the object's position."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_range_metadata)

    _set_range_metadata = { "name" : "range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range.setter
    def range(self, newVal:float) -> None:
        """The range offset of the site location relative to the object's position."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_range_metadata, newVal)

    _get_vgt_point_metadata = { "name" : "vgt_point",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def vgt_point(self) -> str:
        """The reference VGT Point."""
        return self._intf.get_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_vgt_point_metadata)

    _set_vgt_point_metadata = { "name" : "vgt_point",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @vgt_point.setter
    def vgt_point(self, newVal:str) -> None:
        """The reference VGT Point."""
        return self._intf.set_property(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._set_vgt_point_metadata, newVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteSTKObjectWaypoint._metadata, ISiteSTKObjectWaypoint._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{b6021d54-bf89-41b2-a5bc-0ee0c064a0f3}", ISiteSTKObjectWaypoint)
agcls.AgTypeNameMap["ISiteSTKObjectWaypoint"] = ISiteSTKObjectWaypoint

class ISiteSTKStaticObject(object):
    """Interface used to access the options for a STK Static Object site."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b9b132d7-25a7-49c2-8f68-945ef572a4fe}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_object_name" : 1,
                             "set_object_name" : 2,
                             "get_valid_object_names" : 3,
                             "get_as_site" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteSTKStaticObject._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKStaticObject from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKStaticObject.__dict__ and type(ISiteSTKStaticObject.__dict__[attrname]) == property:
            return ISiteSTKStaticObject.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKStaticObject.")
    
    _get_object_name_metadata = { "name" : "object_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        return self._intf.get_property(ISiteSTKStaticObject._metadata, ISiteSTKStaticObject._get_object_name_metadata)

    _set_object_name_metadata = { "name" : "object_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        return self._intf.set_property(ISiteSTKStaticObject._metadata, ISiteSTKStaticObject._set_object_name_metadata, newVal)

    _get_valid_object_names_metadata = { "name" : "valid_object_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        return self._intf.get_property(ISiteSTKStaticObject._metadata, ISiteSTKStaticObject._get_valid_object_names_metadata)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteSTKStaticObject._metadata, ISiteSTKStaticObject._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{b9b132d7-25a7-49c2-8f68-945ef572a4fe}", ISiteSTKStaticObject)
agcls.AgTypeNameMap["ISiteSTKStaticObject"] = ISiteSTKStaticObject

class ISiteRelToSTKObject(object):
    """Interface used to access the options for a Relative to Stationary STK Object site."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b0257931-faca-477d-a0a1-9f36cbbb5c7f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_object_name" : 1,
                             "set_object_name" : 2,
                             "get_valid_object_names" : 3,
                             "get_bearing" : 4,
                             "set_bearing" : 5,
                             "get_use_magnetic_bearing" : 6,
                             "set_use_magnetic_bearing" : 7,
                             "get_range" : 8,
                             "set_range" : 9,
                             "get_as_site" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteRelToSTKObject._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteRelToSTKObject from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRelToSTKObject.__dict__ and type(ISiteRelToSTKObject.__dict__[attrname]) == property:
            return ISiteRelToSTKObject.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRelToSTKObject.")
    
    _get_object_name_metadata = { "name" : "object_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        return self._intf.get_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._get_object_name_metadata)

    _set_object_name_metadata = { "name" : "object_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        return self._intf.set_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._set_object_name_metadata, newVal)

    _get_valid_object_names_metadata = { "name" : "valid_object_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        return self._intf.get_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._get_valid_object_names_metadata)

    _get_bearing_metadata = { "name" : "bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bearing(self) -> typing.Any:
        """The bearing from the STK object."""
        return self._intf.get_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._get_bearing_metadata)

    _set_bearing_metadata = { "name" : "bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing from the STK object."""
        return self._intf.set_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._set_bearing_metadata, newVal)

    _get_use_magnetic_bearing_metadata = { "name" : "use_magnetic_bearing",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_bearing(self) -> bool:
        """The option to use a magnetic bearing."""
        return self._intf.get_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._get_use_magnetic_bearing_metadata)

    _set_use_magnetic_bearing_metadata = { "name" : "use_magnetic_bearing",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_bearing.setter
    def use_magnetic_bearing(self, newVal:bool) -> None:
        """The option to use a magnetic bearing."""
        return self._intf.set_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._set_use_magnetic_bearing_metadata, newVal)

    _get_range_metadata = { "name" : "range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range(self) -> float:
        """The range from the STK object."""
        return self._intf.get_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._get_range_metadata)

    _set_range_metadata = { "name" : "range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range.setter
    def range(self, newVal:float) -> None:
        """The range from the STK object."""
        return self._intf.set_property(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._set_range_metadata, newVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteRelToSTKObject._metadata, ISiteRelToSTKObject._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{b0257931-faca-477d-a0a1-9f36cbbb5c7f}", ISiteRelToSTKObject)
agcls.AgTypeNameMap["ISiteRelToSTKObject"] = ISiteRelToSTKObject

class ISiteSTKAreaTarget(object):
    """Interface used to access the options for a STK Area Target site."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{38dbad68-357f-4129-b8fb-3fbecd506e23}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_object_name" : 1,
                             "set_object_name" : 2,
                             "get_valid_object_names" : 3,
                             "get_as_site" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteSTKAreaTarget._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteSTKAreaTarget from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteSTKAreaTarget.__dict__ and type(ISiteSTKAreaTarget.__dict__[attrname]) == property:
            return ISiteSTKAreaTarget.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteSTKAreaTarget.")
    
    _get_object_name_metadata = { "name" : "object_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        return self._intf.get_property(ISiteSTKAreaTarget._metadata, ISiteSTKAreaTarget._get_object_name_metadata)

    _set_object_name_metadata = { "name" : "object_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        return self._intf.set_property(ISiteSTKAreaTarget._metadata, ISiteSTKAreaTarget._set_object_name_metadata, newVal)

    _get_valid_object_names_metadata = { "name" : "valid_object_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        return self._intf.get_property(ISiteSTKAreaTarget._metadata, ISiteSTKAreaTarget._get_valid_object_names_metadata)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteSTKAreaTarget._metadata, ISiteSTKAreaTarget._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{38dbad68-357f-4129-b8fb-3fbecd506e23}", ISiteSTKAreaTarget)
agcls.AgTypeNameMap["ISiteSTKAreaTarget"] = ISiteSTKAreaTarget

class ISiteRunway(object):
    """Interface used to access the options for a Runway site type."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5b6661c4-9722-49ab-9236-ffbfe2821e86}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude" : 1,
                             "set_altitude" : 2,
                             "get_latitude" : 3,
                             "set_latitude" : 4,
                             "get_longitude" : 5,
                             "set_longitude" : 6,
                             "get_length" : 7,
                             "set_length" : 8,
                             "get_altitude_reference" : 9,
                             "set_altitude_reference" : 10,
                             "get_low_end_heading" : 11,
                             "set_low_end_heading" : 12,
                             "get_high_end_heading" : 13,
                             "set_high_end_heading" : 14,
                             "get_is_magnetic" : 15,
                             "set_is_magnetic" : 16,
                             "add_to_catalog" : 17,
                             "copy_from_catalog" : 18,
                             "get_as_site" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteRunway._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteRunway from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRunway.__dict__ and type(ISiteRunway.__dict__[attrname]) == property:
            return ISiteRunway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRunway.")
    
    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The runway altitude."""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The runway altitude."""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_altitude_metadata, newVal)

    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def latitude(self) -> typing.Any:
        """The runway latitude."""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The runway latitude."""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_latitude_metadata, newVal)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def longitude(self) -> typing.Any:
        """The runway longitude."""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The runway longitude."""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_longitude_metadata, newVal)

    _get_length_metadata = { "name" : "length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def length(self) -> float:
        """The length of the runway"""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_length_metadata)

    _set_length_metadata = { "name" : "length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @length.setter
    def length(self, newVal:float) -> None:
        """The length of the runway"""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_length_metadata, newVal)

    _get_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @property
    def altitude_reference(self) -> "AGL_MSL":
        """The altitude reference for the runway."""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_altitude_reference_metadata)

    _set_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @altitude_reference.setter
    def altitude_reference(self, newVal:"AGL_MSL") -> None:
        """The altitude reference for the runway."""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_altitude_reference_metadata, newVal)

    _get_low_end_heading_metadata = { "name" : "low_end_heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def low_end_heading(self) -> typing.Any:
        """The low end heading of the runway."""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_low_end_heading_metadata)

    _set_low_end_heading_metadata = { "name" : "low_end_heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @low_end_heading.setter
    def low_end_heading(self, newVal:typing.Any) -> None:
        """The low end heading of the runway."""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_low_end_heading_metadata, newVal)

    _get_high_end_heading_metadata = { "name" : "high_end_heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def high_end_heading(self) -> typing.Any:
        """The high end heading of the runway."""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_high_end_heading_metadata)

    _set_high_end_heading_metadata = { "name" : "high_end_heading",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @high_end_heading.setter
    def high_end_heading(self, newVal:typing.Any) -> None:
        """The high end heading of the runway."""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_high_end_heading_metadata, newVal)

    _get_is_magnetic_metadata = { "name" : "is_magnetic",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_magnetic(self) -> bool:
        """Opt whether to use a magnetic heading for the runway heading."""
        return self._intf.get_property(ISiteRunway._metadata, ISiteRunway._get_is_magnetic_metadata)

    _set_is_magnetic_metadata = { "name" : "is_magnetic",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @is_magnetic.setter
    def is_magnetic(self, newVal:bool) -> None:
        """Opt whether to use a magnetic heading for the runway heading."""
        return self._intf.set_property(ISiteRunway._metadata, ISiteRunway._set_is_magnetic_metadata, newVal)

    _add_to_catalog_metadata = { "name" : "add_to_catalog",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    def add_to_catalog(self, overwrite:bool) -> None:
        """Add the runway to the catalog."""
        return self._intf.invoke(ISiteRunway._metadata, ISiteRunway._add_to_catalog_metadata, overwrite)

    _copy_from_catalog_metadata = { "name" : "copy_from_catalog",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICatalogRunway"),) }
    def copy_from_catalog(self, runway:"ICatalogRunway") -> None:
        """Copy the information from the runway stored in the catalog."""
        return self._intf.invoke(ISiteRunway._metadata, ISiteRunway._copy_from_catalog_metadata, runway)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteRunway._metadata, ISiteRunway._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{5b6661c4-9722-49ab-9236-ffbfe2821e86}", ISiteRunway)
agcls.AgTypeNameMap["ISiteRunway"] = ISiteRunway

class IProcedureLanding(object):
    """Interface used to access the options for a landing procedure."""
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b3541a24-1ba3-47cd-86a9-4dc90b7d0c14}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_mode_as_standard_instrument_approach" : 1,
                             "get_mode_as_intercept_glideslope" : 2,
                             "get_mode_as_enter_downwind_pattern" : 3,
                             "get_runway_heading_options" : 4,
                             "get_enroute_cruise_airspeed_options" : 5,
                             "get_enroute_turn_direction_options" : 6,
                             "get_enroute_options" : 7,
                             "get_vertical_plane_options" : 8,
                             "get_approach_mode" : 9,
                             "set_approach_mode" : 10,
                             "get_as_procedure" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureLanding._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLanding from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLanding.__dict__ and type(IProcedureLanding.__dict__[attrname]) == property:
            return IProcedureLanding.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLanding.")
    
    _get_mode_as_standard_instrument_approach_metadata = { "name" : "mode_as_standard_instrument_approach",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_standard_instrument_approach(self) -> "LandingStandardInstrumentApproach":
        """Get the interface for a standard instrument approach landing."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_mode_as_standard_instrument_approach_metadata)

    _get_mode_as_intercept_glideslope_metadata = { "name" : "mode_as_intercept_glideslope",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_intercept_glideslope(self) -> "LandingInterceptGlideslope":
        """Get the interface for an intercept glideslope landing."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_mode_as_intercept_glideslope_metadata)

    _get_mode_as_enter_downwind_pattern_metadata = { "name" : "mode_as_enter_downwind_pattern",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_enter_downwind_pattern(self) -> "LandingEnterDownwindPattern":
        """Get the interface for a downwind pattern landing."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_mode_as_enter_downwind_pattern_metadata)

    _get_runway_heading_options_metadata = { "name" : "runway_heading_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def runway_heading_options(self) -> "RunwayHeadingOptions":
        """Get the runway heading options."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_runway_heading_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedAndProfileOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_enroute_cruise_airspeed_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_enroute_turn_direction_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_enroute_options_metadata)

    _get_vertical_plane_options_metadata = { "name" : "vertical_plane_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vertical_plane_options(self) -> "IVerticalPlaneOptions":
        """Get the vertical plane options."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_vertical_plane_options_metadata)

    _get_approach_mode_metadata = { "name" : "approach_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(APPROACH_MODE),) }
    @property
    def approach_mode(self) -> "APPROACH_MODE":
        """The type of landing the aircraft will perform."""
        return self._intf.get_property(IProcedureLanding._metadata, IProcedureLanding._get_approach_mode_metadata)

    _set_approach_mode_metadata = { "name" : "approach_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(APPROACH_MODE),) }
    @approach_mode.setter
    def approach_mode(self, newVal:"APPROACH_MODE") -> None:
        """The type of landing the aircraft will perform."""
        return self._intf.set_property(IProcedureLanding._metadata, IProcedureLanding._set_approach_mode_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureLanding._metadata, IProcedureLanding._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{b3541a24-1ba3-47cd-86a9-4dc90b7d0c14}", IProcedureLanding)
agcls.AgTypeNameMap["IProcedureLanding"] = IProcedureLanding

class IProcedureEnroute(object):
    """Interface used to access the options for an enroute procedure."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{a35c59ac-496b-4b6c-aa8a-fd55e9992a97}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_msl_options" : 1,
                             "get_navigation_options" : 2,
                             "get_enroute_options" : 3,
                             "get_enroute_cruise_airspeed_options" : 4,
                             "get_as_procedure" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureEnroute._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureEnroute from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureEnroute.__dict__ and type(IProcedureEnroute.__dict__[attrname]) == property:
            return IProcedureEnroute.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureEnroute.")
    
    _get_altitude_msl_options_metadata = { "name" : "altitude_msl_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_msl_options(self) -> "AltitudeMSLAndLevelOffOptions":
        """Get the altitude MSL options."""
        return self._intf.get_property(IProcedureEnroute._metadata, IProcedureEnroute._get_altitude_msl_options_metadata)

    _get_navigation_options_metadata = { "name" : "navigation_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def navigation_options(self) -> "NavigationOptions":
        """Get the navigation options."""
        return self._intf.get_property(IProcedureEnroute._metadata, IProcedureEnroute._get_navigation_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureEnroute._metadata, IProcedureEnroute._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureEnroute._metadata, IProcedureEnroute._get_enroute_cruise_airspeed_options_metadata)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureEnroute._metadata, IProcedureEnroute._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{a35c59ac-496b-4b6c-aa8a-fd55e9992a97}", IProcedureEnroute)
agcls.AgTypeNameMap["IProcedureEnroute"] = IProcedureEnroute

class IProcedureExtEphem(object):
    """Interface used to access the options for an ExtEphem procedure."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7A4CFB91-336F-4150-AD2C-C861410FB496}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_ephemeris_file" : 1,
                             "get_ephemeris_file" : 2,
                             "get_ephemeris_file_duration" : 3,
                             "set_use_start_duration" : 4,
                             "get_use_start_duration" : 5,
                             "set_start_time" : 6,
                             "get_start_time" : 7,
                             "set_duration" : 8,
                             "get_duration" : 9,
                             "get_flight_mode" : 10,
                             "set_flight_mode" : 11,
                             "get_as_procedure" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureExtEphem._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureExtEphem from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureExtEphem.__dict__ and type(IProcedureExtEphem.__dict__[attrname]) == property:
            return IProcedureExtEphem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureExtEphem.")
    
    _get_ephemeris_file_metadata = { "name" : "ephemeris_file",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ephemeris_file(self) -> str:
        """Get the ephemeris filename."""
        return self._intf.get_property(IProcedureExtEphem._metadata, IProcedureExtEphem._get_ephemeris_file_metadata)

    _set_ephemeris_file_metadata = { "name" : "ephemeris_file",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @ephemeris_file.setter
    def ephemeris_file(self, newVal:str) -> None:
        """Set the ephemeris filename."""
        return self._intf.set_property(IProcedureExtEphem._metadata, IProcedureExtEphem._set_ephemeris_file_metadata, newVal)

    _get_ephemeris_file_duration_metadata = { "name" : "ephemeris_file_duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ephemeris_file_duration(self) -> float:
        """Get the ephemeris file duration."""
        return self._intf.get_property(IProcedureExtEphem._metadata, IProcedureExtEphem._get_ephemeris_file_duration_metadata)

    _get_use_start_duration_metadata = { "name" : "use_start_duration",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_start_duration(self) -> bool:
        """Get whether to use Start and Duration"""
        return self._intf.get_property(IProcedureExtEphem._metadata, IProcedureExtEphem._get_use_start_duration_metadata)

    _set_use_start_duration_metadata = { "name" : "use_start_duration",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_start_duration.setter
    def use_start_duration(self, useSD:bool) -> None:
        """Set whether to use Start and Duration"""
        return self._intf.set_property(IProcedureExtEphem._metadata, IProcedureExtEphem._set_use_start_duration_metadata, useSD)

    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_time(self) -> float:
        """Get the start time"""
        return self._intf.get_property(IProcedureExtEphem._metadata, IProcedureExtEphem._get_start_time_metadata)

    _set_start_time_metadata = { "name" : "start_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_time.setter
    def start_time(self, start:float) -> None:
        """Set the start time"""
        return self._intf.set_property(IProcedureExtEphem._metadata, IProcedureExtEphem._set_start_time_metadata, start)

    _get_duration_metadata = { "name" : "duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def duration(self) -> float:
        """Get the duration"""
        return self._intf.get_property(IProcedureExtEphem._metadata, IProcedureExtEphem._get_duration_metadata)

    _set_duration_metadata = { "name" : "duration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @duration.setter
    def duration(self, start:float) -> None:
        """Set the duration"""
        return self._intf.set_property(IProcedureExtEphem._metadata, IProcedureExtEphem._set_duration_metadata, start)

    _get_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(EXT_EPHEM_FLIGHT_MODE),) }
    @property
    def flight_mode(self) -> "EXT_EPHEM_FLIGHT_MODE":
        """Get the flight mode"""
        return self._intf.get_property(IProcedureExtEphem._metadata, IProcedureExtEphem._get_flight_mode_metadata)

    _set_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(EXT_EPHEM_FLIGHT_MODE),) }
    @flight_mode.setter
    def flight_mode(self, mode:"EXT_EPHEM_FLIGHT_MODE") -> None:
        """Set the flight mode"""
        return self._intf.set_property(IProcedureExtEphem._metadata, IProcedureExtEphem._set_flight_mode_metadata, mode)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureExtEphem._metadata, IProcedureExtEphem._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7A4CFB91-336F-4150-AD2C-C861410FB496}", IProcedureExtEphem)
agcls.AgTypeNameMap["IProcedureExtEphem"] = IProcedureExtEphem

class IProcedureFormationFlyer(object):
    """Interface used to access the options for an enroute procedure."""
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A8EF3889-1443-405A-AFC6-5072D53F9AC4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_min_time_step" : 1,
                             "set_min_time_step" : 2,
                             "get_max_time_step" : 3,
                             "set_max_time_step" : 4,
                             "get_cross_range_close_rate" : 5,
                             "set_cross_range_close_rate" : 6,
                             "get_initial_close_max_speed_advantage" : 7,
                             "set_initial_close_max_speed_advantage" : 8,
                             "get_stop_condition" : 9,
                             "set_stop_condition" : 10,
                             "get_stop_time" : 11,
                             "set_stop_time" : 12,
                             "get_stop_down_range" : 13,
                             "set_stop_down_range" : 14,
                             "get_stop_fuel_state" : 15,
                             "set_stop_fuel_state" : 16,
                             "get_as_procedure" : 17, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureFormationFlyer._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFormationFlyer from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFormationFlyer.__dict__ and type(IProcedureFormationFlyer.__dict__[attrname]) == property:
            return IProcedureFormationFlyer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFormationFlyer.")
    
    _get_min_time_step_metadata = { "name" : "min_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min_time_step(self) -> float:
        """Get Min time Step"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_min_time_step_metadata)

    _set_min_time_step_metadata = { "name" : "min_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min_time_step.setter
    def min_time_step(self, pVal:float) -> None:
        """Set Min time Step"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_min_time_step_metadata, pVal)

    _get_max_time_step_metadata = { "name" : "max_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_time_step(self) -> float:
        """Get Max time Step"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_max_time_step_metadata)

    _set_max_time_step_metadata = { "name" : "max_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_time_step.setter
    def max_time_step(self, pVal:float) -> None:
        """Set Max time Step"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_max_time_step_metadata, pVal)

    _get_cross_range_close_rate_metadata = { "name" : "cross_range_close_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def cross_range_close_rate(self) -> float:
        """Get Cross Range close rate"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_cross_range_close_rate_metadata)

    _set_cross_range_close_rate_metadata = { "name" : "cross_range_close_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @cross_range_close_rate.setter
    def cross_range_close_rate(self, pVal:float) -> None:
        """Set Cross Range close rate"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_cross_range_close_rate_metadata, pVal)

    _get_initial_close_max_speed_advantage_metadata = { "name" : "initial_close_max_speed_advantage",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def initial_close_max_speed_advantage(self) -> float:
        """Get Initial Close Max Speed Advantage"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_initial_close_max_speed_advantage_metadata)

    _set_initial_close_max_speed_advantage_metadata = { "name" : "initial_close_max_speed_advantage",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @initial_close_max_speed_advantage.setter
    def initial_close_max_speed_advantage(self, pVal:float) -> None:
        """Set Initial Close Max Speed Advantage"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_initial_close_max_speed_advantage_metadata, pVal)

    _get_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FORMATION_FLYER_STOP_CONDITION),) }
    @property
    def stop_condition(self) -> "FORMATION_FLYER_STOP_CONDITION":
        """Get Stop condition"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_stop_condition_metadata)

    _set_stop_condition_metadata = { "name" : "stop_condition",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FORMATION_FLYER_STOP_CONDITION),) }
    @stop_condition.setter
    def stop_condition(self, pVal:"FORMATION_FLYER_STOP_CONDITION") -> None:
        """Set Stop condition"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_stop_condition_metadata, pVal)

    _get_stop_time_metadata = { "name" : "stop_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_time(self) -> float:
        """Get stop time"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_stop_time_metadata)

    _set_stop_time_metadata = { "name" : "stop_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_time.setter
    def stop_time(self, pVal:float) -> None:
        """Set stop time"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_stop_time_metadata, pVal)

    _get_stop_down_range_metadata = { "name" : "stop_down_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_down_range(self) -> float:
        """Get stop downrange"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_stop_down_range_metadata)

    _set_stop_down_range_metadata = { "name" : "stop_down_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_down_range.setter
    def stop_down_range(self, pVal:float) -> None:
        """Set stop downrange"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_stop_down_range_metadata, pVal)

    _get_stop_fuel_state_metadata = { "name" : "stop_fuel_state",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_fuel_state(self) -> float:
        """Get stop fuel state"""
        return self._intf.get_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_stop_fuel_state_metadata)

    _set_stop_fuel_state_metadata = { "name" : "stop_fuel_state",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_fuel_state.setter
    def stop_fuel_state(self, pVal:float) -> None:
        """Set stop fuel state"""
        return self._intf.set_property(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._set_stop_fuel_state_metadata, pVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureFormationFlyer._metadata, IProcedureFormationFlyer._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{A8EF3889-1443-405A-AFC6-5072D53F9AC4}", IProcedureFormationFlyer)
agcls.AgTypeNameMap["IProcedureFormationFlyer"] = IProcedureFormationFlyer

class IProcedureBasicPointToPoint(object):
    """Interface used to access the options for a basic point to point procedure."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e6e53440-4d07-4808-be87-ed2bf3908208}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_navigation_options" : 2,
                             "get_enroute_options" : 3,
                             "get_enroute_cruise_airspeed_options" : 4,
                             "get_vertical_plane_options" : 5,
                             "get_as_procedure" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureBasicPointToPoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureBasicPointToPoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureBasicPointToPoint.__dict__ and type(IProcedureBasicPointToPoint.__dict__[attrname]) == property:
            return IProcedureBasicPointToPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureBasicPointToPoint.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureBasicPointToPoint._metadata, IProcedureBasicPointToPoint._get_altitude_options_metadata)

    _get_navigation_options_metadata = { "name" : "navigation_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def navigation_options(self) -> "NavigationOptions":
        """Get the navigation options."""
        return self._intf.get_property(IProcedureBasicPointToPoint._metadata, IProcedureBasicPointToPoint._get_navigation_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureBasicPointToPoint._metadata, IProcedureBasicPointToPoint._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedAndProfileOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureBasicPointToPoint._metadata, IProcedureBasicPointToPoint._get_enroute_cruise_airspeed_options_metadata)

    _get_vertical_plane_options_metadata = { "name" : "vertical_plane_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vertical_plane_options(self) -> "VerticalPlaneAndFlightPathOptions":
        """Get the vertical plane options."""
        return self._intf.get_property(IProcedureBasicPointToPoint._metadata, IProcedureBasicPointToPoint._get_vertical_plane_options_metadata)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureBasicPointToPoint._metadata, IProcedureBasicPointToPoint._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{e6e53440-4d07-4808-be87-ed2bf3908208}", IProcedureBasicPointToPoint)
agcls.AgTypeNameMap["IProcedureBasicPointToPoint"] = IProcedureBasicPointToPoint

class IProcedureDelay(object):
    """Interface used to access the options for a delay procedure."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0196f260-017d-4f54-af50-7ca1ed1056b0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_mode" : 1,
                             "set_altitude_mode" : 2,
                             "get_altitude" : 3,
                             "set_altitude" : 4,
                             "get_cruise_airspeed_options" : 5,
                             "get_turn_direction" : 6,
                             "set_turn_direction" : 7,
                             "get_turn_radius_factor" : 8,
                             "set_turn_radius_factor" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureDelay._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureDelay from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureDelay.__dict__ and type(IProcedureDelay.__dict__[attrname]) == property:
            return IProcedureDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureDelay.")
    
    _get_altitude_mode_metadata = { "name" : "altitude_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(DELAY_ALTITUDE_MODE),) }
    @property
    def altitude_mode(self) -> "DELAY_ALTITUDE_MODE":
        """The mode for handling the altitude of the aircraft."""
        return self._intf.get_property(IProcedureDelay._metadata, IProcedureDelay._get_altitude_mode_metadata)

    _set_altitude_mode_metadata = { "name" : "altitude_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(DELAY_ALTITUDE_MODE),) }
    @altitude_mode.setter
    def altitude_mode(self, newVal:"DELAY_ALTITUDE_MODE") -> None:
        """The mode for handling the altitude of the aircraft."""
        return self._intf.set_property(IProcedureDelay._metadata, IProcedureDelay._set_altitude_mode_metadata, newVal)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The requested altitude of the procedure."""
        return self._intf.get_property(IProcedureDelay._metadata, IProcedureDelay._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The requested altitude of the procedure."""
        return self._intf.set_property(IProcedureDelay._metadata, IProcedureDelay._set_altitude_metadata, newVal)

    _get_cruise_airspeed_options_metadata = { "name" : "cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the interface for the cruise airspeed options."""
        return self._intf.get_property(IProcedureDelay._metadata, IProcedureDelay._get_cruise_airspeed_options_metadata)

    _get_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @property
    def turn_direction(self) -> "NAVIGATOR_TURN_DIRECTION":
        """The turn direction of the procedure."""
        return self._intf.get_property(IProcedureDelay._metadata, IProcedureDelay._get_turn_direction_metadata)

    _set_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(NAVIGATOR_TURN_DIRECTION),) }
    @turn_direction.setter
    def turn_direction(self, newVal:"NAVIGATOR_TURN_DIRECTION") -> None:
        """The turn direction of the procedure."""
        return self._intf.set_property(IProcedureDelay._metadata, IProcedureDelay._set_turn_direction_metadata, newVal)

    _get_turn_radius_factor_metadata = { "name" : "turn_radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turn_radius_factor(self) -> float:
        """The turn radius factor."""
        return self._intf.get_property(IProcedureDelay._metadata, IProcedureDelay._get_turn_radius_factor_metadata)

    _set_turn_radius_factor_metadata = { "name" : "turn_radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @turn_radius_factor.setter
    def turn_radius_factor(self, newVal:float) -> None:
        """The turn radius factor."""
        return self._intf.set_property(IProcedureDelay._metadata, IProcedureDelay._set_turn_radius_factor_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{0196f260-017d-4f54-af50-7ca1ed1056b0}", IProcedureDelay)
agcls.AgTypeNameMap["IProcedureDelay"] = IProcedureDelay

class IProcedureTakeoff(object):
    """Interface used to access the options for a takeoff procedure."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2f8f0f66-d7ea-41df-ad48-bcd5bfcd90b7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_runway_heading_options" : 1,
                             "get_mode_as_normal" : 2,
                             "get_mode_as_departure_point" : 3,
                             "get_mode_as_low_transition" : 4,
                             "get_takeoff_mode" : 5,
                             "set_takeoff_mode" : 6,
                             "get_as_procedure" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureTakeoff._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTakeoff from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTakeoff.__dict__ and type(IProcedureTakeoff.__dict__[attrname]) == property:
            return IProcedureTakeoff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTakeoff.")
    
    _get_runway_heading_options_metadata = { "name" : "runway_heading_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def runway_heading_options(self) -> "RunwayHeadingOptions":
        """Get the runway heading options."""
        return self._intf.get_property(IProcedureTakeoff._metadata, IProcedureTakeoff._get_runway_heading_options_metadata)

    _get_mode_as_normal_metadata = { "name" : "mode_as_normal",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_normal(self) -> "TakeoffNormal":
        """Get the interface for a normal takeoff."""
        return self._intf.get_property(IProcedureTakeoff._metadata, IProcedureTakeoff._get_mode_as_normal_metadata)

    _get_mode_as_departure_point_metadata = { "name" : "mode_as_departure_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_departure_point(self) -> "TakeoffDeparturePoint":
        """Get the interface for a departure point takeoff."""
        return self._intf.get_property(IProcedureTakeoff._metadata, IProcedureTakeoff._get_mode_as_departure_point_metadata)

    _get_mode_as_low_transition_metadata = { "name" : "mode_as_low_transition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_low_transition(self) -> "TakeoffLowTransition":
        """Get the interface for a low transition takeoff."""
        return self._intf.get_property(IProcedureTakeoff._metadata, IProcedureTakeoff._get_mode_as_low_transition_metadata)

    _get_takeoff_mode_metadata = { "name" : "takeoff_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TAKEOFF_MODE),) }
    @property
    def takeoff_mode(self) -> "TAKEOFF_MODE":
        """The type of takeoff the aircraft will perform."""
        return self._intf.get_property(IProcedureTakeoff._metadata, IProcedureTakeoff._get_takeoff_mode_metadata)

    _set_takeoff_mode_metadata = { "name" : "takeoff_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TAKEOFF_MODE),) }
    @takeoff_mode.setter
    def takeoff_mode(self, newVal:"TAKEOFF_MODE") -> None:
        """The type of takeoff the aircraft will perform."""
        return self._intf.set_property(IProcedureTakeoff._metadata, IProcedureTakeoff._set_takeoff_mode_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureTakeoff._metadata, IProcedureTakeoff._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{2f8f0f66-d7ea-41df-ad48-bcd5bfcd90b7}", IProcedureTakeoff)
agcls.AgTypeNameMap["IProcedureTakeoff"] = IProcedureTakeoff

class IProcedureArcEnroute(object):
    """Interface used to access the options for an arc enroute procedure."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{e4073986-cdc3-47de-994d-e731e309f7a2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_arc_options" : 2,
                             "get_arc_cruise_airspeed_options" : 3,
                             "get_enroute_options" : 4,
                             "get_enroute_cruise_airspeed_options" : 5,
                             "get_enroute_turn_direction_options" : 6,
                             "get_as_procedure" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureArcEnroute._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureArcEnroute from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureArcEnroute.__dict__ and type(IProcedureArcEnroute.__dict__[attrname]) == property:
            return IProcedureArcEnroute.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureArcEnroute.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "ArcAltitudeAndDelayOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureArcEnroute._metadata, IProcedureArcEnroute._get_altitude_options_metadata)

    _get_arc_options_metadata = { "name" : "arc_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arc_options(self) -> "ArcOptions":
        """Get the arc options."""
        return self._intf.get_property(IProcedureArcEnroute._metadata, IProcedureArcEnroute._get_arc_options_metadata)

    _get_arc_cruise_airspeed_options_metadata = { "name" : "arc_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arc_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the arc cruise airspeed options."""
        return self._intf.get_property(IProcedureArcEnroute._metadata, IProcedureArcEnroute._get_arc_cruise_airspeed_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureArcEnroute._metadata, IProcedureArcEnroute._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureArcEnroute._metadata, IProcedureArcEnroute._get_enroute_cruise_airspeed_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureArcEnroute._metadata, IProcedureArcEnroute._get_enroute_turn_direction_options_metadata)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureArcEnroute._metadata, IProcedureArcEnroute._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{e4073986-cdc3-47de-994d-e731e309f7a2}", IProcedureArcEnroute)
agcls.AgTypeNameMap["IProcedureArcEnroute"] = IProcedureArcEnroute

class IProcedureArcPointToPoint(object):
    """Interface used to access the options for an arc point to point procedure."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0b5eaf53-8f72-4039-b469-18cfccedc1ef}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_arc_options" : 2,
                             "get_arc_cruise_airspeed_options" : 3,
                             "get_enroute_options" : 4,
                             "get_enroute_cruise_airspeed_options" : 5,
                             "get_enroute_turn_direction_options" : 6,
                             "get_fly_cruise_airspeed_profile" : 7,
                             "set_fly_cruise_airspeed_profile" : 8,
                             "get_vertical_plane_options" : 9,
                             "get_as_procedure" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureArcPointToPoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureArcPointToPoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureArcPointToPoint.__dict__ and type(IProcedureArcPointToPoint.__dict__[attrname]) == property:
            return IProcedureArcPointToPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureArcPointToPoint.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "ArcAltitudeOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_altitude_options_metadata)

    _get_arc_options_metadata = { "name" : "arc_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arc_options(self) -> "ArcOptions":
        """Get the arc options."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_arc_options_metadata)

    _get_arc_cruise_airspeed_options_metadata = { "name" : "arc_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def arc_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the arc cruise airspeed options."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_arc_cruise_airspeed_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_enroute_cruise_airspeed_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_enroute_turn_direction_options_metadata)

    _get_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_fly_cruise_airspeed_profile_metadata)

    _set_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, pVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.set_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._set_fly_cruise_airspeed_profile_metadata, pVal)

    _get_vertical_plane_options_metadata = { "name" : "vertical_plane_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vertical_plane_options(self) -> "ArcVerticalPlaneOptions":
        """Get the vertical plane options."""
        return self._intf.get_property(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_vertical_plane_options_metadata)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureArcPointToPoint._metadata, IProcedureArcPointToPoint._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{0b5eaf53-8f72-4039-b469-18cfccedc1ef}", IProcedureArcPointToPoint)
agcls.AgTypeNameMap["IProcedureArcPointToPoint"] = IProcedureArcPointToPoint

class IProcedureFlightLine(object):
    """Interface used to access the options for a flight line procedure."""
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{cfa301c6-3326-4e4b-8973-5e74d00b7553}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_fly_cruise_airspeed_profile" : 2,
                             "set_fly_cruise_airspeed_profile" : 3,
                             "get_flight_line_airspeed_options" : 4,
                             "get_enroute_options" : 5,
                             "get_enroute_turn_direction_options" : 6,
                             "get_enroute_cruise_airspeed_options" : 7,
                             "get_procedure_type" : 8,
                             "set_procedure_type" : 9,
                             "get_outbound_course" : 10,
                             "set_outbound_course" : 11,
                             "get_use_magnetic_heading" : 12,
                             "set_use_magnetic_heading" : 13,
                             "get_leg_length" : 14,
                             "set_leg_length" : 15,
                             "get_must_level_off" : 16,
                             "set_must_level_off" : 17,
                             "get_level_off_mode" : 18,
                             "set_level_off_mode" : 19,
                             "get_as_procedure" : 20, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureFlightLine._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFlightLine from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFlightLine.__dict__ and type(IProcedureFlightLine.__dict__[attrname]) == property:
            return IProcedureFlightLine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFlightLine.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_altitude_options_metadata)

    _get_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_fly_cruise_airspeed_profile_metadata)

    _set_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, pVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.set_property(IProcedureFlightLine._metadata, IProcedureFlightLine._set_fly_cruise_airspeed_profile_metadata, pVal)

    _get_flight_line_airspeed_options_metadata = { "name" : "flight_line_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def flight_line_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the flight line airspeed options."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_flight_line_airspeed_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_enroute_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_enroute_turn_direction_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_enroute_cruise_airspeed_options_metadata)

    _get_procedure_type_metadata = { "name" : "procedure_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FLIGHT_LINE_PROC_TYPE),) }
    @property
    def procedure_type(self) -> "FLIGHT_LINE_PROC_TYPE":
        """The procedure methodology used to calculate the flight line."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_procedure_type_metadata)

    _set_procedure_type_metadata = { "name" : "procedure_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FLIGHT_LINE_PROC_TYPE),) }
    @procedure_type.setter
    def procedure_type(self, newVal:"FLIGHT_LINE_PROC_TYPE") -> None:
        """The procedure methodology used to calculate the flight line."""
        return self._intf.set_property(IProcedureFlightLine._metadata, IProcedureFlightLine._set_procedure_type_metadata, newVal)

    _get_outbound_course_metadata = { "name" : "outbound_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def outbound_course(self) -> typing.Any:
        """The outbound course."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_outbound_course_metadata)

    _set_outbound_course_metadata = { "name" : "outbound_course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @outbound_course.setter
    def outbound_course(self, newVal:typing.Any) -> None:
        """The outbound course."""
        return self._intf.set_property(IProcedureFlightLine._metadata, IProcedureFlightLine._set_outbound_course_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_use_magnetic_heading_metadata)

    _set_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        return self._intf.set_property(IProcedureFlightLine._metadata, IProcedureFlightLine._set_use_magnetic_heading_metadata, newVal)

    _get_leg_length_metadata = { "name" : "leg_length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def leg_length(self) -> float:
        """The length of the flight line."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_leg_length_metadata)

    _set_leg_length_metadata = { "name" : "leg_length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @leg_length.setter
    def leg_length(self, newVal:float) -> None:
        """The length of the flight line."""
        return self._intf.set_property(IProcedureFlightLine._metadata, IProcedureFlightLine._set_leg_length_metadata, newVal)

    _get_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_must_level_off_metadata)

    _set_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        return self._intf.set_property(IProcedureFlightLine._metadata, IProcedureFlightLine._set_must_level_off_metadata, newVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.get_property(IProcedureFlightLine._metadata, IProcedureFlightLine._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, newVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.set_property(IProcedureFlightLine._metadata, IProcedureFlightLine._set_level_off_mode_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureFlightLine._metadata, IProcedureFlightLine._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{cfa301c6-3326-4e4b-8973-5e74d00b7553}", IProcedureFlightLine)
agcls.AgTypeNameMap["IProcedureFlightLine"] = IProcedureFlightLine

class IProcedureHoldingCircular(object):
    """Interface used to access the options for a holding circular procedure."""
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ecb689b1-ebcb-45f2-832a-ed36734601ae}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_profile_mode" : 2,
                             "set_profile_mode" : 3,
                             "get_level_off_mode" : 4,
                             "set_level_off_mode" : 5,
                             "get_bearing" : 6,
                             "set_bearing" : 7,
                             "get_use_magnetic_heading" : 8,
                             "set_use_magnetic_heading" : 9,
                             "get_range" : 10,
                             "set_range" : 11,
                             "get_diameter" : 12,
                             "set_diameter" : 13,
                             "get_use_alternate_entry_points" : 14,
                             "set_use_alternate_entry_points" : 15,
                             "get_turn_direction" : 16,
                             "set_turn_direction" : 17,
                             "get_turns" : 18,
                             "set_turns" : 19,
                             "get_refuel_dump_mode" : 20,
                             "set_refuel_dump_mode" : 21,
                             "get_hold_cruise_airspeed_options" : 22,
                             "get_enroute_options" : 23,
                             "get_enroute_cruise_airspeed_options" : 24,
                             "get_enroute_turn_direction_options" : 25,
                             "get_minimum_diameter" : 26,
                             "get_as_procedure" : 27, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureHoldingCircular._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoldingCircular from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoldingCircular.__dict__ and type(IProcedureHoldingCircular.__dict__[attrname]) == property:
            return IProcedureHoldingCircular.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoldingCircular.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeMSLOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_altitude_options_metadata)

    _get_profile_mode_metadata = { "name" : "profile_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_PROFILE_MODE),) }
    @property
    def profile_mode(self) -> "HOLDING_PROFILE_MODE":
        """The mode defines how the aircraft will perform the holding pattern."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_profile_mode_metadata)

    _set_profile_mode_metadata = { "name" : "profile_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_PROFILE_MODE),) }
    @profile_mode.setter
    def profile_mode(self, newVal:"HOLDING_PROFILE_MODE") -> None:
        """The mode defines how the aircraft will perform the holding pattern."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_profile_mode_metadata, newVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The mode for the level off maneuver."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, newVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The mode for the level off maneuver."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_level_off_mode_metadata, newVal)

    _get_bearing_metadata = { "name" : "bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bearing(self) -> typing.Any:
        """The bearing of the holding point from the site."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_bearing_metadata)

    _set_bearing_metadata = { "name" : "bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the holding point from the site."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_bearing_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_use_magnetic_heading_metadata)

    _set_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_use_magnetic_heading_metadata, newVal)

    _get_range_metadata = { "name" : "range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range(self) -> float:
        """The distance to the holding point from the site."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_range_metadata)

    _set_range_metadata = { "name" : "range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range.setter
    def range(self, newVal:float) -> None:
        """The distance to the holding point from the site."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_range_metadata, newVal)

    _get_diameter_metadata = { "name" : "diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def diameter(self) -> float:
        """The diameter of the holding pattern."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_diameter_metadata)

    _set_diameter_metadata = { "name" : "diameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @diameter.setter
    def diameter(self, newVal:float) -> None:
        """The diameter of the holding pattern."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_diameter_metadata, newVal)

    _get_use_alternate_entry_points_metadata = { "name" : "use_alternate_entry_points",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_alternate_entry_points(self) -> bool:
        """The option to enter the holding pattern from an alternate point."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_use_alternate_entry_points_metadata)

    _set_use_alternate_entry_points_metadata = { "name" : "use_alternate_entry_points",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_alternate_entry_points.setter
    def use_alternate_entry_points(self, newVal:bool) -> None:
        """The option to enter the holding pattern from an alternate point."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_use_alternate_entry_points_metadata, newVal)

    _get_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_DIRECTION),) }
    @property
    def turn_direction(self) -> "HOLDING_DIRECTION":
        """The turn direction to enter the holding pattern."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_turn_direction_metadata)

    _set_turn_direction_metadata = { "name" : "turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_DIRECTION),) }
    @turn_direction.setter
    def turn_direction(self, newVal:"HOLDING_DIRECTION") -> None:
        """The turn direction to enter the holding pattern."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_turn_direction_metadata, newVal)

    _get_turns_metadata = { "name" : "turns",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def turns(self) -> int:
        """The number of full turns."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_turns_metadata)

    _set_turns_metadata = { "name" : "turns",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @turns.setter
    def turns(self, newVal:int) -> None:
        """The number of full turns."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_turns_metadata, newVal)

    _get_refuel_dump_mode_metadata = { "name" : "refuel_dump_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLD_REFUEL_DUMP_MODE),) }
    @property
    def refuel_dump_mode(self) -> "HOLD_REFUEL_DUMP_MODE":
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_refuel_dump_mode_metadata)

    _set_refuel_dump_mode_metadata = { "name" : "refuel_dump_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLD_REFUEL_DUMP_MODE),) }
    @refuel_dump_mode.setter
    def refuel_dump_mode(self, newVal:"HOLD_REFUEL_DUMP_MODE") -> None:
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        return self._intf.set_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._set_refuel_dump_mode_metadata, newVal)

    _get_hold_cruise_airspeed_options_metadata = { "name" : "hold_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def hold_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the hold cruise airspeed options."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_hold_cruise_airspeed_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_enroute_cruise_airspeed_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_enroute_turn_direction_options_metadata)

    _get_minimum_diameter_metadata = { "name" : "get_minimum_diameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def get_minimum_diameter(self) -> float:
        """The aircraft's minimum diameter at this altitude."""
        return self._intf.invoke(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_minimum_diameter_metadata, out_arg())

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureHoldingCircular._metadata, IProcedureHoldingCircular._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{ecb689b1-ebcb-45f2-832a-ed36734601ae}", IProcedureHoldingCircular)
agcls.AgTypeNameMap["IProcedureHoldingCircular"] = IProcedureHoldingCircular

class IProcedureHoldingFigure8(object):
    """Interface used to access the options for a holding figure 8 procedure."""
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5b4e19a2-dd75-462f-b4da-ed23c6c16de3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_profile_mode" : 2,
                             "set_profile_mode" : 3,
                             "get_level_off_mode" : 4,
                             "set_level_off_mode" : 5,
                             "get_bearing" : 6,
                             "set_bearing" : 7,
                             "get_use_magnetic_heading" : 8,
                             "set_use_magnetic_heading" : 9,
                             "get_range" : 10,
                             "set_range" : 11,
                             "get_length" : 12,
                             "set_length" : 13,
                             "get_width" : 14,
                             "set_width" : 15,
                             "get_use_alternate_entry_points" : 16,
                             "set_use_alternate_entry_points" : 17,
                             "get_turns" : 18,
                             "set_turns" : 19,
                             "get_refuel_dump_mode" : 20,
                             "set_refuel_dump_mode" : 21,
                             "get_hold_cruise_airspeed_options" : 22,
                             "get_enroute_options" : 23,
                             "get_enroute_cruise_airspeed_options" : 24,
                             "get_enroute_turn_direction_options" : 25,
                             "get_minimum_width" : 26,
                             "get_as_procedure" : 27, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureHoldingFigure8._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoldingFigure8 from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoldingFigure8.__dict__ and type(IProcedureHoldingFigure8.__dict__[attrname]) == property:
            return IProcedureHoldingFigure8.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoldingFigure8.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeMSLOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_altitude_options_metadata)

    _get_profile_mode_metadata = { "name" : "profile_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_PROFILE_MODE),) }
    @property
    def profile_mode(self) -> "HOLDING_PROFILE_MODE":
        """The mode defines how the aircraft will perform the holding pattern."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_profile_mode_metadata)

    _set_profile_mode_metadata = { "name" : "profile_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_PROFILE_MODE),) }
    @profile_mode.setter
    def profile_mode(self, newVal:"HOLDING_PROFILE_MODE") -> None:
        """The mode defines how the aircraft will perform the holding pattern."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_profile_mode_metadata, newVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The mode for the level off maneuver."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, newVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The mode for the level off maneuver."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_level_off_mode_metadata, newVal)

    _get_bearing_metadata = { "name" : "bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bearing(self) -> typing.Any:
        """The bearing of the holding point from the site."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_bearing_metadata)

    _set_bearing_metadata = { "name" : "bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the holding point from the site."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_bearing_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_use_magnetic_heading_metadata)

    _set_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_use_magnetic_heading_metadata, newVal)

    _get_range_metadata = { "name" : "range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range(self) -> float:
        """The distance to the holding point from the site."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_range_metadata)

    _set_range_metadata = { "name" : "range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range.setter
    def range(self, newVal:float) -> None:
        """The distance to the holding point from the site."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_range_metadata, newVal)

    _get_length_metadata = { "name" : "length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def length(self) -> float:
        """The distance between the centers of the pattern's arcs."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_length_metadata)

    _set_length_metadata = { "name" : "length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @length.setter
    def length(self, newVal:float) -> None:
        """The distance between the centers of the pattern's arcs."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_length_metadata, newVal)

    _get_width_metadata = { "name" : "width",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def width(self) -> float:
        """The width of the holding pattern."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_width_metadata)

    _set_width_metadata = { "name" : "width",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @width.setter
    def width(self, newVal:float) -> None:
        """The width of the holding pattern."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_width_metadata, newVal)

    _get_use_alternate_entry_points_metadata = { "name" : "use_alternate_entry_points",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_alternate_entry_points(self) -> bool:
        """The option to enter the holding pattern from an alternate point."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_use_alternate_entry_points_metadata)

    _set_use_alternate_entry_points_metadata = { "name" : "use_alternate_entry_points",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_alternate_entry_points.setter
    def use_alternate_entry_points(self, newVal:bool) -> None:
        """The option to enter the holding pattern from an alternate point."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_use_alternate_entry_points_metadata, newVal)

    _get_turns_metadata = { "name" : "turns",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def turns(self) -> int:
        """The number of full turns."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_turns_metadata)

    _set_turns_metadata = { "name" : "turns",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @turns.setter
    def turns(self, newVal:int) -> None:
        """The number of full turns."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_turns_metadata, newVal)

    _get_refuel_dump_mode_metadata = { "name" : "refuel_dump_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLD_REFUEL_DUMP_MODE),) }
    @property
    def refuel_dump_mode(self) -> "HOLD_REFUEL_DUMP_MODE":
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_refuel_dump_mode_metadata)

    _set_refuel_dump_mode_metadata = { "name" : "refuel_dump_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLD_REFUEL_DUMP_MODE),) }
    @refuel_dump_mode.setter
    def refuel_dump_mode(self, newVal:"HOLD_REFUEL_DUMP_MODE") -> None:
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        return self._intf.set_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._set_refuel_dump_mode_metadata, newVal)

    _get_hold_cruise_airspeed_options_metadata = { "name" : "hold_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def hold_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the hold cruise airspeed options."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_hold_cruise_airspeed_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_enroute_cruise_airspeed_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_enroute_turn_direction_options_metadata)

    _get_minimum_width_metadata = { "name" : "get_minimum_width",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def get_minimum_width(self) -> float:
        """The minimum allowable width based on the aircraft's minimum diameter at this altitude."""
        return self._intf.invoke(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_minimum_width_metadata, out_arg())

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureHoldingFigure8._metadata, IProcedureHoldingFigure8._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{5b4e19a2-dd75-462f-b4da-ed23c6c16de3}", IProcedureHoldingFigure8)
agcls.AgTypeNameMap["IProcedureHoldingFigure8"] = IProcedureHoldingFigure8

class IProcedureHoldingRacetrack(object):
    """Interface used to access the options for a holding racetrack procedure."""
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f4b0bbae-3a2b-4333-949c-ab5fc5a232b4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_profile_mode" : 2,
                             "set_profile_mode" : 3,
                             "get_level_off_mode" : 4,
                             "set_level_off_mode" : 5,
                             "get_bearing" : 6,
                             "set_bearing" : 7,
                             "get_use_magnetic_heading" : 8,
                             "set_use_magnetic_heading" : 9,
                             "get_range" : 10,
                             "set_range" : 11,
                             "get_length" : 12,
                             "set_length" : 13,
                             "get_width" : 14,
                             "set_width" : 15,
                             "get_entry_maneuver" : 16,
                             "set_entry_maneuver" : 17,
                             "get_turns" : 18,
                             "set_turns" : 19,
                             "get_refuel_dump_mode" : 20,
                             "set_refuel_dump_mode" : 21,
                             "get_hold_cruise_airspeed_options" : 22,
                             "get_enroute_options" : 23,
                             "get_enroute_cruise_airspeed_options" : 24,
                             "get_enroute_turn_direction_options" : 25,
                             "get_minimum_width" : 26,
                             "get_as_procedure" : 27, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureHoldingRacetrack._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoldingRacetrack from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoldingRacetrack.__dict__ and type(IProcedureHoldingRacetrack.__dict__[attrname]) == property:
            return IProcedureHoldingRacetrack.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoldingRacetrack.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeMSLOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_altitude_options_metadata)

    _get_profile_mode_metadata = { "name" : "profile_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_PROFILE_MODE),) }
    @property
    def profile_mode(self) -> "HOLDING_PROFILE_MODE":
        """The mode defines how the aircraft will perform the holding pattern."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_profile_mode_metadata)

    _set_profile_mode_metadata = { "name" : "profile_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_PROFILE_MODE),) }
    @profile_mode.setter
    def profile_mode(self, newVal:"HOLDING_PROFILE_MODE") -> None:
        """The mode defines how the aircraft will perform the holding pattern."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_profile_mode_metadata, newVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The mode for the level off maneuver."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, newVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The mode for the level off maneuver."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_level_off_mode_metadata, newVal)

    _get_bearing_metadata = { "name" : "bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bearing(self) -> typing.Any:
        """The bearing of the holding point from the site."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_bearing_metadata)

    _set_bearing_metadata = { "name" : "bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the holding point from the site."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_bearing_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_use_magnetic_heading_metadata)

    _set_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_heading.setter
    def use_magnetic_heading(self, newVal:bool) -> None:
        """The option to use a magnetic heading."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_use_magnetic_heading_metadata, newVal)

    _get_range_metadata = { "name" : "range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range(self) -> float:
        """The distance to the holding point from the site."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_range_metadata)

    _set_range_metadata = { "name" : "range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range.setter
    def range(self, newVal:float) -> None:
        """The distance to the holding point from the site."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_range_metadata, newVal)

    _get_length_metadata = { "name" : "length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def length(self) -> float:
        """The distance between the centers of the pattern's arcs."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_length_metadata)

    _set_length_metadata = { "name" : "length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @length.setter
    def length(self, newVal:float) -> None:
        """The distance between the centers of the pattern's arcs."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_length_metadata, newVal)

    _get_width_metadata = { "name" : "width",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def width(self) -> float:
        """The width of the holding pattern."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_width_metadata)

    _set_width_metadata = { "name" : "width",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @width.setter
    def width(self, newVal:float) -> None:
        """The width of the holding pattern."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_width_metadata, newVal)

    _get_entry_maneuver_metadata = { "name" : "entry_maneuver",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_ENTRY_MANEUVER),) }
    @property
    def entry_maneuver(self) -> "HOLDING_ENTRY_MANEUVER":
        """Defines how the aircraft will enter the holding pattern."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_entry_maneuver_metadata)

    _set_entry_maneuver_metadata = { "name" : "entry_maneuver",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLDING_ENTRY_MANEUVER),) }
    @entry_maneuver.setter
    def entry_maneuver(self, newVal:"HOLDING_ENTRY_MANEUVER") -> None:
        """Defines how the aircraft will enter the holding pattern."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_entry_maneuver_metadata, newVal)

    _get_turns_metadata = { "name" : "turns",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def turns(self) -> int:
        """The number of full turns."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_turns_metadata)

    _set_turns_metadata = { "name" : "turns",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @turns.setter
    def turns(self, newVal:int) -> None:
        """The number of full turns."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_turns_metadata, newVal)

    _get_refuel_dump_mode_metadata = { "name" : "refuel_dump_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOLD_REFUEL_DUMP_MODE),) }
    @property
    def refuel_dump_mode(self) -> "HOLD_REFUEL_DUMP_MODE":
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_refuel_dump_mode_metadata)

    _set_refuel_dump_mode_metadata = { "name" : "refuel_dump_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOLD_REFUEL_DUMP_MODE),) }
    @refuel_dump_mode.setter
    def refuel_dump_mode(self, newVal:"HOLD_REFUEL_DUMP_MODE") -> None:
        """The mode that defines when the aircraft will leave the holding pattern for a Refuel/Dump operation."""
        return self._intf.set_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._set_refuel_dump_mode_metadata, newVal)

    _get_hold_cruise_airspeed_options_metadata = { "name" : "hold_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def hold_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the hold cruise airspeed options."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_hold_cruise_airspeed_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "IEnrouteAndDelayOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_enroute_cruise_airspeed_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_enroute_turn_direction_options_metadata)

    _get_minimum_width_metadata = { "name" : "get_minimum_width",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def get_minimum_width(self) -> float:
        """The minimum allowable width based on the aircraft's minimum diameter at this altitude."""
        return self._intf.invoke(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_minimum_width_metadata, out_arg())

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureHoldingRacetrack._metadata, IProcedureHoldingRacetrack._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{f4b0bbae-3a2b-4333-949c-ab5fc5a232b4}", IProcedureHoldingRacetrack)
agcls.AgTypeNameMap["IProcedureHoldingRacetrack"] = IProcedureHoldingRacetrack

class IProcedureTransitionToHover(object):
    """Interface used to access the options for a transition to hover procedure."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{06667f6e-68d3-4a3f-b285-64c556aac5c0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_reference" : 1,
                             "set_altitude_reference" : 2,
                             "get_altitude" : 3,
                             "set_altitude" : 4,
                             "get_use_magnetic_heading" : 5,
                             "get_course" : 6,
                             "get_transition_into_wind" : 7,
                             "set_transition_course" : 8,
                             "set_transition_into_wind" : 9,
                             "get_enroute_options" : 10,
                             "get_enroute_turn_direction_options" : 11,
                             "get_vertical_plane_options" : 12,
                             "get_smooth_transition_mode" : 13,
                             "set_smooth_transition_mode" : 14,
                             "get_as_procedure" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureTransitionToHover._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTransitionToHover from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTransitionToHover.__dict__ and type(IProcedureTransitionToHover.__dict__[attrname]) == property:
            return IProcedureTransitionToHover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTransitionToHover.")
    
    _get_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @property
    def altitude_reference(self) -> "AGL_MSL":
        """The altitude reference."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_altitude_reference_metadata)

    _set_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AGL_MSL),) }
    @altitude_reference.setter
    def altitude_reference(self, newVal:"AGL_MSL") -> None:
        """The altitude reference."""
        return self._intf.set_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._set_altitude_reference_metadata, newVal)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The altitude for the procedure."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, newVal:float) -> None:
        """The altitude for the procedure."""
        return self._intf.set_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._set_altitude_metadata, newVal)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the course."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_use_magnetic_heading_metadata)

    _get_course_metadata = { "name" : "course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def course(self) -> typing.Any:
        """The course for the procedure."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_course_metadata)

    _get_transition_into_wind_metadata = { "name" : "transition_into_wind",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def transition_into_wind(self) -> bool:
        """The option to transition into the wind."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_transition_into_wind_metadata)

    _set_transition_course_metadata = { "name" : "set_transition_course",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def set_transition_course(self, course:typing.Any, useMagneticCourse:bool) -> None:
        """Set the course and heading reference."""
        return self._intf.invoke(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._set_transition_course_metadata, course, useMagneticCourse)

    _set_transition_into_wind_metadata = { "name" : "set_transition_into_wind",
            "arg_types" : (),
            "marshallers" : () }
    def set_transition_into_wind(self) -> None:
        """Set the option to transition into the wind to true."""
        return self._intf.invoke(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._set_transition_into_wind_metadata, )

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_enroute_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_enroute_turn_direction_options_metadata)

    _get_vertical_plane_options_metadata = { "name" : "vertical_plane_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vertical_plane_options(self) -> "VerticalPlaneAndFlightPathOptions":
        """Get the vertical plane options."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_vertical_plane_options_metadata)

    _get_smooth_transition_mode_metadata = { "name" : "smooth_transition_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TRANSITION_TO_HOVER_MODE),) }
    @property
    def smooth_transition_mode(self) -> "TRANSITION_TO_HOVER_MODE":
        """The transition mode of the aircraft at the end of the procedure."""
        return self._intf.get_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_smooth_transition_mode_metadata)

    _set_smooth_transition_mode_metadata = { "name" : "smooth_transition_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TRANSITION_TO_HOVER_MODE),) }
    @smooth_transition_mode.setter
    def smooth_transition_mode(self, newVal:"TRANSITION_TO_HOVER_MODE") -> None:
        """The transition mode of the aircraft at the end of the procedure."""
        return self._intf.set_property(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._set_smooth_transition_mode_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureTransitionToHover._metadata, IProcedureTransitionToHover._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{06667f6e-68d3-4a3f-b285-64c556aac5c0}", IProcedureTransitionToHover)
agcls.AgTypeNameMap["IProcedureTransitionToHover"] = IProcedureTransitionToHover

class IProcedureTerrainFollow(object):
    """Interface used to access the options for a terrain following procedure."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4c79076e-a174-469f-8370-0cb2271446ec}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_agl" : 1,
                             "set_altitude_agl" : 2,
                             "get_navigation_options" : 3,
                             "get_terrain_following_airspeed_options" : 4,
                             "get_reduce_turn_radii" : 5,
                             "set_reduce_turn_radii" : 6,
                             "get_turn_factor" : 7,
                             "set_turn_factor" : 8,
                             "get_as_procedure" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureTerrainFollow._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTerrainFollow from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTerrainFollow.__dict__ and type(IProcedureTerrainFollow.__dict__[attrname]) == property:
            return IProcedureTerrainFollow.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTerrainFollow.")
    
    _get_altitude_agl_metadata = { "name" : "altitude_agl",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_agl(self) -> float:
        """The altitude above ground level the aircraft will fly."""
        return self._intf.get_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._get_altitude_agl_metadata)

    _set_altitude_agl_metadata = { "name" : "altitude_agl",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_agl.setter
    def altitude_agl(self, newVal:float) -> None:
        """The altitude above ground level the aircraft will fly."""
        return self._intf.set_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._set_altitude_agl_metadata, newVal)

    _get_navigation_options_metadata = { "name" : "navigation_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def navigation_options(self) -> "NavigationOptions":
        """Get the navigation options."""
        return self._intf.get_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._get_navigation_options_metadata)

    _get_terrain_following_airspeed_options_metadata = { "name" : "terrain_following_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def terrain_following_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the terrain following airspeed options."""
        return self._intf.get_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._get_terrain_following_airspeed_options_metadata)

    _get_reduce_turn_radii_metadata = { "name" : "reduce_turn_radii",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def reduce_turn_radii(self) -> bool:
        """Option to use the minimum speed to compute the turn radius."""
        return self._intf.get_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._get_reduce_turn_radii_metadata)

    _set_reduce_turn_radii_metadata = { "name" : "reduce_turn_radii",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @reduce_turn_radii.setter
    def reduce_turn_radii(self, newVal:bool) -> None:
        """Option to use the minimum speed to compute the turn radius."""
        return self._intf.set_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._set_reduce_turn_radii_metadata, newVal)

    _get_turn_factor_metadata = { "name" : "turn_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def turn_factor(self) -> float:
        """The maximum turn radius factor."""
        return self._intf.get_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._get_turn_factor_metadata)

    _set_turn_factor_metadata = { "name" : "turn_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @turn_factor.setter
    def turn_factor(self, newVal:float) -> None:
        """The maximum turn radius factor."""
        return self._intf.set_property(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._set_turn_factor_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureTerrainFollow._metadata, IProcedureTerrainFollow._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4c79076e-a174-469f-8370-0cb2271446ec}", IProcedureTerrainFollow)
agcls.AgTypeNameMap["IProcedureTerrainFollow"] = IProcedureTerrainFollow

class IProcedureHover(object):
    """Interface used to access the options for a hover procedure."""
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9e58b1a4-ae09-41dd-aadb-fd1886d01fff}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_hover_mode" : 2,
                             "set_hover_mode" : 3,
                             "get_fixed_time" : 4,
                             "set_fixed_time" : 5,
                             "get_heading_mode" : 6,
                             "set_heading_mode" : 7,
                             "get_final_heading_mode" : 8,
                             "set_relative_course" : 9,
                             "set_absolute_course" : 10,
                             "set_final_translation_course" : 11,
                             "get_absolute_course" : 12,
                             "get_relative_course" : 13,
                             "get_use_magnetic_heading" : 14,
                             "get_final_heading_rate" : 15,
                             "set_final_heading_rate" : 16,
                             "get_translation_mode" : 17,
                             "set_translation_mode" : 18,
                             "get_bearing" : 19,
                             "set_bearing" : 20,
                             "get_use_magnetic_bearing" : 21,
                             "set_use_magnetic_bearing" : 22,
                             "get_range" : 23,
                             "set_range" : 24,
                             "get_final_course_mode" : 25,
                             "set_final_course_mode" : 26,
                             "get_smooth_translation_mode" : 27,
                             "set_smooth_translation_mode" : 28,
                             "get_radius_factor" : 29,
                             "set_radius_factor" : 30,
                             "get_as_procedure" : 31, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureHover._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHover from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHover.__dict__ and type(IProcedureHover.__dict__[attrname]) == property:
            return IProcedureHover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHover.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "HoverAltitudeOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_altitude_options_metadata)

    _get_hover_mode_metadata = { "name" : "hover_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(HOVER_MODE),) }
    @property
    def hover_mode(self) -> "HOVER_MODE":
        """The option to have the aircraft hover in place for a fixed time or to perform a hovering maneuver."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_hover_mode_metadata)

    _set_hover_mode_metadata = { "name" : "hover_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(HOVER_MODE),) }
    @hover_mode.setter
    def hover_mode(self, newVal:"HOVER_MODE") -> None:
        """The option to have the aircraft hover in place for a fixed time or to perform a hovering maneuver."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_hover_mode_metadata, newVal)

    _get_fixed_time_metadata = { "name" : "fixed_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def fixed_time(self) -> typing.Any:
        """The time to hover in place."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_fixed_time_metadata)

    _set_fixed_time_metadata = { "name" : "fixed_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @fixed_time.setter
    def fixed_time(self, newVal:typing.Any) -> None:
        """The time to hover in place."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_fixed_time_metadata, newVal)

    _get_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_HEADING_MODE),) }
    @property
    def heading_mode(self) -> "VTOL_HEADING_MODE":
        """The heading mode for the aircraft."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_heading_mode_metadata)

    _set_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_HEADING_MODE),) }
    @heading_mode.setter
    def heading_mode(self, newVal:"VTOL_HEADING_MODE") -> None:
        """The heading mode for the aircraft."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_heading_mode_metadata, newVal)

    _get_final_heading_mode_metadata = { "name" : "final_heading_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_FINAL_HEADING_MODE),) }
    @property
    def final_heading_mode(self) -> "VTOL_FINAL_HEADING_MODE":
        """The mode to define the heading at the end of the hover."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_final_heading_mode_metadata)

    _set_relative_course_metadata = { "name" : "set_relative_course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_relative_course(self, headingChange:typing.Any) -> None:
        """Set the relative heading change."""
        return self._intf.invoke(IProcedureHover._metadata, IProcedureHover._set_relative_course_metadata, headingChange)

    _set_absolute_course_metadata = { "name" : "set_absolute_course",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def set_absolute_course(self, course:typing.Any, isMagnetic:bool) -> None:
        """Set the absolute heading and reference."""
        return self._intf.invoke(IProcedureHover._metadata, IProcedureHover._set_absolute_course_metadata, course, isMagnetic)

    _set_final_translation_course_metadata = { "name" : "set_final_translation_course",
            "arg_types" : (),
            "marshallers" : () }
    def set_final_translation_course(self) -> None:
        """The option to have the final heading to match the translation bearing."""
        return self._intf.invoke(IProcedureHover._metadata, IProcedureHover._set_final_translation_course_metadata, )

    _get_absolute_course_metadata = { "name" : "absolute_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def absolute_course(self) -> typing.Any:
        """The absolute course for the heading."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_absolute_course_metadata)

    _get_relative_course_metadata = { "name" : "relative_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def relative_course(self) -> typing.Any:
        """The relative heading change."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_relative_course_metadata)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the heading course."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_use_magnetic_heading_metadata)

    _get_final_heading_rate_metadata = { "name" : "final_heading_rate",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @property
    def final_heading_rate(self) -> "VTOL_RATE_MODE":
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_final_heading_rate_metadata)

    _set_final_heading_rate_metadata = { "name" : "final_heading_rate",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @final_heading_rate.setter
    def final_heading_rate(self, newVal:"VTOL_RATE_MODE") -> None:
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_final_heading_rate_metadata, newVal)

    _get_translation_mode_metadata = { "name" : "translation_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_TRANSLATION_MODE),) }
    @property
    def translation_mode(self) -> "VTOL_TRANSLATION_MODE":
        """Define how the aircraft will translate during the hover."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_translation_mode_metadata)

    _set_translation_mode_metadata = { "name" : "translation_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_TRANSLATION_MODE),) }
    @translation_mode.setter
    def translation_mode(self, newVal:"VTOL_TRANSLATION_MODE") -> None:
        """Define how the aircraft will translate during the hover."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_translation_mode_metadata, newVal)

    _get_bearing_metadata = { "name" : "bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def bearing(self) -> typing.Any:
        """The bearing of the translation during the hover."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_bearing_metadata)

    _set_bearing_metadata = { "name" : "bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @bearing.setter
    def bearing(self, newVal:typing.Any) -> None:
        """The bearing of the translation during the hover."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_bearing_metadata, newVal)

    _get_use_magnetic_bearing_metadata = { "name" : "use_magnetic_bearing",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_bearing(self) -> bool:
        """The option to use a magnetic heading for the translation bearing."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_use_magnetic_bearing_metadata)

    _set_use_magnetic_bearing_metadata = { "name" : "use_magnetic_bearing",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_magnetic_bearing.setter
    def use_magnetic_bearing(self, newVal:bool) -> None:
        """The option to use a magnetic heading for the translation bearing."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_use_magnetic_bearing_metadata, newVal)

    _get_range_metadata = { "name" : "range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def range(self) -> float:
        """The range to translate during the hover."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_range_metadata)

    _set_range_metadata = { "name" : "range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @range.setter
    def range(self, newVal:float) -> None:
        """The range to translate during the hover."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_range_metadata, newVal)

    _get_final_course_mode_metadata = { "name" : "final_course_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_TRANSLATION_FINAL_COURSE_MODE),) }
    @property
    def final_course_mode(self) -> "VTOL_TRANSLATION_FINAL_COURSE_MODE":
        """The mode to specify the final course at the end of the hover."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_final_course_mode_metadata)

    _set_final_course_mode_metadata = { "name" : "final_course_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_TRANSLATION_FINAL_COURSE_MODE),) }
    @final_course_mode.setter
    def final_course_mode(self, newVal:"VTOL_TRANSLATION_FINAL_COURSE_MODE") -> None:
        """The mode to specify the final course at the end of the hover."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_final_course_mode_metadata, newVal)

    _get_smooth_translation_mode_metadata = { "name" : "smooth_translation_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @property
    def smooth_translation_mode(self) -> "VTOL_RATE_MODE":
        """The translation mode of the aircraft at the end of the procedure."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_smooth_translation_mode_metadata)

    _set_smooth_translation_mode_metadata = { "name" : "smooth_translation_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @smooth_translation_mode.setter
    def smooth_translation_mode(self, newVal:"VTOL_RATE_MODE") -> None:
        """The translation mode of the aircraft at the end of the procedure."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_smooth_translation_mode_metadata, newVal)

    _get_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def radius_factor(self) -> float:
        """The turn radius factor."""
        return self._intf.get_property(IProcedureHover._metadata, IProcedureHover._get_radius_factor_metadata)

    _set_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The turn radius factor."""
        return self._intf.set_property(IProcedureHover._metadata, IProcedureHover._set_radius_factor_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureHover._metadata, IProcedureHover._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{9e58b1a4-ae09-41dd-aadb-fd1886d01fff}", IProcedureHover)
agcls.AgTypeNameMap["IProcedureHover"] = IProcedureHover

class IProcedureHoverTranslate(object):
    """Interface used to access the options for a hover translate procedure."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7c58df50-e3d1-4e96-bb3c-8cc2b2c58343}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_heading_mode" : 2,
                             "set_heading_mode" : 3,
                             "get_final_heading_mode" : 4,
                             "set_relative_course" : 5,
                             "set_absolute_course" : 6,
                             "set_final_translation_course" : 7,
                             "get_absolute_course" : 8,
                             "get_relative_course" : 9,
                             "get_use_magnetic_heading" : 10,
                             "get_final_heading_rate" : 11,
                             "set_final_heading_rate" : 12,
                             "get_final_course_mode" : 13,
                             "set_final_course_mode" : 14,
                             "get_smooth_translation_mode" : 15,
                             "set_smooth_translation_mode" : 16,
                             "get_radius_factor" : 17,
                             "set_radius_factor" : 18,
                             "get_as_procedure" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureHoverTranslate._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureHoverTranslate from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureHoverTranslate.__dict__ and type(IProcedureHoverTranslate.__dict__[attrname]) == property:
            return IProcedureHoverTranslate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureHoverTranslate.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "HoverAltitudeOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_altitude_options_metadata)

    _get_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_HEADING_MODE),) }
    @property
    def heading_mode(self) -> "VTOL_HEADING_MODE":
        """The heading mode for the aircraft."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_heading_mode_metadata)

    _set_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_HEADING_MODE),) }
    @heading_mode.setter
    def heading_mode(self, newVal:"VTOL_HEADING_MODE") -> None:
        """The heading mode for the aircraft."""
        return self._intf.set_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_heading_mode_metadata, newVal)

    _get_final_heading_mode_metadata = { "name" : "final_heading_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_FINAL_HEADING_MODE),) }
    @property
    def final_heading_mode(self) -> "VTOL_FINAL_HEADING_MODE":
        """The mode to define the heading at the end of the hover."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_final_heading_mode_metadata)

    _set_relative_course_metadata = { "name" : "set_relative_course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_relative_course(self, headingChange:typing.Any) -> None:
        """Set the relative heading change."""
        return self._intf.invoke(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_relative_course_metadata, headingChange)

    _set_absolute_course_metadata = { "name" : "set_absolute_course",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def set_absolute_course(self, course:typing.Any, isMagnetic:bool) -> None:
        """Set the absolute heading and reference."""
        return self._intf.invoke(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_absolute_course_metadata, course, isMagnetic)

    _set_final_translation_course_metadata = { "name" : "set_final_translation_course",
            "arg_types" : (),
            "marshallers" : () }
    def set_final_translation_course(self) -> None:
        """The option to have the final heading to match the translation bearing."""
        return self._intf.invoke(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_final_translation_course_metadata, )

    _get_absolute_course_metadata = { "name" : "absolute_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def absolute_course(self) -> typing.Any:
        """The absolute course for the heading."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_absolute_course_metadata)

    _get_relative_course_metadata = { "name" : "relative_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def relative_course(self) -> typing.Any:
        """The relative heading change."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_relative_course_metadata)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the heading course."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_use_magnetic_heading_metadata)

    _get_final_heading_rate_metadata = { "name" : "final_heading_rate",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @property
    def final_heading_rate(self) -> "VTOL_RATE_MODE":
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_final_heading_rate_metadata)

    _set_final_heading_rate_metadata = { "name" : "final_heading_rate",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @final_heading_rate.setter
    def final_heading_rate(self, newVal:"VTOL_RATE_MODE") -> None:
        """The options to define the heading rate of the aircraft at the end of the procedure."""
        return self._intf.set_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_final_heading_rate_metadata, newVal)

    _get_final_course_mode_metadata = { "name" : "final_course_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_TRANSLATION_FINAL_COURSE_MODE),) }
    @property
    def final_course_mode(self) -> "VTOL_TRANSLATION_FINAL_COURSE_MODE":
        """The mode to specify the final course at the end of the hover."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_final_course_mode_metadata)

    _set_final_course_mode_metadata = { "name" : "final_course_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_TRANSLATION_FINAL_COURSE_MODE),) }
    @final_course_mode.setter
    def final_course_mode(self, newVal:"VTOL_TRANSLATION_FINAL_COURSE_MODE") -> None:
        """The mode to specify the final course at the end of the hover."""
        return self._intf.set_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_final_course_mode_metadata, newVal)

    _get_smooth_translation_mode_metadata = { "name" : "smooth_translation_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @property
    def smooth_translation_mode(self) -> "VTOL_RATE_MODE":
        """The translation mode of the aircraft at the end of the procedure."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_smooth_translation_mode_metadata)

    _set_smooth_translation_mode_metadata = { "name" : "smooth_translation_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @smooth_translation_mode.setter
    def smooth_translation_mode(self, newVal:"VTOL_RATE_MODE") -> None:
        """The translation mode of the aircraft at the end of the procedure."""
        return self._intf.set_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_smooth_translation_mode_metadata, newVal)

    _get_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def radius_factor(self) -> float:
        """The turn radius factor."""
        return self._intf.get_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_radius_factor_metadata)

    _set_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The turn radius factor."""
        return self._intf.set_property(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._set_radius_factor_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureHoverTranslate._metadata, IProcedureHoverTranslate._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7c58df50-e3d1-4e96-bb3c-8cc2b2c58343}", IProcedureHoverTranslate)
agcls.AgTypeNameMap["IProcedureHoverTranslate"] = IProcedureHoverTranslate

class IProcedureTransitionToForwardFlight(object):
    """Interface used to access the options for a transition to forward flight procedure."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5dbdb660-3320-47c7-ac2b-f1ebd3b0eeae}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_transition_course_mode" : 1,
                             "set_transition_into_wind" : 2,
                             "set_absolute_course" : 3,
                             "set_relative_course" : 4,
                             "get_use_magnetic_heading" : 5,
                             "get_absolute_course" : 6,
                             "get_relative_course" : 7,
                             "get_flight_path_angle" : 8,
                             "set_flight_path_angle" : 9,
                             "get_as_procedure" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureTransitionToForwardFlight._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureTransitionToForwardFlight from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureTransitionToForwardFlight.__dict__ and type(IProcedureTransitionToForwardFlight.__dict__[attrname]) == property:
            return IProcedureTransitionToForwardFlight.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureTransitionToForwardFlight.")
    
    _get_transition_course_mode_metadata = { "name" : "transition_course_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_TRANSITION_MODE),) }
    @property
    def transition_course_mode(self) -> "VTOL_TRANSITION_MODE":
        """The mode to specify the course of the transition maneuver."""
        return self._intf.get_property(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._get_transition_course_mode_metadata)

    _set_transition_into_wind_metadata = { "name" : "set_transition_into_wind",
            "arg_types" : (),
            "marshallers" : () }
    def set_transition_into_wind(self) -> None:
        """Set the option to transition into the wind to true."""
        return self._intf.invoke(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._set_transition_into_wind_metadata, )

    _set_absolute_course_metadata = { "name" : "set_absolute_course",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def set_absolute_course(self, course:typing.Any, useMagneticCourse:bool) -> None:
        """Set the mode to absolute and specify the course and heading reference."""
        return self._intf.invoke(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._set_absolute_course_metadata, course, useMagneticCourse)

    _set_relative_course_metadata = { "name" : "set_relative_course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_relative_course(self, headingChange:typing.Any) -> None:
        """Set the mode to relative and specify the heading change."""
        return self._intf.invoke(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._set_relative_course_metadata, headingChange)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading for the course."""
        return self._intf.get_property(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._get_use_magnetic_heading_metadata)

    _get_absolute_course_metadata = { "name" : "absolute_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def absolute_course(self) -> typing.Any:
        """The absolute course for the procedure."""
        return self._intf.get_property(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._get_absolute_course_metadata)

    _get_relative_course_metadata = { "name" : "relative_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def relative_course(self) -> typing.Any:
        """The relative course for the procedure."""
        return self._intf.get_property(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._get_relative_course_metadata)

    _get_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def flight_path_angle(self) -> typing.Any:
        """The pitch angle of the flight path at the end of the procedure."""
        return self._intf.get_property(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._get_flight_path_angle_metadata)

    _set_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The pitch angle of the flight path at the end of the procedure."""
        return self._intf.set_property(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._set_flight_path_angle_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureTransitionToForwardFlight._metadata, IProcedureTransitionToForwardFlight._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{5dbdb660-3320-47c7-ac2b-f1ebd3b0eeae}", IProcedureTransitionToForwardFlight)
agcls.AgTypeNameMap["IProcedureTransitionToForwardFlight"] = IProcedureTransitionToForwardFlight

class IProcedureVerticalTakeoff(object):
    """Interface used to access the options for a vertical takeoff procedure."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1d8d4dbd-b18b-4fc7-862f-0afbdff5054c}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_above_point" : 1,
                             "set_altitude_above_point" : 2,
                             "get_final_altitude_rate" : 3,
                             "set_final_altitude_rate" : 4,
                             "get_altitude_offset" : 5,
                             "set_altitude_offset" : 6,
                             "set_heading" : 7,
                             "get_heading" : 8,
                             "get_use_magnetic_heading" : 9,
                             "get_heading_into_wind" : 10,
                             "set_heading_into_wind" : 11,
                             "get_hold_on_deck" : 12,
                             "set_hold_on_deck" : 13,
                             "get_as_procedure" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureVerticalTakeoff._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureVerticalTakeoff from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureVerticalTakeoff.__dict__ and type(IProcedureVerticalTakeoff.__dict__[attrname]) == property:
            return IProcedureVerticalTakeoff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureVerticalTakeoff.")
    
    _get_altitude_above_point_metadata = { "name" : "altitude_above_point",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_above_point(self) -> float:
        """The altitude the aircraft will takeoff to."""
        return self._intf.get_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_altitude_above_point_metadata)

    _set_altitude_above_point_metadata = { "name" : "altitude_above_point",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_above_point.setter
    def altitude_above_point(self, newVal:float) -> None:
        """The altitude the aircraft will takeoff to."""
        return self._intf.set_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._set_altitude_above_point_metadata, newVal)

    _get_final_altitude_rate_metadata = { "name" : "final_altitude_rate",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @property
    def final_altitude_rate(self) -> "VTOL_RATE_MODE":
        """The altitude rate at the end of the procedure."""
        return self._intf.get_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_final_altitude_rate_metadata)

    _set_final_altitude_rate_metadata = { "name" : "final_altitude_rate",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @final_altitude_rate.setter
    def final_altitude_rate(self, newVal:"VTOL_RATE_MODE") -> None:
        """The altitude rate at the end of the procedure."""
        return self._intf.set_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._set_final_altitude_rate_metadata, newVal)

    _get_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_offset(self) -> float:
        """The altitude offset from the site to begin the vertical takeoff."""
        return self._intf.get_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_altitude_offset_metadata)

    _set_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The altitude offset from the site to begin the vertical takeoff."""
        return self._intf.set_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._set_altitude_offset_metadata, newVal)

    _set_heading_metadata = { "name" : "set_heading",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def set_heading(self, heading:typing.Any, isMagnetic:bool) -> None:
        """Set the heading and heading reference."""
        return self._intf.invoke(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._set_heading_metadata, heading, isMagnetic)

    _get_heading_metadata = { "name" : "heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading(self) -> typing.Any:
        """The heading for the procedure."""
        return self._intf.get_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_heading_metadata)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        return self._intf.get_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_use_magnetic_heading_metadata)

    _get_heading_into_wind_metadata = { "name" : "heading_into_wind",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def heading_into_wind(self) -> bool:
        """The option to define the heading according to the wind direction."""
        return self._intf.get_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_heading_into_wind_metadata)

    _set_heading_into_wind_metadata = { "name" : "heading_into_wind",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @heading_into_wind.setter
    def heading_into_wind(self, pVal:bool) -> None:
        """The option to define the heading according to the wind direction."""
        return self._intf.set_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._set_heading_into_wind_metadata, pVal)

    _get_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hold_on_deck(self) -> typing.Any:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.get_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_hold_on_deck_metadata)

    _set_hold_on_deck_metadata = { "name" : "hold_on_deck",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hold_on_deck.setter
    def hold_on_deck(self, inVal:typing.Any) -> None:
        """The duration the aircraft will wait before beginning the takeoff."""
        return self._intf.set_property(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._set_hold_on_deck_metadata, inVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureVerticalTakeoff._metadata, IProcedureVerticalTakeoff._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{1d8d4dbd-b18b-4fc7-862f-0afbdff5054c}", IProcedureVerticalTakeoff)
agcls.AgTypeNameMap["IProcedureVerticalTakeoff"] = IProcedureVerticalTakeoff

class IProcedureVerticalLanding(object):
    """Interface used to access the options for a vertical landing procedure."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{22009a25-626b-4677-aac4-668cc62a6d9f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_above_point" : 1,
                             "set_altitude_above_point" : 2,
                             "get_final_altitude_rate" : 3,
                             "set_final_altitude_rate" : 4,
                             "get_altitude_offset" : 5,
                             "set_altitude_offset" : 6,
                             "get_heading_mode" : 7,
                             "set_heading_mode" : 8,
                             "set_heading" : 9,
                             "get_heading" : 10,
                             "get_use_magnetic_heading" : 11,
                             "get_radius_factor" : 12,
                             "set_radius_factor" : 13,
                             "get_as_procedure" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureVerticalLanding._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureVerticalLanding from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureVerticalLanding.__dict__ and type(IProcedureVerticalLanding.__dict__[attrname]) == property:
            return IProcedureVerticalLanding.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureVerticalLanding.")
    
    _get_altitude_above_point_metadata = { "name" : "altitude_above_point",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_above_point(self) -> float:
        """The altitude the aircraft will takeoff to."""
        return self._intf.get_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_altitude_above_point_metadata)

    _set_altitude_above_point_metadata = { "name" : "altitude_above_point",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_above_point.setter
    def altitude_above_point(self, newVal:float) -> None:
        """The altitude the aircraft will takeoff to."""
        return self._intf.set_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._set_altitude_above_point_metadata, newVal)

    _get_final_altitude_rate_metadata = { "name" : "final_altitude_rate",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @property
    def final_altitude_rate(self) -> "VTOL_RATE_MODE":
        """The altitude rate at the end of the procedure."""
        return self._intf.get_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_final_altitude_rate_metadata)

    _set_final_altitude_rate_metadata = { "name" : "final_altitude_rate",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VTOL_RATE_MODE),) }
    @final_altitude_rate.setter
    def final_altitude_rate(self, newVal:"VTOL_RATE_MODE") -> None:
        """The altitude rate at the end of the procedure."""
        return self._intf.set_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._set_final_altitude_rate_metadata, newVal)

    _get_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_offset(self) -> float:
        """The altitude offset from the site to begin the vertical takeoff."""
        return self._intf.get_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_altitude_offset_metadata)

    _set_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The altitude offset from the site to begin the vertical takeoff."""
        return self._intf.set_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._set_altitude_offset_metadata, newVal)

    _get_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VERT_LANDING_MODE),) }
    @property
    def heading_mode(self) -> "VERT_LANDING_MODE":
        """The mode to define the heading during the landing."""
        return self._intf.get_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_heading_mode_metadata)

    _set_heading_mode_metadata = { "name" : "heading_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VERT_LANDING_MODE),) }
    @heading_mode.setter
    def heading_mode(self, newVal:"VERT_LANDING_MODE") -> None:
        """The mode to define the heading during the landing."""
        return self._intf.set_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._set_heading_mode_metadata, newVal)

    _set_heading_metadata = { "name" : "set_heading",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def set_heading(self, heading:typing.Any, isMagnetic:bool) -> None:
        """Set the heading and heading reference."""
        return self._intf.invoke(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._set_heading_metadata, heading, isMagnetic)

    _get_heading_metadata = { "name" : "heading",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def heading(self) -> typing.Any:
        """The heading for the procedure."""
        return self._intf.get_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_heading_metadata)

    _get_use_magnetic_heading_metadata = { "name" : "use_magnetic_heading",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_magnetic_heading(self) -> bool:
        """The option to use a magnetic heading."""
        return self._intf.get_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_use_magnetic_heading_metadata)

    _get_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def radius_factor(self) -> float:
        """The radius factor for turns performed while translating to the hover point."""
        return self._intf.get_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_radius_factor_metadata)

    _set_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The radius factor for turns performed while translating to the hover point."""
        return self._intf.set_property(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._set_radius_factor_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureVerticalLanding._metadata, IProcedureVerticalLanding._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{22009a25-626b-4677-aac4-668cc62a6d9f}", IProcedureVerticalLanding)
agcls.AgTypeNameMap["IProcedureVerticalLanding"] = IProcedureVerticalLanding

class IProcedureReferenceState(object):
    """Interface used to access the options for a reference state procedure."""
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{729bb865-8651-4e35-beac-db80804116bb}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_time" : 1,
                             "set_start_time" : 2,
                             "get_as_procedure" : 3,
                             "get_latitude" : 4,
                             "set_latitude" : 5,
                             "get_longitude" : 6,
                             "set_longitude" : 7,
                             "get_use_default_cruise_altitude" : 8,
                             "set_use_default_cruise_altitude" : 9,
                             "get_msl_altitude" : 10,
                             "set_msl_altitude" : 11,
                             "get_performance_mode" : 12,
                             "set_performance_mode" : 13,
                             "get_reference_frame" : 14,
                             "set_reference_frame" : 15,
                             "get_fuel_flow" : 16,
                             "set_fuel_flow" : 17,
                             "get_mode_as_forward_flight" : 18,
                             "get_mode_as_takeoff_landing" : 19,
                             "get_mode_as_hover" : 20,
                             "get_mode_as_weight_on_wheels" : 21, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureReferenceState._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureReferenceState from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureReferenceState.__dict__ and type(IProcedureReferenceState.__dict__[attrname]) == property:
            return IProcedureReferenceState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureReferenceState.")
    
    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_time(self) -> typing.Any:
        """The start time of the reference state."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_start_time_metadata)

    _set_start_time_metadata = { "name" : "start_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @start_time.setter
    def start_time(self, newVal:typing.Any) -> None:
        """The start time of the reference state."""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_start_time_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureReferenceState._metadata, IProcedureReferenceState._get_as_procedure_metadata, out_arg())

    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def latitude(self) -> typing.Any:
        """The waypoint latitude."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        """The waypoint latitude."""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_latitude_metadata, newVal)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def longitude(self) -> typing.Any:
        """The waypoint longitude."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        """The waypoint longitude."""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_longitude_metadata, newVal)

    _get_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_default_cruise_altitude(self) -> bool:
        """Opt whether to use the default cruise altitude."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_use_default_cruise_altitude_metadata)

    _set_use_default_cruise_altitude_metadata = { "name" : "use_default_cruise_altitude",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_default_cruise_altitude.setter
    def use_default_cruise_altitude(self, newVal:bool) -> None:
        """Opt whether to use the default cruise altitude."""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_use_default_cruise_altitude_metadata, newVal)

    _get_msl_altitude_metadata = { "name" : "msl_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def msl_altitude(self) -> float:
        """The MSL altitude. Can only be used when the option to use the default cruise altitude is off."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_msl_altitude_metadata)

    _set_msl_altitude_metadata = { "name" : "msl_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @msl_altitude.setter
    def msl_altitude(self, newVal:float) -> None:
        """Set the MSLAltitude"""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_msl_altitude_metadata, newVal)

    _get_performance_mode_metadata = { "name" : "performance_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_PERF_MODE),) }
    @property
    def performance_mode(self) -> "REFERENCE_STATE_PERF_MODE":
        """The type of motion the aircraft is engaged in."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_performance_mode_metadata)

    _set_performance_mode_metadata = { "name" : "performance_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(REFERENCE_STATE_PERF_MODE),) }
    @performance_mode.setter
    def performance_mode(self, newVal:"REFERENCE_STATE_PERF_MODE") -> None:
        """The type of motion the aircraft is engaged in."""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_performance_mode_metadata, newVal)

    _get_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @property
    def reference_frame(self) -> "BASIC_MANEUVER_REFERENCE_FRAME":
        """The reference frame the aircraft will use."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "name" : "reference_frame",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(BASIC_MANEUVER_REFERENCE_FRAME),) }
    @reference_frame.setter
    def reference_frame(self, newVal:"BASIC_MANEUVER_REFERENCE_FRAME") -> None:
        """The reference frame the aircraft will use."""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_reference_frame_metadata, newVal)

    _get_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fuel_flow(self) -> float:
        """The rate of fuel consumption."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_fuel_flow_metadata)

    _set_fuel_flow_metadata = { "name" : "fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fuel_flow.setter
    def fuel_flow(self, newVal:float) -> None:
        """The rate of fuel consumption."""
        return self._intf.set_property(IProcedureReferenceState._metadata, IProcedureReferenceState._set_fuel_flow_metadata, newVal)

    _get_mode_as_forward_flight_metadata = { "name" : "mode_as_forward_flight",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_forward_flight(self) -> "ReferenceStateForwardFlightOptions":
        """Get the forward flight options."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_mode_as_forward_flight_metadata)

    _get_mode_as_takeoff_landing_metadata = { "name" : "mode_as_takeoff_landing",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_takeoff_landing(self) -> "ReferenceStateTakeoffLandingOptions":
        """Get the takeoff and landing options."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_mode_as_takeoff_landing_metadata)

    _get_mode_as_hover_metadata = { "name" : "mode_as_hover",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_hover(self) -> "ReferenceStateHoverOptions":
        """Get the hover options."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_mode_as_hover_metadata)

    _get_mode_as_weight_on_wheels_metadata = { "name" : "mode_as_weight_on_wheels",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def mode_as_weight_on_wheels(self) -> "ReferenceStateWeightOnWheelsOptions":
        """Get the weight on wheels options."""
        return self._intf.get_property(IProcedureReferenceState._metadata, IProcedureReferenceState._get_mode_as_weight_on_wheels_metadata)


agcls.AgClassCatalog.add_catalog_entry("{729bb865-8651-4e35-beac-db80804116bb}", IProcedureReferenceState)
agcls.AgTypeNameMap["IProcedureReferenceState"] = IProcedureReferenceState

class IProcedureSuperProcedure(object):
    """Interface used to access the options for a super procedure."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{47fee7c5-8e6d-4510-b70d-6d234b4db640}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_procedure" : 1,
                             "load_procedures_from_clipboard" : 2,
                             "load_procedures_from_file" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureSuperProcedure._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureSuperProcedure from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureSuperProcedure.__dict__ and type(IProcedureSuperProcedure.__dict__[attrname]) == property:
            return IProcedureSuperProcedure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureSuperProcedure.")
    
    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureSuperProcedure._metadata, IProcedureSuperProcedure._get_as_procedure_metadata, out_arg())

    _load_procedures_from_clipboard_metadata = { "name" : "load_procedures_from_clipboard",
            "arg_types" : (),
            "marshallers" : () }
    def load_procedures_from_clipboard(self) -> None:
        """Load procedures from the clipboard."""
        return self._intf.invoke(IProcedureSuperProcedure._metadata, IProcedureSuperProcedure._load_procedures_from_clipboard_metadata, )

    _load_procedures_from_file_metadata = { "name" : "load_procedures_from_file",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def load_procedures_from_file(self, filepath:str) -> None:
        """Load procedures from a file."""
        return self._intf.invoke(IProcedureSuperProcedure._metadata, IProcedureSuperProcedure._load_procedures_from_file_metadata, filepath)


agcls.AgClassCatalog.add_catalog_entry("{47fee7c5-8e6d-4510-b70d-6d234b4db640}", IProcedureSuperProcedure)
agcls.AgTypeNameMap["IProcedureSuperProcedure"] = IProcedureSuperProcedure

class IProcedureLaunch(object):
    """Interface used to access the options for a launch procedure."""
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f74d4c55-51c8-4559-ad0f-3236b5764f12}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_launch_time" : 1,
                             "set_launch_time" : 2,
                             "get_position_point_name" : 3,
                             "set_position_point_name" : 4,
                             "get_direction_vec_name" : 5,
                             "set_direction_vec_name" : 6,
                             "get_attitude_mode" : 7,
                             "set_attitude_mode" : 8,
                             "get_specify_launch_airspeed" : 9,
                             "set_specify_launch_airspeed" : 10,
                             "get_accel_g" : 11,
                             "set_accel_g" : 12,
                             "get_airspeed_type" : 13,
                             "get_airspeed" : 14,
                             "set_airspeed" : 15,
                             "get_fuel_flow_type" : 16,
                             "set_fuel_flow_type" : 17,
                             "get_override_fuel_flow" : 18,
                             "set_override_fuel_flow" : 19,
                             "get_as_procedure" : 20,
                             "get_true_course_hint" : 21,
                             "set_true_course_hint" : 22, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureLaunch._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLaunch from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLaunch.__dict__ and type(IProcedureLaunch.__dict__[attrname]) == property:
            return IProcedureLaunch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLaunch.")
    
    _get_launch_time_metadata = { "name" : "launch_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def launch_time(self) -> typing.Any:
        """The launch time of the aircraft."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_launch_time_metadata)

    _set_launch_time_metadata = { "name" : "launch_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @launch_time.setter
    def launch_time(self, newVal:typing.Any) -> None:
        """The launch time of the aircraft."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_launch_time_metadata, newVal)

    _get_position_point_name_metadata = { "name" : "position_point_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def position_point_name(self) -> str:
        """The name of the point used for the launch position."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_position_point_name_metadata)

    _set_position_point_name_metadata = { "name" : "position_point_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @position_point_name.setter
    def position_point_name(self, pVal:str) -> None:
        """The name of the point used for the launch position."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_position_point_name_metadata, pVal)

    _get_direction_vec_name_metadata = { "name" : "direction_vec_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def direction_vec_name(self) -> str:
        """The name of the vector used for the launch direction."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_direction_vec_name_metadata)

    _set_direction_vec_name_metadata = { "name" : "direction_vec_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @direction_vec_name.setter
    def direction_vec_name(self, pVal:str) -> None:
        """The name of the vector used for the launch direction."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_direction_vec_name_metadata, pVal)

    _get_attitude_mode_metadata = { "name" : "attitude_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_ATTITUDE_MODE),) }
    @property
    def attitude_mode(self) -> "LAUNCH_ATTITUDE_MODE":
        """The attitude mode during the launch."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_attitude_mode_metadata)

    _set_attitude_mode_metadata = { "name" : "attitude_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_ATTITUDE_MODE),) }
    @attitude_mode.setter
    def attitude_mode(self, newVal:"LAUNCH_ATTITUDE_MODE") -> None:
        """The attitude mode during the launch."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_attitude_mode_metadata, newVal)

    _get_specify_launch_airspeed_metadata = { "name" : "specify_launch_airspeed",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def specify_launch_airspeed(self) -> bool:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_specify_launch_airspeed_metadata)

    _set_specify_launch_airspeed_metadata = { "name" : "specify_launch_airspeed",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @specify_launch_airspeed.setter
    def specify_launch_airspeed(self, newVal:bool) -> None:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_specify_launch_airspeed_metadata, newVal)

    _get_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_g(self) -> float:
        """The acceleration of the aircraft during the launch."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_accel_g_metadata)

    _set_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The acceleration of the aircraft during the launch."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_accel_g_metadata, newVal)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_airspeed_type_metadata)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_airspeed_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        return self._intf.invoke(IProcedureLaunch._metadata, IProcedureLaunch._set_airspeed_metadata, airspeedType, airspeed)

    _get_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @property
    def fuel_flow_type(self) -> "FUEL_FLOW_TYPE":
        """The fuel flow type of the aircraft during the launch."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_fuel_flow_type_metadata)

    _set_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"FUEL_FLOW_TYPE") -> None:
        """The fuel flow type of the aircraft during the launch."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_fuel_flow_type_metadata, newVal)

    _get_override_fuel_flow_metadata = { "name" : "override_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_fuel_flow(self) -> float:
        """The fuel flow value for a fuel flow type set to Override."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_override_fuel_flow_metadata)

    _set_override_fuel_flow_metadata = { "name" : "override_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_fuel_flow.setter
    def override_fuel_flow(self, newVal:float) -> None:
        """The fuel flow value for a fuel flow type set to Override."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_override_fuel_flow_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureLaunch._metadata, IProcedureLaunch._get_as_procedure_metadata, out_arg())

    _get_true_course_hint_metadata = { "name" : "true_course_hint",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def true_course_hint(self) -> typing.Any:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        return self._intf.get_property(IProcedureLaunch._metadata, IProcedureLaunch._get_true_course_hint_metadata)

    _set_true_course_hint_metadata = { "name" : "true_course_hint",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @true_course_hint.setter
    def true_course_hint(self, newVal:typing.Any) -> None:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        return self._intf.set_property(IProcedureLaunch._metadata, IProcedureLaunch._set_true_course_hint_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{f74d4c55-51c8-4559-ad0f-3236b5764f12}", IProcedureLaunch)
agcls.AgTypeNameMap["IProcedureLaunch"] = IProcedureLaunch

class IProcedureAirway(object):
    """Interface used to access the options for an Airway procedure."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{49483b87-39de-46f6-b61b-633ada0c7970}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_procedure" : 1,
                             "get_altitude_options" : 2,
                             "get_enroute_options" : 3,
                             "get_enroute_cruise_airspeed_options" : 4,
                             "get_router" : 5,
                             "set_router" : 6,
                             "get_airway_id" : 7,
                             "set_airway_id" : 8,
                             "get_airway_names" : 9,
                             "get_sequence" : 10,
                             "set_sequence" : 11,
                             "get_sequences" : 12,
                             "get_entry_id" : 13,
                             "set_entry_id" : 14,
                             "get_exit_id" : 15,
                             "set_exit_id" : 16,
                             "get_waypoints" : 17,
                             "copy_procedures" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureAirway._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureAirway from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureAirway.__dict__ and type(IProcedureAirway.__dict__[attrname]) == property:
            return IProcedureAirway.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureAirway.")
    
    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureAirway._metadata, IProcedureAirway._get_as_procedure_metadata, out_arg())

    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeMSLOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_altitude_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_enroute_cruise_airspeed_options_metadata)

    _get_router_metadata = { "name" : "router",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def router(self) -> str:
        """The router used to provide available airways."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_router_metadata)

    _set_router_metadata = { "name" : "router",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @router.setter
    def router(self, newVal:str) -> None:
        """The router used to provide available airways."""
        return self._intf.set_property(IProcedureAirway._metadata, IProcedureAirway._set_router_metadata, newVal)

    _get_airway_id_metadata = { "name" : "airway_id",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def airway_id(self) -> str:
        """The airway ID."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_airway_id_metadata)

    _set_airway_id_metadata = { "name" : "airway_id",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @airway_id.setter
    def airway_id(self, newVal:str) -> None:
        """The airway ID."""
        return self._intf.set_property(IProcedureAirway._metadata, IProcedureAirway._set_airway_id_metadata, newVal)

    _get_airway_names_metadata = { "name" : "get_airway_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_airway_names(self) -> list:
        """Get the a list of names of the available airways."""
        return self._intf.invoke(IProcedureAirway._metadata, IProcedureAirway._get_airway_names_metadata, out_arg())

    _get_sequence_metadata = { "name" : "sequence",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def sequence(self) -> str:
        """The direction the aircraft will fly the route."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_sequence_metadata)

    _set_sequence_metadata = { "name" : "sequence",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @sequence.setter
    def sequence(self, newVal:str) -> None:
        """The direction the aircraft will fly the route."""
        return self._intf.set_property(IProcedureAirway._metadata, IProcedureAirway._set_sequence_metadata, newVal)

    _get_sequences_metadata = { "name" : "get_sequences",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_sequences(self) -> list:
        """Get a list of sequence options."""
        return self._intf.invoke(IProcedureAirway._metadata, IProcedureAirway._get_sequences_metadata, out_arg())

    _get_entry_id_metadata = { "name" : "entry_id",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def entry_id(self) -> str:
        """The ID of the entry waypoint."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_entry_id_metadata)

    _set_entry_id_metadata = { "name" : "entry_id",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @entry_id.setter
    def entry_id(self, newVal:str) -> None:
        """The ID of the entry waypoint."""
        return self._intf.set_property(IProcedureAirway._metadata, IProcedureAirway._set_entry_id_metadata, newVal)

    _get_exit_id_metadata = { "name" : "exit_id",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def exit_id(self) -> str:
        """The ID of the exit waypoint."""
        return self._intf.get_property(IProcedureAirway._metadata, IProcedureAirway._get_exit_id_metadata)

    _set_exit_id_metadata = { "name" : "exit_id",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @exit_id.setter
    def exit_id(self, newVal:str) -> None:
        """The ID of the exit waypoint."""
        return self._intf.set_property(IProcedureAirway._metadata, IProcedureAirway._set_exit_id_metadata, newVal)

    _get_waypoints_metadata = { "name" : "get_waypoints",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_waypoints(self) -> list:
        """Get a list of available waypoints for the airway."""
        return self._intf.invoke(IProcedureAirway._metadata, IProcedureAirway._get_waypoints_metadata, out_arg())

    _copy_procedures_metadata = { "name" : "copy_procedures",
            "arg_types" : (),
            "marshallers" : () }
    def copy_procedures(self) -> None:
        """Copy the airway route as a set of procedures to the clipboard."""
        return self._intf.invoke(IProcedureAirway._metadata, IProcedureAirway._copy_procedures_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{49483b87-39de-46f6-b61b-633ada0c7970}", IProcedureAirway)
agcls.AgTypeNameMap["IProcedureAirway"] = IProcedureAirway

class IProcedureAirwayRouter(object):
    """Interface used to access the options for an Airway Router procedure."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5f3240be-4a51-4580-976b-f8ca68855608}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_procedure" : 1,
                             "get_altitude_options" : 2,
                             "get_enroute_options" : 3,
                             "get_enroute_cruise_airspeed_options" : 4,
                             "get_router" : 5,
                             "get_optimize_for_wind" : 6,
                             "set_optimize_for_wind" : 7,
                             "get_bounding_box_pad" : 8,
                             "set_bounding_box_pad" : 9,
                             "get_max_waypoint_range" : 10,
                             "set_max_waypoint_range" : 11,
                             "get_entry_exit_and_or" : 12,
                             "set_entry_exit_and_or" : 13,
                             "get_max_waypoint_count" : 14,
                             "set_max_waypoint_count" : 15,
                             "update_route" : 16,
                             "get_waypoints" : 17,
                             "get_segments" : 18,
                             "copy_procedures" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureAirwayRouter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureAirwayRouter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureAirwayRouter.__dict__ and type(IProcedureAirwayRouter.__dict__[attrname]) == property:
            return IProcedureAirwayRouter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureAirwayRouter.")
    
    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_as_procedure_metadata, out_arg())

    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeMSLOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_altitude_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_enroute_cruise_airspeed_options_metadata)

    _get_router_metadata = { "name" : "router",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def router(self) -> str:
        """The router used to provide available airways."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_router_metadata)

    _get_optimize_for_wind_metadata = { "name" : "optimize_for_wind",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def optimize_for_wind(self) -> bool:
        """Opt to account for the wind when calculating the most efficient route."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_optimize_for_wind_metadata)

    _set_optimize_for_wind_metadata = { "name" : "optimize_for_wind",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @optimize_for_wind.setter
    def optimize_for_wind(self, newVal:bool) -> None:
        """Opt to account for the wind when calculating the most efficient route."""
        return self._intf.set_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._set_optimize_for_wind_metadata, newVal)

    _get_bounding_box_pad_metadata = { "name" : "bounding_box_pad",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def bounding_box_pad(self) -> float:
        """The maximum distance beyond the bounding box that a waypoint will be considered for the final route."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_bounding_box_pad_metadata)

    _set_bounding_box_pad_metadata = { "name" : "bounding_box_pad",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @bounding_box_pad.setter
    def bounding_box_pad(self, newVal:float) -> None:
        """The maximum distance beyond the bounding box that a waypoint will be considered for the final route."""
        return self._intf.set_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._set_bounding_box_pad_metadata, newVal)

    _get_max_waypoint_range_metadata = { "name" : "max_waypoint_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_waypoint_range(self) -> float:
        """The maximum distance from the end of the previous procedure that an airway waypoint will be considered."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_max_waypoint_range_metadata)

    _set_max_waypoint_range_metadata = { "name" : "max_waypoint_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_waypoint_range.setter
    def max_waypoint_range(self, newVal:float) -> None:
        """The maximum distance from the end of the previous procedure that an airway waypoint will be considered."""
        return self._intf.set_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._set_max_waypoint_range_metadata, newVal)

    _get_entry_exit_and_or_metadata = { "name" : "entry_exit_and_or",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AND_OR),) }
    @property
    def entry_exit_and_or(self) -> "AND_OR":
        """Define how the two Entry/Exit Waypoint constraints will be considered."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_entry_exit_and_or_metadata)

    _set_entry_exit_and_or_metadata = { "name" : "entry_exit_and_or",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AND_OR),) }
    @entry_exit_and_or.setter
    def entry_exit_and_or(self, newVal:"AND_OR") -> None:
        """Define how the two Entry/Exit Waypoint constraints will be considered."""
        return self._intf.set_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._set_entry_exit_and_or_metadata, newVal)

    _get_max_waypoint_count_metadata = { "name" : "max_waypoint_count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def max_waypoint_count(self) -> int:
        """The maximum number of airway waypoints that the procedure will consider for each segment."""
        return self._intf.get_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_max_waypoint_count_metadata)

    _set_max_waypoint_count_metadata = { "name" : "max_waypoint_count",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @max_waypoint_count.setter
    def max_waypoint_count(self, newVal:int) -> None:
        """The maximum number of airway waypoints that the procedure will consider for each segment."""
        return self._intf.set_property(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._set_max_waypoint_count_metadata, newVal)

    _update_route_metadata = { "name" : "update_route",
            "arg_types" : (),
            "marshallers" : () }
    def update_route(self) -> None:
        """Recalculate the route."""
        return self._intf.invoke(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._update_route_metadata, )

    _get_waypoints_metadata = { "name" : "get_waypoints",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_waypoints(self) -> list:
        """Get a list of the current route's waypoints."""
        return self._intf.invoke(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_waypoints_metadata, out_arg())

    _get_segments_metadata = { "name" : "get_segments",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_segments(self) -> list:
        """Get a list of the current route's individual procedures."""
        return self._intf.invoke(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._get_segments_metadata, out_arg())

    _copy_procedures_metadata = { "name" : "copy_procedures",
            "arg_types" : (),
            "marshallers" : () }
    def copy_procedures(self) -> None:
        """Copy the route as a set of procedures to the clipboard."""
        return self._intf.invoke(IProcedureAirwayRouter._metadata, IProcedureAirwayRouter._copy_procedures_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{5f3240be-4a51-4580-976b-f8ca68855608}", IProcedureAirwayRouter)
agcls.AgTypeNameMap["IProcedureAirwayRouter"] = IProcedureAirwayRouter

class IProcedureAreaTargetSearch(object):
    """Interface used to access the options for an Area Target Search procedure."""
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ad0dc4ce-a6b1-499b-9a60-54dd5b6266ac}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_procedure" : 1,
                             "get_altitude_options" : 2,
                             "get_enroute_options" : 3,
                             "get_enroute_cruise_airspeed_options" : 4,
                             "get_procedure_type" : 5,
                             "set_procedure_type" : 6,
                             "get_max_separation" : 7,
                             "set_max_separation" : 8,
                             "get_course_mode" : 9,
                             "set_course_mode" : 10,
                             "get_first_leg_retrograde" : 11,
                             "set_first_leg_retrograde" : 12,
                             "get_centroid_true_course" : 13,
                             "set_centroid_true_course" : 14,
                             "get_fly_cruise_airspeed_profile" : 15,
                             "set_fly_cruise_airspeed_profile" : 16,
                             "get_must_level_off" : 17,
                             "set_must_level_off" : 18,
                             "get_level_off_mode" : 19,
                             "set_level_off_mode" : 20,
                             "copy_procedures" : 21, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureAreaTargetSearch._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureAreaTargetSearch from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureAreaTargetSearch.__dict__ and type(IProcedureAreaTargetSearch.__dict__[attrname]) == property:
            return IProcedureAreaTargetSearch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureAreaTargetSearch.")
    
    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_as_procedure_metadata, out_arg())

    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_altitude_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_enroute_cruise_airspeed_options_metadata)

    _get_procedure_type_metadata = { "name" : "procedure_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FLIGHT_LINE_PROC_TYPE),) }
    @property
    def procedure_type(self) -> "FLIGHT_LINE_PROC_TYPE":
        """The procedure methodology used to calculate the flight line."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_procedure_type_metadata)

    _set_procedure_type_metadata = { "name" : "procedure_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FLIGHT_LINE_PROC_TYPE),) }
    @procedure_type.setter
    def procedure_type(self, newVal:"FLIGHT_LINE_PROC_TYPE") -> None:
        """The procedure methodology used to calculate the flight line."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_procedure_type_metadata, newVal)

    _get_max_separation_metadata = { "name" : "max_separation",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max_separation(self) -> float:
        """The maximum distance between the parallel flight lines of the search pattern."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_max_separation_metadata)

    _set_max_separation_metadata = { "name" : "max_separation",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max_separation.setter
    def max_separation(self, newVal:float) -> None:
        """The maximum distance between the parallel flight lines of the search pattern."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_max_separation_metadata, newVal)

    _get_course_mode_metadata = { "name" : "course_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(SEARCH_PATTERN_COURSE_MODE),) }
    @property
    def course_mode(self) -> "SEARCH_PATTERN_COURSE_MODE":
        """The mode to determine the course of the search pattern."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_course_mode_metadata)

    _set_course_mode_metadata = { "name" : "course_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(SEARCH_PATTERN_COURSE_MODE),) }
    @course_mode.setter
    def course_mode(self, newVal:"SEARCH_PATTERN_COURSE_MODE") -> None:
        """The mode to determine the course of the search pattern."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_course_mode_metadata, newVal)

    _get_first_leg_retrograde_metadata = { "name" : "first_leg_retrograde",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def first_leg_retrograde(self) -> bool:
        """The option to fly the first leg of the search pattern on the reverse heading."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_first_leg_retrograde_metadata)

    _set_first_leg_retrograde_metadata = { "name" : "first_leg_retrograde",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @first_leg_retrograde.setter
    def first_leg_retrograde(self, newVal:bool) -> None:
        """The option to fly the first leg of the search pattern on the reverse heading."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_first_leg_retrograde_metadata, newVal)

    _get_centroid_true_course_metadata = { "name" : "centroid_true_course",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def centroid_true_course(self) -> typing.Any:
        """The specific course of the search pattern."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_centroid_true_course_metadata)

    _set_centroid_true_course_metadata = { "name" : "centroid_true_course",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @centroid_true_course.setter
    def centroid_true_course(self, newVal:typing.Any) -> None:
        """The specific course of the search pattern."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_centroid_true_course_metadata, newVal)

    _get_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def fly_cruise_airspeed_profile(self) -> bool:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_fly_cruise_airspeed_profile_metadata)

    _set_fly_cruise_airspeed_profile_metadata = { "name" : "fly_cruise_airspeed_profile",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @fly_cruise_airspeed_profile.setter
    def fly_cruise_airspeed_profile(self, pVal:bool) -> None:
        """Opt whether the aircraft immediately adopts the selected cruise airspeed or gradually begins accelerating/decelerating in the previous procedure."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_fly_cruise_airspeed_profile_metadata, pVal)

    _get_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_must_level_off_metadata)

    _set_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_must_level_off_metadata, newVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.get_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, newVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.set_property(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._set_level_off_mode_metadata, newVal)

    _copy_procedures_metadata = { "name" : "copy_procedures",
            "arg_types" : (),
            "marshallers" : () }
    def copy_procedures(self) -> None:
        """Copy the search pattern maneuvers as a set of procedures to the clipboard."""
        return self._intf.invoke(IProcedureAreaTargetSearch._metadata, IProcedureAreaTargetSearch._copy_procedures_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{ad0dc4ce-a6b1-499b-9a60-54dd5b6266ac}", IProcedureAreaTargetSearch)
agcls.AgTypeNameMap["IProcedureAreaTargetSearch"] = IProcedureAreaTargetSearch

class IProcedureFormationRecover(object):
    """Interface used to access the options for a Formation Recover procedure."""
    _num_methods = 38
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{d96375bc-d2b6-4397-81bc-35a923b5b883}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_procedure" : 1,
                             "get_enroute_options" : 2,
                             "get_delay_cruise_airspeed_options" : 3,
                             "get_minimum_time" : 4,
                             "get_start_time" : 5,
                             "set_start_time" : 6,
                             "find_first_valid_start_time" : 7,
                             "get_maximum_time" : 8,
                             "get_formation_point" : 9,
                             "set_formation_point" : 10,
                             "get_interpolate_point_position_vel" : 11,
                             "set_interpolate_point_position_vel" : 12,
                             "get_altitude_offset" : 13,
                             "set_altitude_offset" : 14,
                             "get_fuel_flow_type" : 15,
                             "set_fuel_flow_type" : 16,
                             "get_override_fuel_flow_value" : 17,
                             "set_override_fuel_flow_value" : 18,
                             "get_consider_accel_for_fuel_flow" : 19,
                             "set_consider_accel_for_fuel_flow" : 20,
                             "get_first_pause" : 21,
                             "set_first_pause" : 22,
                             "get_transition_time" : 23,
                             "set_transition_time" : 24,
                             "get_second_pause" : 25,
                             "set_second_pause" : 26,
                             "get_display_step_time" : 27,
                             "set_display_step_time" : 28,
                             "get_flight_mode" : 29,
                             "set_flight_mode" : 30,
                             "get_flight_path_angle" : 31,
                             "set_flight_path_angle" : 32,
                             "get_radius_factor" : 33,
                             "set_radius_factor" : 34,
                             "get_use_delay" : 35,
                             "set_use_delay" : 36,
                             "get_delay_turn_direction" : 37,
                             "set_delay_turn_direction" : 38, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureFormationRecover._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureFormationRecover from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureFormationRecover.__dict__ and type(IProcedureFormationRecover.__dict__[attrname]) == property:
            return IProcedureFormationRecover.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureFormationRecover.")
    
    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_as_procedure_metadata, out_arg())

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_enroute_options_metadata)

    _get_delay_cruise_airspeed_options_metadata = { "name" : "delay_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def delay_cruise_airspeed_options(self) -> "CruiseAirspeedOptions":
        """Get the delay cruise airspeed options."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_delay_cruise_airspeed_options_metadata)

    _get_minimum_time_metadata = { "name" : "get_minimum_time",
            "arg_types" : (agcom.VARIANT_BOOL, POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg, agmarshall.VARIANT_arg,) }
    def get_minimum_time(self, considerPrevProc:bool) -> typing.Any:
        """Get the minimum time at which formation might be possible. Opt whether to consider previous procedure(s) for the minimum time."""
        return self._intf.invoke(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_minimum_time_metadata, considerPrevProc, out_arg())

    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_time(self) -> typing.Any:
        """The time at which the formation begins."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_start_time_metadata)

    _set_start_time_metadata = { "name" : "start_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @start_time.setter
    def start_time(self, newVal:typing.Any) -> None:
        """The time at which the formation begins."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_start_time_metadata, newVal)

    _find_first_valid_start_time_metadata = { "name" : "find_first_valid_start_time",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_arg,) }
    def find_first_valid_start_time(self, minTime:typing.Any, maxTime:typing.Any, stepTime:float) -> typing.Any:
        """Have Aviator calculate the earliest valid formation time."""
        return self._intf.invoke(IProcedureFormationRecover._metadata, IProcedureFormationRecover._find_first_valid_start_time_metadata, minTime, maxTime, stepTime, out_arg())

    _get_maximum_time_metadata = { "name" : "maximum_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def maximum_time(self) -> typing.Any:
        """The maximum time at which formation might be possible."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_maximum_time_metadata)

    _get_formation_point_metadata = { "name" : "formation_point",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def formation_point(self) -> str:
        """The position that the aircraft will be locked onto while in formation."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_formation_point_metadata)

    _set_formation_point_metadata = { "name" : "formation_point",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @formation_point.setter
    def formation_point(self, newVal:str) -> None:
        """The position that the aircraft will be locked onto while in formation."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_formation_point_metadata, newVal)

    _get_interpolate_point_position_vel_metadata = { "name" : "interpolate_point_position_vel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def interpolate_point_position_vel(self) -> bool:
        """The option to use interpolation to determine the formation point's speed and position."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_interpolate_point_position_vel_metadata)

    _set_interpolate_point_position_vel_metadata = { "name" : "interpolate_point_position_vel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @interpolate_point_position_vel.setter
    def interpolate_point_position_vel(self, newVal:bool) -> None:
        """The option to use interpolation to determine the formation point's speed and position."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_interpolate_point_position_vel_metadata, newVal)

    _get_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude_offset(self) -> float:
        """The altitude distance between the aircraft and the formation point during the first or second pause."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_altitude_offset_metadata)

    _set_altitude_offset_metadata = { "name" : "altitude_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude_offset.setter
    def altitude_offset(self, newVal:float) -> None:
        """The altitude distance between the aircraft and the formation point during the first or second pause."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_altitude_offset_metadata, newVal)

    _get_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @property
    def fuel_flow_type(self) -> "FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_fuel_flow_type_metadata)

    _set_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"FUEL_FLOW_TYPE") -> None:
        """The source used to calculate the fuel flow for the maneuver."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_fuel_flow_type_metadata, newVal)

    _get_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_override_fuel_flow_value_metadata)

    _set_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_override_fuel_flow_value_metadata, newVal)

    _get_consider_accel_for_fuel_flow_metadata = { "name" : "consider_accel_for_fuel_flow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def consider_accel_for_fuel_flow(self) -> bool:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_consider_accel_for_fuel_flow_metadata)

    _set_consider_accel_for_fuel_flow_metadata = { "name" : "consider_accel_for_fuel_flow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @consider_accel_for_fuel_flow.setter
    def consider_accel_for_fuel_flow(self, newVal:bool) -> None:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_consider_accel_for_fuel_flow_metadata, newVal)

    _get_first_pause_metadata = { "name" : "first_pause",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def first_pause(self) -> typing.Any:
        """The amount of time that the aircraft will pause at the specified altitude offset."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_first_pause_metadata)

    _set_first_pause_metadata = { "name" : "first_pause",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @first_pause.setter
    def first_pause(self, newVal:typing.Any) -> None:
        """The amount of time that the aircraft will pause at the specified altitude offset."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_first_pause_metadata, newVal)

    _get_transition_time_metadata = { "name" : "transition_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transition_time(self) -> float:
        """The amount of time that the aircraft will spend transitioning from the specified altitude offset to a zero altitude offset."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_transition_time_metadata)

    _set_transition_time_metadata = { "name" : "transition_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transition_time.setter
    def transition_time(self, newVal:float) -> None:
        """The amount of time that the aircraft will spend transitioning from the specified altitude offset to a zero altitude offset."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_transition_time_metadata, newVal)

    _get_second_pause_metadata = { "name" : "second_pause",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def second_pause(self) -> typing.Any:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_second_pause_metadata)

    _set_second_pause_metadata = { "name" : "second_pause",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @second_pause.setter
    def second_pause(self, newVal:typing.Any) -> None:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_second_pause_metadata, newVal)

    _get_display_step_time_metadata = { "name" : "display_step_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def display_step_time(self) -> float:
        """The time interval at which ephemeris is generated for display purposes."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_display_step_time_metadata)

    _set_display_step_time_metadata = { "name" : "display_step_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @display_step_time.setter
    def display_step_time(self, newVal:float) -> None:
        """The time interval at which ephemeris is generated for display purposes."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_display_step_time_metadata, newVal)

    _get_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @property
    def flight_mode(self) -> "PHASE_OF_FLIGHT":
        """The type of performance model that the aircraft will use to fly the maneuver."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_flight_mode_metadata)

    _set_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @flight_mode.setter
    def flight_mode(self, newVal:"PHASE_OF_FLIGHT") -> None:
        """The type of performance model that the aircraft will use to fly the maneuver."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_flight_mode_metadata, newVal)

    _get_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def flight_path_angle(self) -> typing.Any:
        """The flight path angle at the beginning of the first pause."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_flight_path_angle_metadata)

    _set_flight_path_angle_metadata = { "name" : "flight_path_angle",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @flight_path_angle.setter
    def flight_path_angle(self, newVal:typing.Any) -> None:
        """The flight path angle at the beginning of the first pause."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_flight_path_angle_metadata, newVal)

    _get_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def radius_factor(self) -> float:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_radius_factor_metadata)

    _set_radius_factor_metadata = { "name" : "radius_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @radius_factor.setter
    def radius_factor(self, newVal:float) -> None:
        """The maximum amount the radius of vertical curve will be increased to minimize the flight path angle required to complete it."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_radius_factor_metadata, newVal)

    _get_use_delay_metadata = { "name" : "use_delay",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_delay(self) -> bool:
        """The option to insert a delay at the beginning of the procedure."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_use_delay_metadata)

    _set_use_delay_metadata = { "name" : "use_delay",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_delay.setter
    def use_delay(self, newVal:bool) -> None:
        """The option to insert a delay at the beginning of the procedure."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_use_delay_metadata, newVal)

    _get_delay_turn_direction_metadata = { "name" : "delay_turn_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(DELAY_TURN_DIRECTION),) }
    @property
    def delay_turn_direction(self) -> "DELAY_TURN_DIRECTION":
        """The turn direction of the delay."""
        return self._intf.get_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._get_delay_turn_direction_metadata)

    _set_delay_turn_direction_metadata = { "name" : "delay_turn_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(DELAY_TURN_DIRECTION),) }
    @delay_turn_direction.setter
    def delay_turn_direction(self, newVal:"DELAY_TURN_DIRECTION") -> None:
        """The turn direction of the delay."""
        return self._intf.set_property(IProcedureFormationRecover._metadata, IProcedureFormationRecover._set_delay_turn_direction_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{d96375bc-d2b6-4397-81bc-35a923b5b883}", IProcedureFormationRecover)
agcls.AgTypeNameMap["IProcedureFormationRecover"] = IProcedureFormationRecover

class IProcedureInFormation(object):
    """Interface used to access the options for an In Formation procedure."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7d5aa09b-b2d4-4984-b930-f4b55acf3219}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_procedure" : 1,
                             "get_flight_mode" : 2,
                             "set_flight_mode" : 3,
                             "get_formation_point" : 4,
                             "set_formation_point" : 5,
                             "get_transition_time" : 6,
                             "set_transition_time" : 7,
                             "get_hold_time" : 8,
                             "set_hold_time" : 9,
                             "get_display_step_time" : 10,
                             "set_display_step_time" : 11,
                             "get_trajectory_blending" : 12,
                             "set_trajectory_blending" : 13,
                             "get_fuel_flow_type" : 14,
                             "set_fuel_flow_type" : 15,
                             "get_override_fuel_flow_value" : 16,
                             "set_override_fuel_flow_value" : 17,
                             "get_consider_accel_for_fuel_flow" : 18,
                             "set_consider_accel_for_fuel_flow" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureInFormation._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureInFormation from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureInFormation.__dict__ and type(IProcedureInFormation.__dict__[attrname]) == property:
            return IProcedureInFormation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureInFormation.")
    
    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureInFormation._metadata, IProcedureInFormation._get_as_procedure_metadata, out_arg())

    _get_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @property
    def flight_mode(self) -> "PHASE_OF_FLIGHT":
        """The type of performance model that the aircraft will use to fly the maneuver."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_flight_mode_metadata)

    _set_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @flight_mode.setter
    def flight_mode(self, newVal:"PHASE_OF_FLIGHT") -> None:
        """The type of performance model that the aircraft will use to fly the maneuver."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_flight_mode_metadata, newVal)

    _get_formation_point_metadata = { "name" : "formation_point",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def formation_point(self) -> str:
        """The position that the aircraft will be locked onto while in formation."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_formation_point_metadata)

    _set_formation_point_metadata = { "name" : "formation_point",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @formation_point.setter
    def formation_point(self, newVal:str) -> None:
        """The position that the aircraft will be locked onto while in formation."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_formation_point_metadata, newVal)

    _get_transition_time_metadata = { "name" : "transition_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transition_time(self) -> float:
        """The amount of time that the aircraft will spend transitioning from the altitude offset to a zero altitude offset."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_transition_time_metadata)

    _set_transition_time_metadata = { "name" : "transition_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transition_time.setter
    def transition_time(self, newVal:float) -> None:
        """The amount of time that the aircraft will spend transitioning from the altitude offset to a zero altitude offset."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_transition_time_metadata, newVal)

    _get_hold_time_metadata = { "name" : "hold_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def hold_time(self) -> typing.Any:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_hold_time_metadata)

    _set_hold_time_metadata = { "name" : "hold_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @hold_time.setter
    def hold_time(self, newVal:typing.Any) -> None:
        """The amount of time that the aircraft will pause at a zero altitude offset."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_hold_time_metadata, newVal)

    _get_display_step_time_metadata = { "name" : "display_step_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def display_step_time(self) -> float:
        """The time interval at which ephemeris is generated for display purposes."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_display_step_time_metadata)

    _set_display_step_time_metadata = { "name" : "display_step_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @display_step_time.setter
    def display_step_time(self, newVal:float) -> None:
        """The time interval at which ephemeris is generated for display purposes."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_display_step_time_metadata, newVal)

    _get_trajectory_blending_metadata = { "name" : "trajectory_blending",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(TRAJECTORY_BLEND_MODE),) }
    @property
    def trajectory_blending(self) -> "TRAJECTORY_BLEND_MODE":
        """The interpolation mode to determine the aircraft's position and velocity."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_trajectory_blending_metadata)

    _set_trajectory_blending_metadata = { "name" : "trajectory_blending",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(TRAJECTORY_BLEND_MODE),) }
    @trajectory_blending.setter
    def trajectory_blending(self, newVal:"TRAJECTORY_BLEND_MODE") -> None:
        """The interpolation mode to determine the aircraft's position and velocity."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_trajectory_blending_metadata, newVal)

    _get_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @property
    def fuel_flow_type(self) -> "FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_fuel_flow_type_metadata)

    _set_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"FUEL_FLOW_TYPE") -> None:
        """The source used to calculate the fuel flow for the maneuver."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_fuel_flow_type_metadata, newVal)

    _get_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_override_fuel_flow_value_metadata)

    _set_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_override_fuel_flow_value_metadata, newVal)

    _get_consider_accel_for_fuel_flow_metadata = { "name" : "consider_accel_for_fuel_flow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def consider_accel_for_fuel_flow(self) -> bool:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        return self._intf.get_property(IProcedureInFormation._metadata, IProcedureInFormation._get_consider_accel_for_fuel_flow_metadata)

    _set_consider_accel_for_fuel_flow_metadata = { "name" : "consider_accel_for_fuel_flow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @consider_accel_for_fuel_flow.setter
    def consider_accel_for_fuel_flow(self, newVal:bool) -> None:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        return self._intf.set_property(IProcedureInFormation._metadata, IProcedureInFormation._set_consider_accel_for_fuel_flow_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{7d5aa09b-b2d4-4984-b930-f4b55acf3219}", IProcedureInFormation)
agcls.AgTypeNameMap["IProcedureInFormation"] = IProcedureInFormation

class IProcedureParallelFlightLine(object):
    """Interface used to access the options for a Parallel Flight Line procedure."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4c911a89-bad8-457e-9dca-64c1adf59603}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_altitude_options" : 1,
                             "get_enroute_options" : 2,
                             "get_enroute_cruise_airspeed_options" : 3,
                             "get_enroute_turn_direction_options" : 4,
                             "get_procedure_type" : 5,
                             "set_procedure_type" : 6,
                             "get_orientation" : 7,
                             "set_orientation" : 8,
                             "get_separation" : 9,
                             "set_separation" : 10,
                             "get_offset" : 11,
                             "set_offset" : 12,
                             "get_leg_length" : 13,
                             "set_leg_length" : 14,
                             "get_must_level_off" : 15,
                             "set_must_level_off" : 16,
                             "get_level_off_mode" : 17,
                             "set_level_off_mode" : 18,
                             "get_as_procedure" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureParallelFlightLine._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureParallelFlightLine from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureParallelFlightLine.__dict__ and type(IProcedureParallelFlightLine.__dict__[attrname]) == property:
            return IProcedureParallelFlightLine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureParallelFlightLine.")
    
    _get_altitude_options_metadata = { "name" : "altitude_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_options(self) -> "AltitudeOptions":
        """Get the altitude options."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_altitude_options_metadata)

    _get_enroute_options_metadata = { "name" : "enroute_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_options(self) -> "EnrouteOptions":
        """Get the enroute options."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_enroute_options_metadata)

    _get_enroute_cruise_airspeed_options_metadata = { "name" : "enroute_cruise_airspeed_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_cruise_airspeed_options(self) -> "ICruiseAirspeedAndProfileOptions":
        """Get the enroute cruise airspeed options."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_enroute_cruise_airspeed_options_metadata)

    _get_enroute_turn_direction_options_metadata = { "name" : "enroute_turn_direction_options",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def enroute_turn_direction_options(self) -> "EnrouteTurnDirectionOptions":
        """Get the enroute turn direction options."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_enroute_turn_direction_options_metadata)

    _get_procedure_type_metadata = { "name" : "procedure_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FLIGHT_LINE_PROC_TYPE),) }
    @property
    def procedure_type(self) -> "FLIGHT_LINE_PROC_TYPE":
        """The procedure methodology used to calculate the flight line."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_procedure_type_metadata)

    _set_procedure_type_metadata = { "name" : "procedure_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FLIGHT_LINE_PROC_TYPE),) }
    @procedure_type.setter
    def procedure_type(self, newVal:"FLIGHT_LINE_PROC_TYPE") -> None:
        """The procedure methodology used to calculate the flight line."""
        return self._intf.set_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._set_procedure_type_metadata, newVal)

    _get_orientation_metadata = { "name" : "orientation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LINE_ORIENTATION),) }
    @property
    def orientation(self) -> "LINE_ORIENTATION":
        """The placement of the procedure with respect to the previous flight line."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_orientation_metadata)

    _set_orientation_metadata = { "name" : "orientation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LINE_ORIENTATION),) }
    @orientation.setter
    def orientation(self, newVal:"LINE_ORIENTATION") -> None:
        """The placement of the procedure with respect to the previous flight line."""
        return self._intf.set_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._set_orientation_metadata, newVal)

    _get_separation_metadata = { "name" : "separation",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def separation(self) -> float:
        """The distance between the flight line and the previous flight line."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_separation_metadata)

    _set_separation_metadata = { "name" : "separation",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @separation.setter
    def separation(self, newVal:float) -> None:
        """The distance between the flight line and the previous flight line."""
        return self._intf.set_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._set_separation_metadata, newVal)

    _get_offset_metadata = { "name" : "offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def offset(self) -> float:
        """The distance from the end of the previous procedure to the beginning of the flight line."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_offset_metadata)

    _set_offset_metadata = { "name" : "offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @offset.setter
    def offset(self, newVal:float) -> None:
        """The distance from the end of the previous procedure to the beginning of the flight line."""
        return self._intf.set_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._set_offset_metadata, newVal)

    _get_leg_length_metadata = { "name" : "leg_length",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def leg_length(self) -> float:
        """The length of the flight line."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_leg_length_metadata)

    _set_leg_length_metadata = { "name" : "leg_length",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @leg_length.setter
    def leg_length(self, newVal:float) -> None:
        """The length of the flight line."""
        return self._intf.set_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._set_leg_length_metadata, newVal)

    _get_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def must_level_off(self) -> bool:
        """Opt whether the procedure must level off."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_must_level_off_metadata)

    _set_must_level_off_metadata = { "name" : "must_level_off",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @must_level_off.setter
    def must_level_off(self, newVal:bool) -> None:
        """Opt whether the procedure must level off."""
        return self._intf.set_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._set_must_level_off_metadata, newVal)

    _get_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @property
    def level_off_mode(self) -> "ALTITUDE_CONSTRAINT_MANEUVER_MODE":
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.get_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_level_off_mode_metadata)

    _set_level_off_mode_metadata = { "name" : "level_off_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_CONSTRAINT_MANEUVER_MODE),) }
    @level_off_mode.setter
    def level_off_mode(self, newVal:"ALTITUDE_CONSTRAINT_MANEUVER_MODE") -> None:
        """The level off mode. This is only used when the must level off option is on."""
        return self._intf.set_property(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._set_level_off_mode_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureParallelFlightLine._metadata, IProcedureParallelFlightLine._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4c911a89-bad8-457e-9dca-64c1adf59603}", IProcedureParallelFlightLine)
agcls.AgTypeNameMap["IProcedureParallelFlightLine"] = IProcedureParallelFlightLine

class IProcedureVGTPoint(object):
    """Interface used to access the options for a VGT Point procedure."""
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{36159f4d-5c80-4a49-bdf8-ccfdda28100b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_as_procedure" : 1,
                             "get_minimum_time" : 2,
                             "get_start_time" : 3,
                             "set_start_time" : 4,
                             "get_maximum_time" : 5,
                             "get_formation_point" : 6,
                             "set_formation_point" : 7,
                             "get_interpolate_point_position_vel" : 8,
                             "set_interpolate_point_position_vel" : 9,
                             "get_duration" : 10,
                             "set_duration" : 11,
                             "get_use_max_point_stop_time" : 12,
                             "set_use_max_point_stop_time" : 13,
                             "get_fuel_flow_type" : 14,
                             "set_fuel_flow_type" : 15,
                             "get_override_fuel_flow_value" : 16,
                             "set_override_fuel_flow_value" : 17,
                             "get_consider_accel_for_fuel_flow" : 18,
                             "set_consider_accel_for_fuel_flow" : 19,
                             "get_flight_mode" : 20,
                             "set_flight_mode" : 21,
                             "get_display_step_time" : 22,
                             "set_display_step_time" : 23, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureVGTPoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureVGTPoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureVGTPoint.__dict__ and type(IProcedureVGTPoint.__dict__[attrname]) == property:
            return IProcedureVGTPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureVGTPoint.")
    
    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_as_procedure_metadata, out_arg())

    _get_minimum_time_metadata = { "name" : "minimum_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def minimum_time(self) -> typing.Any:
        """The minimum time at which formation might be possible."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_minimum_time_metadata)

    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_time(self) -> typing.Any:
        """The time at which the formation begins."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_start_time_metadata)

    _set_start_time_metadata = { "name" : "start_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @start_time.setter
    def start_time(self, newVal:typing.Any) -> None:
        """The time at which the formation begins."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_start_time_metadata, newVal)

    _get_maximum_time_metadata = { "name" : "maximum_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def maximum_time(self) -> typing.Any:
        """The maximum time at which formation might be possible."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_maximum_time_metadata)

    _get_formation_point_metadata = { "name" : "formation_point",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def formation_point(self) -> str:
        """The position that the aircraft will be locked onto while in formation."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_formation_point_metadata)

    _set_formation_point_metadata = { "name" : "formation_point",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @formation_point.setter
    def formation_point(self, newVal:str) -> None:
        """The position that the aircraft will be locked onto while in formation."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_formation_point_metadata, newVal)

    _get_interpolate_point_position_vel_metadata = { "name" : "interpolate_point_position_vel",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def interpolate_point_position_vel(self) -> bool:
        """The option to use interpolation to determine the formation point's speed and position."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_interpolate_point_position_vel_metadata)

    _set_interpolate_point_position_vel_metadata = { "name" : "interpolate_point_position_vel",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @interpolate_point_position_vel.setter
    def interpolate_point_position_vel(self, newVal:bool) -> None:
        """The option to use interpolation to determine the formation point's speed and position."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_interpolate_point_position_vel_metadata, newVal)

    _get_duration_metadata = { "name" : "duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def duration(self) -> float:
        """The duration of the procedure."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_duration_metadata)

    _set_duration_metadata = { "name" : "duration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @duration.setter
    def duration(self, newVal:float) -> None:
        """The duration of the procedure."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_duration_metadata, newVal)

    _get_use_max_point_stop_time_metadata = { "name" : "use_max_point_stop_time",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_max_point_stop_time(self) -> bool:
        """Opt to limit the duration to the maximum possible time if the duration exceeds the time limit."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_use_max_point_stop_time_metadata)

    _set_use_max_point_stop_time_metadata = { "name" : "use_max_point_stop_time",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_max_point_stop_time.setter
    def use_max_point_stop_time(self, newVal:bool) -> None:
        """Opt to limit the duration to the maximum possible time if the duration exceeds the time limit."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_use_max_point_stop_time_metadata, newVal)

    _get_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @property
    def fuel_flow_type(self) -> "FUEL_FLOW_TYPE":
        """The source used to calculate the fuel flow for the maneuver."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_fuel_flow_type_metadata)

    _set_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"FUEL_FLOW_TYPE") -> None:
        """The source used to calculate the fuel flow for the maneuver."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_fuel_flow_type_metadata, newVal)

    _get_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_fuel_flow_value(self) -> float:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_override_fuel_flow_value_metadata)

    _set_override_fuel_flow_value_metadata = { "name" : "override_fuel_flow_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_fuel_flow_value.setter
    def override_fuel_flow_value(self, newVal:float) -> None:
        """The value used for the Override Fuel Flow type. The fuel flow type must be set to Override to access this value."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_override_fuel_flow_value_metadata, newVal)

    _get_consider_accel_for_fuel_flow_metadata = { "name" : "consider_accel_for_fuel_flow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def consider_accel_for_fuel_flow(self) -> bool:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_consider_accel_for_fuel_flow_metadata)

    _set_consider_accel_for_fuel_flow_metadata = { "name" : "consider_accel_for_fuel_flow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @consider_accel_for_fuel_flow.setter
    def consider_accel_for_fuel_flow(self, newVal:bool) -> None:
        """The option to calculate the fuel flow rate according to the acceleration of the aircraft."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_consider_accel_for_fuel_flow_metadata, newVal)

    _get_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @property
    def flight_mode(self) -> "PHASE_OF_FLIGHT":
        """The type of performance model that the aircraft will use to fly the maneuver."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_flight_mode_metadata)

    _set_flight_mode_metadata = { "name" : "flight_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(PHASE_OF_FLIGHT),) }
    @flight_mode.setter
    def flight_mode(self, newVal:"PHASE_OF_FLIGHT") -> None:
        """The type of performance model that the aircraft will use to fly the maneuver."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_flight_mode_metadata, newVal)

    _get_display_step_time_metadata = { "name" : "display_step_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def display_step_time(self) -> float:
        """The time interval at which ephemeris is generated for display purposes."""
        return self._intf.get_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._get_display_step_time_metadata)

    _set_display_step_time_metadata = { "name" : "display_step_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @display_step_time.setter
    def display_step_time(self, newVal:float) -> None:
        """The time interval at which ephemeris is generated for display purposes."""
        return self._intf.set_property(IProcedureVGTPoint._metadata, IProcedureVGTPoint._set_display_step_time_metadata, newVal)


agcls.AgClassCatalog.add_catalog_entry("{36159f4d-5c80-4a49-bdf8-ccfdda28100b}", IProcedureVGTPoint)
agcls.AgTypeNameMap["IProcedureVGTPoint"] = IProcedureVGTPoint

class ISiteRunwayFromCatalog(object):
    """Interface used to access the options for a Runway From Catalog site type."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{56a06eb2-be85-4e31-b850-7c0485566739}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_catalog_runway" : 1,
                             "set_catalog_runway" : 2,
                             "get_as_site" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteRunwayFromCatalog._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteRunwayFromCatalog from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteRunwayFromCatalog.__dict__ and type(ISiteRunwayFromCatalog.__dict__[attrname]) == property:
            return ISiteRunwayFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteRunwayFromCatalog.")
    
    _get_catalog_runway_metadata = { "name" : "get_catalog_runway",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_catalog_runway(self) -> "ICatalogRunway":
        """Get the catalog runway."""
        return self._intf.invoke(ISiteRunwayFromCatalog._metadata, ISiteRunwayFromCatalog._get_catalog_runway_metadata, out_arg())

    _set_catalog_runway_metadata = { "name" : "set_catalog_runway",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICatalogRunway"),) }
    def set_catalog_runway(self, pVal:"ICatalogRunway") -> None:
        """Set the catalog runway."""
        return self._intf.invoke(ISiteRunwayFromCatalog._metadata, ISiteRunwayFromCatalog._set_catalog_runway_metadata, pVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteRunwayFromCatalog._metadata, ISiteRunwayFromCatalog._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{56a06eb2-be85-4e31-b850-7c0485566739}", ISiteRunwayFromCatalog)
agcls.AgTypeNameMap["ISiteRunwayFromCatalog"] = ISiteRunwayFromCatalog

class ISiteAirportFromCatalog(object):
    """Interface used to access the options for a airport From Catalog site type."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8cf3e110-d619-4769-894a-b23cb32baa7f}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_catalog_airport" : 1,
                             "set_catalog_airport" : 2,
                             "get_as_site" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteAirportFromCatalog._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteAirportFromCatalog from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteAirportFromCatalog.__dict__ and type(ISiteAirportFromCatalog.__dict__[attrname]) == property:
            return ISiteAirportFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteAirportFromCatalog.")
    
    _get_catalog_airport_metadata = { "name" : "get_catalog_airport",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_catalog_airport(self) -> "ARINC424Airport":
        """Get the catalog airport."""
        return self._intf.invoke(ISiteAirportFromCatalog._metadata, ISiteAirportFromCatalog._get_catalog_airport_metadata, out_arg())

    _set_catalog_airport_metadata = { "name" : "set_catalog_airport",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICatalogAirport"),) }
    def set_catalog_airport(self, pVal:"ICatalogAirport") -> None:
        """Set the catalog airport."""
        return self._intf.invoke(ISiteAirportFromCatalog._metadata, ISiteAirportFromCatalog._set_catalog_airport_metadata, pVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteAirportFromCatalog._metadata, ISiteAirportFromCatalog._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{8cf3e110-d619-4769-894a-b23cb32baa7f}", ISiteAirportFromCatalog)
agcls.AgTypeNameMap["ISiteAirportFromCatalog"] = ISiteAirportFromCatalog

class ISiteNavaidFromCatalog(object):
    """Interface used to access the options for a navaid From Catalog site type."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{960e8584-5349-44cc-8b49-9a00c209f9a5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_catalog_navaid" : 1,
                             "set_catalog_navaid" : 2,
                             "get_as_site" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteNavaidFromCatalog._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteNavaidFromCatalog from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteNavaidFromCatalog.__dict__ and type(ISiteNavaidFromCatalog.__dict__[attrname]) == property:
            return ISiteNavaidFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteNavaidFromCatalog.")
    
    _get_catalog_navaid_metadata = { "name" : "get_catalog_navaid",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_catalog_navaid(self) -> "ARINC424Navaid":
        """Get the catalog navaid."""
        return self._intf.invoke(ISiteNavaidFromCatalog._metadata, ISiteNavaidFromCatalog._get_catalog_navaid_metadata, out_arg())

    _set_catalog_navaid_metadata = { "name" : "set_catalog_navaid",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICatalogNavaid"),) }
    def set_catalog_navaid(self, pVal:"ICatalogNavaid") -> None:
        """Set the catalog navaid."""
        return self._intf.invoke(ISiteNavaidFromCatalog._metadata, ISiteNavaidFromCatalog._set_catalog_navaid_metadata, pVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteNavaidFromCatalog._metadata, ISiteNavaidFromCatalog._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{960e8584-5349-44cc-8b49-9a00c209f9a5}", ISiteNavaidFromCatalog)
agcls.AgTypeNameMap["ISiteNavaidFromCatalog"] = ISiteNavaidFromCatalog

class ISiteVTOLPointFromCatalog(object):
    """Interface used to access the options for a VTOL Point From Catalog site type."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{f0556822-9ba9-45ca-9cd2-e965d442d997}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_catalog_vtol_point" : 1,
                             "set_catalog_vtol_point" : 2,
                             "get_as_site" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteVTOLPointFromCatalog._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteVTOLPointFromCatalog from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteVTOLPointFromCatalog.__dict__ and type(ISiteVTOLPointFromCatalog.__dict__[attrname]) == property:
            return ISiteVTOLPointFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteVTOLPointFromCatalog.")
    
    _get_catalog_vtol_point_metadata = { "name" : "get_catalog_vtol_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_catalog_vtol_point(self) -> "ICatalogVTOLPoint":
        """Get the catalog VTOL point."""
        return self._intf.invoke(ISiteVTOLPointFromCatalog._metadata, ISiteVTOLPointFromCatalog._get_catalog_vtol_point_metadata, out_arg())

    _set_catalog_vtol_point_metadata = { "name" : "set_catalog_vtol_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICatalogVTOLPoint"),) }
    def set_catalog_vtol_point(self, pVal:"ICatalogVTOLPoint") -> None:
        """Set the catalog VTOL point."""
        return self._intf.invoke(ISiteVTOLPointFromCatalog._metadata, ISiteVTOLPointFromCatalog._set_catalog_vtol_point_metadata, pVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteVTOLPointFromCatalog._metadata, ISiteVTOLPointFromCatalog._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{f0556822-9ba9-45ca-9cd2-e965d442d997}", ISiteVTOLPointFromCatalog)
agcls.AgTypeNameMap["ISiteVTOLPointFromCatalog"] = ISiteVTOLPointFromCatalog

class ISiteWaypointFromCatalog(object):
    """Interface used to access the options for a waypoint From Catalog site type."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{89b1a048-7b22-45ab-bd5c-34584de7b2b7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_catalog_waypoint" : 1,
                             "set_catalog_waypoint" : 2,
                             "get_as_site" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteWaypointFromCatalog._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteWaypointFromCatalog from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteWaypointFromCatalog.__dict__ and type(ISiteWaypointFromCatalog.__dict__[attrname]) == property:
            return ISiteWaypointFromCatalog.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteWaypointFromCatalog.")
    
    _get_catalog_waypoint_metadata = { "name" : "get_catalog_waypoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_catalog_waypoint(self) -> "ICatalogWaypoint":
        """Get the catalog waypoint."""
        return self._intf.invoke(ISiteWaypointFromCatalog._metadata, ISiteWaypointFromCatalog._get_catalog_waypoint_metadata, out_arg())

    _set_catalog_waypoint_metadata = { "name" : "set_catalog_waypoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICatalogWaypoint"),) }
    def set_catalog_waypoint(self, pVal:"ICatalogWaypoint") -> None:
        """Set the catalog waypoint."""
        return self._intf.invoke(ISiteWaypointFromCatalog._metadata, ISiteWaypointFromCatalog._set_catalog_waypoint_metadata, pVal)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteWaypointFromCatalog._metadata, ISiteWaypointFromCatalog._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{89b1a048-7b22-45ab-bd5c-34584de7b2b7}", ISiteWaypointFromCatalog)
agcls.AgTypeNameMap["ISiteWaypointFromCatalog"] = ISiteWaypointFromCatalog

class IProcedureLaunchDynState(object):
    """Interface used to access the options for a dyn state launch procedure."""
    _num_methods = 26
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BC0541E2-248E-4B42-8A7F-E9C411E40073}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_launch_time" : 1,
                             "set_launch_time" : 2,
                             "get_coord_frame" : 3,
                             "set_coord_frame" : 4,
                             "get_bearing_reference" : 5,
                             "set_bearing_reference" : 6,
                             "get_launch_bearing" : 7,
                             "set_launch_bearing" : 8,
                             "get_launch_elevation" : 9,
                             "set_launch_elevation" : 10,
                             "get_attitude_mode" : 11,
                             "set_attitude_mode" : 12,
                             "get_specify_launch_airspeed" : 13,
                             "set_specify_launch_airspeed" : 14,
                             "get_accel_g" : 15,
                             "set_accel_g" : 16,
                             "get_airspeed_type" : 17,
                             "get_airspeed" : 18,
                             "set_airspeed" : 19,
                             "get_fuel_flow_type" : 20,
                             "set_fuel_flow_type" : 21,
                             "get_override_fuel_flow" : 22,
                             "set_override_fuel_flow" : 23,
                             "get_true_course_hint" : 24,
                             "set_true_course_hint" : 25,
                             "get_as_procedure" : 26, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureLaunchDynState._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLaunchDynState from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLaunchDynState.__dict__ and type(IProcedureLaunchDynState.__dict__[attrname]) == property:
            return IProcedureLaunchDynState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLaunchDynState.")
    
    _get_launch_time_metadata = { "name" : "launch_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def launch_time(self) -> typing.Any:
        """The launch time of the aircraft."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_launch_time_metadata)

    _set_launch_time_metadata = { "name" : "launch_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @launch_time.setter
    def launch_time(self, newVal:typing.Any) -> None:
        """The launch time of the aircraft."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_launch_time_metadata, newVal)

    _get_coord_frame_metadata = { "name" : "coord_frame",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_DYN_STATE_COORD_FRAME),) }
    @property
    def coord_frame(self) -> "LAUNCH_DYN_STATE_COORD_FRAME":
        """The reference coordinate frame for the dyn state launch procedure."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_coord_frame_metadata)

    _set_coord_frame_metadata = { "name" : "coord_frame",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_DYN_STATE_COORD_FRAME),) }
    @coord_frame.setter
    def coord_frame(self, pVal:"LAUNCH_DYN_STATE_COORD_FRAME") -> None:
        """The reference coordinate frame for the dyn state launch procedure."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_coord_frame_metadata, pVal)

    _get_bearing_reference_metadata = { "name" : "bearing_reference",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_DYN_STATE_BEARING_REFERENCE),) }
    @property
    def bearing_reference(self) -> "LAUNCH_DYN_STATE_BEARING_REFERENCE":
        """The bearing reference for the dyn state launch procedure."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_bearing_reference_metadata)

    _set_bearing_reference_metadata = { "name" : "bearing_reference",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_DYN_STATE_BEARING_REFERENCE),) }
    @bearing_reference.setter
    def bearing_reference(self, pVal:"LAUNCH_DYN_STATE_BEARING_REFERENCE") -> None:
        """The bearing reference for the dyn state launch procedure."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_bearing_reference_metadata, pVal)

    _get_launch_bearing_metadata = { "name" : "launch_bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def launch_bearing(self) -> typing.Any:
        """The launch direction bearing."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_launch_bearing_metadata)

    _set_launch_bearing_metadata = { "name" : "launch_bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @launch_bearing.setter
    def launch_bearing(self, newVal:typing.Any) -> None:
        """The launch direction bearing."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_launch_bearing_metadata, newVal)

    _get_launch_elevation_metadata = { "name" : "launch_elevation",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def launch_elevation(self) -> typing.Any:
        """The launch direction elevation."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_launch_elevation_metadata)

    _set_launch_elevation_metadata = { "name" : "launch_elevation",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @launch_elevation.setter
    def launch_elevation(self, newVal:typing.Any) -> None:
        """The launch direction elevation."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_launch_elevation_metadata, newVal)

    _get_attitude_mode_metadata = { "name" : "attitude_mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_ATTITUDE_MODE),) }
    @property
    def attitude_mode(self) -> "LAUNCH_ATTITUDE_MODE":
        """The attitude mode during the launch."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_attitude_mode_metadata)

    _set_attitude_mode_metadata = { "name" : "attitude_mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(LAUNCH_ATTITUDE_MODE),) }
    @attitude_mode.setter
    def attitude_mode(self, newVal:"LAUNCH_ATTITUDE_MODE") -> None:
        """The attitude mode during the launch."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_attitude_mode_metadata, newVal)

    _get_specify_launch_airspeed_metadata = { "name" : "specify_launch_airspeed",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def specify_launch_airspeed(self) -> bool:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_specify_launch_airspeed_metadata)

    _set_specify_launch_airspeed_metadata = { "name" : "specify_launch_airspeed",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @specify_launch_airspeed.setter
    def specify_launch_airspeed(self, newVal:bool) -> None:
        """Opt to specify a minimum launch speed the aircraft will accelerate to."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_specify_launch_airspeed_metadata, newVal)

    _get_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_g(self) -> float:
        """The acceleration of the aircraft during the launch."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_accel_g_metadata)

    _set_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The acceleration of the aircraft during the launch."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_accel_g_metadata, newVal)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_airspeed_type_metadata)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_airspeed_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        return self._intf.invoke(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_airspeed_metadata, airspeedType, airspeed)

    _get_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @property
    def fuel_flow_type(self) -> "FUEL_FLOW_TYPE":
        """The fuel flow type of the aircraft during the launch."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_fuel_flow_type_metadata)

    _set_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"FUEL_FLOW_TYPE") -> None:
        """The fuel flow type of the aircraft during the launch."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_fuel_flow_type_metadata, newVal)

    _get_override_fuel_flow_metadata = { "name" : "override_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_fuel_flow(self) -> float:
        """The fuel flow value for a fuel flow type set to Override."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_override_fuel_flow_metadata)

    _set_override_fuel_flow_metadata = { "name" : "override_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_fuel_flow.setter
    def override_fuel_flow(self, newVal:float) -> None:
        """The fuel flow value for a fuel flow type set to Override."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_override_fuel_flow_metadata, newVal)

    _get_true_course_hint_metadata = { "name" : "true_course_hint",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def true_course_hint(self) -> typing.Any:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        return self._intf.get_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_true_course_hint_metadata)

    _set_true_course_hint_metadata = { "name" : "true_course_hint",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @true_course_hint.setter
    def true_course_hint(self, newVal:typing.Any) -> None:
        """The true course used when the vehicle's direction vector is set to Zenith."""
        return self._intf.set_property(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._set_true_course_hint_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureLaunchDynState._metadata, IProcedureLaunchDynState._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{BC0541E2-248E-4B42-8A7F-E9C411E40073}", IProcedureLaunchDynState)
agcls.AgTypeNameMap["IProcedureLaunchDynState"] = IProcedureLaunchDynState

class IProcedureLaunchWaypoint(object):
    """Interface used to access the options for a waypoint launch procedure."""
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6154839D-55D1-4A31-9B03-330411C54D24}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_launch_time" : 1,
                             "set_launch_time" : 2,
                             "get_altitude_reference" : 3,
                             "set_altitude_reference" : 4,
                             "get_launch_altitude" : 5,
                             "set_launch_altitude" : 6,
                             "get_launch_true_bearing" : 7,
                             "set_launch_true_bearing" : 8,
                             "get_launch_elevation" : 9,
                             "set_launch_elevation" : 10,
                             "get_accel_g" : 11,
                             "set_accel_g" : 12,
                             "get_airspeed_type" : 13,
                             "get_airspeed" : 14,
                             "set_airspeed" : 15,
                             "get_fuel_flow_type" : 16,
                             "set_fuel_flow_type" : 17,
                             "get_override_fuel_flow" : 18,
                             "set_override_fuel_flow" : 19,
                             "get_as_procedure" : 20, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IProcedureLaunchWaypoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IProcedureLaunchWaypoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProcedureLaunchWaypoint.__dict__ and type(IProcedureLaunchWaypoint.__dict__[attrname]) == property:
            return IProcedureLaunchWaypoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProcedureLaunchWaypoint.")
    
    _get_launch_time_metadata = { "name" : "launch_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def launch_time(self) -> typing.Any:
        """The launch time of the aircraft."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_launch_time_metadata)

    _set_launch_time_metadata = { "name" : "launch_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @launch_time.setter
    def launch_time(self, newVal:typing.Any) -> None:
        """The launch time of the aircraft."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_launch_time_metadata, newVal)

    _get_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_REFERENCE),) }
    @property
    def altitude_reference(self) -> "ALTITUDE_REFERENCE":
        """The launch altitude reference."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_altitude_reference_metadata)

    _set_altitude_reference_metadata = { "name" : "altitude_reference",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(ALTITUDE_REFERENCE),) }
    @altitude_reference.setter
    def altitude_reference(self, newVal:"ALTITUDE_REFERENCE") -> None:
        """The launch altitude reference."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_altitude_reference_metadata, newVal)

    _get_launch_altitude_metadata = { "name" : "launch_altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def launch_altitude(self) -> float:
        """The launch altitude."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_launch_altitude_metadata)

    _set_launch_altitude_metadata = { "name" : "launch_altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @launch_altitude.setter
    def launch_altitude(self, newVal:float) -> None:
        """The launch altitude."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_launch_altitude_metadata, newVal)

    _get_launch_true_bearing_metadata = { "name" : "launch_true_bearing",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def launch_true_bearing(self) -> typing.Any:
        """The launch direction bearing."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_launch_true_bearing_metadata)

    _set_launch_true_bearing_metadata = { "name" : "launch_true_bearing",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @launch_true_bearing.setter
    def launch_true_bearing(self, newVal:typing.Any) -> None:
        """The launch direction bearing."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_launch_true_bearing_metadata, newVal)

    _get_launch_elevation_metadata = { "name" : "launch_elevation",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def launch_elevation(self) -> typing.Any:
        """The launch direction elevation."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_launch_elevation_metadata)

    _set_launch_elevation_metadata = { "name" : "launch_elevation",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @launch_elevation.setter
    def launch_elevation(self, newVal:typing.Any) -> None:
        """The launch direction elevation."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_launch_elevation_metadata, newVal)

    _get_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def accel_g(self) -> float:
        """The acceleration of the aircraft during the launch."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_accel_g_metadata)

    _set_accel_g_metadata = { "name" : "accel_g",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @accel_g.setter
    def accel_g(self, newVal:float) -> None:
        """The acceleration of the aircraft during the launch."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_accel_g_metadata, newVal)

    _get_airspeed_type_metadata = { "name" : "airspeed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE),) }
    @property
    def airspeed_type(self) -> "AIRSPEED_TYPE":
        """The airspeed type."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_airspeed_type_metadata)

    _get_airspeed_metadata = { "name" : "airspeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def airspeed(self) -> float:
        """The goal airspeed for the launch."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_airspeed_metadata)

    _set_airspeed_metadata = { "name" : "set_airspeed",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AIRSPEED_TYPE), agmarshall.DOUBLE_arg,) }
    def set_airspeed(self, airspeedType:"AIRSPEED_TYPE", airspeed:float) -> None:
        """Set the launch airspeed."""
        return self._intf.invoke(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_airspeed_metadata, airspeedType, airspeed)

    _get_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @property
    def fuel_flow_type(self) -> "FUEL_FLOW_TYPE":
        """The fuel flow type of the aircraft during the launch."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_fuel_flow_type_metadata)

    _set_fuel_flow_type_metadata = { "name" : "fuel_flow_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(FUEL_FLOW_TYPE),) }
    @fuel_flow_type.setter
    def fuel_flow_type(self, newVal:"FUEL_FLOW_TYPE") -> None:
        """The fuel flow type of the aircraft during the launch."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_fuel_flow_type_metadata, newVal)

    _get_override_fuel_flow_metadata = { "name" : "override_fuel_flow",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def override_fuel_flow(self) -> float:
        """The fuel flow value for a fuel flow type set to Override."""
        return self._intf.get_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_override_fuel_flow_metadata)

    _set_override_fuel_flow_metadata = { "name" : "override_fuel_flow",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @override_fuel_flow.setter
    def override_fuel_flow(self, newVal:float) -> None:
        """The fuel flow value for a fuel flow type set to Override."""
        return self._intf.set_property(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._set_override_fuel_flow_metadata, newVal)

    _get_as_procedure_metadata = { "name" : "get_as_procedure",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_procedure(self) -> "IProcedure":
        """Get the procedure interface."""
        return self._intf.invoke(IProcedureLaunchWaypoint._metadata, IProcedureLaunchWaypoint._get_as_procedure_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{6154839D-55D1-4A31-9B03-330411C54D24}", IProcedureLaunchWaypoint)
agcls.AgTypeNameMap["IProcedureLaunchWaypoint"] = IProcedureLaunchWaypoint

class ISiteDynState(object):
    """Interface used to access the options for a dyn state site type."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{06485268-3338-46D7-8F0C-7BCA35CE9589}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_object_name" : 1,
                             "set_object_name" : 2,
                             "get_valid_object_names" : 3,
                             "get_as_site" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(ISiteDynState._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create ISiteDynState from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISiteDynState.__dict__ and type(ISiteDynState.__dict__[attrname]) == property:
            return ISiteDynState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISiteDynState.")
    
    _get_object_name_metadata = { "name" : "object_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def object_name(self) -> str:
        """The object name to link to."""
        return self._intf.get_property(ISiteDynState._metadata, ISiteDynState._get_object_name_metadata)

    _set_object_name_metadata = { "name" : "object_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @object_name.setter
    def object_name(self, newVal:str) -> None:
        """The object name to link to."""
        return self._intf.set_property(ISiteDynState._metadata, ISiteDynState._set_object_name_metadata, newVal)

    _get_valid_object_names_metadata = { "name" : "valid_object_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def valid_object_names(self) -> list:
        """Returns the valid object names."""
        return self._intf.get_property(ISiteDynState._metadata, ISiteDynState._get_valid_object_names_metadata)

    _get_as_site_metadata = { "name" : "get_as_site",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_as_site(self) -> "ISite":
        """Get the site interface."""
        return self._intf.invoke(ISiteDynState._metadata, ISiteDynState._get_as_site_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{06485268-3338-46D7-8F0C-7BCA35CE9589}", ISiteDynState)
agcls.AgTypeNameMap["ISiteDynState"] = ISiteDynState



class SiteWaypoint(ISiteWaypoint, ISite):
    """Class defining a waypoint site."""
    def __init__(self, sourceObject=None):
        ISiteWaypoint.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteWaypoint._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteWaypoint._get_property(self, attrname) is not None: found_prop = ISiteWaypoint._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteWaypoint.")

agcls.AgClassCatalog.add_catalog_entry("{6d98e9b3-6766-46e5-98e2-b1f859b2ce92}", SiteWaypoint)
agcls.AgTypeNameMap["SiteWaypoint"] = SiteWaypoint

class SiteEndOfPrevProcedure(ISiteEndOfPrevProcedure, ISite):
    """Class defining an End of Previous Procedure site."""
    def __init__(self, sourceObject=None):
        ISiteEndOfPrevProcedure.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteEndOfPrevProcedure._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteEndOfPrevProcedure._get_property(self, attrname) is not None: found_prop = ISiteEndOfPrevProcedure._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteEndOfPrevProcedure.")

agcls.AgClassCatalog.add_catalog_entry("{24d8e613-5ce5-4e04-9251-fe44414caa14}", SiteEndOfPrevProcedure)
agcls.AgTypeNameMap["SiteEndOfPrevProcedure"] = SiteEndOfPrevProcedure

class SiteVTOLPoint(ISiteVTOLPoint, ISite):
    """Class defining a VTOL Point site."""
    def __init__(self, sourceObject=None):
        ISiteVTOLPoint.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteVTOLPoint._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteVTOLPoint._get_property(self, attrname) is not None: found_prop = ISiteVTOLPoint._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteVTOLPoint.")

agcls.AgClassCatalog.add_catalog_entry("{4f9d9e04-fa7e-4335-b1f4-15788a01c7ea}", SiteVTOLPoint)
agcls.AgTypeNameMap["SiteVTOLPoint"] = SiteVTOLPoint

class SiteReferenceState(ISiteReferenceState, ISite):
    """Class defining a Reference State site."""
    def __init__(self, sourceObject=None):
        ISiteReferenceState.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteReferenceState._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteReferenceState._get_property(self, attrname) is not None: found_prop = ISiteReferenceState._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteReferenceState.")

agcls.AgClassCatalog.add_catalog_entry("{978180ff-3f87-4ead-9405-e12e915c27e1}", SiteReferenceState)
agcls.AgTypeNameMap["SiteReferenceState"] = SiteReferenceState

class SiteSTKVehicle(ISiteSTKVehicle, ISite):
    """Class defining a STK Vehicle site."""
    def __init__(self, sourceObject=None):
        ISiteSTKVehicle.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteSTKVehicle._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKVehicle._get_property(self, attrname) is not None: found_prop = ISiteSTKVehicle._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKVehicle.")

agcls.AgClassCatalog.add_catalog_entry("{01b272ac-3b19-4daf-825f-88c0ff0e10bb}", SiteSTKVehicle)
agcls.AgTypeNameMap["SiteSTKVehicle"] = SiteSTKVehicle

class SiteSuperProcedure(ISiteSuperProcedure, ISite):
    """Class defining a Super Procedure site."""
    def __init__(self, sourceObject=None):
        ISiteSuperProcedure.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteSuperProcedure._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSuperProcedure._get_property(self, attrname) is not None: found_prop = ISiteSuperProcedure._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSuperProcedure.")

agcls.AgClassCatalog.add_catalog_entry("{0faf9c77-17bc-4a8d-b490-d4dcd2326ca9}", SiteSuperProcedure)
agcls.AgTypeNameMap["SiteSuperProcedure"] = SiteSuperProcedure

class SiteRelToPrevProcedure(ISiteRelToPrevProcedure, ISite):
    """Class defining a Relative to Previous Procedure site."""
    def __init__(self, sourceObject=None):
        ISiteRelToPrevProcedure.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteRelToPrevProcedure._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRelToPrevProcedure._get_property(self, attrname) is not None: found_prop = ISiteRelToPrevProcedure._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRelToPrevProcedure.")

agcls.AgClassCatalog.add_catalog_entry("{aa8dc548-3b50-44d0-b340-f1fca98283ee}", SiteRelToPrevProcedure)
agcls.AgTypeNameMap["SiteRelToPrevProcedure"] = SiteRelToPrevProcedure

class SiteSTKObjectWaypoint(ISiteSTKObjectWaypoint, ISite):
    """Class defining a STK Object Waypoint site."""
    def __init__(self, sourceObject=None):
        ISiteSTKObjectWaypoint.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteSTKObjectWaypoint._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKObjectWaypoint._get_property(self, attrname) is not None: found_prop = ISiteSTKObjectWaypoint._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKObjectWaypoint.")

agcls.AgClassCatalog.add_catalog_entry("{0b1f12ad-e7be-4158-abb4-39efb21a87d3}", SiteSTKObjectWaypoint)
agcls.AgTypeNameMap["SiteSTKObjectWaypoint"] = SiteSTKObjectWaypoint

class SiteSTKStaticObject(ISiteSTKStaticObject, ISite):
    """Class defining a STK Static Object site."""
    def __init__(self, sourceObject=None):
        ISiteSTKStaticObject.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteSTKStaticObject._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKStaticObject._get_property(self, attrname) is not None: found_prop = ISiteSTKStaticObject._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKStaticObject.")

agcls.AgClassCatalog.add_catalog_entry("{16bc1a6a-6cf6-4e2a-b73f-82e6e0928c61}", SiteSTKStaticObject)
agcls.AgTypeNameMap["SiteSTKStaticObject"] = SiteSTKStaticObject

class SiteRelToSTKObject(ISiteRelToSTKObject, ISite):
    """Class defining a Relative to Stationary STK Object site."""
    def __init__(self, sourceObject=None):
        ISiteRelToSTKObject.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteRelToSTKObject._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRelToSTKObject._get_property(self, attrname) is not None: found_prop = ISiteRelToSTKObject._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRelToSTKObject.")

agcls.AgClassCatalog.add_catalog_entry("{0c4677b4-f09b-4f8c-a170-3d4f0e1bf7f9}", SiteRelToSTKObject)
agcls.AgTypeNameMap["SiteRelToSTKObject"] = SiteRelToSTKObject

class SiteSTKAreaTarget(ISiteSTKAreaTarget, ISite):
    """Class defining a STK Area Target site."""
    def __init__(self, sourceObject=None):
        ISiteSTKAreaTarget.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteSTKAreaTarget._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteSTKAreaTarget._get_property(self, attrname) is not None: found_prop = ISiteSTKAreaTarget._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteSTKAreaTarget.")

agcls.AgClassCatalog.add_catalog_entry("{8ae70236-0185-4072-b230-da6e68e122f1}", SiteSTKAreaTarget)
agcls.AgTypeNameMap["SiteSTKAreaTarget"] = SiteSTKAreaTarget

class SiteRunway(ISiteRunway, ISite):
    """Class defining a runway site."""
    def __init__(self, sourceObject=None):
        ISiteRunway.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteRunway._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRunway._get_property(self, attrname) is not None: found_prop = ISiteRunway._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRunway.")

agcls.AgClassCatalog.add_catalog_entry("{6bbd87f1-83bc-4750-8128-8ba51a48b4ed}", SiteRunway)
agcls.AgTypeNameMap["SiteRunway"] = SiteRunway

class Site(ISite, ISiteUnknown):
    """Class defining an unknown site type."""
    def __init__(self, sourceObject=None):
        ISite.__init__(self, sourceObject)
        ISiteUnknown.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISite._private_init(self, intf)
        ISiteUnknown._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if ISiteUnknown._get_property(self, attrname) is not None: found_prop = ISiteUnknown._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Site.")

agcls.AgClassCatalog.add_catalog_entry("{445bad6d-6125-446d-bce6-ac9233f11706}", Site)
agcls.AgTypeNameMap["Site"] = Site

class ProcedureLanding(IProcedureLanding, IProcedure):
    """Class defining a landing procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLanding.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureLanding._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLanding._get_property(self, attrname) is not None: found_prop = IProcedureLanding._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLanding.")

agcls.AgClassCatalog.add_catalog_entry("{bde94020-cc95-4868-b5f1-da680baf4aeb}", ProcedureLanding)
agcls.AgTypeNameMap["ProcedureLanding"] = ProcedureLanding

class ProcedureEnroute(IProcedureEnroute, IProcedure):
    """Class defining an enroute procedure."""
    def __init__(self, sourceObject=None):
        IProcedureEnroute.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureEnroute._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureEnroute._get_property(self, attrname) is not None: found_prop = IProcedureEnroute._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureEnroute.")

agcls.AgClassCatalog.add_catalog_entry("{f073011a-bfc1-4c9a-bd43-1a99bed41390}", ProcedureEnroute)
agcls.AgTypeNameMap["ProcedureEnroute"] = ProcedureEnroute

class ProcedureExtEphem(IProcedureExtEphem, IProcedure):
    """Class defining an ExtEphem procedure."""
    def __init__(self, sourceObject=None):
        IProcedureExtEphem.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureExtEphem._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureExtEphem._get_property(self, attrname) is not None: found_prop = IProcedureExtEphem._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureExtEphem.")

agcls.AgClassCatalog.add_catalog_entry("{0F39A3ED-4A9E-4893-A061-F73A75ACF910}", ProcedureExtEphem)
agcls.AgTypeNameMap["ProcedureExtEphem"] = ProcedureExtEphem

class ProcedureFormationFlyer(IProcedureFormationFlyer, IProcedure):
    """Class defining an formationflyer procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFormationFlyer.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureFormationFlyer._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFormationFlyer._get_property(self, attrname) is not None: found_prop = IProcedureFormationFlyer._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFormationFlyer.")

agcls.AgClassCatalog.add_catalog_entry("{678807EC-D03C-4E14-A068-3C0D14923D72}", ProcedureFormationFlyer)
agcls.AgTypeNameMap["ProcedureFormationFlyer"] = ProcedureFormationFlyer

class ProcedureBasicPointToPoint(IProcedureBasicPointToPoint, IProcedure):
    """Class defining a basic point to point procedure."""
    def __init__(self, sourceObject=None):
        IProcedureBasicPointToPoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureBasicPointToPoint._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureBasicPointToPoint._get_property(self, attrname) is not None: found_prop = IProcedureBasicPointToPoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureBasicPointToPoint.")

agcls.AgClassCatalog.add_catalog_entry("{36ce90e9-da71-40a6-aff9-db4aecab63bd}", ProcedureBasicPointToPoint)
agcls.AgTypeNameMap["ProcedureBasicPointToPoint"] = ProcedureBasicPointToPoint

class ProcedureArcEnroute(IProcedureArcEnroute, IProcedure):
    """Class defining a arc enroute procedure."""
    def __init__(self, sourceObject=None):
        IProcedureArcEnroute.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureArcEnroute._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureArcEnroute._get_property(self, attrname) is not None: found_prop = IProcedureArcEnroute._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureArcEnroute.")

agcls.AgClassCatalog.add_catalog_entry("{7466bbc5-38eb-48ee-aec6-d45c69c562c1}", ProcedureArcEnroute)
agcls.AgTypeNameMap["ProcedureArcEnroute"] = ProcedureArcEnroute

class ProcedureArcPointToPoint(IProcedureArcPointToPoint, IProcedure):
    """Class defining a arc point to point procedure."""
    def __init__(self, sourceObject=None):
        IProcedureArcPointToPoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureArcPointToPoint._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureArcPointToPoint._get_property(self, attrname) is not None: found_prop = IProcedureArcPointToPoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureArcPointToPoint.")

agcls.AgClassCatalog.add_catalog_entry("{c8026c77-0b69-413a-9903-bff5e40f44b8}", ProcedureArcPointToPoint)
agcls.AgTypeNameMap["ProcedureArcPointToPoint"] = ProcedureArcPointToPoint

class ProcedureFlightLine(IProcedureFlightLine, IProcedure):
    """Class defining a flight line procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFlightLine.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureFlightLine._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFlightLine._get_property(self, attrname) is not None: found_prop = IProcedureFlightLine._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFlightLine.")

agcls.AgClassCatalog.add_catalog_entry("{5079d60a-789b-489e-b1ba-749d7a888eba}", ProcedureFlightLine)
agcls.AgTypeNameMap["ProcedureFlightLine"] = ProcedureFlightLine

class ProcedureDelay(IProcedureDelay, IProcedure):
    """Class defining a delay procedure."""
    def __init__(self, sourceObject=None):
        IProcedureDelay.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureDelay._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureDelay._get_property(self, attrname) is not None: found_prop = IProcedureDelay._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureDelay.")

agcls.AgClassCatalog.add_catalog_entry("{bf773446-cf9e-4f29-8c9e-57d62abbdb09}", ProcedureDelay)
agcls.AgTypeNameMap["ProcedureDelay"] = ProcedureDelay

class ProcedureTakeoff(IProcedureTakeoff, IProcedure):
    """Class defining a takeoff procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTakeoff.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureTakeoff._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTakeoff._get_property(self, attrname) is not None: found_prop = IProcedureTakeoff._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTakeoff.")

agcls.AgClassCatalog.add_catalog_entry("{52f322eb-31ca-4026-910d-ce46cc0830ee}", ProcedureTakeoff)
agcls.AgTypeNameMap["ProcedureTakeoff"] = ProcedureTakeoff

class ProcedureCollection(IProcedureCollection):
    """Class defining the collection of procedures in the phase of an Aviator mission."""
    def __init__(self, sourceObject=None):
        IProcedureCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureCollection._get_property(self, attrname) is not None: found_prop = IProcedureCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureCollection.")

agcls.AgClassCatalog.add_catalog_entry("{02be4f36-f12f-4df0-86f4-3740e53fafe9}", ProcedureCollection)
agcls.AgTypeNameMap["ProcedureCollection"] = ProcedureCollection

class Phase(IPhase):
    """Class defining a phase in an Aviator mission."""
    def __init__(self, sourceObject=None):
        IPhase.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IPhase._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPhase._get_property(self, attrname) is not None: found_prop = IPhase._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Phase.")

agcls.AgClassCatalog.add_catalog_entry("{ff7ca84a-39d9-49ee-9629-0e3d46183fbf}", Phase)
agcls.AgTypeNameMap["Phase"] = Phase

class PhaseCollection(IPhaseCollection):
    """Class defining the collection of phases."""
    def __init__(self, sourceObject=None):
        IPhaseCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IPhaseCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPhaseCollection._get_property(self, attrname) is not None: found_prop = IPhaseCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PhaseCollection.")

agcls.AgClassCatalog.add_catalog_entry("{6518b03b-1889-4b4e-86d0-403939b71a21}", PhaseCollection)
agcls.AgTypeNameMap["PhaseCollection"] = PhaseCollection

class Mission(IMission):
    """Class defining the Aviator mission."""
    def __init__(self, sourceObject=None):
        IMission.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMission._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMission._get_property(self, attrname) is not None: found_prop = IMission._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Mission.")

agcls.AgClassCatalog.add_catalog_entry("{26840b17-5789-4690-96be-c8637b15f434}", Mission)
agcls.AgTypeNameMap["Mission"] = Mission

class AviatorPropagator(IAviatorPropagator):
    """Class defining the Aviator propagator."""
    def __init__(self, sourceObject=None):
        IAviatorPropagator.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAviatorPropagator._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAviatorPropagator._get_property(self, attrname) is not None: found_prop = IAviatorPropagator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AviatorPropagator.")

agcls.AgClassCatalog.add_catalog_entry("{e20f6939-fe05-44eb-a175-d63fa503526f}", AviatorPropagator)
agcls.AgTypeNameMap["AviatorPropagator"] = AviatorPropagator

class ProcedureBasicManeuver(IProcedureBasicManeuver, IProcedure):
    """Class defining a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IProcedureBasicManeuver.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureBasicManeuver._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureBasicManeuver._get_property(self, attrname) is not None: found_prop = IProcedureBasicManeuver._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureBasicManeuver.")

agcls.AgClassCatalog.add_catalog_entry("{7eb66528-bec8-4b78-a9c7-45333edbda52}", ProcedureBasicManeuver)
agcls.AgTypeNameMap["ProcedureBasicManeuver"] = ProcedureBasicManeuver

class BasicManeuverStrategyWeave(IBasicManeuverStrategyWeave, IBasicManeuverStrategy):
    """Class defining Weave strategy for a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyWeave.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyWeave._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyWeave._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyWeave._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyWeave.")

agcls.AgClassCatalog.add_catalog_entry("{46876894-f405-41cc-b071-9368b2d615f8}", BasicManeuverStrategyWeave)
agcls.AgTypeNameMap["BasicManeuverStrategyWeave"] = BasicManeuverStrategyWeave

class ProcedureTimeOptions(IProcedureTimeOptions):
    """Class defining the time options for the current procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTimeOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureTimeOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTimeOptions._get_property(self, attrname) is not None: found_prop = IProcedureTimeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTimeOptions.")

agcls.AgClassCatalog.add_catalog_entry("{8f9d3e7e-4531-42b5-b066-44a87d6afc8c}", ProcedureTimeOptions)
agcls.AgTypeNameMap["ProcedureTimeOptions"] = ProcedureTimeOptions

class CalculationOptions(ICalculationOptions):
    """Class defining the calculation options for a procedure or phase."""
    def __init__(self, sourceObject=None):
        ICalculationOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationOptions._get_property(self, attrname) is not None: found_prop = ICalculationOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationOptions.")

agcls.AgClassCatalog.add_catalog_entry("{0538ece7-c599-4fc2-9d5b-3750f6712233}", CalculationOptions)
agcls.AgTypeNameMap["CalculationOptions"] = CalculationOptions

class AircraftCategory(IAircraftCategory):
    """Class defining the aircraft category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IAircraftCategory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftCategory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftCategory._get_property(self, attrname) is not None: found_prop = IAircraftCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftCategory.")

agcls.AgClassCatalog.add_catalog_entry("{7c68c433-7123-45ec-9e3d-3bc4d999c6f3}", AircraftCategory)
agcls.AgTypeNameMap["AircraftCategory"] = AircraftCategory

class Catalog(ICatalog):
    """Class defining the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        ICatalog.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICatalog._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICatalog._get_property(self, attrname) is not None: found_prop = ICatalog._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Catalog.")

agcls.AgClassCatalog.add_catalog_entry("{3ac28f35-5412-4419-ac35-24dfd086a210}", Catalog)
agcls.AgTypeNameMap["Catalog"] = Catalog

class AircraftModel(IAircraftModel, IAviatorVehicle, ICatalogItem):
    """Class defining an aircraft in Aviator."""
    def __init__(self, sourceObject=None):
        IAircraftModel.__init__(self, sourceObject)
        IAviatorVehicle.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftModel._private_init(self, intf)
        IAviatorVehicle._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftModel._get_property(self, attrname) is not None: found_prop = IAircraftModel._get_property(self, attrname)
        if IAviatorVehicle._get_property(self, attrname) is not None: found_prop = IAviatorVehicle._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftModel.")

agcls.AgClassCatalog.add_catalog_entry("{063a922a-36a4-492c-8b6b-7b9cd7c29e8d}", AircraftModel)
agcls.AgTypeNameMap["AircraftModel"] = AircraftModel

class MissileModel(IMissileModel, IAviatorVehicle, ICatalogItem):
    """Class defining a missile in Aviator."""
    def __init__(self, sourceObject=None):
        IMissileModel.__init__(self, sourceObject)
        IAviatorVehicle.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileModel._private_init(self, intf)
        IAviatorVehicle._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileModel._get_property(self, attrname) is not None: found_prop = IMissileModel._get_property(self, attrname)
        if IAviatorVehicle._get_property(self, attrname) is not None: found_prop = IAviatorVehicle._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileModel.")

agcls.AgClassCatalog.add_catalog_entry("{4b46d7a8-3e2b-4cd9-a927-2e49e1b9ab5c}", MissileModel)
agcls.AgTypeNameMap["MissileModel"] = MissileModel

class RotorcraftModel(IRotorcraftModel, IAviatorVehicle, ICatalogItem):
    """Class defining a rotorcraft in Aviator."""
    def __init__(self, sourceObject=None):
        IRotorcraftModel.__init__(self, sourceObject)
        IAviatorVehicle.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IRotorcraftModel._private_init(self, intf)
        IAviatorVehicle._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftModel._get_property(self, attrname) is not None: found_prop = IRotorcraftModel._get_property(self, attrname)
        if IAviatorVehicle._get_property(self, attrname) is not None: found_prop = IAviatorVehicle._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftModel.")

agcls.AgClassCatalog.add_catalog_entry("{a10ff662-0083-473b-90c7-5ff75d3144c9}", RotorcraftModel)
agcls.AgTypeNameMap["RotorcraftModel"] = RotorcraftModel

class RotorcraftAero(IRotorcraftAero):
    """Class defining the aerodynamic options for a rotorcraft."""
    def __init__(self, sourceObject=None):
        IRotorcraftAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IRotorcraftAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftAero._get_property(self, attrname) is not None: found_prop = IRotorcraftAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftAero.")

agcls.AgClassCatalog.add_catalog_entry("{df267da7-689f-48eb-bd92-1bdfebc51435}", RotorcraftAero)
agcls.AgTypeNameMap["RotorcraftAero"] = RotorcraftAero

class RotorcraftProp(IRotorcraftProp):
    """Class defining the propulsion options for a rotorcraft."""
    def __init__(self, sourceObject=None):
        IRotorcraftProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IRotorcraftProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftProp._get_property(self, attrname) is not None: found_prop = IRotorcraftProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftProp.")

agcls.AgClassCatalog.add_catalog_entry("{c0734618-529f-4ff2-9a14-3e4bd14cd601}", RotorcraftProp)
agcls.AgTypeNameMap["RotorcraftProp"] = RotorcraftProp

class AircraftAcceleration(IAircraftAcceleration, ICatalogItem):
    """Class defining the aircraft acceleration category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAcceleration.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAcceleration._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAcceleration._get_property(self, attrname) is not None: found_prop = IAircraftAcceleration._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAcceleration.")

agcls.AgClassCatalog.add_catalog_entry("{574f37f4-4889-4c85-baf5-8359e847acfa}", AircraftAcceleration)
agcls.AgTypeNameMap["AircraftAcceleration"] = AircraftAcceleration

class AircraftBasicAccelerationModel(IAircraftBasicAccelerationModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic acceleration performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicAccelerationModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicAccelerationModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicAccelerationModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicAccelerationModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicAccelerationModel.")

agcls.AgClassCatalog.add_catalog_entry("{e33469ad-d69d-48a2-9fc0-3fce97a2b98e}", AircraftBasicAccelerationModel)
agcls.AgTypeNameMap["AircraftBasicAccelerationModel"] = AircraftBasicAccelerationModel

class AircraftClimb(IAircraftClimb, ICatalogItem):
    """Class defining the aircraft climb category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftClimb.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftClimb._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftClimb._get_property(self, attrname) is not None: found_prop = IAircraftClimb._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftClimb.")

agcls.AgClassCatalog.add_catalog_entry("{2f0086b2-66d4-4df6-9711-ee2524ba1ed0}", AircraftClimb)
agcls.AgTypeNameMap["AircraftClimb"] = AircraftClimb

class AircraftCruise(IAircraftCruise, ICatalogItem):
    """Class defining the aircraft cruise category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftCruise.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftCruise._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftCruise._get_property(self, attrname) is not None: found_prop = IAircraftCruise._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftCruise.")

agcls.AgClassCatalog.add_catalog_entry("{efe9b334-9261-44bb-9834-8e7207ca6e05}", AircraftCruise)
agcls.AgTypeNameMap["AircraftCruise"] = AircraftCruise

class AircraftDescent(IAircraftDescent, ICatalogItem):
    """Class defining the aircraft descent category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftDescent.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftDescent._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftDescent._get_property(self, attrname) is not None: found_prop = IAircraftDescent._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftDescent.")

agcls.AgClassCatalog.add_catalog_entry("{d76fa881-77b3-486a-976c-8184e9cb91fd}", AircraftDescent)
agcls.AgTypeNameMap["AircraftDescent"] = AircraftDescent

class AircraftLanding(IAircraftLanding, ICatalogItem):
    """Class defining the aircraft landing category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftLanding.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftLanding._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftLanding._get_property(self, attrname) is not None: found_prop = IAircraftLanding._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftLanding.")

agcls.AgClassCatalog.add_catalog_entry("{8371480b-53cf-41ca-b749-41623f6d380a}", AircraftLanding)
agcls.AgTypeNameMap["AircraftLanding"] = AircraftLanding

class AircraftTakeoff(IAircraftTakeoff, ICatalogItem):
    """Class defining the aircraft takeoff category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftTakeoff.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftTakeoff._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftTakeoff._get_property(self, attrname) is not None: found_prop = IAircraftTakeoff._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftTakeoff.")

agcls.AgClassCatalog.add_catalog_entry("{aeef7451-7456-4d8c-aabf-147a466149cd}", AircraftTakeoff)
agcls.AgTypeNameMap["AircraftTakeoff"] = AircraftTakeoff

class AircraftBasicClimbModel(IAircraftBasicClimbModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic climb performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicClimbModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicClimbModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicClimbModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicClimbModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicClimbModel.")

agcls.AgClassCatalog.add_catalog_entry("{2950de29-1009-4c2a-8db5-378b41c6d48d}", AircraftBasicClimbModel)
agcls.AgTypeNameMap["AircraftBasicClimbModel"] = AircraftBasicClimbModel

class AircraftAdvClimbModel(IAircraftAdvClimbModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced climb performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvClimbModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAdvClimbModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvClimbModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvClimbModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvClimbModel.")

agcls.AgClassCatalog.add_catalog_entry("{C1C87503-2B8E-41BC-8BA9-02B7CC1E02C2}", AircraftAdvClimbModel)
agcls.AgTypeNameMap["AircraftAdvClimbModel"] = AircraftAdvClimbModel

class AircraftBasicCruiseModel(IAircraftBasicCruiseModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic cruise performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicCruiseModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicCruiseModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicCruiseModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicCruiseModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicCruiseModel.")

agcls.AgClassCatalog.add_catalog_entry("{c6090ace-e557-4bef-adf3-2e56387015a8}", AircraftBasicCruiseModel)
agcls.AgTypeNameMap["AircraftBasicCruiseModel"] = AircraftBasicCruiseModel

class AircraftAdvCruiseModel(IAircraftAdvCruiseModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced cruise performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvCruiseModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAdvCruiseModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvCruiseModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvCruiseModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvCruiseModel.")

agcls.AgClassCatalog.add_catalog_entry("{ead08117-2561-4bb7-a82b-86057f506090}", AircraftAdvCruiseModel)
agcls.AgTypeNameMap["AircraftAdvCruiseModel"] = AircraftAdvCruiseModel

class AircraftBasicDescentModel(IAircraftBasicDescentModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic descent performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicDescentModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicDescentModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicDescentModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicDescentModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicDescentModel.")

agcls.AgClassCatalog.add_catalog_entry("{30cb8d6f-afe5-4275-8479-4ce73b93a758}", AircraftBasicDescentModel)
agcls.AgTypeNameMap["AircraftBasicDescentModel"] = AircraftBasicDescentModel

class AircraftAdvDescentModel(IAircraftAdvDescentModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced descent performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvDescentModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAdvDescentModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvDescentModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvDescentModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvDescentModel.")

agcls.AgClassCatalog.add_catalog_entry("{40ee1832-9491-49e5-bd27-40d40fefb326}", AircraftAdvDescentModel)
agcls.AgTypeNameMap["AircraftAdvDescentModel"] = AircraftAdvDescentModel

class AircraftBasicTakeoffModel(IAircraftBasicTakeoffModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic takeoff performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicTakeoffModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicTakeoffModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicTakeoffModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicTakeoffModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicTakeoffModel.")

agcls.AgClassCatalog.add_catalog_entry("{3d9380c9-1aa0-4dcf-86bb-ded3b6b656e8}", AircraftBasicTakeoffModel)
agcls.AgTypeNameMap["AircraftBasicTakeoffModel"] = AircraftBasicTakeoffModel

class AircraftAdvTakeoffModel(IAircraftAdvTakeoffModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced takeoff performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvTakeoffModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAdvTakeoffModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvTakeoffModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvTakeoffModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvTakeoffModel.")

agcls.AgClassCatalog.add_catalog_entry("{fc3190a3-fbeb-46bb-8395-22405fbf5b80}", AircraftAdvTakeoffModel)
agcls.AgTypeNameMap["AircraftAdvTakeoffModel"] = AircraftAdvTakeoffModel

class AircraftBasicLandingModel(IAircraftBasicLandingModel, IPerformanceModel, ICatalogItem):
    """Class defining the basic landing performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicLandingModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicLandingModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicLandingModel._get_property(self, attrname) is not None: found_prop = IAircraftBasicLandingModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicLandingModel.")

agcls.AgClassCatalog.add_catalog_entry("{bd4e5100-7e2c-40ca-815a-02a618a4321d}", AircraftBasicLandingModel)
agcls.AgTypeNameMap["AircraftBasicLandingModel"] = AircraftBasicLandingModel

class AircraftAdvLandingModel(IAircraftAdvLandingModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced landing performance model for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvLandingModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAdvLandingModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvLandingModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvLandingModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvLandingModel.")

agcls.AgClassCatalog.add_catalog_entry("{fb7534d7-1f9b-4133-9712-66728255532b}", AircraftAdvLandingModel)
agcls.AgTypeNameMap["AircraftAdvLandingModel"] = AircraftAdvLandingModel

class AirportCategory(IAirportCategory):
    """Class defining the airport category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IAirportCategory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAirportCategory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAirportCategory._get_property(self, attrname) is not None: found_prop = IAirportCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AirportCategory.")

agcls.AgClassCatalog.add_catalog_entry("{d497aeeb-3c6a-44ad-9f1a-6af1504c9a99}", AirportCategory)
agcls.AgTypeNameMap["AirportCategory"] = AirportCategory

class ARINC424Airport(IARINC424Item, ICatalogAirport, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Airport."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogAirport.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IARINC424Item._private_init(self, intf)
        ICatalogAirport._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogAirport._get_property(self, attrname) is not None: found_prop = ICatalogAirport._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Airport.")

agcls.AgClassCatalog.add_catalog_entry("{1d942d58-5b4d-4784-8ec9-435008352423}", ARINC424Airport)
agcls.AgTypeNameMap["ARINC424Airport"] = ARINC424Airport

class ARINC424Runway(IARINC424Runway, IARINC424Item, ICatalogRunway, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Runway."""
    def __init__(self, sourceObject=None):
        IARINC424Runway.__init__(self, sourceObject)
        IARINC424Item.__init__(self, sourceObject)
        ICatalogRunway.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IARINC424Runway._private_init(self, intf)
        IARINC424Item._private_init(self, intf)
        ICatalogRunway._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Runway._get_property(self, attrname) is not None: found_prop = IARINC424Runway._get_property(self, attrname)
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogRunway._get_property(self, attrname) is not None: found_prop = ICatalogRunway._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Runway.")

agcls.AgClassCatalog.add_catalog_entry("{20c6f0ee-a2d5-4447-8d9a-3b67fe759266}", ARINC424Runway)
agcls.AgTypeNameMap["ARINC424Runway"] = ARINC424Runway

class DAFIFRunway(IDAFIFItem, ICatalogRunway, ICatalogWaypoint, ICatalogItem):
    """Class defining an DAFIF Runway."""
    def __init__(self, sourceObject=None):
        IDAFIFItem.__init__(self, sourceObject)
        ICatalogRunway.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IDAFIFItem._private_init(self, intf)
        ICatalogRunway._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFItem._get_property(self, attrname) is not None: found_prop = IDAFIFItem._get_property(self, attrname)
        if ICatalogRunway._get_property(self, attrname) is not None: found_prop = ICatalogRunway._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFRunway.")

agcls.AgClassCatalog.add_catalog_entry("{95867fe1-39fa-41cf-aa24-c6068c2cd86a}", DAFIFRunway)
agcls.AgTypeNameMap["DAFIFRunway"] = DAFIFRunway

class DAFIFHelipad(IDAFIFItem, ICatalogVTOLPoint, ICatalogWaypoint, ICatalogItem):
    """Class defining an DAFIF Helipad."""
    def __init__(self, sourceObject=None):
        IDAFIFItem.__init__(self, sourceObject)
        ICatalogVTOLPoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IDAFIFItem._private_init(self, intf)
        ICatalogVTOLPoint._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFItem._get_property(self, attrname) is not None: found_prop = IDAFIFItem._get_property(self, attrname)
        if ICatalogVTOLPoint._get_property(self, attrname) is not None: found_prop = ICatalogVTOLPoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFHelipad.")

agcls.AgClassCatalog.add_catalog_entry("{6973673c-7c51-48c2-8931-614aa2ab1da5}", DAFIFHelipad)
agcls.AgTypeNameMap["DAFIFHelipad"] = DAFIFHelipad

class DAFIFWaypoint(IDAFIFItem, ICatalogWaypoint, ICatalogItem):
    """Class defining an DAFIF Waypoint."""
    def __init__(self, sourceObject=None):
        IDAFIFItem.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IDAFIFItem._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFItem._get_property(self, attrname) is not None: found_prop = IDAFIFItem._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFWaypoint.")

agcls.AgClassCatalog.add_catalog_entry("{62195e59-a4fc-40f9-ab7d-4229c79c0e8f}", DAFIFWaypoint)
agcls.AgTypeNameMap["DAFIFWaypoint"] = DAFIFWaypoint

class RunwayCategory(IRunwayCategory):
    """Class defining the runway category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IRunwayCategory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IRunwayCategory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRunwayCategory._get_property(self, attrname) is not None: found_prop = IRunwayCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RunwayCategory.")

agcls.AgClassCatalog.add_catalog_entry("{69b1b664-f8d4-4be5-bfe9-8760573b2c72}", RunwayCategory)
agcls.AgTypeNameMap["RunwayCategory"] = RunwayCategory

class UserRunwaySource(IUserRunwaySource, ICatalogSource):
    """Class defining the user runways in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserRunwaySource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IUserRunwaySource._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserRunwaySource._get_property(self, attrname) is not None: found_prop = IUserRunwaySource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserRunwaySource.")

agcls.AgClassCatalog.add_catalog_entry("{7b8c1764-ce59-4e35-940a-24d99c2953ef}", UserRunwaySource)
agcls.AgTypeNameMap["UserRunwaySource"] = UserRunwaySource

class UserRunway(IUserRunway, ICatalogRunway, ICatalogItem, ICatalogWaypoint):
    """Class defining the user runway in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserRunway.__init__(self, sourceObject)
        ICatalogRunway.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IUserRunway._private_init(self, intf)
        ICatalogRunway._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserRunway._get_property(self, attrname) is not None: found_prop = IUserRunway._get_property(self, attrname)
        if ICatalogRunway._get_property(self, attrname) is not None: found_prop = ICatalogRunway._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserRunway.")

agcls.AgClassCatalog.add_catalog_entry("{693bdacd-4c8d-4efd-bb23-3f14c83d3b04}", UserRunway)
agcls.AgTypeNameMap["UserRunway"] = UserRunway

class AltitudeMSLOptions(IAltitudeMSLOptions):
    """Class defining the altitude MSL options in a procedure."""
    def __init__(self, sourceObject=None):
        IAltitudeMSLOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAltitudeMSLOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeMSLOptions._get_property(self, attrname) is not None: found_prop = IAltitudeMSLOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeMSLOptions.")

agcls.AgClassCatalog.add_catalog_entry("{c866a6dd-1070-4162-bff2-4339ab28f6b2}", AltitudeMSLOptions)
agcls.AgTypeNameMap["AltitudeMSLOptions"] = AltitudeMSLOptions

class AltitudeOptions(IAltitudeOptions):
    """Class defining the altitude options in a procedure."""
    def __init__(self, sourceObject=None):
        IAltitudeOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAltitudeOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeOptions._get_property(self, attrname) is not None: found_prop = IAltitudeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeOptions.")

agcls.AgClassCatalog.add_catalog_entry("{4d5d82b7-e342-4dcb-9af1-7cbfa909fc23}", AltitudeOptions)
agcls.AgTypeNameMap["AltitudeOptions"] = AltitudeOptions

class ArcAltitudeOptions(IArcAltitudeOptions):
    """Class defining the altitude options for an arc procedure."""
    def __init__(self, sourceObject=None):
        IArcAltitudeOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IArcAltitudeOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcAltitudeOptions._get_property(self, attrname) is not None: found_prop = IArcAltitudeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcAltitudeOptions.")

agcls.AgClassCatalog.add_catalog_entry("{1c4f7491-db5d-4e52-ba8e-e64ddfc687fe}", ArcAltitudeOptions)
agcls.AgTypeNameMap["ArcAltitudeOptions"] = ArcAltitudeOptions

class ArcAltitudeAndDelayOptions(IArcAltitudeAndDelayOptions):
    """Class defining the altitude and delay options for an arc procedure."""
    def __init__(self, sourceObject=None):
        IArcAltitudeAndDelayOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IArcAltitudeAndDelayOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcAltitudeAndDelayOptions._get_property(self, attrname) is not None: found_prop = IArcAltitudeAndDelayOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcAltitudeAndDelayOptions.")

agcls.AgClassCatalog.add_catalog_entry("{fdf04fa7-1588-4e15-a0ab-37b9586c878f}", ArcAltitudeAndDelayOptions)
agcls.AgTypeNameMap["ArcAltitudeAndDelayOptions"] = ArcAltitudeAndDelayOptions

class ArcOptions(IArcOptions):
    """Class defining the arc options for a procedure."""
    def __init__(self, sourceObject=None):
        IArcOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IArcOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcOptions._get_property(self, attrname) is not None: found_prop = IArcOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcOptions.")

agcls.AgClassCatalog.add_catalog_entry("{41af67f7-489f-452e-858a-bd8cc0bf782d}", ArcOptions)
agcls.AgTypeNameMap["ArcOptions"] = ArcOptions

class AltitudeMSLAndLevelOffOptions(IAltitudeMSLAndLevelOffOptions):
    """Class defining the altitude MSL and Level off options in a procedure."""
    def __init__(self, sourceObject=None):
        IAltitudeMSLAndLevelOffOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAltitudeMSLAndLevelOffOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAltitudeMSLAndLevelOffOptions._get_property(self, attrname) is not None: found_prop = IAltitudeMSLAndLevelOffOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AltitudeMSLAndLevelOffOptions.")

agcls.AgClassCatalog.add_catalog_entry("{0a38e533-78b2-402b-aed6-0ff04a62fcce}", AltitudeMSLAndLevelOffOptions)
agcls.AgTypeNameMap["AltitudeMSLAndLevelOffOptions"] = AltitudeMSLAndLevelOffOptions

class CruiseAirspeedOptions(ICruiseAirspeedOptions):
    """Class defining the cruise airspeed options in a procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICruiseAirspeedOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedOptions._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CruiseAirspeedOptions.")

agcls.AgClassCatalog.add_catalog_entry("{05251788-e43e-4d91-84ad-3d2bcfc2087a}", CruiseAirspeedOptions)
agcls.AgTypeNameMap["CruiseAirspeedOptions"] = CruiseAirspeedOptions

class CruiseAirspeedProfile(ICruiseAirspeedProfile):
    """Class defining the cruise profile options in a procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedProfile.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICruiseAirspeedProfile._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedProfile._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedProfile._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CruiseAirspeedProfile.")

agcls.AgClassCatalog.add_catalog_entry("{5afc99d6-3a02-45f9-b6f5-87690d8f9702}", CruiseAirspeedProfile)
agcls.AgTypeNameMap["CruiseAirspeedProfile"] = CruiseAirspeedProfile

class CruiseAirspeedAndProfileOptions(ICruiseAirspeedAndProfileOptions):
    """Class defining the cruise airspeed and profile options in a procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedAndProfileOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICruiseAirspeedAndProfileOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedAndProfileOptions._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedAndProfileOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CruiseAirspeedAndProfileOptions.")

agcls.AgClassCatalog.add_catalog_entry("{ee439155-cd45-45b5-b7f8-eae4f5e51b8e}", CruiseAirspeedAndProfileOptions)
agcls.AgTypeNameMap["CruiseAirspeedAndProfileOptions"] = CruiseAirspeedAndProfileOptions

class LandingCruiseAirspeedAndProfileOptions(ICruiseAirspeedAndProfileOptions):
    """Class defining the cruise airspeed and profile options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ICruiseAirspeedAndProfileOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICruiseAirspeedAndProfileOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICruiseAirspeedAndProfileOptions._get_property(self, attrname) is not None: found_prop = ICruiseAirspeedAndProfileOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingCruiseAirspeedAndProfileOptions.")

agcls.AgClassCatalog.add_catalog_entry("{cb47399c-3316-494f-959c-4f84b4c4936c}", LandingCruiseAirspeedAndProfileOptions)
agcls.AgTypeNameMap["LandingCruiseAirspeedAndProfileOptions"] = LandingCruiseAirspeedAndProfileOptions

class EnrouteOptions(IEnrouteOptions):
    """Class defining the enroute options in a procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IEnrouteOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteOptions._get_property(self, attrname) is not None: found_prop = IEnrouteOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EnrouteOptions.")

agcls.AgClassCatalog.add_catalog_entry("{cb708621-5036-4dbc-a900-a3b3a3fa7124}", EnrouteOptions)
agcls.AgTypeNameMap["EnrouteOptions"] = EnrouteOptions

class EnrouteAndDelayOptions(IEnrouteAndDelayOptions):
    """Class defining the enroute and delay options in a procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteAndDelayOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IEnrouteAndDelayOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteAndDelayOptions._get_property(self, attrname) is not None: found_prop = IEnrouteAndDelayOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EnrouteAndDelayOptions.")

agcls.AgClassCatalog.add_catalog_entry("{fc46b909-c927-4e2d-9d82-79c6980807d8}", EnrouteAndDelayOptions)
agcls.AgTypeNameMap["EnrouteAndDelayOptions"] = EnrouteAndDelayOptions

class LandingEnrouteOptions(IEnrouteAndDelayOptions):
    """Class defining the enroute options in a landing procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteAndDelayOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IEnrouteAndDelayOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteAndDelayOptions._get_property(self, attrname) is not None: found_prop = IEnrouteAndDelayOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingEnrouteOptions.")

agcls.AgClassCatalog.add_catalog_entry("{42ec119b-2661-4c68-b807-a5ed2a3af018}", LandingEnrouteOptions)
agcls.AgTypeNameMap["LandingEnrouteOptions"] = LandingEnrouteOptions

class EnrouteTurnDirectionOptions(IEnrouteTurnDirectionOptions):
    """Class defining the enroute turn direction options in a procedure."""
    def __init__(self, sourceObject=None):
        IEnrouteTurnDirectionOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IEnrouteTurnDirectionOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnrouteTurnDirectionOptions._get_property(self, attrname) is not None: found_prop = IEnrouteTurnDirectionOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EnrouteTurnDirectionOptions.")

agcls.AgClassCatalog.add_catalog_entry("{16e895f3-5a65-4caf-960e-691f904ca66c}", EnrouteTurnDirectionOptions)
agcls.AgTypeNameMap["EnrouteTurnDirectionOptions"] = EnrouteTurnDirectionOptions

class NavigationOptions(INavigationOptions):
    """Class defining the navigation options in a procedure."""
    def __init__(self, sourceObject=None):
        INavigationOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        INavigationOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if INavigationOptions._get_property(self, attrname) is not None: found_prop = INavigationOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in NavigationOptions.")

agcls.AgClassCatalog.add_catalog_entry("{ce90add8-b152-4984-b864-0f6e61e680d4}", NavigationOptions)
agcls.AgTypeNameMap["NavigationOptions"] = NavigationOptions

class VerticalPlaneOptions(IVerticalPlaneOptions):
    """Class defining the vertical plane options in a procedure."""
    def __init__(self, sourceObject=None):
        IVerticalPlaneOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVerticalPlaneOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVerticalPlaneOptions._get_property(self, attrname) is not None: found_prop = IVerticalPlaneOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VerticalPlaneOptions.")

agcls.AgClassCatalog.add_catalog_entry("{a902b408-0141-4280-b6cf-e1cb18dae4f6}", VerticalPlaneOptions)
agcls.AgTypeNameMap["VerticalPlaneOptions"] = VerticalPlaneOptions

class ArcVerticalPlaneOptions(IArcVerticalPlaneOptions):
    """Class defining the vertical plane options in a procedure."""
    def __init__(self, sourceObject=None):
        IArcVerticalPlaneOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IArcVerticalPlaneOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IArcVerticalPlaneOptions._get_property(self, attrname) is not None: found_prop = IArcVerticalPlaneOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ArcVerticalPlaneOptions.")

agcls.AgClassCatalog.add_catalog_entry("{eae3a835-4897-408f-91dc-59b9a2fbcb5c}", ArcVerticalPlaneOptions)
agcls.AgTypeNameMap["ArcVerticalPlaneOptions"] = ArcVerticalPlaneOptions

class VerticalPlaneAndFlightPathOptions(IVerticalPlaneAndFlightPathOptions):
    """Class defining the vertical plane options for an arc procedure."""
    def __init__(self, sourceObject=None):
        IVerticalPlaneAndFlightPathOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVerticalPlaneAndFlightPathOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVerticalPlaneAndFlightPathOptions._get_property(self, attrname) is not None: found_prop = IVerticalPlaneAndFlightPathOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VerticalPlaneAndFlightPathOptions.")

agcls.AgClassCatalog.add_catalog_entry("{7db61c31-a562-43b9-b3fa-76dc120bdd74}", VerticalPlaneAndFlightPathOptions)
agcls.AgTypeNameMap["VerticalPlaneAndFlightPathOptions"] = VerticalPlaneAndFlightPathOptions

class LandingVerticalPlaneOptions(IVerticalPlaneOptions):
    """Class defining the vertical plane options in a landing procedure."""
    def __init__(self, sourceObject=None):
        IVerticalPlaneOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVerticalPlaneOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVerticalPlaneOptions._get_property(self, attrname) is not None: found_prop = IVerticalPlaneOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingVerticalPlaneOptions.")

agcls.AgClassCatalog.add_catalog_entry("{846a07a8-230c-4036-a43b-c61ccd1bde69}", LandingVerticalPlaneOptions)
agcls.AgTypeNameMap["LandingVerticalPlaneOptions"] = LandingVerticalPlaneOptions

class RunwayHeadingOptions(IRunwayHeadingOptions):
    """Class defining the runway heading options in a takeoff or landing procedure."""
    def __init__(self, sourceObject=None):
        IRunwayHeadingOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IRunwayHeadingOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRunwayHeadingOptions._get_property(self, attrname) is not None: found_prop = IRunwayHeadingOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RunwayHeadingOptions.")

agcls.AgClassCatalog.add_catalog_entry("{167457be-4afe-477d-af6d-4e49413f4863}", RunwayHeadingOptions)
agcls.AgTypeNameMap["RunwayHeadingOptions"] = RunwayHeadingOptions

class LandingEnterDownwindPattern(ILandingEnterDownwindPattern):
    """Class defining the enter downwind pattern options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ILandingEnterDownwindPattern.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ILandingEnterDownwindPattern._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILandingEnterDownwindPattern._get_property(self, attrname) is not None: found_prop = ILandingEnterDownwindPattern._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingEnterDownwindPattern.")

agcls.AgClassCatalog.add_catalog_entry("{7fd1f000-c683-490f-9eea-a30062392898}", LandingEnterDownwindPattern)
agcls.AgTypeNameMap["LandingEnterDownwindPattern"] = LandingEnterDownwindPattern

class LandingInterceptGlideslope(ILandingInterceptGlideslope):
    """Class defining the intercept glideslope options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ILandingInterceptGlideslope.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ILandingInterceptGlideslope._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILandingInterceptGlideslope._get_property(self, attrname) is not None: found_prop = ILandingInterceptGlideslope._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingInterceptGlideslope.")

agcls.AgClassCatalog.add_catalog_entry("{f9735637-159f-4a79-9b1c-05d88d8437ac}", LandingInterceptGlideslope)
agcls.AgTypeNameMap["LandingInterceptGlideslope"] = LandingInterceptGlideslope

class LandingStandardInstrumentApproach(ILandingStandardInstrumentApproach):
    """Class defining the standard instrument approach options for a landing procedure."""
    def __init__(self, sourceObject=None):
        ILandingStandardInstrumentApproach.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ILandingStandardInstrumentApproach._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILandingStandardInstrumentApproach._get_property(self, attrname) is not None: found_prop = ILandingStandardInstrumentApproach._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LandingStandardInstrumentApproach.")

agcls.AgClassCatalog.add_catalog_entry("{6463a94a-8a78-432d-b155-d9d6d436c748}", LandingStandardInstrumentApproach)
agcls.AgTypeNameMap["LandingStandardInstrumentApproach"] = LandingStandardInstrumentApproach

class TakeoffDeparturePoint(ITakeoffDeparturePoint):
    """Class defining the departure point options for a takeoff procedure."""
    def __init__(self, sourceObject=None):
        ITakeoffDeparturePoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITakeoffDeparturePoint._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITakeoffDeparturePoint._get_property(self, attrname) is not None: found_prop = ITakeoffDeparturePoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TakeoffDeparturePoint.")

agcls.AgClassCatalog.add_catalog_entry("{59ebf9c6-d1de-47c0-bd56-b3d455c5c335}", TakeoffDeparturePoint)
agcls.AgTypeNameMap["TakeoffDeparturePoint"] = TakeoffDeparturePoint

class TakeoffLowTransition(ITakeoffLowTransition):
    """Class defining the low transition options for a takeoff procedure."""
    def __init__(self, sourceObject=None):
        ITakeoffLowTransition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITakeoffLowTransition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITakeoffLowTransition._get_property(self, attrname) is not None: found_prop = ITakeoffLowTransition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TakeoffLowTransition.")

agcls.AgClassCatalog.add_catalog_entry("{c8f9161b-97e3-4eab-b5e9-6a5aebaddaea}", TakeoffLowTransition)
agcls.AgTypeNameMap["TakeoffLowTransition"] = TakeoffLowTransition

class TakeoffNormal(ITakeoffNormal):
    """Class defining the normal options for a takeoff procedure."""
    def __init__(self, sourceObject=None):
        ITakeoffNormal.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITakeoffNormal._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITakeoffNormal._get_property(self, attrname) is not None: found_prop = ITakeoffNormal._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TakeoffNormal.")

agcls.AgClassCatalog.add_catalog_entry("{4951950f-59cb-4524-a2c6-5d8b6f35922d}", TakeoffNormal)
agcls.AgTypeNameMap["TakeoffNormal"] = TakeoffNormal

class LevelTurns(ILevelTurns):
    """Class defining the level turns options for an acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        ILevelTurns.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ILevelTurns._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ILevelTurns._get_property(self, attrname) is not None: found_prop = ILevelTurns._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LevelTurns.")

agcls.AgClassCatalog.add_catalog_entry("{8c955be7-5999-4332-bb80-4151d864d1d4}", LevelTurns)
agcls.AgTypeNameMap["LevelTurns"] = LevelTurns

class AttitudeTransitions(IAttitudeTransitions):
    """Class defining the attitude transition options for an acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAttitudeTransitions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAttitudeTransitions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeTransitions._get_property(self, attrname) is not None: found_prop = IAttitudeTransitions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeTransitions.")

agcls.AgClassCatalog.add_catalog_entry("{0fc49614-6fbf-4d80-94ae-f8a338d8e7ab}", AttitudeTransitions)
agcls.AgTypeNameMap["AttitudeTransitions"] = AttitudeTransitions

class ClimbAndDescentTransitions(IClimbAndDescentTransitions):
    """Class defining the climb and descent transition options for an Acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IClimbAndDescentTransitions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IClimbAndDescentTransitions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IClimbAndDescentTransitions._get_property(self, attrname) is not None: found_prop = IClimbAndDescentTransitions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ClimbAndDescentTransitions.")

agcls.AgClassCatalog.add_catalog_entry("{c8d87c4a-ee0c-4a96-b7f4-9dbe84a7b2aa}", ClimbAndDescentTransitions)
agcls.AgTypeNameMap["ClimbAndDescentTransitions"] = ClimbAndDescentTransitions

class AeroPropManeuverModeHelper(IAeroPropManeuverModeHelper):
    """Class defining the The calculation mode for the Aero/Prop maneuver mode helper. Helper for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAeroPropManeuverModeHelper.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAeroPropManeuverModeHelper._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAeroPropManeuverModeHelper._get_property(self, attrname) is not None: found_prop = IAeroPropManeuverModeHelper._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AeroPropManeuverModeHelper.")

agcls.AgClassCatalog.add_catalog_entry("{854b3e50-7d20-4d15-a58d-b1f36dac5c77}", AeroPropManeuverModeHelper)
agcls.AgTypeNameMap["AeroPropManeuverModeHelper"] = AeroPropManeuverModeHelper

class AircraftAdvAccelerationModel(IAircraftAdvAccelerationModel, IPerformanceModel, ICatalogItem):
    """Class defining the advanced acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAdvAccelerationModel.__init__(self, sourceObject)
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAdvAccelerationModel._private_init(self, intf)
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAdvAccelerationModel._get_property(self, attrname) is not None: found_prop = IAircraftAdvAccelerationModel._get_property(self, attrname)
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAdvAccelerationModel.")

agcls.AgClassCatalog.add_catalog_entry("{e55e8521-3091-4a5d-afe0-57f7e7ee698e}", AircraftAdvAccelerationModel)
agcls.AgTypeNameMap["AircraftAdvAccelerationModel"] = AircraftAdvAccelerationModel

class AircraftAccelerationMode(IAircraftAccelerationMode):
    """Class defining the acceleration mode options for an advanced acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAccelerationMode.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAccelerationMode._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAccelerationMode._get_property(self, attrname) is not None: found_prop = IAircraftAccelerationMode._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAccelerationMode.")

agcls.AgClassCatalog.add_catalog_entry("{551999ee-51a5-4863-a244-0030899884ee}", AircraftAccelerationMode)
agcls.AgTypeNameMap["AircraftAccelerationMode"] = AircraftAccelerationMode

class AircraftSimpleAero(IAircraftSimpleAero):
    """Class defining the simple aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftSimpleAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftSimpleAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftSimpleAero._get_property(self, attrname) is not None: found_prop = IAircraftSimpleAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftSimpleAero.")

agcls.AgClassCatalog.add_catalog_entry("{54bb15cb-5b0e-44af-9605-0b646efebaeb}", AircraftSimpleAero)
agcls.AgTypeNameMap["AircraftSimpleAero"] = AircraftSimpleAero

class AircraftExternalAero(IAircraftExternalAero):
    """Class defining the external file aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftExternalAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftExternalAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftExternalAero._get_property(self, attrname) is not None: found_prop = IAircraftExternalAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftExternalAero.")

agcls.AgClassCatalog.add_catalog_entry("{f79db172-f8c6-4dc9-84c7-dfff374156bc}", AircraftExternalAero)
agcls.AgTypeNameMap["AircraftExternalAero"] = AircraftExternalAero

class AircraftAero(IAircraftAero):
    """Class defining the aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftAero._get_property(self, attrname) is not None: found_prop = IAircraftAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftAero.")

agcls.AgClassCatalog.add_catalog_entry("{6005f6fd-9923-4688-a60f-6179d5cec1f3}", AircraftAero)
agcls.AgTypeNameMap["AircraftAero"] = AircraftAero

class AircraftBasicFixedWingAero(IAircraftBasicFixedWingAero):
    """Class defining the basic fixed wing aerodynamic options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicFixedWingAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicFixedWingAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicFixedWingAero._get_property(self, attrname) is not None: found_prop = IAircraftBasicFixedWingAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicFixedWingAero.")

agcls.AgClassCatalog.add_catalog_entry("{3e05b32c-25ac-400d-ae1c-e1628b2e6ebb}", AircraftBasicFixedWingAero)
agcls.AgTypeNameMap["AircraftBasicFixedWingAero"] = AircraftBasicFixedWingAero

class AircraftProp(IAircraftProp):
    """Class defining the propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftProp._get_property(self, attrname) is not None: found_prop = IAircraftProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftProp.")

agcls.AgClassCatalog.add_catalog_entry("{8773e358-a871-4d66-b7b2-25a473f22bdb}", AircraftProp)
agcls.AgTypeNameMap["AircraftProp"] = AircraftProp

class AircraftSimpleProp(IAircraftSimpleProp):
    """Class defining the basic fixed wing propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftSimpleProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftSimpleProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftSimpleProp._get_property(self, attrname) is not None: found_prop = IAircraftSimpleProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftSimpleProp.")

agcls.AgClassCatalog.add_catalog_entry("{359cf55e-59da-4f34-93fe-010180c2a415}", AircraftSimpleProp)
agcls.AgTypeNameMap["AircraftSimpleProp"] = AircraftSimpleProp

class AircraftExternalProp(IAircraftExternalProp):
    """Class defining the external propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftExternalProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftExternalProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftExternalProp._get_property(self, attrname) is not None: found_prop = IAircraftExternalProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftExternalProp.")

agcls.AgClassCatalog.add_catalog_entry("{9a59b51f-6133-446f-9f7c-04bfa1e8c69a}", AircraftExternalProp)
agcls.AgTypeNameMap["AircraftExternalProp"] = AircraftExternalProp

class AircraftBasicFixedWingProp(IAircraftBasicFixedWingProp):
    """Class defining the basic fixed wing propulsion options for a basic acceleration performance model of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftBasicFixedWingProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftBasicFixedWingProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftBasicFixedWingProp._get_property(self, attrname) is not None: found_prop = IAircraftBasicFixedWingProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftBasicFixedWingProp.")

agcls.AgClassCatalog.add_catalog_entry("{b4158163-51d7-4eb6-956a-14740ae523b3}", AircraftBasicFixedWingProp)
agcls.AgTypeNameMap["AircraftBasicFixedWingProp"] = AircraftBasicFixedWingProp

class ARINC424Source(IARINC424Source, ICatalogSource):
    """Class defining an ARINC424 source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IARINC424Source.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IARINC424Source._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Source._get_property(self, attrname) is not None: found_prop = IARINC424Source._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Source.")

agcls.AgClassCatalog.add_catalog_entry("{e4f5b464-d93a-4541-8a1e-737ece8b120c}", ARINC424Source)
agcls.AgTypeNameMap["ARINC424Source"] = ARINC424Source

class DAFIFSource(IDAFIFSource, ICatalogSource):
    """Class defining an DAFIF source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IDAFIFSource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IDAFIFSource._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDAFIFSource._get_property(self, attrname) is not None: found_prop = IDAFIFSource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DAFIFSource.")

agcls.AgClassCatalog.add_catalog_entry("{4325ae72-1155-40cd-a708-0cf4da0b653c}", DAFIFSource)
agcls.AgTypeNameMap["DAFIFSource"] = DAFIFSource

class BasicFixedWingFwdFlightLiftHelper(IBasicFixedWingLiftHelper):
    """Class defining the Lift Coefficient Helper for Forward Flight in the Basic Fixed Wing Aerodynamics interface for the Basic Acceleration Model of an aircraft."""
    def __init__(self, sourceObject=None):
        IBasicFixedWingLiftHelper.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicFixedWingLiftHelper._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicFixedWingLiftHelper._get_property(self, attrname) is not None: found_prop = IBasicFixedWingLiftHelper._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicFixedWingFwdFlightLiftHelper.")

agcls.AgClassCatalog.add_catalog_entry("{507fa67b-cebe-431c-a109-fb6d77b6b026}", BasicFixedWingFwdFlightLiftHelper)
agcls.AgTypeNameMap["BasicFixedWingFwdFlightLiftHelper"] = BasicFixedWingFwdFlightLiftHelper

class BasicManeuverStrategyStraightAhead(IBasicManeuverStrategyStraightAhead, IBasicManeuverStrategy):
    """Class defining the Straight Ahead strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyStraightAhead.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyStraightAhead._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyStraightAhead._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyStraightAhead._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyStraightAhead.")

agcls.AgClassCatalog.add_catalog_entry("{beae703c-6b09-4ff9-a7d0-3e6513848c84}", BasicManeuverStrategyStraightAhead)
agcls.AgTypeNameMap["BasicManeuverStrategyStraightAhead"] = BasicManeuverStrategyStraightAhead

class BasicManeuverStrategyCruiseProfile(IBasicManeuverStrategyCruiseProfile, IBasicManeuverStrategy):
    """Class defining the Cruise profile strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyCruiseProfile.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyCruiseProfile._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyCruiseProfile._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyCruiseProfile._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyCruiseProfile.")

agcls.AgClassCatalog.add_catalog_entry("{00a0e796-7322-478b-9ad6-b8f1d6ef81e1}", BasicManeuverStrategyCruiseProfile)
agcls.AgTypeNameMap["BasicManeuverStrategyCruiseProfile"] = BasicManeuverStrategyCruiseProfile

class BasicManeuverStrategyGlideProfile(IBasicManeuverStrategyGlideProfile, IBasicManeuverStrategy):
    """Class defining the Glide profile strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyGlideProfile.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyGlideProfile._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyGlideProfile._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyGlideProfile._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyGlideProfile.")

agcls.AgClassCatalog.add_catalog_entry("{0e60df52-4bb8-40a1-90a8-ecf7a57bca0a}", BasicManeuverStrategyGlideProfile)
agcls.AgTypeNameMap["BasicManeuverStrategyGlideProfile"] = BasicManeuverStrategyGlideProfile

class AircraftModels(IAircraftModels, ICatalogSource):
    """Class defining the User Aircraft Models in the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        IAircraftModels.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftModels._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftModels._get_property(self, attrname) is not None: found_prop = IAircraftModels._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftModels.")

agcls.AgClassCatalog.add_catalog_entry("{47dd19b1-0ce7-458b-bdb2-2ec0d337231b}", AircraftModels)
agcls.AgTypeNameMap["AircraftModels"] = AircraftModels

class MissileModels(IMissileModels, ICatalogSource):
    """Class defining the User Missile Models in the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        IMissileModels.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileModels._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileModels._get_property(self, attrname) is not None: found_prop = IMissileModels._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileModels.")

agcls.AgClassCatalog.add_catalog_entry("{038a565a-efe0-4bc0-8a22-eb1c2d88d87a}", MissileModels)
agcls.AgTypeNameMap["MissileModels"] = MissileModels

class RotorcraftModels(IRotorcraftModels, ICatalogSource):
    """Class defining the User Rotorcraft Models in the Aviator Catalog."""
    def __init__(self, sourceObject=None):
        IRotorcraftModels.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IRotorcraftModels._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRotorcraftModels._get_property(self, attrname) is not None: found_prop = IRotorcraftModels._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RotorcraftModels.")

agcls.AgClassCatalog.add_catalog_entry("{f85cc088-0dc1-4436-bc2e-a985bfd4dfb4}", RotorcraftModels)
agcls.AgTypeNameMap["RotorcraftModels"] = RotorcraftModels

class Configuration(IConfiguration):
    """Class defining the aircraft configuration for an Aviator mission."""
    def __init__(self, sourceObject=None):
        IConfiguration.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IConfiguration._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConfiguration._get_property(self, attrname) is not None: found_prop = IConfiguration._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Configuration.")

agcls.AgClassCatalog.add_catalog_entry("{823e96a0-a485-4c5b-9abc-7d6658432f99}", Configuration)
agcls.AgTypeNameMap["Configuration"] = Configuration

class FuelTankInternal(IFuelTankInternal, IStation):
    """Class defining an internal fuel tank for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IFuelTankInternal.__init__(self, sourceObject)
        IStation.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IFuelTankInternal._private_init(self, intf)
        IStation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelTankInternal._get_property(self, attrname) is not None: found_prop = IFuelTankInternal._get_property(self, attrname)
        if IStation._get_property(self, attrname) is not None: found_prop = IStation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelTankInternal.")

agcls.AgClassCatalog.add_catalog_entry("{64fd434a-e313-4f15-a236-f25f10461444}", FuelTankInternal)
agcls.AgTypeNameMap["FuelTankInternal"] = FuelTankInternal

class FuelTankExternal(IFuelTankExternal):
    """Class defining an external fuel tank for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IFuelTankExternal.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IFuelTankExternal._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelTankExternal._get_property(self, attrname) is not None: found_prop = IFuelTankExternal._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelTankExternal.")

agcls.AgClassCatalog.add_catalog_entry("{8037f407-784e-469e-b92d-2a0fff148e86}", FuelTankExternal)
agcls.AgTypeNameMap["FuelTankExternal"] = FuelTankExternal

class PayloadStation(IPayloadStation, IStation):
    """Class defining a payload station for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IPayloadStation.__init__(self, sourceObject)
        IStation.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IPayloadStation._private_init(self, intf)
        IStation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPayloadStation._get_property(self, attrname) is not None: found_prop = IPayloadStation._get_property(self, attrname)
        if IStation._get_property(self, attrname) is not None: found_prop = IStation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PayloadStation.")

agcls.AgClassCatalog.add_catalog_entry("{13423a45-1732-438b-a96a-502bc40f0827}", PayloadStation)
agcls.AgTypeNameMap["PayloadStation"] = PayloadStation

class StationCollection(IStationCollection):
    """Class defining a collection of payload stations for an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IStationCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IStationCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStationCollection._get_property(self, attrname) is not None: found_prop = IStationCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StationCollection.")

agcls.AgClassCatalog.add_catalog_entry("{e81ed53f-b172-46c4-85b1-e80fe06e211a}", StationCollection)
agcls.AgTypeNameMap["StationCollection"] = StationCollection

class WindModel(IWindModel):
    """Class defining the wind model for a mission, scenario, or procedure."""
    def __init__(self, sourceObject=None):
        IWindModel.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IWindModel._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWindModel._get_property(self, attrname) is not None: found_prop = IWindModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WindModel.")

agcls.AgClassCatalog.add_catalog_entry("{8c0e170c-1818-4bd9-8bbf-e578065ea2a8}", WindModel)
agcls.AgTypeNameMap["WindModel"] = WindModel

class WindModelConstant(IWindModelConstant):
    """Class defining a constant bearing/speed wind model for a mission."""
    def __init__(self, sourceObject=None):
        IWindModelConstant.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IWindModelConstant._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWindModelConstant._get_property(self, attrname) is not None: found_prop = IWindModelConstant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WindModelConstant.")

agcls.AgClassCatalog.add_catalog_entry("{079a1206-8ed3-423d-8f1d-855551f0435c}", WindModelConstant)
agcls.AgTypeNameMap["WindModelConstant"] = WindModelConstant

class WindModelADDS(IWindModelADDS):
    """Class defining a wind model using the NOAA ADDS service for a mission."""
    def __init__(self, sourceObject=None):
        IWindModelADDS.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IWindModelADDS._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWindModelADDS._get_property(self, attrname) is not None: found_prop = IWindModelADDS._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WindModelADDS.")

agcls.AgClassCatalog.add_catalog_entry("{1e2024ff-d594-49bf-8ea7-a110213078ba}", WindModelADDS)
agcls.AgTypeNameMap["WindModelADDS"] = WindModelADDS

class ADDSMessage(IADDSMessage):
    """Class defining a message from the NOAA ADDS service."""
    def __init__(self, sourceObject=None):
        IADDSMessage.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IADDSMessage._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IADDSMessage._get_property(self, attrname) is not None: found_prop = IADDSMessage._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ADDSMessage.")

agcls.AgClassCatalog.add_catalog_entry("{22e44fa2-cfe7-456a-900c-0916f1d88cec}", ADDSMessage)
agcls.AgTypeNameMap["ADDSMessage"] = ADDSMessage

class ADDSMessageCollection(IADDSMessageCollection):
    """Class defining a collection of messages from the NOAA ADDS service."""
    def __init__(self, sourceObject=None):
        IADDSMessageCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IADDSMessageCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IADDSMessageCollection._get_property(self, attrname) is not None: found_prop = IADDSMessageCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ADDSMessageCollection.")

agcls.AgClassCatalog.add_catalog_entry("{f5e634eb-3433-4336-9c0d-73b3d0e9674a}", ADDSMessageCollection)
agcls.AgTypeNameMap["ADDSMessageCollection"] = ADDSMessageCollection

class Procedure(IProcedure, IConnect):
    """Class defining an unknown procedure type."""
    def __init__(self, sourceObject=None):
        IProcedure.__init__(self, sourceObject)
        IConnect.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedure._private_init(self, intf)
        IConnect._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if IConnect._get_property(self, attrname) is not None: found_prop = IConnect._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Procedure.")

agcls.AgClassCatalog.add_catalog_entry("{c744fb3a-e51d-4b87-8006-ed9dd4d48495}", Procedure)
agcls.AgTypeNameMap["Procedure"] = Procedure

class AtmosphereModel(IAtmosphereModel):
    """Class defining the atmosphere model for a mission, scenario, or procedure."""
    def __init__(self, sourceObject=None):
        IAtmosphereModel.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAtmosphereModel._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAtmosphereModel._get_property(self, attrname) is not None: found_prop = IAtmosphereModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AtmosphereModel.")

agcls.AgClassCatalog.add_catalog_entry("{43ce46bb-52dc-42d7-818a-5bd4d13dd15d}", AtmosphereModel)
agcls.AgTypeNameMap["AtmosphereModel"] = AtmosphereModel

class AtmosphereModelBasic(IAtmosphereModelBasic):
    """Class defining the basic atmosphere model."""
    def __init__(self, sourceObject=None):
        IAtmosphereModelBasic.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAtmosphereModelBasic._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAtmosphereModelBasic._get_property(self, attrname) is not None: found_prop = IAtmosphereModelBasic._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AtmosphereModelBasic.")

agcls.AgClassCatalog.add_catalog_entry("{9c9a3976-e898-4e98-b2ce-26d045ab4d46}", AtmosphereModelBasic)
agcls.AgTypeNameMap["AtmosphereModelBasic"] = AtmosphereModelBasic

class BasicManeuverStrategySimpleTurn(IBasicManeuverStrategySimpleTurn, IBasicManeuverStrategy):
    """Class defining the simple turn strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategySimpleTurn.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategySimpleTurn._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategySimpleTurn._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategySimpleTurn._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategySimpleTurn.")

agcls.AgClassCatalog.add_catalog_entry("{5a0fd768-cf78-47cb-8a85-ccb1fbe68cee}", BasicManeuverStrategySimpleTurn)
agcls.AgTypeNameMap["BasicManeuverStrategySimpleTurn"] = BasicManeuverStrategySimpleTurn

class BasicManeuverStrategyAileronRoll(IBasicManeuverStrategyAileronRoll, IBasicManeuverStrategy):
    """Class defining the aileron roll strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyAileronRoll.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyAileronRoll._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyAileronRoll._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyAileronRoll._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyAileronRoll.")

agcls.AgClassCatalog.add_catalog_entry("{b8979539-00bf-46af-a412-9a16ebb57ac7}", BasicManeuverStrategyAileronRoll)
agcls.AgTypeNameMap["BasicManeuverStrategyAileronRoll"] = BasicManeuverStrategyAileronRoll

class BasicManeuverStrategyFlyAOA(IBasicManeuverStrategyFlyAOA, IBasicManeuverStrategy):
    """Class defining the fly AOA strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyFlyAOA.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyFlyAOA._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyFlyAOA._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyFlyAOA._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyFlyAOA.")

agcls.AgClassCatalog.add_catalog_entry("{f3c56de2-f58f-4292-a05b-d6e8f2756a55}", BasicManeuverStrategyFlyAOA)
agcls.AgTypeNameMap["BasicManeuverStrategyFlyAOA"] = BasicManeuverStrategyFlyAOA

class BasicManeuverStrategyPull(IBasicManeuverStrategyPull, IBasicManeuverStrategy):
    """Class defining the pull strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyPull.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyPull._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyPull._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyPull._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyPull.")

agcls.AgClassCatalog.add_catalog_entry("{7f14c043-4c1d-46f2-a3fd-112b17a27e82}", BasicManeuverStrategyPull)
agcls.AgTypeNameMap["BasicManeuverStrategyPull"] = BasicManeuverStrategyPull

class BasicManeuverStrategyRollingPull(IBasicManeuverStrategyRollingPull, IBasicManeuverStrategy):
    """Class defining the rolling pull strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRollingPull.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyRollingPull._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRollingPull._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRollingPull._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRollingPull.")

agcls.AgClassCatalog.add_catalog_entry("{abb3d02b-ae1f-482e-a903-cdc6bcb7bde1}", BasicManeuverStrategyRollingPull)
agcls.AgTypeNameMap["BasicManeuverStrategyRollingPull"] = BasicManeuverStrategyRollingPull

class BasicManeuverStrategySmoothAccel(IBasicManeuverStrategySmoothAccel, IBasicManeuverStrategy):
    """Class defining the smooth accel strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategySmoothAccel.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategySmoothAccel._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategySmoothAccel._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategySmoothAccel._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategySmoothAccel.")

agcls.AgClassCatalog.add_catalog_entry("{e5277844-1d1b-49ae-9a08-553e55823581}", BasicManeuverStrategySmoothAccel)
agcls.AgTypeNameMap["BasicManeuverStrategySmoothAccel"] = BasicManeuverStrategySmoothAccel

class BasicManeuverStrategySmoothTurn(IBasicManeuverStrategySmoothTurn, IBasicManeuverStrategy):
    """Class defining the smooth turn strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategySmoothTurn.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategySmoothTurn._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategySmoothTurn._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategySmoothTurn._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategySmoothTurn.")

agcls.AgClassCatalog.add_catalog_entry("{d55e7e13-72e2-4046-b7c7-a0702d951b03}", BasicManeuverStrategySmoothTurn)
agcls.AgTypeNameMap["BasicManeuverStrategySmoothTurn"] = BasicManeuverStrategySmoothTurn

class BasicManeuverAirspeedOptions(IBasicManeuverAirspeedOptions):
    """Class defining the airspeed options for basic maneuver strategies."""
    def __init__(self, sourceObject=None):
        IBasicManeuverAirspeedOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverAirspeedOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverAirspeedOptions._get_property(self, attrname) is not None: found_prop = IBasicManeuverAirspeedOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverAirspeedOptions.")

agcls.AgClassCatalog.add_catalog_entry("{0eb776dc-78a8-42db-b8c0-8c62611d7e44}", BasicManeuverAirspeedOptions)
agcls.AgTypeNameMap["BasicManeuverAirspeedOptions"] = BasicManeuverAirspeedOptions

class PropulsionThrust(IPropulsionThrust):
    """Class defining the the thrust propulsion used in basic maneuver procedures."""
    def __init__(self, sourceObject=None):
        IPropulsionThrust.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IPropulsionThrust._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPropulsionThrust._get_property(self, attrname) is not None: found_prop = IPropulsionThrust._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PropulsionThrust.")

agcls.AgClassCatalog.add_catalog_entry("{50e5309a-e9f9-4dc0-8296-b3bf43a9b1a5}", PropulsionThrust)
agcls.AgTypeNameMap["PropulsionThrust"] = PropulsionThrust

class BasicManeuverStrategyAutopilotNav(IBasicManeuverStrategyAutopilotNav, IBasicManeuverStrategy):
    """Class defining the autopilot - horizontal plane strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyAutopilotNav.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyAutopilotNav._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyAutopilotNav._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyAutopilotNav._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyAutopilotNav.")

agcls.AgClassCatalog.add_catalog_entry("{129c0672-05c6-41ae-ae30-3aa82d83783a}", BasicManeuverStrategyAutopilotNav)
agcls.AgTypeNameMap["BasicManeuverStrategyAutopilotNav"] = BasicManeuverStrategyAutopilotNav

class BasicManeuverStrategyAutopilotProf(IBasicManeuverStrategyAutopilotProf, IBasicManeuverStrategy):
    """Class defining the autopiloc - vertical plane strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyAutopilotProf.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyAutopilotProf._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyAutopilotProf._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyAutopilotProf._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyAutopilotProf.")

agcls.AgClassCatalog.add_catalog_entry("{a86d3f81-6bd4-4f3d-8747-c1b31d7b06e9}", BasicManeuverStrategyAutopilotProf)
agcls.AgTypeNameMap["BasicManeuverStrategyAutopilotProf"] = BasicManeuverStrategyAutopilotProf

class BasicManeuverStrategyBarrelRoll(IBasicManeuverStrategyBarrelRoll, IBasicManeuverStrategy):
    """Class defining the barrel roll strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyBarrelRoll.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyBarrelRoll._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyBarrelRoll._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyBarrelRoll._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyBarrelRoll.")

agcls.AgClassCatalog.add_catalog_entry("{3ee92041-1fb9-4a53-ad71-9045d738fe7d}", BasicManeuverStrategyBarrelRoll)
agcls.AgTypeNameMap["BasicManeuverStrategyBarrelRoll"] = BasicManeuverStrategyBarrelRoll

class BasicManeuverStrategyLoop(IBasicManeuverStrategyLoop, IBasicManeuverStrategy):
    """Class defining the loop strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyLoop.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyLoop._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyLoop._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyLoop._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyLoop.")

agcls.AgClassCatalog.add_catalog_entry("{77780df4-1f0f-411c-a4eb-edfeb5d44d82}", BasicManeuverStrategyLoop)
agcls.AgTypeNameMap["BasicManeuverStrategyLoop"] = BasicManeuverStrategyLoop

class BasicManeuverStrategyLTAHover(IBasicManeuverStrategyLTAHover, IBasicManeuverStrategy):
    """Class defining the lighter than air hover strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyLTAHover.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyLTAHover._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyLTAHover._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyLTAHover._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyLTAHover.")

agcls.AgClassCatalog.add_catalog_entry("{5dfffe06-20ce-4e0e-903e-90ca3e60c273}", BasicManeuverStrategyLTAHover)
agcls.AgTypeNameMap["BasicManeuverStrategyLTAHover"] = BasicManeuverStrategyLTAHover

class BasicManeuverStrategyIntercept(IBasicManeuverStrategyIntercept, IBasicManeuverStrategy):
    """Class defining the Intercept strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyIntercept.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyIntercept._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyIntercept._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyIntercept._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyIntercept.")

agcls.AgClassCatalog.add_catalog_entry("{015abd40-d52a-479b-b9ef-92aadb650a42}", BasicManeuverStrategyIntercept)
agcls.AgTypeNameMap["BasicManeuverStrategyIntercept"] = BasicManeuverStrategyIntercept

class BasicManeuverStrategyRelativeBearing(IBasicManeuverStrategyRelativeBearing, IBasicManeuverStrategy):
    """Class defining the Relative Bearing strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelativeBearing.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyRelativeBearing._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelativeBearing._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelativeBearing._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelativeBearing.")

agcls.AgClassCatalog.add_catalog_entry("{e2ffd4c9-cab5-4e7d-972f-d7b0f6983a04}", BasicManeuverStrategyRelativeBearing)
agcls.AgTypeNameMap["BasicManeuverStrategyRelativeBearing"] = BasicManeuverStrategyRelativeBearing

class BasicManeuverStrategyRelativeCourse(IBasicManeuverStrategyRelativeCourse, IBasicManeuverStrategy):
    """Class defining the Relative Course strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelativeCourse.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyRelativeCourse._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelativeCourse._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelativeCourse._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelativeCourse.")

agcls.AgClassCatalog.add_catalog_entry("{b38ed3c1-d896-476f-8b6d-c5b6d72b4590}", BasicManeuverStrategyRelativeCourse)
agcls.AgTypeNameMap["BasicManeuverStrategyRelativeCourse"] = BasicManeuverStrategyRelativeCourse

class BasicManeuverStrategyRendezvous(IBasicManeuverStrategyRendezvous, IBasicManeuverStrategy):
    """Class defining the Rendezvous/Formation strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRendezvous.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyRendezvous._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRendezvous._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRendezvous._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRendezvous.")

agcls.AgClassCatalog.add_catalog_entry("{bb5fdd2b-8e95-40e1-8048-86547b0daff0}", BasicManeuverStrategyRendezvous)
agcls.AgTypeNameMap["BasicManeuverStrategyRendezvous"] = BasicManeuverStrategyRendezvous

class BasicManeuverStrategyStationkeeping(IBasicManeuverStrategyStationkeeping, IBasicManeuverStrategy):
    """Class defining the Stationkeeping strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyStationkeeping.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyStationkeeping._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyStationkeeping._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyStationkeeping._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyStationkeeping.")

agcls.AgClassCatalog.add_catalog_entry("{949ee147-7b1f-4f22-b721-aea0725b9116}", BasicManeuverStrategyStationkeeping)
agcls.AgTypeNameMap["BasicManeuverStrategyStationkeeping"] = BasicManeuverStrategyStationkeeping

class BasicManeuverStrategyRelativeFPA(IBasicManeuverStrategyRelativeFPA, IBasicManeuverStrategy):
    """Class defining the Relative Flight Path Angle strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelativeFPA.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyRelativeFPA._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelativeFPA._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelativeFPA._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelativeFPA.")

agcls.AgClassCatalog.add_catalog_entry("{dd290505-55b9-48a9-a800-451bcc816dd6}", BasicManeuverStrategyRelativeFPA)
agcls.AgTypeNameMap["BasicManeuverStrategyRelativeFPA"] = BasicManeuverStrategyRelativeFPA

class BasicManeuverStrategyRelSpeedAltitude(IBasicManeuverStrategyRelSpeedAltitude, IBasicManeuverStrategy):
    """Class defining the Relative Speed/Altitude strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyRelSpeedAltitude.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyRelSpeedAltitude._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyRelSpeedAltitude._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyRelSpeedAltitude._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyRelSpeedAltitude.")

agcls.AgClassCatalog.add_catalog_entry("{72d18bdd-ad36-43ed-a8d6-6c25a7d88078}", BasicManeuverStrategyRelSpeedAltitude)
agcls.AgTypeNameMap["BasicManeuverStrategyRelSpeedAltitude"] = BasicManeuverStrategyRelSpeedAltitude

class BasicManeuverStrategyBezier(IBasicManeuverStrategyBezier, IBasicManeuverStrategy):
    """Class defining the Bezier strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyBezier.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyBezier._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyBezier._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyBezier._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyBezier.")

agcls.AgClassCatalog.add_catalog_entry("{84f1131f-4e28-4879-902c-bf5c2cbfff5b}", BasicManeuverStrategyBezier)
agcls.AgTypeNameMap["BasicManeuverStrategyBezier"] = BasicManeuverStrategyBezier

class BasicManeuverStrategyPushPull(IBasicManeuverStrategyPushPull, IBasicManeuverStrategy):
    """Class defining the Push/Pull strategy for a basic maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyPushPull.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyPushPull._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyPushPull._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyPushPull._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyPushPull.")

agcls.AgClassCatalog.add_catalog_entry("{6184d781-4842-4e83-8211-fc4baab53395}", BasicManeuverStrategyPushPull)
agcls.AgTypeNameMap["BasicManeuverStrategyPushPull"] = BasicManeuverStrategyPushPull

class ProcedureHoldingCircular(IProcedureHoldingCircular, IProcedure):
    """Class defining a holding circular procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoldingCircular.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureHoldingCircular._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoldingCircular._get_property(self, attrname) is not None: found_prop = IProcedureHoldingCircular._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoldingCircular.")

agcls.AgClassCatalog.add_catalog_entry("{dec98be5-d1d2-4a97-bbcd-5a1f7ca5f158}", ProcedureHoldingCircular)
agcls.AgTypeNameMap["ProcedureHoldingCircular"] = ProcedureHoldingCircular

class ProcedureHoldingFigure8(IProcedureHoldingFigure8, IProcedure):
    """Class defining a holding figure 8 procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoldingFigure8.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureHoldingFigure8._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoldingFigure8._get_property(self, attrname) is not None: found_prop = IProcedureHoldingFigure8._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoldingFigure8.")

agcls.AgClassCatalog.add_catalog_entry("{cdd17fce-e24c-45f4-8b7c-b313f490e124}", ProcedureHoldingFigure8)
agcls.AgTypeNameMap["ProcedureHoldingFigure8"] = ProcedureHoldingFigure8

class ProcedureHoldingRacetrack(IProcedureHoldingRacetrack, IProcedure):
    """Class defining a holding racetrack procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoldingRacetrack.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureHoldingRacetrack._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoldingRacetrack._get_property(self, attrname) is not None: found_prop = IProcedureHoldingRacetrack._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoldingRacetrack.")

agcls.AgClassCatalog.add_catalog_entry("{d2aa71dd-b167-4eea-be1d-665e4fd586da}", ProcedureHoldingRacetrack)
agcls.AgTypeNameMap["ProcedureHoldingRacetrack"] = ProcedureHoldingRacetrack

class ProcedureTransitionToHover(IProcedureTransitionToHover, IProcedure):
    """Class defining a transition to hover procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTransitionToHover.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureTransitionToHover._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTransitionToHover._get_property(self, attrname) is not None: found_prop = IProcedureTransitionToHover._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTransitionToHover.")

agcls.AgClassCatalog.add_catalog_entry("{4cc8f381-2118-4c51-a1f4-68db53833efc}", ProcedureTransitionToHover)
agcls.AgTypeNameMap["ProcedureTransitionToHover"] = ProcedureTransitionToHover

class ProcedureTerrainFollow(IProcedureTerrainFollow, IProcedure):
    """Class defining a terrain following procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTerrainFollow.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureTerrainFollow._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTerrainFollow._get_property(self, attrname) is not None: found_prop = IProcedureTerrainFollow._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTerrainFollow.")

agcls.AgClassCatalog.add_catalog_entry("{3ab3ca3e-70dd-405c-a470-9bfbdfa23734}", ProcedureTerrainFollow)
agcls.AgTypeNameMap["ProcedureTerrainFollow"] = ProcedureTerrainFollow

class ProcedureHover(IProcedureHover, IProcedure):
    """Class defining a hover procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHover.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureHover._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHover._get_property(self, attrname) is not None: found_prop = IProcedureHover._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHover.")

agcls.AgClassCatalog.add_catalog_entry("{2af73325-a00b-405c-987c-af5f4e7f60cf}", ProcedureHover)
agcls.AgTypeNameMap["ProcedureHover"] = ProcedureHover

class ProcedureHoverTranslate(IProcedureHoverTranslate, IProcedure):
    """Class defining a hover translate procedure."""
    def __init__(self, sourceObject=None):
        IProcedureHoverTranslate.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureHoverTranslate._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureHoverTranslate._get_property(self, attrname) is not None: found_prop = IProcedureHoverTranslate._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureHoverTranslate.")

agcls.AgClassCatalog.add_catalog_entry("{fde61d2d-7896-4b38-a0cb-f3a2776c8cfb}", ProcedureHoverTranslate)
agcls.AgTypeNameMap["ProcedureHoverTranslate"] = ProcedureHoverTranslate

class ProcedureTransitionToForwardFlight(IProcedureTransitionToForwardFlight, IProcedure):
    """Class defining a transition to forward flight procedure."""
    def __init__(self, sourceObject=None):
        IProcedureTransitionToForwardFlight.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureTransitionToForwardFlight._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureTransitionToForwardFlight._get_property(self, attrname) is not None: found_prop = IProcedureTransitionToForwardFlight._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureTransitionToForwardFlight.")

agcls.AgClassCatalog.add_catalog_entry("{f4e5896e-1457-4909-8b6f-0740d9852278}", ProcedureTransitionToForwardFlight)
agcls.AgTypeNameMap["ProcedureTransitionToForwardFlight"] = ProcedureTransitionToForwardFlight

class HoverAltitudeOptions(IHoverAltitudeOptions):
    """Class defining the altitude options for a VTOL procedure."""
    def __init__(self, sourceObject=None):
        IHoverAltitudeOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IHoverAltitudeOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IHoverAltitudeOptions._get_property(self, attrname) is not None: found_prop = IHoverAltitudeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in HoverAltitudeOptions.")

agcls.AgClassCatalog.add_catalog_entry("{feb66c2d-f9c7-472d-a389-4764db1d37bf}", HoverAltitudeOptions)
agcls.AgTypeNameMap["HoverAltitudeOptions"] = HoverAltitudeOptions

class ProcedureVerticalTakeoff(IProcedureVerticalTakeoff, IProcedure):
    """Class defining a vertical takeoff procedure."""
    def __init__(self, sourceObject=None):
        IProcedureVerticalTakeoff.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureVerticalTakeoff._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureVerticalTakeoff._get_property(self, attrname) is not None: found_prop = IProcedureVerticalTakeoff._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureVerticalTakeoff.")

agcls.AgClassCatalog.add_catalog_entry("{518b6d80-31d5-427e-b55f-8b299ba082b9}", ProcedureVerticalTakeoff)
agcls.AgTypeNameMap["ProcedureVerticalTakeoff"] = ProcedureVerticalTakeoff

class ProcedureVerticalLanding(IProcedureVerticalLanding, IProcedure):
    """Class defining a vertical landing procedure."""
    def __init__(self, sourceObject=None):
        IProcedureVerticalLanding.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureVerticalLanding._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureVerticalLanding._get_property(self, attrname) is not None: found_prop = IProcedureVerticalLanding._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureVerticalLanding.")

agcls.AgClassCatalog.add_catalog_entry("{68401463-90f1-4a74-9346-6e1e99906906}", ProcedureVerticalLanding)
agcls.AgTypeNameMap["ProcedureVerticalLanding"] = ProcedureVerticalLanding

class ProcedureReferenceState(IProcedureReferenceState, IProcedure):
    """Class defining a reference state procedure."""
    def __init__(self, sourceObject=None):
        IProcedureReferenceState.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureReferenceState._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureReferenceState._get_property(self, attrname) is not None: found_prop = IProcedureReferenceState._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureReferenceState.")

agcls.AgClassCatalog.add_catalog_entry("{44f22ac8-6eec-42ca-a433-dbf8b9fdaabf}", ProcedureReferenceState)
agcls.AgTypeNameMap["ProcedureReferenceState"] = ProcedureReferenceState

class ProcedureSuperProcedure(IProcedureSuperProcedure, IProcedure):
    """Class defining a super procedure."""
    def __init__(self, sourceObject=None):
        IProcedureSuperProcedure.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureSuperProcedure._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureSuperProcedure._get_property(self, attrname) is not None: found_prop = IProcedureSuperProcedure._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureSuperProcedure.")

agcls.AgClassCatalog.add_catalog_entry("{b49011b5-9b02-48df-9ddd-9936e7903017}", ProcedureSuperProcedure)
agcls.AgTypeNameMap["ProcedureSuperProcedure"] = ProcedureSuperProcedure

class ProcedureLaunch(IProcedureLaunch, IProcedure):
    """Class defining a launch procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLaunch.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureLaunch._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLaunch._get_property(self, attrname) is not None: found_prop = IProcedureLaunch._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLaunch.")

agcls.AgClassCatalog.add_catalog_entry("{4121a688-337a-4436-999f-9e1de57aab96}", ProcedureLaunch)
agcls.AgTypeNameMap["ProcedureLaunch"] = ProcedureLaunch

class ProcedureAirway(IProcedureAirway, IProcedure):
    """Class defining an Airway procedure."""
    def __init__(self, sourceObject=None):
        IProcedureAirway.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureAirway._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureAirway._get_property(self, attrname) is not None: found_prop = IProcedureAirway._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureAirway.")

agcls.AgClassCatalog.add_catalog_entry("{66c4d604-dac9-4eff-a18d-be1efb81f1f0}", ProcedureAirway)
agcls.AgTypeNameMap["ProcedureAirway"] = ProcedureAirway

class ProcedureAirwayRouter(IProcedureAirwayRouter, IProcedure):
    """Class defining an Airway Router procedure."""
    def __init__(self, sourceObject=None):
        IProcedureAirwayRouter.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureAirwayRouter._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureAirwayRouter._get_property(self, attrname) is not None: found_prop = IProcedureAirwayRouter._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureAirwayRouter.")

agcls.AgClassCatalog.add_catalog_entry("{c240ee52-dee2-42e0-a8c1-17f52b665f39}", ProcedureAirwayRouter)
agcls.AgTypeNameMap["ProcedureAirwayRouter"] = ProcedureAirwayRouter

class ProcedureAreaTargetSearch(IProcedureAreaTargetSearch, IProcedure):
    """Class defining an Area Target Search procedure."""
    def __init__(self, sourceObject=None):
        IProcedureAreaTargetSearch.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureAreaTargetSearch._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureAreaTargetSearch._get_property(self, attrname) is not None: found_prop = IProcedureAreaTargetSearch._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureAreaTargetSearch.")

agcls.AgClassCatalog.add_catalog_entry("{d065a50b-ba9e-4f25-831e-bb691df5cc71}", ProcedureAreaTargetSearch)
agcls.AgTypeNameMap["ProcedureAreaTargetSearch"] = ProcedureAreaTargetSearch

class ProcedureFormationRecover(IProcedureFormationRecover, IProcedure):
    """Class defining a Formation/Recover procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFormationRecover.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureFormationRecover._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFormationRecover._get_property(self, attrname) is not None: found_prop = IProcedureFormationRecover._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFormationRecover.")

agcls.AgClassCatalog.add_catalog_entry("{c3ca901a-fcb0-407b-a8d7-0f6972ebcd85}", ProcedureFormationRecover)
agcls.AgTypeNameMap["ProcedureFormationRecover"] = ProcedureFormationRecover

class ProcedureInFormation(IProcedureInFormation, IProcedure):
    """Class defining an In Formation procedure."""
    def __init__(self, sourceObject=None):
        IProcedureInFormation.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureInFormation._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureInFormation._get_property(self, attrname) is not None: found_prop = IProcedureInFormation._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureInFormation.")

agcls.AgClassCatalog.add_catalog_entry("{5f09f987-b896-4cc7-b356-732d0c1500b8}", ProcedureInFormation)
agcls.AgTypeNameMap["ProcedureInFormation"] = ProcedureInFormation

class ProcedureParallelFlightLine(IProcedureParallelFlightLine, IProcedure):
    """Class defining a Parallel Flight Line procedure."""
    def __init__(self, sourceObject=None):
        IProcedureParallelFlightLine.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureParallelFlightLine._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureParallelFlightLine._get_property(self, attrname) is not None: found_prop = IProcedureParallelFlightLine._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureParallelFlightLine.")

agcls.AgClassCatalog.add_catalog_entry("{3d83878f-7cda-46e8-b93f-9cbdc117244b}", ProcedureParallelFlightLine)
agcls.AgTypeNameMap["ProcedureParallelFlightLine"] = ProcedureParallelFlightLine

class ProcedureVGTPoint(IProcedureVGTPoint, IProcedure):
    """Class defining a VGT Point procedure."""
    def __init__(self, sourceObject=None):
        IProcedureVGTPoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureVGTPoint._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureVGTPoint._get_property(self, attrname) is not None: found_prop = IProcedureVGTPoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureVGTPoint.")

agcls.AgClassCatalog.add_catalog_entry("{c1c57b66-ecf6-47f5-be6a-36075f83917a}", ProcedureVGTPoint)
agcls.AgTypeNameMap["ProcedureVGTPoint"] = ProcedureVGTPoint

class PerformanceModelOptions(IPerformanceModelOptions):
    """Class defining the options for the active performance model in a phase."""
    def __init__(self, sourceObject=None):
        IPerformanceModelOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IPerformanceModelOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPerformanceModelOptions._get_property(self, attrname) is not None: found_prop = IPerformanceModelOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PerformanceModelOptions.")

agcls.AgClassCatalog.add_catalog_entry("{d37c0417-9eab-4d38-8a3f-a70e144b5368}", PerformanceModelOptions)
agcls.AgTypeNameMap["PerformanceModelOptions"] = PerformanceModelOptions

class AdvFixedWingTool(IAdvFixedWingTool):
    """Class defining the options for the Advanced Fixed Wing Tool of an aircraft."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTool.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingTool._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTool._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTool._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTool.")

agcls.AgClassCatalog.add_catalog_entry("{e250469c-80a2-44d2-b53d-2712363d7b47}", AdvFixedWingTool)
agcls.AgTypeNameMap["AdvFixedWingTool"] = AdvFixedWingTool

class AdvFixedWingExternalAero(IAdvFixedWingExternalAero):
    """Class defining the External Aero File aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingExternalAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingExternalAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingExternalAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingExternalAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingExternalAero.")

agcls.AgClassCatalog.add_catalog_entry("{0938800e-fa5d-446d-bf7b-3d79283da798}", AdvFixedWingExternalAero)
agcls.AgTypeNameMap["AdvFixedWingExternalAero"] = AdvFixedWingExternalAero

class AdvFixedWingSubsonicAero(IAdvFixedWingSubsonicAero):
    """Class defining the subsonic aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSubsonicAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingSubsonicAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSubsonicAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSubsonicAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSubsonicAero.")

agcls.AgClassCatalog.add_catalog_entry("{ced4d6ca-5a7e-4640-936f-e0db35949454}", AdvFixedWingSubsonicAero)
agcls.AgTypeNameMap["AdvFixedWingSubsonicAero"] = AdvFixedWingSubsonicAero

class AdvFixedWingSubSuperHypersonicAero(IAdvFixedWingSubSuperHypersonicAero):
    """Class defining the Sub/Super/Hypersonic aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSubSuperHypersonicAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingSubSuperHypersonicAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSubSuperHypersonicAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSubSuperHypersonicAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSubSuperHypersonicAero.")

agcls.AgClassCatalog.add_catalog_entry("{aa686d0d-7a40-44bb-b340-a5a5470ed81f}", AdvFixedWingSubSuperHypersonicAero)
agcls.AgTypeNameMap["AdvFixedWingSubSuperHypersonicAero"] = AdvFixedWingSubSuperHypersonicAero

class AdvFixedWingSupersonicAero(IAdvFixedWingSupersonicAero):
    """Class defining the supersonic aerodynamic strategy in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSupersonicAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingSupersonicAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSupersonicAero._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSupersonicAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSupersonicAero.")

agcls.AgClassCatalog.add_catalog_entry("{00683dc3-fc6d-4ba2-9d0b-306363523e17}", AdvFixedWingSupersonicAero)
agcls.AgTypeNameMap["AdvFixedWingSupersonicAero"] = AdvFixedWingSupersonicAero

class PerformanceModel(IPerformanceModel, ICatalogItem):
    """Class defining an unknown performance model."""
    def __init__(self, sourceObject=None):
        IPerformanceModel.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IPerformanceModel._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPerformanceModel._get_property(self, attrname) is not None: found_prop = IPerformanceModel._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PerformanceModel.")

agcls.AgClassCatalog.add_catalog_entry("{07c21222-ddfa-4417-8739-aa7e41a6091a}", PerformanceModel)
agcls.AgTypeNameMap["PerformanceModel"] = PerformanceModel

class AdvFixedWingGeometryBasic(IAdvFixedWingGeometryBasic, IAdvFixedWingGeometry):
    """Class defining a basic geometry wing in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingGeometryBasic.__init__(self, sourceObject)
        IAdvFixedWingGeometry.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingGeometryBasic._private_init(self, intf)
        IAdvFixedWingGeometry._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingGeometryBasic._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometryBasic._get_property(self, attrname)
        if IAdvFixedWingGeometry._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometry._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingGeometryBasic.")

agcls.AgClassCatalog.add_catalog_entry("{3fccd7b1-9fd7-424e-a251-cadcc2d44a0a}", AdvFixedWingGeometryBasic)
agcls.AgTypeNameMap["AdvFixedWingGeometryBasic"] = AdvFixedWingGeometryBasic

class AdvFixedWingGeometryVariable(IAdvFixedWingGeometryVariable, IAdvFixedWingGeometry):
    """Class defining a variable geometry wing in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingGeometryVariable.__init__(self, sourceObject)
        IAdvFixedWingGeometry.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingGeometryVariable._private_init(self, intf)
        IAdvFixedWingGeometry._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingGeometryVariable._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometryVariable._get_property(self, attrname)
        if IAdvFixedWingGeometry._get_property(self, attrname) is not None: found_prop = IAdvFixedWingGeometry._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingGeometryVariable.")

agcls.AgClassCatalog.add_catalog_entry("{a7cb26ac-fa5b-416d-b81b-8a5975937740}", AdvFixedWingGeometryVariable)
agcls.AgTypeNameMap["AdvFixedWingGeometryVariable"] = AdvFixedWingGeometryVariable

class AdvFixedWingElectricPowerplant(IAdvFixedWingElectricPowerplant):
    """Class defining an Electric powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingElectricPowerplant.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingElectricPowerplant._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingElectricPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingElectricPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingElectricPowerplant.")

agcls.AgClassCatalog.add_catalog_entry("{64f956f4-4b87-4b13-b459-efef51191309}", AdvFixedWingElectricPowerplant)
agcls.AgTypeNameMap["AdvFixedWingElectricPowerplant"] = AdvFixedWingElectricPowerplant

class AdvFixedWingExternalProp(IAdvFixedWingExternalProp):
    """Class defining an External Prop File powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingExternalProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingExternalProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingExternalProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingExternalProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingExternalProp.")

agcls.AgClassCatalog.add_catalog_entry("{86d612c4-8537-48d7-912b-931a2c939c8e}", AdvFixedWingExternalProp)
agcls.AgTypeNameMap["AdvFixedWingExternalProp"] = AdvFixedWingExternalProp

class AdvFixedWingSubSuperHypersonicProp(IAdvFixedWingSubSuperHypersonicProp):
    """Class defining a Sub/Super/Hypersonic powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingSubSuperHypersonicProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingSubSuperHypersonicProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingSubSuperHypersonicProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingSubSuperHypersonicProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingSubSuperHypersonicProp.")

agcls.AgClassCatalog.add_catalog_entry("{15279d03-0f3b-458d-957c-2cdee97bc0a8}", AdvFixedWingSubSuperHypersonicProp)
agcls.AgTypeNameMap["AdvFixedWingSubSuperHypersonicProp"] = AdvFixedWingSubSuperHypersonicProp

class AdvFixedWingPistonPowerplant(IAdvFixedWingPistonPowerplant):
    """Class defining a Piston powerplant in the Advanced Fixed Wing Tool."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingPistonPowerplant.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingPistonPowerplant._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingPistonPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingPistonPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingPistonPowerplant.")

agcls.AgClassCatalog.add_catalog_entry("{dd383e2b-f1e9-4afe-9241-4d89e95db034}", AdvFixedWingPistonPowerplant)
agcls.AgTypeNameMap["AdvFixedWingPistonPowerplant"] = AdvFixedWingPistonPowerplant

class AdvFixedWingEmpiricalJetEngine(IAdvFixedWingEmpiricalJetEngine):
    """Class defining the Turbojet and Turbofan empirical models in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingEmpiricalJetEngine.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingEmpiricalJetEngine._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingEmpiricalJetEngine._get_property(self, attrname) is not None: found_prop = IAdvFixedWingEmpiricalJetEngine._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingEmpiricalJetEngine.")

agcls.AgClassCatalog.add_catalog_entry("{cf86965f-eacf-47ca-a6b8-5c69a1f9612f}", AdvFixedWingEmpiricalJetEngine)
agcls.AgTypeNameMap["AdvFixedWingEmpiricalJetEngine"] = AdvFixedWingEmpiricalJetEngine

class AdvFixedWingTurbofanBasicABPowerplant(IAdvFixedWingTurbofanBasicABPowerplant):
    """This class is deprecated. Use AdvFixedWingTurbofanBasicABProp instead."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbofanBasicABPowerplant.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingTurbofanBasicABPowerplant._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbofanBasicABPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbofanBasicABPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbofanBasicABPowerplant.")

agcls.AgClassCatalog.add_catalog_entry("{27a6cd0b-bd9b-4af7-9367-9d2ce3fa39cd}", AdvFixedWingTurbofanBasicABPowerplant)
agcls.AgTypeNameMap["AdvFixedWingTurbofanBasicABPowerplant"] = AdvFixedWingTurbofanBasicABPowerplant

class AdvFixedWingTurbojetBasicABPowerplant(IAdvFixedWingTurbojetBasicABPowerplant):
    """This class is deprecated. Use AdvFixedWingTurbojetBasicABProp instead."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbojetBasicABPowerplant.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingTurbojetBasicABPowerplant._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbojetBasicABPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbojetBasicABPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbojetBasicABPowerplant.")

agcls.AgClassCatalog.add_catalog_entry("{65230337-ecdc-4b80-92aa-107af1bcfdbe}", AdvFixedWingTurbojetBasicABPowerplant)
agcls.AgTypeNameMap["AdvFixedWingTurbojetBasicABPowerplant"] = AdvFixedWingTurbojetBasicABPowerplant

class AdvFixedWingTurbofanBasicABProp(IAdvFixedWingTurbofanBasicABProp):
    """Class defining the Turbofan - Basic w/AB (Thermodynamic model) powerplant in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbofanBasicABProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingTurbofanBasicABProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbofanBasicABProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbofanBasicABProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbofanBasicABProp.")

agcls.AgClassCatalog.add_catalog_entry("{327e3a7a-ecce-445e-b105-2dbec0239e6d}", AdvFixedWingTurbofanBasicABProp)
agcls.AgTypeNameMap["AdvFixedWingTurbofanBasicABProp"] = AdvFixedWingTurbofanBasicABProp

class AdvFixedWingTurbojetBasicABProp(IAdvFixedWingTurbojetBasicABProp):
    """Class defining the Turbojet - Basic w/AB (Thermodynamic model) powerplant in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbojetBasicABProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingTurbojetBasicABProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbojetBasicABProp._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbojetBasicABProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbojetBasicABProp.")

agcls.AgClassCatalog.add_catalog_entry("{c60f96fa-5802-4d89-b522-2a1dd5e03ca0}", AdvFixedWingTurbojetBasicABProp)
agcls.AgTypeNameMap["AdvFixedWingTurbojetBasicABProp"] = AdvFixedWingTurbojetBasicABProp

class AdvFixedWingTurbopropPowerplant(IAdvFixedWingTurbopropPowerplant):
    """Class defining the Turboprop powerplant in the Advanced Fixed Wing Tool"""
    def __init__(self, sourceObject=None):
        IAdvFixedWingTurbopropPowerplant.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingTurbopropPowerplant._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingTurbopropPowerplant._get_property(self, attrname) is not None: found_prop = IAdvFixedWingTurbopropPowerplant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingTurbopropPowerplant.")

agcls.AgClassCatalog.add_catalog_entry("{7ac5402a-9b5d-4fc9-94b5-365e9bc1e25e}", AdvFixedWingTurbopropPowerplant)
agcls.AgTypeNameMap["AdvFixedWingTurbopropPowerplant"] = AdvFixedWingTurbopropPowerplant

class MissileSimpleAero(IMissileSimpleAero):
    """Class defining the simple aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileSimpleAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileSimpleAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileSimpleAero._get_property(self, attrname) is not None: found_prop = IMissileSimpleAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileSimpleAero.")

agcls.AgClassCatalog.add_catalog_entry("{99dff5f7-c73c-414d-9c38-2e7b35c93f5e}", MissileSimpleAero)
agcls.AgTypeNameMap["MissileSimpleAero"] = MissileSimpleAero

class MissileExternalAero(IMissileExternalAero):
    """Class defining the external aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileExternalAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileExternalAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileExternalAero._get_property(self, attrname) is not None: found_prop = IMissileExternalAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileExternalAero.")

agcls.AgClassCatalog.add_catalog_entry("{92940e34-6d78-4e39-b774-4a865e9d0bc0}", MissileExternalAero)
agcls.AgTypeNameMap["MissileExternalAero"] = MissileExternalAero

class MissileAdvancedAero(IMissileAdvancedAero):
    """Class defining the advanced aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileAdvancedAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileAdvancedAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileAdvancedAero._get_property(self, attrname) is not None: found_prop = IMissileAdvancedAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileAdvancedAero.")

agcls.AgClassCatalog.add_catalog_entry("{becfe264-7b70-461f-9f64-b0d23aa59f1e}", MissileAdvancedAero)
agcls.AgTypeNameMap["MissileAdvancedAero"] = MissileAdvancedAero

class MissileAero(IMissileAero):
    """Class defining the aerodynamic options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileAero.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileAero._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileAero._get_property(self, attrname) is not None: found_prop = IMissileAero._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileAero.")

agcls.AgClassCatalog.add_catalog_entry("{bc518434-5a42-49e0-8a54-8212a797c728}", MissileAero)
agcls.AgTypeNameMap["MissileAero"] = MissileAero

class MissileProp(IMissileProp):
    """Class defining the propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileProp._get_property(self, attrname) is not None: found_prop = IMissileProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileProp.")

agcls.AgClassCatalog.add_catalog_entry("{544b60ce-22da-4e8b-a222-ffd4bc070a01}", MissileProp)
agcls.AgTypeNameMap["MissileProp"] = MissileProp

class MissileSimpleProp(IMissileSimpleProp):
    """Class defining the Simple propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileSimpleProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileSimpleProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileSimpleProp._get_property(self, attrname) is not None: found_prop = IMissileSimpleProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileSimpleProp.")

agcls.AgClassCatalog.add_catalog_entry("{e92e2a28-9614-4afe-97ee-8e0d90e4ee3b}", MissileSimpleProp)
agcls.AgTypeNameMap["MissileSimpleProp"] = MissileSimpleProp

class MissileExternalProp(IMissileExternalProp):
    """Class defining the External propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileExternalProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileExternalProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileExternalProp._get_property(self, attrname) is not None: found_prop = IMissileExternalProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileExternalProp.")

agcls.AgClassCatalog.add_catalog_entry("{4b7a80c7-e7a6-453b-a423-1c53ac68c0bc}", MissileExternalProp)
agcls.AgTypeNameMap["MissileExternalProp"] = MissileExternalProp

class MissileRamjetProp(IMissileRamjetProp):
    """Class defining the Ramjet propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileRamjetProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileRamjetProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileRamjetProp._get_property(self, attrname) is not None: found_prop = IMissileRamjetProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileRamjetProp.")

agcls.AgClassCatalog.add_catalog_entry("{0bef31b2-9f2c-4dea-b475-e2feeb55052e}", MissileRamjetProp)
agcls.AgTypeNameMap["MissileRamjetProp"] = MissileRamjetProp

class MissileRocketProp(IMissileRocketProp):
    """Class defining the Rocket propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileRocketProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileRocketProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileRocketProp._get_property(self, attrname) is not None: found_prop = IMissileRocketProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileRocketProp.")

agcls.AgClassCatalog.add_catalog_entry("{68296bb7-edd5-4305-8b51-3f3d0c7d4428}", MissileRocketProp)
agcls.AgTypeNameMap["MissileRocketProp"] = MissileRocketProp

class MissileTurbojetProp(IMissileTurbojetProp):
    """Class defining the Turbojet propulsion options for a missile."""
    def __init__(self, sourceObject=None):
        IMissileTurbojetProp.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IMissileTurbojetProp._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissileTurbojetProp._get_property(self, attrname) is not None: found_prop = IMissileTurbojetProp._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissileTurbojetProp.")

agcls.AgClassCatalog.add_catalog_entry("{6024d1a7-768e-4015-abb3-e0539d431ff9}", MissileTurbojetProp)
agcls.AgTypeNameMap["MissileTurbojetProp"] = MissileTurbojetProp

class ReferenceStateForwardFlightOptions(IReferenceStateForwardFlightOptions):
    """Class defining the Forward Flight options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateForwardFlightOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IReferenceStateForwardFlightOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateForwardFlightOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateForwardFlightOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateForwardFlightOptions.")

agcls.AgClassCatalog.add_catalog_entry("{6f60fd0b-6c79-48a5-908b-b5d697552b94}", ReferenceStateForwardFlightOptions)
agcls.AgTypeNameMap["ReferenceStateForwardFlightOptions"] = ReferenceStateForwardFlightOptions

class ReferenceStateTakeoffLandingOptions(IReferenceStateTakeoffLandingOptions):
    """Class defining the Takeoff or Landing options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateTakeoffLandingOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IReferenceStateTakeoffLandingOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateTakeoffLandingOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateTakeoffLandingOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateTakeoffLandingOptions.")

agcls.AgClassCatalog.add_catalog_entry("{5a54840f-128e-411c-af24-2e2c49fbd922}", ReferenceStateTakeoffLandingOptions)
agcls.AgTypeNameMap["ReferenceStateTakeoffLandingOptions"] = ReferenceStateTakeoffLandingOptions

class ReferenceStateHoverOptions(IReferenceStateHoverOptions):
    """Class defining the Hover options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateHoverOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IReferenceStateHoverOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateHoverOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateHoverOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateHoverOptions.")

agcls.AgClassCatalog.add_catalog_entry("{0767b34e-3bc9-447d-956e-5e0939cc9bfc}", ReferenceStateHoverOptions)
agcls.AgTypeNameMap["ReferenceStateHoverOptions"] = ReferenceStateHoverOptions

class ReferenceStateWeightOnWheelsOptions(IReferenceStateWeightOnWheelsOptions):
    """Class defining the Weight on Wheels options for a Reference State procedure."""
    def __init__(self, sourceObject=None):
        IReferenceStateWeightOnWheelsOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IReferenceStateWeightOnWheelsOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IReferenceStateWeightOnWheelsOptions._get_property(self, attrname) is not None: found_prop = IReferenceStateWeightOnWheelsOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ReferenceStateWeightOnWheelsOptions.")

agcls.AgClassCatalog.add_catalog_entry("{de32d95c-707b-41dd-a7de-072506f171b9}", ReferenceStateWeightOnWheelsOptions)
agcls.AgTypeNameMap["ReferenceStateWeightOnWheelsOptions"] = ReferenceStateWeightOnWheelsOptions

class SiteRunwayFromCatalog(ISiteRunwayFromCatalog, ISite):
    """Class defining a runway from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteRunwayFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteRunwayFromCatalog._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteRunwayFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteRunwayFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteRunwayFromCatalog.")

agcls.AgClassCatalog.add_catalog_entry("{9220ceaa-69a7-4b64-8dfe-ec4ca0083d3e}", SiteRunwayFromCatalog)
agcls.AgTypeNameMap["SiteRunwayFromCatalog"] = SiteRunwayFromCatalog

class SiteAirportFromCatalog(ISiteAirportFromCatalog, ISite):
    """Class defining a airport from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteAirportFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteAirportFromCatalog._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteAirportFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteAirportFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteAirportFromCatalog.")

agcls.AgClassCatalog.add_catalog_entry("{b5a44f89-2af4-41bd-8ebc-8e503f43f912}", SiteAirportFromCatalog)
agcls.AgTypeNameMap["SiteAirportFromCatalog"] = SiteAirportFromCatalog

class SiteNavaidFromCatalog(ISiteNavaidFromCatalog, ISite):
    """Class defining a navaid from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteNavaidFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteNavaidFromCatalog._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteNavaidFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteNavaidFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteNavaidFromCatalog.")

agcls.AgClassCatalog.add_catalog_entry("{59135b93-5164-4c35-8128-de6a6376a66f}", SiteNavaidFromCatalog)
agcls.AgTypeNameMap["SiteNavaidFromCatalog"] = SiteNavaidFromCatalog

class SiteVTOLPointFromCatalog(ISiteVTOLPointFromCatalog, ISite):
    """Class defining a VTOL point from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteVTOLPointFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteVTOLPointFromCatalog._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteVTOLPointFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteVTOLPointFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteVTOLPointFromCatalog.")

agcls.AgClassCatalog.add_catalog_entry("{189c8c0a-c6a4-424f-b2ff-b1e466c38cd4}", SiteVTOLPointFromCatalog)
agcls.AgTypeNameMap["SiteVTOLPointFromCatalog"] = SiteVTOLPointFromCatalog

class SiteWaypointFromCatalog(ISiteWaypointFromCatalog, ISite):
    """Class defining a waypoint from catalog site."""
    def __init__(self, sourceObject=None):
        ISiteWaypointFromCatalog.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteWaypointFromCatalog._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteWaypointFromCatalog._get_property(self, attrname) is not None: found_prop = ISiteWaypointFromCatalog._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteWaypointFromCatalog.")

agcls.AgClassCatalog.add_catalog_entry("{d620651a-2526-43c8-8715-122ad6d6eb40}", SiteWaypointFromCatalog)
agcls.AgTypeNameMap["SiteWaypointFromCatalog"] = SiteWaypointFromCatalog

class NavaidCategory(INavaidCategory):
    """Class defining the navaid category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        INavaidCategory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        INavaidCategory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if INavaidCategory._get_property(self, attrname) is not None: found_prop = INavaidCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in NavaidCategory.")

agcls.AgClassCatalog.add_catalog_entry("{9cab926c-f92d-4b63-9588-d5e849f047bf}", NavaidCategory)
agcls.AgTypeNameMap["NavaidCategory"] = NavaidCategory

class VTOLPointCategory(IVTOLPointCategory):
    """Class defining the VTOL point category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IVTOLPointCategory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVTOLPointCategory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVTOLPointCategory._get_property(self, attrname) is not None: found_prop = IVTOLPointCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VTOLPointCategory.")

agcls.AgClassCatalog.add_catalog_entry("{35a0a9ce-18bd-47b5-927a-1cb825edab22}", VTOLPointCategory)
agcls.AgTypeNameMap["VTOLPointCategory"] = VTOLPointCategory

class WaypointCategory(IWaypointCategory):
    """Class defining the waypoint category in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IWaypointCategory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IWaypointCategory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IWaypointCategory._get_property(self, attrname) is not None: found_prop = IWaypointCategory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in WaypointCategory.")

agcls.AgClassCatalog.add_catalog_entry("{502442da-96cc-4a07-9124-9d4e4c287801}", WaypointCategory)
agcls.AgTypeNameMap["WaypointCategory"] = WaypointCategory

class ARINC424Navaid(IARINC424Item, ICatalogNavaid, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Navaid."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogNavaid.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IARINC424Item._private_init(self, intf)
        ICatalogNavaid._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogNavaid._get_property(self, attrname) is not None: found_prop = ICatalogNavaid._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Navaid.")

agcls.AgClassCatalog.add_catalog_entry("{18308bdb-0318-4820-87c7-59e4ad432c0f}", ARINC424Navaid)
agcls.AgTypeNameMap["ARINC424Navaid"] = ARINC424Navaid

class ARINC424Helipad(IARINC424Item, ICatalogVTOLPoint, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Helipad."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogVTOLPoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IARINC424Item._private_init(self, intf)
        ICatalogVTOLPoint._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogVTOLPoint._get_property(self, attrname) is not None: found_prop = ICatalogVTOLPoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Helipad.")

agcls.AgClassCatalog.add_catalog_entry("{6cf2bbc6-dcf3-493e-ad3d-bf58879edd2d}", ARINC424Helipad)
agcls.AgTypeNameMap["ARINC424Helipad"] = ARINC424Helipad

class ARINC424Waypoint(IARINC424Item, ICatalogWaypoint, ICatalogItem):
    """Class defining an ARINC424 Waypoint."""
    def __init__(self, sourceObject=None):
        IARINC424Item.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IARINC424Item._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IARINC424Item._get_property(self, attrname) is not None: found_prop = IARINC424Item._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ARINC424Waypoint.")

agcls.AgClassCatalog.add_catalog_entry("{55d1b405-651f-4687-a34a-f0bb64ec8814}", ARINC424Waypoint)
agcls.AgTypeNameMap["ARINC424Waypoint"] = ARINC424Waypoint

class UserVTOLPointSource(IUserVTOLPointSource, ICatalogSource):
    """Class defining the user VTOL Point source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserVTOLPointSource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IUserVTOLPointSource._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVTOLPointSource._get_property(self, attrname) is not None: found_prop = IUserVTOLPointSource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVTOLPointSource.")

agcls.AgClassCatalog.add_catalog_entry("{dfc0b12b-f8c4-4d99-bb5c-6aecebe0ea7d}", UserVTOLPointSource)
agcls.AgTypeNameMap["UserVTOLPointSource"] = UserVTOLPointSource

class UserVTOLPoint(IUserVTOLPoint, ICatalogVTOLPoint, ICatalogWaypoint, ICatalogItem):
    """Class defining the user VTOL Point in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserVTOLPoint.__init__(self, sourceObject)
        ICatalogVTOLPoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IUserVTOLPoint._private_init(self, intf)
        ICatalogVTOLPoint._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVTOLPoint._get_property(self, attrname) is not None: found_prop = IUserVTOLPoint._get_property(self, attrname)
        if ICatalogVTOLPoint._get_property(self, attrname) is not None: found_prop = ICatalogVTOLPoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVTOLPoint.")

agcls.AgClassCatalog.add_catalog_entry("{748a44bd-4d22-4800-a311-fc8c95901638}", UserVTOLPoint)
agcls.AgTypeNameMap["UserVTOLPoint"] = UserVTOLPoint

class UserWaypointSource(IUserWaypointSource, ICatalogSource):
    """Class defining the user waypoint source in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserWaypointSource.__init__(self, sourceObject)
        ICatalogSource.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IUserWaypointSource._private_init(self, intf)
        ICatalogSource._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserWaypointSource._get_property(self, attrname) is not None: found_prop = IUserWaypointSource._get_property(self, attrname)
        if ICatalogSource._get_property(self, attrname) is not None: found_prop = ICatalogSource._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserWaypointSource.")

agcls.AgClassCatalog.add_catalog_entry("{7f85e32f-b5a1-4d12-b7ac-a817dd7162d0}", UserWaypointSource)
agcls.AgTypeNameMap["UserWaypointSource"] = UserWaypointSource

class UserWaypoint(IUserWaypoint, ICatalogWaypoint, ICatalogItem):
    """Class defining the user waypoint in the Aviator catalog."""
    def __init__(self, sourceObject=None):
        IUserWaypoint.__init__(self, sourceObject)
        ICatalogWaypoint.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IUserWaypoint._private_init(self, intf)
        ICatalogWaypoint._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserWaypoint._get_property(self, attrname) is not None: found_prop = IUserWaypoint._get_property(self, attrname)
        if ICatalogWaypoint._get_property(self, attrname) is not None: found_prop = ICatalogWaypoint._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserWaypoint.")

agcls.AgClassCatalog.add_catalog_entry("{ca33c45d-2eba-409b-aa44-b57b5a57e3b3}", UserWaypoint)
agcls.AgTypeNameMap["UserWaypoint"] = UserWaypoint

class PropulsionEfficiencies(IPropulsionEfficiencies):
    """Class defining the Propulsion Efficiencies and Losses of a jet engine powerplant in the advanced fixed wing tool."""
    def __init__(self, sourceObject=None):
        IPropulsionEfficiencies.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IPropulsionEfficiencies._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPropulsionEfficiencies._get_property(self, attrname) is not None: found_prop = IPropulsionEfficiencies._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PropulsionEfficiencies.")

agcls.AgClassCatalog.add_catalog_entry("{0af7363a-b62a-4eaf-a4b5-4103197bc6b1}", PropulsionEfficiencies)
agcls.AgTypeNameMap["PropulsionEfficiencies"] = PropulsionEfficiencies

class FuelModelKeroseneAFPROP(IFuelModelKeroseneAFPROP):
    """Class defining the Kerosense - AFPROP fuel type for a thermodynamic jet engine model."""
    def __init__(self, sourceObject=None):
        IFuelModelKeroseneAFPROP.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IFuelModelKeroseneAFPROP._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelModelKeroseneAFPROP._get_property(self, attrname) is not None: found_prop = IFuelModelKeroseneAFPROP._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelModelKeroseneAFPROP.")

agcls.AgClassCatalog.add_catalog_entry("{fb23d809-5785-4a45-b914-415015e6d9eb}", FuelModelKeroseneAFPROP)
agcls.AgTypeNameMap["FuelModelKeroseneAFPROP"] = FuelModelKeroseneAFPROP

class FuelModelKeroseneCEA(IFuelModelKeroseneCEA):
    """Class defining the Kerosense - CEA fuel type for a thermodynamic jet engine model."""
    def __init__(self, sourceObject=None):
        IFuelModelKeroseneCEA.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IFuelModelKeroseneCEA._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelModelKeroseneCEA._get_property(self, attrname) is not None: found_prop = IFuelModelKeroseneCEA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelModelKeroseneCEA.")

agcls.AgClassCatalog.add_catalog_entry("{6df7fa84-6983-4ed2-9447-a11d0fbd0fac}", FuelModelKeroseneCEA)
agcls.AgTypeNameMap["FuelModelKeroseneCEA"] = FuelModelKeroseneCEA

class AdvFixedWingRamjetBasic(IAdvFixedWingRamjetBasic):
    """Class defining the basic Ramjet model."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingRamjetBasic.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingRamjetBasic._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingRamjetBasic._get_property(self, attrname) is not None: found_prop = IAdvFixedWingRamjetBasic._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingRamjetBasic.")

agcls.AgClassCatalog.add_catalog_entry("{9f333e9b-3d22-429d-9880-940122216dde}", AdvFixedWingRamjetBasic)
agcls.AgTypeNameMap["AdvFixedWingRamjetBasic"] = AdvFixedWingRamjetBasic

class AdvFixedWingScramjetBasic(IAdvFixedWingScramjetBasic):
    """Class defining the basic Scramjet model."""
    def __init__(self, sourceObject=None):
        IAdvFixedWingScramjetBasic.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAdvFixedWingScramjetBasic._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAdvFixedWingScramjetBasic._get_property(self, attrname) is not None: found_prop = IAdvFixedWingScramjetBasic._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AdvFixedWingScramjetBasic.")

agcls.AgClassCatalog.add_catalog_entry("{6caec1e6-8cf4-4752-89c6-42b55473f144}", AdvFixedWingScramjetBasic)
agcls.AgTypeNameMap["AdvFixedWingScramjetBasic"] = AdvFixedWingScramjetBasic

class AircraftVTOLModel(IAircraftVTOLModel):
    """Class defining the VTOL performance model of an aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftVTOLModel.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftVTOLModel._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftVTOLModel._get_property(self, attrname) is not None: found_prop = IAircraftVTOLModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftVTOLModel.")

agcls.AgClassCatalog.add_catalog_entry("{5fb18d9d-20cb-408e-a0d0-60f5cdd9dc2c}", AircraftVTOLModel)
agcls.AgTypeNameMap["AircraftVTOLModel"] = AircraftVTOLModel

class AircraftVTOL(IAircraftVTOL, ICatalogItem):
    """Class defining the VTOL category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftVTOL.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftVTOL._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftVTOL._get_property(self, attrname) is not None: found_prop = IAircraftVTOL._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftVTOL.")

agcls.AgClassCatalog.add_catalog_entry("{c1bd235a-6ffc-435c-900d-0ff6a7ca5422}", AircraftVTOL)
agcls.AgTypeNameMap["AircraftVTOL"] = AircraftVTOL

class AircraftTerrainFollowModel(IAircraftTerrainFollowModel):
    """Class defining the TerrainFollow performance model of an aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftTerrainFollowModel.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftTerrainFollowModel._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftTerrainFollowModel._get_property(self, attrname) is not None: found_prop = IAircraftTerrainFollowModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftTerrainFollowModel.")

agcls.AgClassCatalog.add_catalog_entry("{27d2c971-cdce-4465-a3df-eaf526de6c01}", AircraftTerrainFollowModel)
agcls.AgTypeNameMap["AircraftTerrainFollowModel"] = AircraftTerrainFollowModel

class AircraftTerrainFollow(IAircraftTerrainFollow, ICatalogItem):
    """Class defining the TerrainFollow category of an Aviator aircraft."""
    def __init__(self, sourceObject=None):
        IAircraftTerrainFollow.__init__(self, sourceObject)
        ICatalogItem.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAircraftTerrainFollow._private_init(self, intf)
        ICatalogItem._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAircraftTerrainFollow._get_property(self, attrname) is not None: found_prop = IAircraftTerrainFollow._get_property(self, attrname)
        if ICatalogItem._get_property(self, attrname) is not None: found_prop = ICatalogItem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AircraftTerrainFollow.")

agcls.AgClassCatalog.add_catalog_entry("{683bec0d-293d-4afa-a1ab-b23b123d62e4}", AircraftTerrainFollow)
agcls.AgTypeNameMap["AircraftTerrainFollow"] = AircraftTerrainFollow

class BasicManeuverStrategyBallistic3D(IBasicManeuverStrategyBallistic3D, IBasicManeuverStrategy):
    """Class defining Ballistic 3D strategy for a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyBallistic3D.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyBallistic3D._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyBallistic3D._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyBallistic3D._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyBallistic3D.")

agcls.AgClassCatalog.add_catalog_entry("{ec8f88ae-2944-459b-90aa-f8df3e74bf89}", BasicManeuverStrategyBallistic3D)
agcls.AgTypeNameMap["BasicManeuverStrategyBallistic3D"] = BasicManeuverStrategyBallistic3D

class ProcedureLaunchDynState(IProcedureLaunchDynState, IProcedure):
    """Class defining a Launch Dyn State procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLaunchDynState.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureLaunchDynState._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLaunchDynState._get_property(self, attrname) is not None: found_prop = IProcedureLaunchDynState._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLaunchDynState.")

agcls.AgClassCatalog.add_catalog_entry("{AA90861B-C8E1-46D1-BA87-47F27D731B84}", ProcedureLaunchDynState)
agcls.AgTypeNameMap["ProcedureLaunchDynState"] = ProcedureLaunchDynState

class ProcedureLaunchWaypoint(IProcedureLaunchWaypoint, IProcedure):
    """Class defining a Launch Waypoint procedure."""
    def __init__(self, sourceObject=None):
        IProcedureLaunchWaypoint.__init__(self, sourceObject)
        IProcedure.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureLaunchWaypoint._private_init(self, intf)
        IProcedure._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureLaunchWaypoint._get_property(self, attrname) is not None: found_prop = IProcedureLaunchWaypoint._get_property(self, attrname)
        if IProcedure._get_property(self, attrname) is not None: found_prop = IProcedure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureLaunchWaypoint.")

agcls.AgClassCatalog.add_catalog_entry("{05730C66-FF4D-4A05-A821-C541134119CE}", ProcedureLaunchWaypoint)
agcls.AgTypeNameMap["ProcedureLaunchWaypoint"] = ProcedureLaunchWaypoint

class SiteDynState(ISiteDynState, ISite):
    """Class defining a Dyn State site."""
    def __init__(self, sourceObject=None):
        ISiteDynState.__init__(self, sourceObject)
        ISite.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISiteDynState._private_init(self, intf)
        ISite._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISiteDynState._get_property(self, attrname) is not None: found_prop = ISiteDynState._get_property(self, attrname)
        if ISite._get_property(self, attrname) is not None: found_prop = ISite._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SiteDynState.")

agcls.AgClassCatalog.add_catalog_entry("{DF907297-E5CC-4346-9E97-95A3AFEE02FD}", SiteDynState)
agcls.AgTypeNameMap["SiteDynState"] = SiteDynState

class BasicManeuverStrategyPitch3D(IBasicManeuverStrategyPitch3D, IBasicManeuverStrategy):
    """Class defining Pitch 3D strategy for a Basic Maneuver procedure."""
    def __init__(self, sourceObject=None):
        IBasicManeuverStrategyPitch3D.__init__(self, sourceObject)
        IBasicManeuverStrategy.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverStrategyPitch3D._private_init(self, intf)
        IBasicManeuverStrategy._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverStrategyPitch3D._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategyPitch3D._get_property(self, attrname)
        if IBasicManeuverStrategy._get_property(self, attrname) is not None: found_prop = IBasicManeuverStrategy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverStrategyPitch3D.")

agcls.AgClassCatalog.add_catalog_entry("{A10EDD83-CED6-4747-AFBA-948653338437}", BasicManeuverStrategyPitch3D)
agcls.AgTypeNameMap["BasicManeuverStrategyPitch3D"] = BasicManeuverStrategyPitch3D

class RefuelDumpProperties(IRefuelDumpProperties):
    """Class defining the refuel/dump properties for the current procedure."""
    def __init__(self, sourceObject=None):
        IRefuelDumpProperties.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IRefuelDumpProperties._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRefuelDumpProperties._get_property(self, attrname) is not None: found_prop = IRefuelDumpProperties._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RefuelDumpProperties.")

agcls.AgClassCatalog.add_catalog_entry("{9CB1E862-FDED-463D-B449-C39030B149D6}", RefuelDumpProperties)
agcls.AgTypeNameMap["RefuelDumpProperties"] = RefuelDumpProperties

class ProcedureFastTimeOptions(IProcedureFastTimeOptions):
    """Class defining fast operations (without error or constraint checks) for time options for the current procedure."""
    def __init__(self, sourceObject=None):
        IProcedureFastTimeOptions.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IProcedureFastTimeOptions._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProcedureFastTimeOptions._get_property(self, attrname) is not None: found_prop = IProcedureFastTimeOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProcedureFastTimeOptions.")

agcls.AgClassCatalog.add_catalog_entry("{D69CF956-3A04-48F1-B553-7A10412253A0}", ProcedureFastTimeOptions)
agcls.AgTypeNameMap["ProcedureFastTimeOptions"] = ProcedureFastTimeOptions

class BasicManeuverTargetPositionVel(IBasicManeuverTargetPositionVel):
    """Class defining the target position and velocity strategies for basic maneuvers."""
    def __init__(self, sourceObject=None):
        IBasicManeuverTargetPositionVel.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverTargetPositionVel._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverTargetPositionVel._get_property(self, attrname) is not None: found_prop = IBasicManeuverTargetPositionVel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverTargetPositionVel.")

agcls.AgClassCatalog.add_catalog_entry("{4084EB67-0992-4F64-B710-7B5B4E275AC5}", BasicManeuverTargetPositionVel)
agcls.AgTypeNameMap["BasicManeuverTargetPositionVel"] = BasicManeuverTargetPositionVel

class BasicManeuverTargetPositionVelNoisyBrnRng(IBasicManeuverTargetPositionVelNoisyBrnRng):
    """Class defining the position and velocity strategy, Noisy Bearing Range"""
    def __init__(self, sourceObject=None):
        IBasicManeuverTargetPositionVelNoisyBrnRng.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverTargetPositionVelNoisyBrnRng._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverTargetPositionVelNoisyBrnRng._get_property(self, attrname) is not None: found_prop = IBasicManeuverTargetPositionVelNoisyBrnRng._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverTargetPositionVelNoisyBrnRng.")

agcls.AgClassCatalog.add_catalog_entry("{B64A8B6B-FA25-47EF-8945-2DA2817D6853}", BasicManeuverTargetPositionVelNoisyBrnRng)
agcls.AgTypeNameMap["BasicManeuverTargetPositionVelNoisyBrnRng"] = BasicManeuverTargetPositionVelNoisyBrnRng

class BasicManeuverTargetPositionVelNoisySurfTgt(IBasicManeuverTargetPositionVelNoisySurfTgt):
    """Class defining the position and velocity strategy, Noisy Surface Target"""
    def __init__(self, sourceObject=None):
        IBasicManeuverTargetPositionVelNoisySurfTgt.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IBasicManeuverTargetPositionVelNoisySurfTgt._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBasicManeuverTargetPositionVelNoisySurfTgt._get_property(self, attrname) is not None: found_prop = IBasicManeuverTargetPositionVelNoisySurfTgt._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BasicManeuverTargetPositionVelNoisySurfTgt.")

agcls.AgClassCatalog.add_catalog_entry("{A04BE0CD-AF3B-4887-A160-F4FCF29B9610}", BasicManeuverTargetPositionVelNoisySurfTgt)
agcls.AgTypeNameMap["BasicManeuverTargetPositionVelNoisySurfTgt"] = BasicManeuverTargetPositionVelNoisySurfTgt


################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################
